hApi = hApi or {}		--全局命名空间
local function ReturnEverything(...)
	return unpack({...})
end
setmetatable(hApi,{
	__index = function(t,k)
		local f = function(...)
			local p = {...}
			local msg = "	*[程序函数]	"..k.."("
			local ret,result
			for i = 1,#p do
				if i==#p then
					if type(p[i])=="string" then
						local s,e = string.find(p[i],"%[r%]")
						if s==1 then
							if e==string.len(p[i]) then
								ret = ReturnEverything
								result = "[自定义返回值]"
							else
								ret = string.sub(p[i],e+1)
								local s,e = string.find(ret,"%(num%)")
								if s==1 then
									ret = tonumber(tostring(string.sub(ret,e+1)))
								end
								result = ret
							end
							break
						end
					end
				end
				msg = msg..(i==1 and "" or ",")..tostring(p[i])
			end
			_DEBUG_MSG(msg..") : "..(result or "void"))
			return ret
		end
		rawset(t,k,f)
		return f
	end
})
hVar.IS_WIN32 = 1
if xlGB2UTF==nil then
	xlGB2UTF = function(s) return s end
end
if xlGB2UTF("啊")=="啊" then
	hVar.IS_WIN32 = 0
end
_T = xlGB2UTF
--------------------------------------------------
--分割字符串
hApi.Split = function(str, delim, maxNb)
	-- Eliminate bad cases...
	if string.find(str, delim) == nil then
		return { str }
	end
	if maxNb == nil or maxNb < 1 then
		maxNb = 0 -- No limit
	end
	local result = {}
	local pat = "(.-)" .. delim .. "()"
	local nb = 0
	local lastPos
	for part, pos in string.gfind(str, pat) do
		nb = nb + 1
		result[nb] = part
		lastPos = pos
		if nb == maxNb then break end
	end
	-- Handle the last field
	if nb ~= maxNb then
		result[nb + 1] = string.sub(str, lastPos)
	end  
	return result
end

--------------------------------------------------
--分割字符串2:"it,1000,1000,...."
hApi.SplitN = function(str,delim,maxNb)
	local r = hApi.Split(str,delim,maxNb)
	for i = 2,#r do
		r[i] = tonumber(r[i]) or 0
	end
	return r
end

--分割字符串3:"1000,1000,1000,...."
hApi.SplitNEx = function(str,delim,maxNb)
	local r = hApi.Split(str,delim,maxNb)
	for i = 1,#r do
		r[i] = tonumber(r[i]) or 0
	end
	return r
end

local cc = {}
cc.UNIFORM_COS_TIME = 0x5
cc.UNIFORM_MV_MATRIX    = 0x1
cc.UNIFORM_MVP_MATRIX   = 0x2
cc.UNIFORM_P_MATRIX = 0x0
cc.UNIFORM_RANDOM01 = 0x6
cc.UNIFORM_SAMPLER  = 0x7
cc.UNIFORM_SIN_TIME = 0x4
cc.UNIFORM_TIME = 0x3
cc.UNIFORM_MAX  = 0x8
cc.VERTEX_ATTRIB_FLAG_COLOR = 0x2
cc.VERTEX_ATTRIB_FLAG_NONE  = 0x0
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = 0x7
cc.VERTEX_ATTRIB_FLAG_POSITION  = 0x1
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS    = 0x4
cc.VERTEX_ATTRIB_COLOR  = 0x1
cc.VERTEX_ATTRIB_MAX    = 0x3
cc.VERTEX_ATTRIB_POSITION   = 0x0
cc.VERTEX_ATTRIB_TEX_COORD = 0x2

cc.VERTEX_ATTRIB_TEX_COORDS = 0x2

cc.ATTRIBUTE_NAME_COLOR = 'a_color'
cc.ATTRIBUTE_NAME_POSITION  = 'a_position'
cc.ATTRIBUTE_NAME_TEX_COORD = 'a_texCoord'
cc.SHADER_POSITION_COLOR    = 'ShaderPositionColor'
cc.SHADER_POSITION_LENGTH_TEXURE_COLOR  = 'ShaderPositionLengthTextureColor'
cc.SHADER_POSITION_TEXTURE  = 'ShaderPositionTexture'
cc.SHADER_POSITION_TEXTURE_A8_COLOR = 'ShaderPositionTextureA8Color'
cc.SHADER_POSITION_TEXTURE_COLOR    = 'ShaderPositionTextureColor'
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHA_TEST = 'ShaderPositionTextureColorAlphaTest'
cc.SHADER_POSITION_TEXTURE_U_COLOR  = 'ShaderPositionTexture_uColor'
cc.SHADER_POSITION_U_COLOR  = 'ShaderPosition_uColor'
cc.UNIFORM_ALPHA_TEST_VALUE_S   = 'CC_AlphaValue'
cc.UNIFORM_COS_TIME_S   = 'CC_CosTime'
cc.UNIFORM_MV_MATRIX_S  = 'CC_MVMatrix'
cc.UNIFORM_MVP_MATRIX_S = 'CC_MVPMatrix'
cc.UNIFORM_P_MATRIX_S   = 'CC_PMatrix'
cc.UNIFORM_RANDOM01_S   = 'CC_Random01'
cc.UNIFORM_SAMPLER_S    = 'CC_Texture0'
cc.UNIFORM_SIN_TIME_S   = 'CC_SinTime'
cc.UNIFORM_TIME_S   = 'CC_Time'

hApi.getShader = function(name, tag, nFlag)
	local shaderFullName = nil --全称
	
	--name
	if (type(name) ~= "string") then
		print("hApi.getShader #1 para must be a string.")
		return 0
	end
	shaderFullName = name
	--tag
	if (type(tag) == "string") or (type(tag) == "number") then
		shaderFullName = shaderFullName .. tostring(tag)
	end
	
	--nFlag
	if (type(nFlag) == "number") then
		--只保留2位有效数字
		nFlag = math.floor(nFlag * 100) / 100
		shaderFullName = shaderFullName .. tostring(nFlag)
	end
	
	if CCGLProgram then
		if hVar.SHADER_CONTAINER then
			--...
		else
			hVar.SHADER_CONTAINER = {}
		end
		for i = 1,#hVar.SHADER_CONTAINER do
			if (hVar.SHADER_CONTAINER[i][1]) and (hVar.SHADER_CONTAINER[i][1] == shaderFullName) then
				if hVar.SHADER_CONTAINER[i][2] and type(hVar.SHADER_CONTAINER[i][2]) == "userdata" then
					return hVar.SHADER_CONTAINER[i][2]
				end
			end
		end
		
		local program = CCGLProgram.initWithVertexShaderFilename("data/shader/"..name..".vsh", "data/shader/"..name..".fsh")
		program:addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION) 
		program:addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR)
		program:addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS)
		program:link()
		program:updateUniforms()
		hVar.SHADER_CONTAINER[#hVar.SHADER_CONTAINER + 1] = {shaderFullName, program}
		return program
	else
		print("no CCGLProgram in this program vision.")
		return 0
	end
end

hApi.ConcatEx = function(t,v)
	local r = {}
	for i = 1,#t do
		r[#r+1] = t[i]
		if i~=#t then
			r[#r+1] = v
		end
	end
	return table.concat(r)
end


hApi.GetNumberFromString = function(str,patten)
	local t = {string.find(str,patten)}
	if #t>2 then
		local r = {}
		for i = 3,#t do
			r[#r+1] = tonumber(t[i])
		end
		return unpack(r)
	end
end

--------------------------------------------------
-- a:(%d+);
hApi.GetNumByPatten = function(sCmd,sPatten)
	local _,_,v = string.find(sCmd,sPatten)
	if v then
		local n = tonumber(v)
		if type(n)=="number" then
			return n
		end
	end
	return 0
end
--------------------------------------------------
--解析服务器字符串
hApi.FormatLobbyString = function(str,pre)
	if type(str)=="string" then
		local nLen = string.len(str)
		if string.sub(str,1,1)=="$" and nLen>1 then
			return string.sub(str,2,nLen)
		elseif pre then
			return hVar.tab_string[pre..str]
		else
			return hVar.tab_string[str]
		end
	else
		return ""
	end
end
--------------------------------------------------
hApi.WDLD_BuildingReady = function(level)
	if level >= 30 then
		return {41071,41050,41051,41052,41045,41001,41006,41011,41050,41051,41052,41045,41015,41020,41025,41072,41050,41051,41052,41045,41002,41007,41012}
	elseif level >= 27 then
		return {41071,41050,41051,41052,41045,41001,41006,41011,41050,41051,41052,41045,41015,41020,41025,41072,41050,41051,41052,41045}
	elseif level >= 24 then
		return {41071,41050,41051,41052,41045,41001,41006,41011,41050,41051,41052,41045,41015,41020,41025,41072,41050,41051,41052}
	elseif level >= 21 then
		return {41071,41050,41051,41052,41045,41001,41006,41011,41050,41051,41052,41045,41015,41020,41025,41072}
	elseif level >= 18 then
		return {41071,41050,41051,41052,41045,41001,41006,41011,41050,41051,41052,41045,41015,41020,41025}
	elseif level >= 15 then
		return {41071,41050,41051,41052,41045,41001,41006,41011,41050,41051,41052,41045}
	elseif level >= 12 then
		return {41071,41050,41051,41052,41045,41001,41006,41011,41050,41051,41052}
	elseif level >= 9 then
		return {41071,41050,41051,41052,41045,41001,41006,41011}
	elseif level >= 6 then
		return {41071,41050,41051,41052,41045}
	elseif level >= 3 then
		return {41071,41050,41051,41052}
	else
		return {41071}
	end
end

hApi.WDLD_ProvidePec = function(level)
	if level >= 30 then
		return 400
	elseif level >= 25 then
		return 350
	elseif level >= 19 then
		return 300
	elseif level >= 13 then
		return 250
	elseif level >= 7 then
		return 200
	else
		return 150
	end
end


--判断是否免费英雄
hApi.IsHeroFree = function(id)
	if hVar.HERO_FREE[id]==1 then
		return 1
	elseif type(hVar.HERO_IN_DLC[id])=="table" then
		for i = 1,#hVar.HERO_IN_DLC[id] do
			if LuaCheckPlayerDLCMap(hVar.HERO_IN_DLC[id][i])==1 then
				return 1
			end
		end
	end
end
---------------------------------------------------
-- 安全排错函数
hApi.SafeObject = function(o,o__ID)
	if o and o.__ID==o__ID then
		return o
	end
end

hApi.GetObjectFromParam = function(o)
	if o~=nil and o~=0 then
		return o
	end
end

--取中间值
hApi.NumBetween = function(v,a,b)
	if a>b then
		a,b = b,a
	end
	if v<a then
		return a
	elseif v<=b then
		return v
	else
		return b
	end
end

--hApi.SelectFromTab = function(t,n,r,oWorld,DropSource)
--	local v
--	r = r or {}
--	if DropSource==1 then
--		v = t
--	else
--		v = {}
--		for i = 1,#t do
--			v[i] = t[i]
--		end
--	end
--	n = math.min((n or #t),#t)
--	if n>0 then
--		local mx = #t
--		for i = 1,n do
--			local nShift = mx-i+1
--			local nSel
--			if oWorld then
--				--nSel = oWorld:random(1,nShift)
--				nSel = hApi.random(1,nShift)
--			else
--				nSel = hApi.random(1,nShift)
--			end
--			r[#r+1] = v[nSel]
--			v[nSel] = v[nShift]
--			v[nShift] = 0
--		end
--	end
--	return r
--end

local __SaveCodeF
__SaveCodeF = function(pKey,key,val,rTab,pre,tail,NoSaveTableKey,Depth)
	Depth = Depth or 0
	pre = pre and pre.."	" or ""
	tail = tail or ""
	local saveTag
	local valType = type(val)
	local tagType = type(key)
	if tagType=="number" then
		saveTag = "["..key.."]"
	elseif tagType=="string" then
		if tostring(tonumber(key))==key then
			saveTag = "["..key.."]"
		else
			saveTag = key
		end
	else
		saveTag = "[\""..tostring(key).."\"]"
	end
	if valType=="table" then
		if Depth==0 then
		else
			if NoSaveTableKey and NoSaveTableKey[key]==1 then
				if val.i~=nil then
					rTab[#rTab+1] = pre..saveTag.." = {i=0}"..tail.."\n"
					return
				else
					rTab[#rTab+1] = pre..saveTag.." = {}"..tail.."\n"
					return
				end
			end
			if Depth>20 then
				return print("警告:存储表格["..tostring(pKey).."]时深度超出限制(max 20)")
			end
			if type(val.ID)=="number" and type(val.__ID)=="number" and getmetatable(val)~=nil then
				--rTab[#rTab+1] = pre..key.." = {\"CLASSOBJECT\",\""..tostring(val.classname).."\","..val.ID..",}"..tail.."\n"
				return print("警告:存储表格["..tostring(pKey).."]中存储了对象类型的数据:"..tostring(key))
			end
		end
		rTab[#rTab+1] = pre..saveTag.." = {\n"
		for k,v in pairs(val)do
			__SaveCodeF(key,k,v,rTab,pre,",",NoSaveTableKey,Depth+1)
		end
		rTab[#rTab+1] = pre.."}"..tail.."\n"
	elseif valType=="number" or valType=="boolean" then
		rTab[#rTab+1] = pre..saveTag.." = "..tostring(val)..tail.."\n"
	elseif valType=="string" then
		rTab[#rTab+1] = pre..saveTag.." = \""..tostring(val).."\""..tail.."\n"
	else
		return print("警告:存储表格["..tostring(pKey).."]中存储了自定义类型的数据["..tostring(key)..":("..valType..")")
	end
end

--新版SaveTable
hApi.SaveTable = function(sTab,rTab,NoSaveTableKey)
	rTab = rTab or {}
	if type(rTab[#rTab])=="string" then
		rTab[#rTab] = rTab[#rTab].." = {"
	end
	local count = 0
	for k,v in pairs(sTab)do
		count = count + 1
	end
	if #sTab==count then
		for i = 1,#sTab do
		local k = i
		local v = sTab[i]
			eClass.ConvertTableToString(nil,k,v,rTab,"	","\n",",\n",NoSaveTableKey)
		end
	else
		for k,v in pairs(sTab) do
			eClass.ConvertTableToString(nil,k,v,rTab,"	","\n",",\n",NoSaveTableKey)
		end
	end
	rTab[#rTab+1] = "}"
	return rTab
end

--允许存储对象数据
hApi.SaveTableEx = function(sTab,rTab,NoSaveTableKey)
	rTab = rTab or {}
	if type(rTab[#rTab])=="string" then
		rTab[#rTab] = rTab[#rTab].." = {"
	end
	local count = 0
	for k,v in pairs(sTab)do
		count = count + 1
	end
	local FilterTab = {}
	if #sTab==count then
		for i = 1,#sTab do
		local k = i
		local v = sTab[i]
			eClass.ConvertTableToStringEx(FilterTab,nil,k,v,rTab,"	","\n",",\n",NoSaveTableKey)
		end
	else
		for k,v in pairs(sTab) do
			eClass.ConvertTableToStringEx(FilterTab,nil,k,v,rTab,"	","\n",",\n",NoSaveTableKey)
		end
	end
	rTab[#rTab+1] = "}"
	return rTab
end

--将表格数据保存为文件
hApi.SaveFile = function(sFileName,sVarName,tTemp,tFilter)
	local rTab = hApi.SaveTable(tTemp,{sVarName},tFilter)
	if type(g_localfilepath)=="string" then
		xlSaveGameData(g_localfilepath..sFileName,table.concat(rTab))
	end
end

--hApi.SaveTable(SaveTab,{"tab_name"},{handle=1})
--hApi.SaveTable = function(sTab,rTab,NoSaveTableKey)
	--rTab = rTab or {}
	--if type(rTab[#rTab])=="string" then
		--rTab[#rTab] = rTab[#rTab].." = { \n"
	--end
	--for k,v in pairs(sTab) do
		--__SaveCodeF(nil,k,v,rTab,nil,",",NoSaveTableKey)
	--end
	--rTab[#rTab+1] = "}"
	--return rTab
--end

local __tCheckTemp = {}
hApi.CheckParamType = function(tCheck,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)
	local _p = __tCheckTemp
	local r = hVar.RESULT_SUCESS
	_p[1],_p[2],_p[3],_p[4],_p[5],_p[6],_p[7],_p[8],_p[9],_p[10] = p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
	for i = 1,#tCheck do
		if type(_p[i])~=tCheck[i] then
			r = hVar.RESULT_FAIL
			break
		end
	end
	for i = 10,1 do
		_p[i] = nil
	end
	return r
end

---------------------------------------------------
-- 安全字符串转换，苹果环境下用自带的字符串会有问题
-- 另外中文字符串在非中文环境也可能会有问题
--__T = function(mode,s)
	--return s
--end
--local __T = __T
---------------------------------------

--通过tab_unit.lua里的id返回建筑物的扩展类型
function hApi.GetBuildingTypeExByID(id)
	local tabU = hVar.tab_unit[id]
	if tabU~=nil then
		if tabU.map~=nil then
			return hVar.BUILDING_TYPE_EX.TOWN
		elseif tabU.seizable==1 then
			if tabU.provide ~= nil then
				return hVar.BUILDING_TYPE_EX.PROVIDE
			end
		end
		if tabU.interaction~=nil then
			local v = tabU.interaction
			for i = 1,#v do
				if v[i]==hVar.INTERACTION_TYPE.VISIT then
					return hVar.BUILDING_TYPE_EX.VISIT
				elseif v[i]==hVar.INTERACTION_TYPE.HIRE then
					return hVar.BUILDING_TYPE_EX.HIRE
				elseif v[i]==hVar.INTERACTION_TYPE.SHOP then
					return hVar.BUILDING_TYPE_EX.SHOP
				end
			end
		end
	end
	return hVar.BUILDING_TYPE_EX.NONE
end

function hApi.intDiv(a,b)
	local i = 0
	while a >= b do
		i = i+1
		a = a - b
	end
	
	return i
end

--字符转换为数字
hApi.ReadNumberFromString = function(cString,r)
	r = r or {}
	if type(cString)~="string" then
		return r
	end
	local count = 0
	local s = 1
	local l = string.len(cString)
	while(s and s<=l)do
		local num
		local e = string.find(cString,",",s)
		if e then
			if e>s then
				num = tonumber(string.sub(cString,s,e-1))
			end
		else
			e = l
			num = tonumber(string.sub(cString,s,l))
		end
		s = e + 1
		r[#r+1] = num or 0
	end
	--print("----------------")
	--for i = 1,#r do
		--print(r[i])
	--end
	return r
end

hApi.ReadNumberFromFormatString = function(sText,k,n)
	if type(sText)=="string" and type(k)=="string" then
		n = n or 1
		local s,e = string.find(sText,k..":([%d]+);",n)
		if s and e then
			return tonumber(string.sub(sText,s+string.len(k)+1,e-1)),e+1
		end
	end
end

hApi.InitItemPosList = function(n,x,y,w)
	local r = {}
	if math.mod(n,2)==1 then
		for i = 1,n do
			r[i] = {x+w*(i-(n+1)/2),y}
		end
	else
		for i = 1,n do
			r[i] = {x+w*(i-n/2)-w/2,y}
		end
	end
	return r
end

--角度转换：r2l
hApi.RyanAngleToLeeAngle = function(a)
	a = 90 - a
	return a<0 and a+360 or a
end
--角度转换：l2r
hApi.LeeAngleToRyanAngle = function(a)
	a = 90 - a
	return a<0 and a+360 or a
end
-------------------------
hApi.ReadParam = function(template,p,d)
	for k,v in pairs(template) do
		d[k] = (p and p[k]) or v
	end
	return d
end

hApi.ReadParamK2I = function(template,p,d)
	for i = 1,#template do
		local k = template[i]
		d[k] = (p and p[k]) or 0
	end
	return d
end

hApi.InsertValueIntoTab = function(t,k,v,mx)
	mx = mx or #t+1
	k = math.min(k or mx,mx)
	if k<=#t then
		for i = #t,k,-1 do
			t[i+1] = t[i]
		end
		t[k] = v
	else
		t[#t+1] = v
	end
	return t
end

hApi.InsertValueIntoTabForKey = function(t,k,v,p)
	if (p or 1)>0 then
		for i = 1,#t do
			if v[k]>t[i][k] then
				return hApi.InsertValueIntoTab(t,i,v)
			end
		end
		
	elseif #t>0 then
		for i = 1,#t do
			if v[k]<t[i][k] then
				return hApi.InsertValueIntoTab(t,i,v)
			end
		end
	end
	t[#t+1] = v
	return t
end

hApi.CompressNumTab = function(t)
	local e
	for i = 1,#t do
		if t[i]==0 then
			e = e or i
		elseif e~=nil then
			t[e] = t[i]
			t[i] = 0
			e = e + 1
		end
	end
	if e~=nil then
		for i = #t,e,-1 do
			t[i] = nil
		end
	end
end

hApi.ShiftValue = function(tab,k1,k2)
	tab[k1],tab[k2] = tab[k2],tab[k1]
end

hApi.SetObjectUnit = function(tab,oUnit)
	if oUnit~=nil then
		tab[1] = oUnit.ID
		tab[2] = oUnit.__ID
	else
		tab[1] = 0
		tab[2] = 0
	end
	return tab
end

hApi.GetObjectUnit = function(tab)
	if tab and tab~=0 then
		local ID = tab[1]
		if ID then
			local u = hClass.unit:find(ID)
			if u and u.__ID==tab[2] then
				return u
			end
		end
	end
end

hApi.SetObjectEasy = function(tab,obj)
	if obj~=nil and obj~=0 and obj.ID~=0 then
		tab[1] = obj
		tab[2] = obj.__ID
		return tab
	else
		tab[1] = 0
		tab[2] = 0
		return tab
	end
end

hApi.GetObjectEasy = function(tab,obj)
	obj = obj or tab[1]
	if obj~=nil and obj~=0 and obj.ID~=0 and obj==tab[1] and obj.__ID==tab[2] then
		return obj
	else
		return nil
	end
end

hApi.SetObject = function(tab,obj)
	if obj~=nil and obj~=0 and obj.ID~=0 then
		local m = getmetatable(obj)
		if m~=nil then
			tab[1] = obj.ID
			tab[2] = obj.__ID
			tab[3] = m.__class
		else
			tab[1] = 0
			tab[2] = 0
			tab[3] = nil
		end
		return tab
	else
		tab[1] = 0
		tab[2] = 0
		tab[3] = nil
		return tab
	end
end

hApi.GetObject = function(tab,obj)
	if tab[3]~=nil and tab[1]~=nil and tab[1]~=0 then
		if obj~=nil then
			if tab[3]:find(obj.ID)==obj and tab[2]==obj.__ID then
				return obj
			end
		else
			local r = tab[3]:find(tab[1])
			if r and r.__ID==tab[2] then
				return r
			end
		end
	end
end

hApi.SetObjectEx = function(tab,obj)
	if obj~=nil and obj~=0 and obj.ID~=0 then
		tab[1] = obj.ID
		tab[2] = obj.__ID
		return tab
	else
		tab[1] = 0
		tab[2] = 0
		return tab
	end
end

hApi.GetObjectEx = function(class,tab,obj)
	if tab[1]~=nil and tab[1]~=0 then
		if obj~=nil then
			if obj==0 or obj.ID==0 then
				return nil
			else
				local oEx = class:find(tab[1])
				if oEx==obj and oEx.__ID==tab[2] then
					return oEx
				end
			end
		else
			local oEx = class:find(tab[1])
			if oEx~=nil and oEx.__ID==tab[2] then
				return oEx
			end
		end
	else
		return nil
	end
end

hApi.SetObjectII = function(tab,obj)
	if obj~=nil and obj~=0 and obj.ID~=0 then
		tab[1] = obj.ID
		tab[2] = obj.__ID
		tab[3] = tostring(obj)
		return tab
	else
		tab[1] = 0
		tab[2] = 0
		tab[3] = 0
		return tab
	end
end

hApi.GetObjectII = function(class,tab,obj)
	if tab[1]~=nil and tab[1]~=0 then
		if obj~=nil then
			if obj==0 or obj.ID==0 then
				return nil
			else
				local oEx = class:find(tab[1])
				if oEx==obj and oEx.__ID==tab[2] and tostring(oEx)==tab[3] then
					return oEx
				end
			end
		else
			local oEx = class:find(tab[1])
			if oEx~=nil and oEx.__ID==tab[2] and tostring(oEx)==tab[3] then
				return oEx
			end
		end
	else
		return nil
	end
end

hApi.ReplaceObject = function(tab,obj)
	local o = hApi.GetObject(tab)
	if o~=nil then
		--xlLG("RoadPoint", "hApi.ReplaceObject(), unit=" .. tostring(o.data.name) .. "_" .. o.__ID .. "\n")
		o:del()
	end
	return hApi.SetObject(tab,obj)
end

hApi.SortTableI = function(tab,IsClearZero)
	local lastI
	local iMax = tab.i or #tab
	for i = 1,iMax do
		if tab[i]==0 then
			lastI = lastI or i
		elseif lastI then
			tab[lastI] = tab[i]
			tab[i] = 0
			lastI = lastI + 1
		end
	end
	if lastI then
		for i = iMax,lastI,-1 do
			tab[i] = nil
		end
		if tab.i then
			tab.i = lastI - 1
		end
	end
	if IsClearZero==1 then
		for i = iMax,1,-1 do
			if tab[i]~=0 then
				break
			else
				tab[i] = nil
			end
		end
	end
	return tab
end

hApi.enumNearGrid = function(gridX,gridY,nearGrid,enumCode,param,param2)
	if nearGrid==nil or nearGrid==0 then
		return hVar.RESULT_FAIL
	elseif nearGrid~=1 and type(nearGrid)=="table" then
		for i = 1,#nearGrid do
			enumCode(gridX+nearGrid[i][1],gridY+nearGrid[i][2],param,param2)
		end
		return hVar.RESULT_SUCESS
	else
		enumCode(gridX,gridY,param,param2)
		return hVar.RESULT_SUCESS
	end
end

hApi.ReadParamWithDepth = function(template,p,d,depth)
	depth = depth or 1
	if depth<0 then
		return d
	end
	for k,v in pairs(template)do
		local _v = (p and p[k])
		if type(v)=="table" then
			d[k] = hApi.ReadParamWithDepth(v,_v,(type(d[k])=="table" and d[k]) or {},depth-1)
		else
			d[k] = _v or v
		end
	end
	return d
end

hApi.ReadListParam = function(tData,nLen)
	if type(tData)=="table" then
		local r = {}
		for n = 1,#tData do
			if type(tData[n])=="table" then
				local v = {}
				r[n] = v
				for i = 1,nLen do
					v[i] = tData[n][i] or 0
				end
			else
				r[n] = tData[n]
			end
		end
		return r
	end
end

hApi.LoadTableWithDepth = function(tTab,nDepth,nLen)
	if tTab~=nil and type(tTab)=="table" and #tTab>(nLen or -1) then
		return hApi.ReadParamWithDepth(tTab,nil,{},nDepth)
	end
end

hApi.GetTableValue = function(t,k)
	if t[k]==nil then
		k = 1
	end
	return t[k],k
end

--hApi.GetTableRandom = function(randMode,t)
--	if t~=nil and #t>0 then
--		if randMode=="SYS" then
--			return t[hApi.random(1,#t)]
--		else
--			return t[hApi.random(1,#t)]
--		end
--	end
--end

local __GetRandPermNum
__GetRandPermNum = function(rTab,aTab,nCur,nIndex)
	local IsEnd = 1
	for i = 1,nIndex,1 do
		if aTab[i]~=1 and nCur>=rTab[i] then
			IsEnd = 0
			aTab[i] = 1
			nCur = nCur + 1
		end
	end
	if IsEnd~=1 then
		return __GetRandPermNum(rTab,aTab,nCur,nIndex)
	else
		return nCur
	end
end
hApi.RandPerm = function(nRange,nNum,fRandCode)
	local r = {}
	fRandCode = fRandCode or math.random
	local nLoop = math.min(nRange,nNum or nRange)
	for i = 1,nLoop,1 do
		r[i] = __GetRandPermNum(r,{},fRandCode(1,nRange-(i-1)),i-1)
	end
	return r
end

hApi.HaveValue = function(t,v)
	for k,n in pairs(t)do
		if n==v then
			return k
		end
	end
end


hApi.NumTable = function(n)
	local r = {}
	for i = 1,n do
		r[i] = 0
	end
	return r
end

hApi.Matrix2D = function(col,row,val)
	local r = {}
	for i = 1,row do
		r[i] = {}
		for j = 1,col do
			r[i][j] = val or 0
		end
	end
	return r
end

hApi.IndexTable = function(t)
	t.index = {}
	for i = 1,#t do
		t.index[t[i]] = i
	end
	return t
end

hApi.KeyTable2NumTable = function(it,t,r)
	r = r or {}
	for i = 1,#it do
		if t then
			r[i] = t[it[i]] or 0
		else
			r[i] = 0
		end
	end
	return r
end

hApi.GetParamByCmd = function(sHead,sCmd,rTab)
	rTab = rTab or {}
	for a in string.gfind(sCmd,(sHead or "").."([^;]-);")do
		local v = {}
		local sus = nil
		local nCur = 0
		local nLen = string.len(a)
		while(nCur and nCur<=nLen)do
			local nCurOld = nCur
			local s = string.find(a,":",nCur+1)
			if string.sub(a,nCur+1,nCur+1)=="{" then
				local e = string.find(a,"}",nCur+2)
				if e then
					v[#v+1] = string.sub(a,nCur+2,e-1)
					nCur = e+1
				else
					--非法的字符串！
					break
				end
			else
				if s~=nil then
					v[#v+1] = string.sub(a,nCur+1,s-1)
					nCur = s
				else
					v[#v+1] = string.sub(a,nCur+1,nLen)
					nCur = nLen + 1
				end
			end
			if nCurOld==nCur then
				nCur = nLen + 1
			end
		end
		rTab[#rTab+1] = v
	end
	return rTab
end

hApi.GetParamByCmdII = function(sHead,sCmd,rTab)
	rTab = rTab or {}
	sHead = sHead or ""
	for a in string.gfind(sCmd,sHead.."([^;]-);")do
		rTab[#rTab+1] = sHead..a..";"
	end
	return rTab
end

hApi.GetUnitName = function(v)
	local id = v
	local sHint
	if type(v)=="table" then
		local oUnit = v
		id = oUnit.data.id
		local tgrData = oUnit:gettriggerdata()
		if tgrData then
			if tgrData.hint then
				local s = hVar.tab_stringM[tgrData.hint]
				if type(s)=="table" then
					sHint = s[1]
				elseif type(s)=="string" then
					sHint = s
				end
			end
			if tgrData.name then
				local s = hVar.tab_stringM[tgrData.name]
				if type(s)=="table" then
					local rn = s[1] or tgrData.name
					local rh = sHint or s[2] or ""
					return rn,rh
				elseif type(s)=="string" then
					return s,sHint or ""
				end
			end
		end
	end
	if type(id)=="number" and id>0 and hVar.tab_stringU[id] then
		local rn = hVar.tab_stringU[id][1] or "UNIT_"..id
		local rh = sHint or hVar.tab_stringU[id][2] or ""
		return rn,rh
	end
	return hVar.tab_string["__BLANK__"],""
end

hApi.GetLootName = function(loot)
	attrNameTable = attrNameTable or {
		HP = hVar.tab_string["__Attr_Hint_Hp"],		--生命值
		MP = hVar.tab_string["__Attr_Hint_Mp"],		--法力值
		exp = hVar.tab_string["__Attr_Hint_Exp"],	--经验值

		lea = hVar.tab_string["__Attr_Hint_Lea"],	--统率
		led = hVar.tab_string["__Attr_Hint_Led"],	--防御
		str = hVar.tab_string["__Attr_Hint_Str"],	--力量
		int = hVar.tab_string["__Attr_Hint_Int"],	--智力
		con = hVar.tab_string["__Attr_Hint_Con"],	--体质
		movepoint = hVar.tab_string["__Attr_Hint_MovePoint"],	--移动点数
		hpRecover = hVar.tab_string["__Attr_hpRecover"],
		mpRecover = hVar.tab_string["__Attr_mpRecover"],
		allAttr = hVar.tab_string["__Attr_Hint_AllAttr"],
	}

	resNameTable = resNameTable or {
		IRON = hVar.tab_string["__Resource_Hint_Iron"],			--铁
		WOOD = hVar.tab_string["__Resource_Hint_Wood"],			--木头
		FOOD = hVar.tab_string["__Resource_Hint_Food"],			--食物
		GOLD = hVar.tab_string["__Resource_Hint_Gold"],			--黄金
		STONE = hVar.tab_string["__Resource_Hint_Stone"],		--石头
		CRYSTAL = hVar.tab_string["__Resource_Hint_Crystal"],	--水晶
	}	
	
	if loot then
		local t1,t2 = unpack(loot)
		if "res" == t1 then
			return resNameTable[t2]
		elseif "attr" == t1 or "attrW" == t1 then
			return  attrNameTable[t2]
		elseif "item" == t1 then
			if hVar.tab_item[t2] then
				return hVar.tab_stringI[t2][1]
			else
				return "item_"..t2
			end
		elseif "battlefieldskill" == t1 then
			return hVar.tab_stringT[t2][1]
		elseif "skill" == t1 then
			if hVar.tab_stringS[t2] and hVar.tab_stringS[t2][1] then
				return hVar.tab_stringS[t2][1]
			else
				return "skill_"..t2
			end
		end
	end

	return nil
end

hApi.GetLootAnimation = function(loot)
	if loot then
		local t1,t2 = unpack(loot)
		if "res" == t1 then
			return 
		elseif "attr" == t1 or "attrW" == t1 then
			return t2
		elseif "item" == t1 then
			return
		elseif "score" == t1 then
			return "normal"
		elseif "battlefieldskill" == t1 then
			return "normal"
		end
	end

	return nil
end

hApi.GetLootModel = function(loot)
	if loot then
		local t1,t2 = unpack(loot)
		if "res" == t1 then
			local subType = hVar.RESOURCE_TYPE[t2]
			if hVar.RESOURCE_ART[subType] then 
				return hVar.RESOURCE_ART[subType].icon
			end
		elseif "attr" == t1 or "attrW" == t1 then
			if t2 == "str" then
				return "ICON:HeroAttr_str"
			elseif t2 == "led" then
				return "ICON:HeroAttr_defense"
			elseif t2 == "lea" then
				return "ICON:HeroAttr_leadship"
			elseif t2 == "int" then
				return "ICON:HeroAttr_int"
			elseif t2 == "con" then
				return "ICON:HeroAttr_con"
			elseif t2 == "hp_pec" then
				return "ICON:HeroAttr"
			elseif t2 == "mp_pec" then
				return "ICON:HeroAttr"
			elseif t2 == "exp" then
				return "ICON:ATTR_exp"
			elseif t2 =="movepoint" then
				return "ICON:Item_Horse01"
			elseif t2 == "hpRecover" then
				return "ICON:icon01_x2y2"
			elseif t2 == "mpRecover" then
				return "ICON:icon01_x2y9"
			elseif t2 == "allAttr" then
				return "UI:skill_point"
			end
		elseif "item" == t1 then
			if hVar.tab_item[t2] then
				return hVar.tab_item[t2].icon
			else
				return "MODEL:Default"
			end
		elseif "score" == t1 then
			return "UI:score"
		elseif "battlefieldskill" == t1 then
			if hVar.tab_tactics[t2] then
				return hVar.tab_tactics[t2].icon
			else
				return "MODEL:Default"--"UI:tactic_card_gold"
			end
		elseif "skill" == t1 then
			if hVar.tab_skill[t2] then
				return hVar.tab_skill[t2].icon
			else
				return "MODEL:Default"--"UI:tactic_card_gold"
			end
		end
		--return "UI:ICON_main_frm_ResourceIron"
		return "MODEL_SCENEOBJ:chest"
	end

	return nil
end

hApi.GetUnitImageWH = function(id,w,h)
	id = id or 0
	local tabU = hVar.tab_unit[id]
	if tabU~=nil then
		if tabU.thumbWH then
			w,h = unpack(tabU.thumbWH)
		else
			local box = tabU.box or hVar.DefaultBox.UNIT
			local _w,_h = box[3],box[4]
			if (_w or 0)>(_h or 0) then
				return w,-1
			else
				return -1,h
			end
		end
	end
	return w,h
end

hApi.random = function(a,b)
	if b==nil then
		return a
	else
		if a<=b then
			return math.random(a,b)
		else
			return math.random(b,a)
		end
	end
end

--返回若干个处在某个区间的相异随机数，比如返回20-100的3个随机数(31,45,99)，不会返回相同的随机数
hApi.randomEx = function(oWorld,valA,valB,nNum,sReason)
	local tValue = {}
	local nMax = math.max(valA,valB)
	local nMin = math.min(valA,valB)
	if type(nNum)~="number" then
		nNum = 1
	end
	if nNum>1 then
		local tTemp = {}
		local nRand = nMax-nMin
		for i = 1,nNum,1 do
			if nRand>=0 then
				local v
				if oWorld then
					--v = oWorld:random(0,nRand,sReason)
					v = hApi.random(0,nRand)
				else
					v = hApi.random(0,nRand)
				end
				local plus = 0
				local n = 1
				local nInsert = #tTemp+1
				for n = 1,#tTemp do
					if (v+plus)>=tTemp[n] then
						plus = plus + 1
					end
					if tTemp[n+1]==nil or (v+plus)<tTemp[n+1] then
						if (v+plus)<=tTemp[n] then
							nInsert = n
						else
							nInsert = n + 1
						end
						break
					end
				end
				v = v + plus
				nRand = nRand - 1
				if nInsert<=#tTemp then
					for n = #tTemp,nInsert,-1 do
						tTemp[n+1] = tTemp[n]
					end
				end
				tTemp[nInsert] = v
				tValue[i] = nMin+v
			else
				tValue[i] = nMin
			end
		end
	elseif nNum==1 then
		local v
		if oWorld then
			--v = oWorld:random(nMin,nMax,sReason)
			v = hApi.random(nMin,nMax)
		else
			v = hApi.random(nMin,nMax)
		end
		tValue[1] = v
	end
	return tValue
end

hApi.localrandom = hApi.random

hApi.IsInEditorDrag = function()
	return xlEditorGetMouseCha()~=nil
end

hApi.SceneRefreshBuildingData = function(sce)
	--geyachao: 同步日志: 刷新障碍信息
	if (hVar.IS_SYNC_LOG == 1) then
		local msg = "xlScene_RefreshBuildingData: refresh!"
		hApi.SyncLog(msg)
	end
	
	return xlScene_RefreshBuildingData(sce)
end

hApi.LoadWorldLayer = function(handleTable,mode)
	if type(hGlobal.WORLD_SCENE[mode])=="userdata" then
		handleTable.worldScene = hGlobal.WORLD_SCENE[mode]
		handleTable.worldLayer = hGlobal.WORLD_LAYER[mode]
	else
		if mode~="none" then
			_DEBUG_MSG("[LUA WARNING]加载世界到未创建的Layer:"..tostring(mode))
		end
		handleTable.worldLayer = hGlobal.WORLD_LAYER["worldmap"]
		handleTable.worldScene = hGlobal.WORLD_SCENE["worldmap"]
	end
	return handleTable.worldLayer
end

hApi.GetWorldChaByHit = function(worldType,worldX,worldY)
	if g_vs_number <= 6 then
		return xlGameLayer_HitTest(xlScene_LuaName2CName(worldType),worldX,worldY)
	else
		return xlScene_HitTest(hGlobal.WORLD_SCENE[worldType],worldX,worldY)
	end
end

local __ReloadFlag = 0
hApi.EnableWorldLayer = function(handleTable,enable)
	if type(handleTable.worldScene)=="userdata" and (__ReloadFlag==1 or g_current_scene~=handleTable.worldScene) then
		__ReloadFlag = 0
		return xlScene_Switch(handleTable.worldScene)
	end
	--xlEnableLayer(handleTable.worldLayer,enable or 1)
end
hApi.clearCurrentWorldScene = function()
	__ReloadFlag = 1
end

hApi.SetCameraRect = function(x,y,w,h,param)
	return xlSetCameraRect(x,y,w,h,param)
end

hApi.CheckTable = function(t,define)
	if type(t)=="table" then
		for i = 1,#define do
			if type(t[i])~=define[i] then
				return hVar.RESULT_FAIL
			end
		end
	end
	return hVar.RESULT_SUCESS
end

hApi.EnumTable2V = function(tab,code,paramI,paramII)
	local t = tab
	if type(t[1])=="table" then
		for row = 1,#t do
			local v = t[row]
			for col = 1,#v do
				code(v[col],col-1,row-1,t,paramI,paramII)
			end
		end
		return 2
	else
		local v = t
		for col = 1,#v do
			code(v[col],col-1,0,v,paramI,paramII)
		end
		return 1
	end
end
-----------------------------------------
--@世界坐标计算函数
--@网格起始宽高
hDefine.grid = {x=0,y=0,w=16,h=16,offsetX=8,offsetY=8}

hApi.view2world = function(x,y)
	return xlView2World(x,y)
end

hApi.ui2world = function(x,y)
	return xlView2World(x,hVar.SCREEN.h-y)
end

hApi.world2view = function(x,y)
	local rx,ry = xlWorld2View(x,y)
	return rx,hVar.SCREEN.h-ry
end

hApi.chaSetPos = function(handleTable,x,y)
	return xlCha_SetPos(handleTable._c,x,y)
end

hApi.chaSetUniqueID = function(handleTable,uid,worldScene)
	return xlCha_SetUniqueID(handleTable._c,uid,worldScene)
end

hApi.chaSetGrid = function(handleTable,girdX,girdY)
	--chaMoveToGrid(c,gridX,gridY)
end

hApi.chaShowPath = function(handleTable,IsShow)
	return xlCha_ShowPath(handleTable._c,IsShow==0 and 0 or 1)
end

hApi.chaSetCameraFollow = function(handleTable)
	if handleTable==nil then
		return xlSetFocusCha(nil)
	else
		return xlSetFocusCha(handleTable._c)
	end
end

xlCha_SetMoveSound = xlCha_SetMoveSound or function()end
hApi.chaSetMoveSound = function(handleTable,sSoundName)
	if handleTable._c==nil then
		--无有效的cha指针
	elseif type(sSoundName)=="string" then
		return xlCha_SetMoveSound(handleTable._c,sSoundName)
	else
		if sSoundName==1 then
			sSoundName = "move_horse01"
		else
			sSoundName = ""
		end
		return xlCha_SetMoveSound(handleTable._c,sSoundName)
	end
end

hApi.chaMoveToGrid = function(handleTable,gridX,gridY,moveTarget)
	local waypoint = xlCha_MoveToGrid(handleTable._c,gridX,gridY,1,moveTarget)
	if waypoint and waypoint[0]==0 then
		return hVar.RESULT_FAIL
	end
	return hVar.RESULT_SUCESS
end

hApi.chaDrawWayPoint = function(handleTable,gridX,gridY,moveTarget)
	--if true then
	--	return
	--end
	
	local waypoint = xlCha_MoveToGrid(handleTable._c,gridX,gridY,0,moveTarget)
	if waypoint and waypoint[0]==0 then
		return hVar.RESULT_FAIL,nil
	end
	return hVar.RESULT_SUCESS,waypoint
end

hApi.chaSetOwner = function(handleTable,owner,withFlag)
	if type(owner)~="number" then
		_DEBUG_MSG("[LUA WARNING] xlSetChaOwner #2 需要一个number")
		return
	end
	return xlChaSetOwner(handleTable._c,owner,withFlag)
	--return xlChaSetOwner(handleTable._c,owner, 0) --geyachao: TD地图不需要插旗子
end

hApi.chaEnableClearFog = function(handleTable,IsEnable,size)
	if handleTable._c then
		return xlCha_EnableClearFog(handleTable._c,IsEnable,size)
	end
end

hApi.chaMoveTo = function(handleTable,x,y,moveTarget)
	--此函数暂时不使用target
	return xlChaMoveToPoint(handleTable._c,x,y)
end

hApi.chaGetPos = function(handleTable)
	if (handleTable == nil) or (handleTable._c == nil) then
		--_DEBUG_MSG("[LUA ERROR] chaGetPos() -> oUnit.handle._c为空!")
		--local text = debug.traceback()
		--print(text)
		return 0, 0
	else
		--版本1
		--return xlCha_GetPos(handleTable._c) --geyachao: 修改接口
		
		--版本2
		--local pos_x, pos_y = handleTable._n:getPosition() --目标的位置
		--pos_y = -pos_y --屏幕坐标系！！！！！！！！！
		--return pos_x, pos_y
		
		--版本3
		return handleTable.x or 0, handleTable.y or 0
	end
end

local __xlPlaySoundEffect = xlPlaySoundEffect
hApi.PlaySound = function(name)
	if hVar.OPTIONS.PLAY_SOUND~=1 then
		return
	end
	return __xlPlaySoundEffect(name)
end

local __BGSound = {}
hApi.PlaySoundBG = function(channel,name,mode)
	for chanl, na in pairs(__BGSound)do
		if (na ~= 0) then --原来本频道有音乐播放
			if (name == 0) or (chanl ~= channel) then
				__BGSound[chanl] = 0
				xlStopMusic(chanl)
			end
		end
	end
	if (name ~= 0) then
		if type(mode)~="number" then
			mode = 1
		end
		__BGSound[channel] = name
		if hVar.OPTIONS.PLAY_SOUND_BG==1 then
			xlPlayMusic(name,channel,mode)
			if channel == g_channel_world then
				local volume = hApi.NumBetween(0.1,1,hVar.MUSIC_VOLUME)
				xlSetMusicVolume(channel,volume)
			end
		end
	end
end

--获得某频道当前播放的音乐
hApi.GetPlaySoundBG = function(channel)
	return __BGSound[channel]
end

hApi.EnableSoundBG = function(IsEnable)
	if IsEnable==1 then
		if xlEnableSound~=nil then
			xlEnableSound(1)
		end
		for k,v in pairs(__BGSound)do
			if v~=0 then
				xlPlayMusic(v,k,1)
			end
		end
	else
		for k,v in pairs(__BGSound)do
			if v~=0 then
				xlStopMusic(k)
			end
		end
		if xlEnableSound~=nil then
			xlEnableSound(0)
		end
	end
end

hApi.StopSound = function(pSound)	--目前似乎没地方在用
	return xlStopSoundEffect(pSound)
end

hApi.getViewScale = function()
	return xlGetViewNodeScale()
end

hApi.chaGetStopPoint = function(handleTable)
	return xlGetChaStopPoint(handleTable._c)
end

--设置角色的移动速度（基础移动速度）
hApi.chaSetMoveSpeed = function(handleTable, speed)
	local unit = hApi.findUnitByCha(handleTable._c)
	
	--print("hApi.chaSetMoveSpeed:unit[".. tostring(unit.data.name).."]:".. tostring(speed))
	local fianlSpeed = speed * hApi.GetTimeScale()
	return xlChaSetMoveSpeed(handleTable._c, math.min(math.max((fianlSpeed or 300), 0), 9999) / 100)
end

--附加角色移动速度（buff移动速度）
hApi.chaAddMoveSpeed = function(handleTable)
	local unit = hApi.findUnitByCha(handleTable._c)
	local move_speed = unit:GetMoveSpeed() --移动速度
	
	--print("hApi.chaSetMoveSpeed:unit[".. tostring(unit.data.name).."]:".. tostring(speed))
	local fianlSpeed = move_speed * hApi.GetTimeScale()
	return xlChaSetMoveSpeed(handleTable._c, math.min(math.max((fianlSpeed or 300), 0), 9999) / 100)
end

hApi.chaGetMovePoint = function(handleTable)
	return xlChaGetCurrentMovePoints(handleTable._c)
end

hApi.chaSetMovePoint = function(handleTable,v)
	return xlChaSetCurrentMovePoints(handleTable._c,v)
end

hApi.chaSetMaxMovePoint = function(handleTable,v)
	return xlChaSetMaxMovePoints(handleTable._c,v)
end

hApi.chaGetMaxMovePoint = function(handleTable)
	return xlChaGetMaxMovePoints(handleTable._c)
end

--设置镜头的中心点
hApi.setViewNodeFocus = function(x, y)
	local oWorld = hGlobal.WORLD.LastWorldMap
	if oWorld then
		local mapInfo = oWorld.data.tdMapInfo
		if mapInfo then
			
			local tParam = hVar.DEVICE_PARAM[g_phone_mode] or {}
			
			local world_scale = tParam.world_scale or 1.0
			
			--编辑器模式固定为1.0缩放
			if (g_editor == 1) then
				fScale = 1.0
			end
			
			local W, H = oWorld.data.sizeW,oWorld.data.sizeH
			local viewRange = mapInfo.viewRange or {}
			local viewOffset = mapInfo.viewOffset or {}
			local viewOffsetPhone = mapInfo.viewOffsetPhone
			local right = (viewRange[1] or 0)
			local left = (viewRange[2] or 0)
			local up = (viewRange[3] or 0)
			local down = (viewRange[4] or 0)
			local ox = (viewOffset[1] or 0)
			local oy = (viewOffset[2] or 0)
			
			if (g_phone_mode == 1 or g_phone_mode == 2) and viewOffsetPhone and type(viewOffsetPhone) == "table" then
				ox = (viewOffsetPhone[1] or 0)
				oy = (viewOffsetPhone[2] or 0)
			end
			
			local leftX = left + (hVar.SCREEN.w * 0.5) / world_scale --x最小值
			local rightX = W - right - (hVar.SCREEN.w * 0.5) / world_scale --x最大值
			local upY = up + (hVar.SCREEN.h * 0.5) / world_scale --y最小值
			local downY = H - down - (hVar.SCREEN.h * 0.5) / world_scale --y最大值
			
			--local minX = math.min(leftX,rightX)
			--local maxX = math.max(leftX,rightX)
			--local minY = math.min(upY,downY)
			--local maxY = math.max(upY,downY)
			
			--x = math.min(math.max(x, minX), maxX)
			--y = math.min(math.max(y, minY), maxY)
			
			if leftX <= rightX then
				if x <= leftX then
					x = leftX
				elseif x >= rightX then
					x = rightX
				end
			end
			
			if upY <= downY then
				if y <= upY then
					y = upY
				elseif y >= downY then
					y = downY
				end
			--else
			--	if y <= downY then
			--		y = downY
			--	elseif y >= upY then
			--		y = upY
			--	end
			end
			
			if W - (right + left) < hVar.SCREEN.w / world_scale then
				x = W * 0.5
			end
			
			if H - (up + down) < hVar.SCREEN.h / world_scale then
				y = H * 0.5
			end
			
			--print("hApi.setViewNodeFocus:",x,y,"left="..left,right,up,down,"leftX="..leftX,rightX,upY,downY)
			
			local regionId = oWorld.data.randommapIdx --当前所在随机地图索引
			if (regionId > 0) then
				local regionData = oWorld.data.randommapInfo[regionId] --随机地图信息
				
				--远景物件
				local farObj = regionData.universe_farobj
				if (type(farObj) == "table") then
					local camX = farObj.camX
					local camY = farObj.camY
					local rollRatio = farObj.rollRatio
					if camX and camY then
						local node = farObj.node
						local dx = x - camX
						local dy = y - camY
						local movedx = dx * (1 - rollRatio)
						local movedy = dy * (1 - rollRatio)
						for n = 1, #node, 1 do
							local nodei = node[n]
							local ex, ey = nodei:getPosition()
							nodei:setPosition(ex + movedx, ey - movedy) --设置角色的位置
						end
						
						farObj.camX = x
						farObj.camY = y
					end
				end
				
				--中景物件
				local middleObj = regionData.universe_middleobj
				if (type(middleObj) == "table") then
					local camX = middleObj.camX
					local camY = middleObj.camY
					local rollRatio = middleObj.rollRatio
					--print("camX", camX)
					--print("camY", camY)
					if camX and camY then
						local node = middleObj.node
						local dx = x - camX
						local dy = y - camY
						local movedx = dx * (1 - rollRatio)
						local movedy = dy * (1 - rollRatio)
						--print("#node", #node)
						for n = 1, #node, 1 do
							local nodei = node[n]
							local ex, ey = nodei:getPosition()
							nodei:setPosition(ex + movedx, ey - movedy) --设置角色的位置
							--print("设置角色的位置", n)
						end
						
						middleObj.camX = x
						middleObj.camY = y
					end
				end
				
				--近景物件
				local nearObj = regionData.universe_nearobj
				if (type(nearObj) == "table") then
					local camX = nearObj.camX
					local camY = nearObj.camY
					local rollRatio = nearObj.rollRatio
					--print("camX", camX)
					--print("camY", camY)
					if camX and camY then
						local node = nearObj.node
						local dx = x - camX
						local dy = y - camY
						local movedx = dx * (1 - rollRatio)
						local movedy = dy * (1 - rollRatio)
						--print("#node", #node)
						for n = 1, #node, 1 do
							local nodei = node[n]
							local ex, ey = nodei:getPosition()
							nodei:setPosition(ex + movedx, ey - movedy) --设置角色的位置
							--print("设置角色的位置", n)
						end
						
						nearObj.camX = x
						nearObj.camY = y
					end
				end
			end
		end
	end
	
	return xlSetViewNodeFocus(x, y)
end

hApi.calMoveTime = function(x,y,tx,ty,speed)
	if speed<=0 then return 1 end
	local r = hApi.getint(math.sqrt((tx-x)^2+(ty-y)^2))
	local t = hApi.getint(r*1000/speed)
	if t<=0 then
		return 1,0
	else
		return t,r
	end
end

hApi.InitUnitTeam = function()
	local team = {}
	for i = 1,hVar.TEAM_UNIT_MAX do
		team[i] = 0
	end
	return team
end

hApi.getint = function(v)
	if v>0 then
		return math.floor(v)
	else
		return -1*math.floor(math.abs(v))
	end
end

hApi.floor = function(v)
	if v>-1 then
		if v<=0 then
			return 0
		else
			return math.floor(v)
		end
	else
		return -1*math.floor(math.abs(v))
	end
end

hApi.ceil = function(v)
	if v>0 then
		return math.ceil(v)
	else
		return -1*math.ceil(math.abs(v))
	end
end

hApi.clearTable = function(mode,t)
	t = t or {}
	if mode=="I" then
		t.i = 0
	elseif mode=="H" then
		for k in pairs(t)do
			t[k] = nil
		end
	end
	return t
end

hApi.zeroTable = function(t)
	if t then
		for k in pairs(t)do
			t[k] = 0
		end
	else
		t = {}
	end
	return t
end

hApi.removeObject = function(o)
	--xlLG("RoadPoint", "hApi.removeObject(), unit=" .. tostring(o.data.name) .. "_" .. tostring(o.__ID) .. "\n")
	o:del()
end

hApi.CreateGridExTable = function(gridTable,exTable)
	local blockEx = {}
	local wIndex = {}
	for i = 1,#gridTable do
		local v = gridTable[i]
		wIndex[v.x.."_"..v.y] = i
	end
	for i = 1,#gridTable do
		local v = gridTable[i]
		for n = 1,#exTable do
			local x,y = v.x+exTable[n][1],v.y+exTable[n][2]
			local key = x.."_"..y
			if type(wIndex[key])~="number" then
				if wIndex[key]==nil then
					wIndex[key] = {x=x,y=y,ox=v.x,oy=v.y}
				else
					local gx,gy = wIndex[key].x,wIndex[key].y
					local ox,oy = wIndex[key].ox,wIndex[key].oy
					if math.abs(x-cx)+math.abs(y-cy)<math.abs(ox-gx)+math.abs(oy-gy) then
						wIndex[key].ox = v.x
						wIndex[key].oy = v.y
					end
				end
			end
		end
	end
	for k,v in pairs(wIndex) do
		if type(v)=="number" then
			blockEx[#blockEx+1] = gridTable[v]
		else
			blockEx[#blockEx+1] = v
		end
	end
	return blockEx
end

hApi.CreateGridIndexTab = function(grid)
	local _grid = {}
	for i = 1,(grid.n or #grid) do
		_grid[grid[i].x.."_"..grid[i].y] = i
	end
	return _grid
end

hApi.getBindObject = function(class,dataKey,oParent,managerKey,key)
	local t = oParent.data[managerKey]
	if t.index and key~=nil then
		local n = t.index[key]
		if n~=nil and n~=0 and t[n]~=nil and t[n]~=0 then
			local oChild = class:find(t[n])
			if oChild~=nil then
				local v = oChild.data[dataKey]
				if type(v)=="table" and v[1]==oParent.ID and v[2]==oParent.__ID and v[3]==n and v[4]==key then
					return oChild
				end
			end
		end
	end
end

hApi.indexForObjectList = function(t)
	t.index = {}
	t.i = t.i or 0
	for i = 1,t.i do
		if t[i]~=0 and v[4]~=nil then
			t.index[v[4]] = i
		end
	end
	return t
end

hApi.createObjectList = function()
	return {i=0,index={}}
end

hApi.bind2Object = function(oChild,dataKey,oParent,managerKey,key)
	if oParent~=nil then
		local t = oParent.data[managerKey]
		local v = oChild.data[dataKey]
		if t.index~=nil and key~=nil then
			local n = t.index[key]
			if n and n~=0 then
				local oldID = t[n]
				t[n] = oChild.ID
				v[1] = oParent.ID
				v[2] = oParent.__ID
				v[3] = n
				v[4] = key
				--print("return n,oldID")
				return n,oldID
			end
		end
		local num = t.i or #t
		for i = 1,num do
			if t[i]==0 then
				t[i] = oChild.ID
				v[1] = oParent.ID
				v[2] = oParent.__ID
				v[3] = i
				v[4] = key
				if t.index~=nil and key~=nil then
					t.index[key] = i
				end
				--print("return i", oChild.ID, i)
				return i
			end
		end
		local n = num+1
		t[n] = oChild.ID
		t.i = n
		v[1] = oParent.ID
		v[2] = oParent.__ID
		v[3] = n
		v[4] = key
		if t.index~=nil and key~=nil then
			t.index[key] = n
		end
		--print("return n")
		return n
	end
end

hApi.unbind2Object = function(oChild,dataKey,oParent,managerKey)
	--print("unbind2Object" .. nil)
	if oChild~=nil then
		if oParent and oParent.data.IsDestroyed~=1 then
			local t = oParent.data[managerKey]
			local v = oChild.data[dataKey]
			local index = v[3]
			local key = v[4]
			v[1] = 0
			v[2] = 0
			v[3] = 0
			v[4] = nil
			if t[index]==oChild.ID then
				t[index] = 0
				if t.index~=nil and key~=nil then
					t.index[key] = 0
				end
			end
		else
			local v = oChild.data[dataKey]
			v[1] = 0
			v[2] = 0
			v[3] = 0
			v[4] = nil
		end
	end
end

hApi.bindObjectWithParent = function(k,_k,p,o)
	if p and p.data and p.data[k] then
		local t = p.data[k]
		local num = t.i or #t
		for i = 1,num do
			if t[i]==0 then
				t[i] = o.ID
				o.data[_k] = i
				return i
			end
		end
		local n = num+1
		o.data[_k] = n
		t[n] = o.ID
		if t.i then
			t.i = n
		end
		return n
	end
	return o.data[_k]
end

hApi.unbindObjectWithParent = function(k,_k,p,o)
	--对已经标记即将被删除的单位不进行解绑
	if p and p.data and p.data[k] and p.data.IsDestroyed~=1 then
		local t,ti = p.data[k],o.data[_k]
		if t[ti]==o.ID then
			t[ti] = 0
		end
	end
end

hApi.getObjectFromBind = function(class,k,_k,p,i)
	--从绑定单位身上拿出object
	if p and p.data and p.data[k] and p.data.IsDestroyed~=1 and p.data[k][i]~=0 and type(p.data[k][i])=="number" then
		local o = class:find(p.data[k][i])
		if o and o.data[_k]==i then
			return o
		end
	end
end

hApi.enumByClass = function(self,class,tab,code,param,param2)
	for i = 1,(tab.i or #tab),1 do
		local o = class:find(tab[i])
		if o then
			code(o,param,param2,self)
		end
	end
end

hApi.enumByClassR = function(self,class,tab,code,param,param2)
	for i = 1,(tab.i or #tab),1 do
		local o = class:find(tab[i])
		if o then
			local r = code(o,param,param2,self)
			if r then
				return r,i
			end
		end
	end
end

hApi.insertIntoIndexTab = function(t,id,v,code)
	local n = t.index[id] or 0
	if n~=0 then
		if v>0 then
			t[n][1] = id
			t[n][2] = v
			if code then
				code(t[n])
			end
		else
			t[n] = 0
			t.index[id] = 0
		end
	elseif v>0 then
		n = #t + 1
		for i = 1,#t do
			if t[i]==0 then
				n = i
				break
			end
		end
		t[n] = {id,v}
		if code then
			code(t[n])
		end
	end
end

--|1 2 3|--|135  90  45|
--|4 * 5|--|180  *    0|
--|6 7 8|--|225 270 305|
--将NODE转换成direction
hApi.calNodeD = function(cNode,nNode,mapW)
	local v = nNode - cNode
	if v==0 then
		return 0
	elseif v>=1 then
		v = v - (mapW-3) + 4
	elseif v<=-1 then
		v = v + (mapW-3) + 5
	end
	return math.min(8,math.max(v,1))
end

--将面向角度facing转换为格子指引direction
local AngleToD = {
	--32方向
	["DIRECTIONx32"] =
	{
		--|1    2    3    4    5    6    7|--|123.75    112.5     101.25     90     78.75     67.5     56.25|
		--|8                             9|--|135                                                         45|
		--|10                           11|--|146.25                                                   33.75|
		--|12                           13|--|157.5                                                     22.5|
		--|14                           15|--|168.75                                                   11.25|
		--|16             *             17|--|180                            *                             0|
		--|18                           19|--|191.25                                                  348.75|
		--|20                           21|--|202.5                                                    337.5|
		--|22                           23|--|213.75                                                  326.25|
		--|24                           25|--|225                                                        315|
		--|26   27   28   29   30   31  32|--|236.25    247.5    258.75     270    281.25    292.5    303.75|
		[0] = {33, 17}, --[0] = {方向数量（不包含[0]），默认返回方向}
		[1] = {0, 17},
		[2] = {0 + 5.625, 15},
		[3] = {11.25 + 5.625, 13},
		[4] = {22.5 + 5.625, 11},
		[5] = {33.75 + 5.625, 9},
		[6] = {45 + 5.625, 7},
		[7] = {56.25 + 5.625, 6},
		[8] = {67.5 + 5.625, 5},
		[9] = {78.75 + 5.625, 4},
		[10] = {90 + 5.625, 3},
		[11] = {101.25 + 5.625, 2},
		[12] = {112.5 + 5.625, 1},
		[13] = {123.75 + 5.625, 8},
		[14] = {135 + 5.625, 10},
		[15] = {146.25 + 5.625, 12},
		[16] = {157.5 + 5.625, 14},
		[17] = {168.75 + 5.625, 16},
		[18] = {180 + 5.625, 18},
		[19] = {191.25+ 5.625, 20},
		[20] = {202.5 + 5.625, 22},
		[21] = {213.75 + 5.625, 24},
		[22] = {225 + 5.625, 26},
		[23] = {236.25 + 5.625, 27},
		[24] = {247.5 + 5.625, 28},
		[25] = {258.75 + 5.625, 29},
		[26] = {270 + 5.625, 30},
		[27] = {281.25 + 5.625, 31},
		[28] = {292.5 + 5.625, 32},
		[29] = {303.75 + 5.625, 25},
		[30] = {315 + 5.625, 23},
		[31] = {326.25 + 5.625, 21},
		[32] = {337.5 + 5.625, 19},
		[33] = {348.75 + 5.625, 17},
	},
	
	--16方向
	["DIRECTIONx16"] =
	{
		--|1   2   3   4   5|--|135      112.5    90     67.5      45|
		--|6               7|--|157.5                            22.5|
		--|8       *       9|--|180               *                 0|
		--|10             11|--|202.5                           337.5|
		--|12  13  14  15 16|--|225     247.5    270    292.5     315|
		[0] = {17, 9}, --[0] = {方向数量（不包含[0]），默认返回方向}
		[1] = {0, 9},
		[2] = {0 + 11.25, 7},
		[3] = {22.5 + 11.25, 5},
		[4] = {45 + 11.25, 4},
		[5] = {67.5 + 11.25, 3},
		[6] = {90 + 11.25, 2},
		[7] = {112.5 + 11.25, 1},
		[8] = {135 + 11.25, 6},
		[9] = {157.5 + 11.25, 8},
		[10] = {180 + 11.25, 10},
		[11] = {202.5 + 11.25, 12},
		[12] = {225 + 11.25, 13},
		[13] = {247.5 + 11.25, 14},
		[14] = {270 + 11.25, 15},
		[15] = {292.5 + 11.25, 16},
		[16] = {315 + 11.25, 11},
		[17] = {337.5 + 11.25, 9},
	},
	
	--8方向
	["DIRECTIONx8"] =
	{
		--|1 2 3|--|135   90   45|
		--|     |--|             |
		--|4 * 5|--|180   *     0|
		--|     |--|             |
		--|6 7 8|--|225  270  315|
		[0] = {9, 5}, --[0] = {方向数量（不包含[0]），默认返回方向}
		[1] = {0, 5},
		[2] = {0 + 22.5, 3},
		[3] = {45 + 22.5, 2},
		[4] = {90 + 22.5, 1},
		[5] = {135 + 22.5, 4},
		[6] = {180 + 22.5, 6},
		[7] = {225 + 22.5, 7},
		[8] = {270 + 22.5, 8},
		[9] = {315 + 22.5, 5},
	},
	
	--4方向
	["DIRECTIONx4"] =
	{
		--|  1  |--|     90     |
		--|2 * 3|--|180   *    0|
		--|  4  |--|     270    |
		[0] = {5, 3}, --[0] = {方向数量（不包含[0]），默认返回方向}
		[1] = {0, 3},
		[2] = {0 + 45, 1},
		[3] = {90 + 45, 2},
		[4] = {180 + 45 ,4},
		[5] = {270 + 45, 3},
	},
}

local Grid2D = {
	--32方向
	["DIRECTIONx32"] =
	{
		--|1    2    3    4    5    6    7|--|123.75    112.5     101.25     90     78.75     67.5     56.25|
		--|8                             9|--|135                                                         45|
		--|10                           11|--|146.25                                                   33.75|
		--|12                           13|--|157.5                                                     22.5|
		--|14                           15|--|168.75                                                   11.25|
		--|16             *             17|--|180                            *                             0|
		--|18                           19|--|191.25                                                  348.75|
		--|20                           21|--|202.5                                                    337.5|
		--|22                           23|--|213.75                                                  326.25|
		--|24                           25|--|225                                                        315|
		--|26   27   28   29   30   31  32|--|236.25    247.5    258.75     270    281.25    292.5    303.75|
		1,   2,   3,   4,   5,   6,   7,
		8,                            9,
		10,                          11,
		12,                          13,
		14,                          15,
		16,                          17,
		18,                          19,
		20,                          21,
		22,                          23,
		24,                          25,
		26,  27,  28,  29,  30,  31, 32,
	},
	
	--16方向
	["DIRECTIONx16"] =
	{
		--|1   2   3   4   5|--|135      112.5    90     67.5      45|
		--|6               7|--|157.5                            22.5|
		--|8       *       9|--|180               *                 0|
		--|10             11|--|202.5                           337.5|
		--|12  13  14  15 16|--|225     247.5    270    292.5     315|
		1,   2,  3,  4,  5,
		6,               7,
		8,               9,
		10,             11,
		12, 13, 14, 15, 16,
	},
	
	--8方向
	["DIRECTIONx8"] =
	{
		--|1 2 3|--|135   90   45|
		--|     |--|             |
		--|4 * 5|--|180   *     0|
		--|     |--|             |
		--|6 7 8|--|225  270  315|
		1, 2, 3,
		4,    5,
		6, 7, 8,
	},
	
	--4方向
	["DIRECTIONx4"] =
	{
		--|  1  |--|     90     |
		--|2 * 3|--|180   *    0|
		--|  4  |--|     270    |
		   1,
		2,   3,
		   4
	},
}

local GridD2S =
{
	--32方向
	["DIRECTIONx32"] =
	{
		--|1    2    3    4    5    6    7|--|123.75    112.5     101.25     90     78.75     67.5     56.25|
		--|8                             9|--|135                                                         45|
		--|10                           11|--|146.25                                                   33.75|
		--|12                           13|--|157.5                                                     22.5|
		--|14                           15|--|168.75                                                   11.25|
		--|16             *             17|--|180                            *                             0|
		--|18                           19|--|191.25                                                  348.75|
		--|20                           21|--|202.5                                                    337.5|
		--|22                           23|--|213.75                                                  326.25|
		--|24                           25|--|225                                                        315|
		--|26   27   28   29   30   31  32|--|236.25    247.5    258.75     270    281.25    292.5    303.75|
		"123.75",  "112.5",  "101.25",  "90",  "78.75",   "67.5",   "56.25",
		"135",                                                         "45",
		"146.25",                                                   "33.75",
		"157.5",                                                     "22.5",
		"168.75",                                                   "11.25",
		"180",                                                         "0",
		"191.25",                                                  "348.75",
		"202.5",                                                    "337.5",
		"213.75",                                                  "326.25",
		"225",                                                        "315",
		"236.25", " 247.5",  "258.75",  "270",  "281.25", "292.5", "303.75",
	},
	
	--16方向
	["DIRECTIONx16"] =
	{
		--|1   2   3   4   5|--|135      112.5    90     67.5      45|
		--|6               7|--|157.5                            22.5|
		--|8       *       9|--|180               *                 0|
		--|10             11|--|202.5                           337.5|
		--|12  13  14  15 16|--|225     247.5    270    292.5     315|
		"135",      "112.5",     "90",      "67.5",         "45",
		"157.5",                                          "22.5",
		"180",                                               "0",
		"202.5",                                         "337.5",
		"225",      "247.5",     "270",     "292.5",       "315",
	},
	
	--8方向
	["DIRECTIONx8"] =
	{
		--|1 2 3|--|135   90   45|
		--|     |--|             |
		--|4 * 5|--|180   *     0|
		--|     |--|             |
		--|6 7 8|--|225  270  315|
		"LT", "MT", "RT",
		"LC",       "RC",
		"LB", "MB", "RB",
	},
	
	--4方向
	["DIRECTIONx4"] = {
		--|  1  |--|     90     |
		--|2 * 3|--|180   *    0|
		--|  4  |--|     270    |
			"T",
		"L",     "R",
			"B",
	},
}

hApi.calAngleD = function(mode,a)
	local r = -1
	local d = AngleToD[mode]
	if d then
		r = d[0][2]
		for i = 1,d[0][1] do
			if a<=d[i][1] then
				return r
			else
				r = d[i][2]
			end
		end
	end
	return r
end

hApi.calAngleS = function(mode,a)
	if mode==nil or mode==0 then
		if a>90 and a<=270 then
			return "L"
		else
			return "R"
		end
	else
		local r = 0
		local d = AngleToD[mode]
		local v = GridD2S[mode]
		if d and v then
			r = d[0][2]
			for i = 1,d[0][1] do
				if a<=d[i][1] then
					return v[r]
				else
					r = d[i][2]
				end
			end
			return v[r]
		end
	end
end

hApi.angleBetweenPoints = function(x,y,tx,ty)
	local baseD = math.atan2(y-ty,tx-x)
	local angle = hApi.getint(math.deg(baseD))
	if angle<0 then
		angle = angle + 360
	end
	return angle
end

hApi.calGridD = function(mode,gridX,gridY,nGridX,nGridY)
	if Grid2D[mode] then
		local x = (gridX>nGridX and 0) or (gridX<nGridX and 2) or 1
		local y = (gridY>nGridY and 0) or (gridY<nGridY and 2) or 1
		return Grid2D[mode][hApi.calNodeD(4,3*y+x,3)] or 0
	end
	return 0
end

hApi.calGridA = function(gridX,gridY,tGridX,tGridY,defaultA)
	if tGridX==gridX and tGridY==gridY then
		return defaultA or 0
	elseif tGridX==gridX and tGridY>gridY then
		return 270
	elseif tGridX==gridX and tGridY<gridY then
		return 90
	elseif tGridX>gridX and tGridY==gridY then
		return 0
	elseif tGridX>gridX and tGridY>gridY then
		return 315
	elseif tGridX>gridX and tGridY<gridY then
		return 45
	elseif tGridX<gridX and tGridY==gridY then
		return 180
	elseif tGridX<gridX and tGridY>gridY then
		return 225
	elseif tGridX<gridX and tGridY<gridY then
		return 135
	end
	return defaultA or 0
end

--------------------------------------------
-- 清除所有的死亡镜像
local __WorldCreateCount = 0
local __ShowILL = function()
	local w = hGlobal.WORLD.LastWorldMap
	if w and __WorldCreateCount==w.__ID then
		for k,v in pairs(hGlobal.LOCAL_DEAD_ILLUSION)do
			hApi.SpriteShowDead(v,"unit")
		end
	end
end
local __ClearILL = function()
	local w = hGlobal.WORLD.LastWorldMap
	if w and __WorldCreateCount==w.__ID then
		for k,v in pairs(hGlobal.LOCAL_DEAD_ILLUSION)do
			hGlobal.LOCAL_DEAD_ILLUSION[k] = nil
			v.s:getParent():removeChild(v.s,true)
		end
	else
		for k,v in pairs(hGlobal.LOCAL_DEAD_ILLUSION)do
			hGlobal.LOCAL_DEAD_ILLUSION[k] = nil
		end
	end
end
hApi.ClearLocalDeadIllusion = function()
	local w = hGlobal.WORLD.LastWorldMap
	if w then
		__WorldCreateCount = w.__ID
		hApi.addTimerOnce("__BattleVictoryX__",200,__ShowILL)
		hApi.addTimerOnce("__ClearLocalIllusion",800,__ClearILL)
	else
		__ClearILL()
	end
end
-----------------------------------------
-----------------------------------------
--@Sprite操作函数
hApi.GetSafeModelByKey = function(model)
	local md
	local modelIndexs
	if hVar.tab_model.index[model] then
		md = hVar.tab_model[hVar.tab_model.index[model]]
		if md then
			modelIndex = hVar.tab_model.index[model]
		else
			md = hVar.tab_model[1]
			modelIndex = 1
		end
	else
		if hVar.tab_model[model] then
			modelIndex = model
		else
			modelIndex = 1
		end
		md = hVar.tab_model[modelIndex]
	end
	return md,modelIndex
end

--local g_tempUIImageCount = 0
--local g_tempChaImageCount = 0
if g_texture_manager~=nil then
	hResource.model = g_texture_manager
else
	local _TEXTURE_LG = function(nLogFlag,sText)
		if hResource.model.showlog==0 then
			--不显示log
		elseif nLogFlag==0 then
			--释放资源
			--xlLG("plist_init",sText)
			print(sText)
		elseif nLogFlag==1 then
			--加载资源
			--print(sText)
		elseif nLogFlag==2 then
			--加载plist
			--print(sText)
		elseif nLogFlag==3 then
			--加载png 失败
			--print(sText)
		elseif nLogFlag==4 then
			--加载plist 失败
			xlLG("plist",sText)
		end
	end
	local _texturePermanent = {}		--存放永久性的texture纹理
	local _shared_pListPath = {}		--共享pList路径记录

	local _textureCache = {}		--存放texture纹理(指针)
	local _textureCacheByType = {}		--存放texture纹理(分类)
	local _textureUnavailable = {}		--记录无法使用的texture(路径)

	local _plistCache = {}			--存放plist纹理(路径)
	local _plistCacheByType = {}		--存放plist纹理(分类)
	local nMax = 0
	for k,v in pairs(hVar.TEMP_HANDLE_TYPE)do
		if v>nMax then
			nMax = v
		end
	end
	for i = 1,nMax do
		_plistCacheByType[i] = {}
		_textureCacheByType[i] = {}
	end
	local _PNG_DefaultPath = "misc/mask.png"
	local _SystemPNG = {
		["misc/blue_circle.png"] = 1,
		["misc/circle.png"] = 1,
		["misc/gridAx6.png"] = 1,
		["misc/valuebar_old.png"] = 1,
		["misc/bosshp.png"] = 1, --geyachao: TD boss血条
		["effect/way_arrow.png"] = 1,
	}
	local _SystemPlist = {
		["misc/psword.plist"] = 1,
	}
	local _tPlistFrameFailToLoad = {}
	local _CODE_LoadPlist = function(self,pCache,pArray,sFrameName,sPlistPath,sImagePath,handleTable,nLoadCount)
		--print("sPlistPath:",sPlistPath)
		--如果是无PNG模式就啥都不加载
		if hVar.OPTIONS.IS_NO_TEXTURE==1 and _SystemPlist[sPlistPath]~=1 then
			--用个小头盔代替
			if nLoadCount==1 then
				local pSpriteFrame
				if handleTable._c then
					pSpriteFrame = pCache:spriteFrameByName("data/image/ui/icon01_x6y1.png")
				else
					pSpriteFrame = pCache:spriteFrameByName("data/image/ui/battle_frame.png")
				end
				if pSpriteFrame~=nil then
					pArray:addObject(pSpriteFrame)
				end
			end
			return
		end
		local pSpriteFrame = pCache:spriteFrameByName(sFrameName)
		if pSpriteFrame~=nil then
			return pArray:addObject(pSpriteFrame)
		elseif _tPlistFrameFailToLoad[sFrameName]==1 then
			--重试加载失败以后就不处理了
			return
		elseif nLoadCount==1 then
			--首次加载可尝试读取文件
			local nTempType = handleTable.__IsTemp or 0
			_plistCache[sPlistPath] = sImagePath
			if nTempType~=0 and _plistCacheByType[nTempType] then
				_plistCacheByType[nTempType][sPlistPath] = sImagePath
			end
			_TEXTURE_LG(1,"[1]加载Plist "..sPlistPath..","..sImagePath.."\n")
			--pCache:addSpriteFramesWithFile(hApi.GetImagePath(sPlistPath),hApi.GetImagePath(sImagePath))
			--尝试加载一下plist
			xlLoadResourceFromPList(hApi.GetImagePath(sPlistPath))
			pSpriteFrame = pCache:spriteFrameByName(sFrameName)
			--到底会不会加载失败呢
			if pSpriteFrame~=nil then
				pArray:addObject(pSpriteFrame)
			else
				--万一失败了再来一次
				_TEXTURE_LG(4,"["..tostring(sFrameName).."]加载失败,准备重试\n")
				xlLoadResourceFromPList(hApi.GetImagePath(sPlistPath))
				pSpriteFrame = pCache:spriteFrameByName(sFrameName)
				if pSpriteFrame~=nil then
					pArray:addObject(pSpriteFrame)
				else
					--如果还失败以后就都不加载这个了
					_TEXTURE_LG(4,"["..tostring(sFrameName).."] plist = "..tostring(hApi.GetImagePath(sPlistPath)).." 重试加载失败\n")
					_tPlistFrameFailToLoad[sFrameName] = 1
				end
			end
		end
	end
	local _CODE_LoadPng
	_CODE_LoadPng = function(self,image,handleTable,nTempModelType)
		--print("_CODE_LoadPng", image)
		--如果是无PNG模式就全部变成绿块
		if hVar.OPTIONS.IS_NO_TEXTURE==1 and _SystemPNG[image]~=1 then
			image = _PNG_DefaultPath
		end
		if _textureCache[image] then
			--print("_textureCache存在")
			return _textureCache[image]
		elseif _textureUnavailable[image] then
			if _textureCache[_PNG_DefaultPath]==nil then
				_textureCache[_PNG_DefaultPath] = CCTextureCache:sharedTextureCache():addImage(hApi.GetImagePath(_PNG_DefaultPath))
				_textureCache[_PNG_DefaultPath]:retain()
			end
			return _textureCache[_PNG_DefaultPath]
		else
			local nTempType = 0
			if handleTable then
				nTempType = handleTable.__IsTemp or nTempModelType or 0
			else
				nTempType = nTempModelType or 0
			end
			local imagePath = hApi.GetImagePath(image)
			if hApi.FileExists(imagePath) then
				_textureCache[image] = CCTextureCache:sharedTextureCache():addImage(imagePath)
				if _textureCache[image] then
					if nTempType~=0 and _textureCacheByType[nTempType] then
						_textureCacheByType[nTempType][image] = 1
					end
					_textureCache[image]:retain()
					_TEXTURE_LG(1,"[1]加载png "..image.." 成功\n")
				else
					_textureUnavailable[image] = 1
					_TEXTURE_LG(1,"[1]加载png "..image.." 失败\n")
				end
			else
				_textureUnavailable[image] = 1
				_TEXTURE_LG(1,"[1]加载png "..image.." 不存在\n")
			end
			if _textureCache[image] then
				return _textureCache[image]
			elseif image~=_PNG_DefaultPath then
				return _CODE_LoadPng(self,_PNG_DefaultPath)
			end
		end
	end
	g_texture_manager = {
		showlog = 1,		--控制是否打印资源释放log
		--不要超过8个项目！
		batchNode = function(self,image)
			local loadMode,pSpriteFrame = self:testImage(image)
			if loadMode=="plist_shared" then
				if pSpriteFrame then
					local texture = pSpriteFrame:getTexture()
					return CCSpriteBatchNode:createWithTexture(texture)
				end
			elseif loadMode=="png" then
				--如果是无PNG模式就全部变成绿块
				if hVar.OPTIONS.IS_NO_TEXTURE==1 and _SystemPNG[image]~=1 then
					image = _PNG_DefaultPath
				end
				if _shared_pListPath[image]~=-1 then
					local imagePath = hApi.GetImagePath(image)
					return CCSpriteBatchNode:create(imagePath)
				end
			end
			--如果走到这里说明已经坑爹，返回绿块
			return CCSpriteBatchNode:create(hApi.GetImagePath(_PNG_DefaultPath))
		end,
		showCache = function(self,nMatchType,tTexturePath)
			local tempTexture = {}
			local tempPlist = {}
			local parementTexture = {}
			local parementPlist = {}
			if type(tTexturePath)~="table" then
				tTexturePath = nil
			end
			if nMatchType then
				if _textureCacheByType[nMatchType] then
					for path in pairs(_textureCacheByType[nMatchType])do
						tempTexture[#tempTexture+1] = path
						if tTexturePath then
							tTexturePath[path] = 1
						end
					end
				end
				if _plistCacheByType[nMatchType] then
					for path in pairs(_plistCacheByType[nMatchType])do
						tempPlist[#tempPlist+1] = path
						if tTexturePath then
							tTexturePath[path] = 1
						end
					end
				end
				--有这个就不打印了
				if tTexturePath then
					return
				end
			else
				for path in pairs(_textureCache)do
					local IsTemp = 0
					for i = 1,#_textureCacheByType do
						if _textureCacheByType[i][path] then
							if IsTemp==0 then
								IsTemp = {}
							end
							IsTemp[#IsTemp+1] = i
						end
					end
					if IsTemp==0 then
						parementTexture[#parementTexture+1] = path
					else
						local s = "("
						for i = 1,#IsTemp do
							s = s..IsTemp[i]..(i==#IsTemp and "" or ",")
						end
						tempTexture[#tempTexture+1] = s..")"..path
					end
				end
				for path in pairs(_plistCache)do
					local IsTemp = 0
					for i = 1,#_plistCacheByType do
						if _plistCacheByType[i][path] then
							if IsTemp==0 then
								IsTemp = {}
							end
							IsTemp[#IsTemp+1] = i
						end
					end
					if IsTemp==0 then
						parementPlist[#parementPlist+1] = path
					else
						local s = "("
						for i = 1,#IsTemp do
							s = s..IsTemp[i]..(i==#IsTemp and "" or ",")
						end
						tempPlist[#tempPlist+1] = s..")"..path
					end
				end
			end
			print("--parement---------------")
			for i = 1,#parementTexture do
				print(" - [texture]"..parementTexture[i])
			end
			for i = 1,#parementPlist do
				print(" - [plist]"..parementPlist[i])
			end
			print("--temp---------------")
			for i = 1,#tempTexture do
				print(" - [texture]"..tempTexture[i])
			end
			for i = 1,#tempPlist do
				print(" - [plist]"..tempPlist[i])
			end
		end,
		releasePngByKey = function(self,key)
			--正常的删除流程
			if _textureCache[key]~=nil then
				if (type(_textureCache[key]) == "userdata") then --这里会弹框？
					if _textureCache[key].release then
						_textureCache[key]:release()
						_textureCache[key] = nil
					end
				end
				
				local texture = CCTextureCache:sharedTextureCache():textureForKey("data/image/" .. key)
				if texture then
					CCTextureCache:sharedTextureCache():removeTexture(texture)
					_TEXTURE_LG(0,"释放png "..tostring(key).."\n")
				else
					_TEXTURE_LG(0,"释放不完全png "..tostring(key).."\n")
				end
			else
				local texture = CCTextureCache:sharedTextureCache():textureForKey("data/image/" .. tostring(key))
				if texture then
					CCTextureCache:sharedTextureCache():removeTexture(texture)
					_TEXTURE_LG(0,"清除png "..tostring(key).."\n")
				end
			end
		end,
		
		--释放xlobj
		releaseXLObjByKey = function(self,key)
			local texture = CCTextureCache:sharedTextureCache():textureForKey("data/xlobj/" .. key)
			if texture then
				CCTextureCache:sharedTextureCache():removeTexture(texture)
				_TEXTURE_LG(0,"释放xlobj "..tostring(key).."\n")
			end
		end,
		
		releasePng = function(self,nReleaseType,tNoReleasePath,tReleaseLog)
			local nReleaseCount = 0
			if nReleaseType==0 then
				for i = 1,#_textureCacheByType do
					nReleaseCount = nReleaseCount + self:releasePng(i,tNoReleasePath,tReleaseLog)
				end
			else
				local tList
				if type(nReleaseType)=="table" then
					tList = nReleaseType
				else
					tList = _textureCacheByType[nReleaseType]
				end
				if tList then
					for k,v in pairs(tList)do
						if tNoReleasePath and tNoReleasePath[k]==1 then
							--如果不删除此贴图
						else
							--正常的删除流程
							tList[k] = nil
							if _textureCache[k]~=nil then
								nReleaseCount = nReleaseCount + 1
								self:releasePngByKey(k)
								if tReleaseLog then
									tReleaseLog[#tReleaseLog+1] = k
								end
							end
						end
					end
				end
			end
			return nReleaseCount
		end,
		releasePlistByKey = function(self, pListCache, key)
			
			local pCache = pListCache or CCSpriteFrameCache:sharedSpriteFrameCache()
			
			--print("releasePlistByKey:",pListCache,key,_plistCache[key])
			if _plistCache[key]~=nil then
				_plistCache[key] = nil
				local path = hApi.GetImagePath(key)
				if path then
					pCache:removeSpriteFramesFromFile(path)
				end
				
				--[[
				--geyachao: 调试代码专用弹框
				--测试 --test
				local strText = "释放plist: path=" .. tostring(path) .. "\n" .. "key=" .. tostring(key)
				hGlobal.UI.MsgBox(strText,{
					font = hVar.FONTC,
					ok = function()
					end,
				})
				]]
				
				_TEXTURE_LG(0,"释放plist "..tostring(key).."\n")
			end
		end,
		releasePlist = function(self,nReleaseType,tNoReleasePath,tReleaseLog)
			local nReleaseCount = 0
			if nReleaseType==0 then
				for i = 1,#_plistCacheByType do
					nReleaseCount = nReleaseCount + self:releasePlist(i,tNoReleasePath,tReleaseLog)
				end
			else
				local pCache = CCSpriteFrameCache:sharedSpriteFrameCache()
				local tList
				if type(nReleaseType)=="table" then
					tList = nReleaseType
				else
					tList = _plistCacheByType[nReleaseType]
				end
				if tList then
					for k,v in pairs(tList)do
						if tNoReleasePath and tNoReleasePath[k]==1 then
							--如果不删除此plist
						else
							--一般删除plist
							tList[k] = nil
							if _plistCache[k]~=nil then
								nReleaseCount = nReleaseCount + 1
								self:releasePlistByKey(pCache,k)
								if tReleaseLog then
									tReleaseLog[#tReleaseLog+1] = k
								end
							end
						end
					end
				end
			end
			return nReleaseCount
		end,
		copyPlistCache = function(self,nReleaseType,tTemp)
			if type(tTemp)~="table" then
				tTemp = {}
			end
			local tList = _plistCacheByType[nReleaseType]
			for path in pairs(tList)do
				tTemp[path] = 1
			end
			return tTemp
		end,
		
		--释放sprite
		releaseCache = function(self,nReleaseMode,tNoReleasePath)
			if hVar.OPTIONS.AUTO_RELEASE_TEXTURE==0 then
				return
			end
			nReleaseMode = nReleaseMode or 0
			local tReleaseLog = {}
			local TextureCount = 0
			local PlistCount = 0
			if type(nReleaseMode)=="table" then
				local tReleaseMode = nReleaseMode
				for i = 1,#tReleaseMode do
					local nMode = tReleaseMode[i]
					if nMode and nMode~=0 then
						TextureCount = TextureCount + self:releasePng(nMode,tNoReleasePath,tReleaseLog)
						PlistCount = PlistCount + self:releasePlist(nMode,tNoReleasePath,tReleaseLog)
					end
				end
			else
				TextureCount = TextureCount + self:releasePng(nReleaseMode,tNoReleasePath,tReleaseLog)
				PlistCount = PlistCount + self:releasePlist(nReleaseMode,tNoReleasePath,tReleaseLog)
			end
			_TEXTURE_LG(0,"释放资源：texture("..TextureCount.."), plist("..PlistCount..")\n")
			if #tReleaseLog>0 then
				local rDetail = ""
				for i = 1,#tReleaseLog do
					rDetail = rDetail.."\n    - "..tostring(tReleaseLog[i])
				end
				_TEXTURE_LG(0,rDetail.."\n")
			end
			--调用程序接口清理显存
			if xlRemoveUnusedTextures then
				xlRemoveUnusedTextures()
			end
		end,
		
		loadTexture = function(self,image,handleTable,nTempModelType)
			return _CODE_LoadPng(self,image,handleTable,nTempModelType)
		end,
		
		--加载sprite
		testImage = function(self,image,IsWithWH)
			local flag = _shared_pListPath[image]
			if flag==0 then
				return "png",nil
			elseif type(flag)=="string" then
				local w,h = 0,0
				local imagePath = flag
				local pSpriteFrame = CCSpriteFrameCache:sharedSpriteFrameCache():spriteFrameByName(imagePath)
				if pSpriteFrame and IsWithWH==1 then
					local size = pSpriteFrame:getOriginalSize()
					w = size.width
					h = size.height
				end
				return "plist_shared",pSpriteFrame,w,h
			else
				local imagePath = hApi.GetImagePath(image)
				if hApi.FileExists(imagePath) then
					_shared_pListPath[image] = 0
					return "png",nil
				else
					--尝试用解析好的plist路径解析一次
					local pSpriteFrame = CCSpriteFrameCache:sharedSpriteFrameCache():spriteFrameByName(imagePath)
					if pSpriteFrame==nil then
						--如果没读取进来，尝试用原始路径在读取一次
						imagePath = image
						pSpriteFrame = CCSpriteFrameCache:sharedSpriteFrameCache():spriteFrameByName(imagePath)
					end
					if pSpriteFrame then
						_shared_pListPath[image] = imagePath
						local w,h = 0,0
						if pSpriteFrame and IsWithWH==1 then
							local size = pSpriteFrame:getOriginalSize()
							w = size.width
							h = size.height
						end
						return "plist_shared",pSpriteFrame,w,h
					else
						_shared_pListPath[image] = -1
						return "none",nil
					end
				end
			end
		end,
		testModel = function(self,modelData,aniKey,image)
			if image==nil then
				if modelData[aniKey] then
					if modelData[aniKey].image then
						image = modelData[aniKey].image
					else
						image = modelData.image
					end
				else
					image = modelData.image
				end
			end
			if modelData.loadmode=="png" then
				--png读取模式
				return modelData.loadmode,image,nil
			elseif modelData.loadmode=="plist" then
				--plist读取模式
				return modelData.loadmode,image,nil
			elseif modelData.loadmode=="plist_shared" then
				local imagePath = _shared_pListPath[image]
				if imagePath==nil then
					local mode,pSpriteFrame = self:testImage(image)
					if mode=="plist_shared" then
						imagePath = _shared_pListPath[image]
					else
						return mode,image,nil
					end
				end
				return modelData.loadmode,image,CCSpriteFrameCache:sharedSpriteFrameCache():spriteFrameByName(imagePath)
			else
				local loadMode,pSpriteFrame,w,h
				if modelData[aniKey][1][3]==0 and modelData[aniKey][1][4]==0 then
					loadMode,pSpriteFrame,w,h = self:testImage(image,1)
				else
					loadMode,pSpriteFrame,w,h = self:testImage(image,0)
				end
				--未注册过的模型,测试一下image
				
				if loadMode=="plist_shared" then
					--存在此frame，以plist_shared模式读取
					--会重新设置图像的尺寸
					modelData.loadmode = "plist_shared"
					if w~=0 and h~=0 then
						modelData[aniKey][1][3] = w
						modelData[aniKey][1][4] = h
					end
					return modelData.loadmode,image,pSpriteFrame
				else
					--完全不存在，当他是绿块好了
					modelData.loadmode = "png"
					return modelData.loadmode,image,nil
				end
			end
			return modelData.loadmode,image
		end,
		loadModel = function(self,key,modelData,aniKey,handleTable,fArray)
			aniKey = aniKey or modelData.animation[1]
			--加载资源查问题,EFF
			--if type(modelData.image)=="string" then
				--if string.find(modelData.image,"pvp") then
					--print("------------------------------------------")
					--print("png加载pvp资源"..modelData.image)
					--hpcall(function()
					--local a = b + 1
					--end)
				--end
			--end
			if modelData.loadmode=="plist" then
				--pvz模型
				local plist = modelData[aniKey].plist or modelData.plist
				local image = modelData[aniKey].image or modelData.image
				local fCache = CCSpriteFrameCache:sharedSpriteFrameCache()
				if fCache and plist and image and modelData[aniKey].pName and modelData[aniKey][1] then
					if fArray==nil then
						fArray = CCArray:create()
					end
					--pMode:
					--0.".png",直接使用路径，必须为1张图
					--1."%04d",0~(n-1)
					--2."number",0~(n-1)
					--3."number",1~n
					local pName = modelData[aniKey].pName
					local pMode = modelData[aniKey].pMode or 1
					local nCountPlus = 0
					local s,e,sFormat
					if pMode==0 then
						--单张图
						local fName = pName..".png"
						_CODE_LoadPlist(self,fCache,fArray,fName,plist,image,handleTable,1)
						--不在做后面的读取了
					else
						if type(pMode)=="table" then
							s = pMode[1]
							e = pMode[2]
							pMode = pMode[3] or 1
						else
							local n = modelData[aniKey][1][5] or 0
							if n<0 then
								s = -1*n
								e = 1
							else
								s = 1
								e = math.max(1,n)
							end
						end
						if pMode==1 then
							sFormat = "%04d"
							nCountPlus = -1
						elseif pMode==2 then
							nCountPlus = -1
						end
					end
					if s and e then
						local nLoadCount = 0
						local p = s<=e and 1 or -1
						for i = s,e,p do
							local fName
							local nCount = i+nCountPlus
							if sFormat then
								fName = pName..string.format(sFormat,nCount)..".png"
								--print(fName)
							else
								fName = pName..nCount..".png"
							end
							nLoadCount = nLoadCount + 1
							_CODE_LoadPlist(self,fCache,fArray,fName,plist,image,handleTable,nLoadCount)
						end
					end
					return fArray
				end
			else
				local loadMode,image,pSpriteFrame = self:testModel(modelData,aniKey)
				if loadMode=="plist_shared" then
					--共享UI模式
					if fArray==nil then
						fArray = CCArray:create()
					end
					if pSpriteFrame then
						fArray:addObject(pSpriteFrame)
					end
					return fArray
				else--if loadMode=="png" then
					--普通模型
					--if image=="icon/portrait/hero_liubei.png" then
						--xlLG("liubei","创建刘备的图片"..tostring(modelData.autorelease).."\n")
					--end
					local texture = _CODE_LoadPng(self,image,handleTable)
					if texture and aniKey and modelData[aniKey] then
						local frameData = modelData[aniKey]
						if fArray==nil then
							fArray = CCArray:create()
						end
						for i = 1,#frameData do
							local x,y,w,h,n,xPlus = unpack(frameData[i])
							xPlus = xPlus or 0
							n = n or 1
							if n<0 then
								for i = -1,n,-1 do
									fArray:addObject(CCSpriteFrame:createWithTexture(texture, CCRectMake(x+(i+1)*(w+xPlus), y, w, h)))
								end
							else
								for i = 1,n do
									fArray:addObject(CCSpriteFrame:createWithTexture(texture, CCRectMake(x+(i-1)*(w+xPlus), y, w, h)))
								end
							end
						end
						return fArray
					end
				end
			end
		end,
		safeAnimation = function(self,handleTable,mTab,aniKey)
			--多方向
			if aniKey~=nil and handleTable and handleTable.animationlink and handleTable.animationlink~=0 then
				local nAniKey = handleTable.animationlink..aniKey
				if mTab and mTab[nAniKey] then
					return nAniKey,hVar.RESULT_SUCESS,mTab
				end
			end
			if aniKey~=nil and mTab and mTab[aniKey] then
				return aniKey,hVar.RESULT_SUCESS,mTab
			else
				--_DEBUG_MSG("动画"..aniKey.."不存在！替换为"..md.animation[1])
				return mTab and mTab.animation[1],hVar.RESULT_FAIL,mTab
			end
		end,
	}
	hResource.model = g_texture_manager
end

hApi.animationByFacing = function(modelName,animation,facing)
	local i = hVar.tab_model.index[modelName]
	if i then
		local modelTable = hVar.tab_model[i]
		if modelTable~=nil and modelTable.modelmode~=nil and modelTable.modelmode~=0 then
			return "DIRECTION:"..tostring(hApi.calAngleD(modelTable.modelmode,facing)).."_"..animation
		end
	end
	return animation
end

hApi.GetModelByName = function(model)
	local i = hVar.tab_model.index[model]
	if i then
		return hVar.tab_model[i]
	end
end

hApi.setModel = function(handleTable,model,facing)
	--如果model是图片路径，就以此路径创建一个单帧model
	handleTable.modelIndex = hVar.tab_model.index[model]
	if handleTable.modelIndex==nil then
		if model==0 then
			handleTable.modelIndex = 1
		elseif type(model)=="string" and string.find(model,".png") then
			local loadMode,pSpriteFrame,pW,pH = hResource.model:testImage(model,1)
			if loadMode=="png" then
				--单帧图片的资源全部都会自动释放
				local tabM = {
					name = model,
					image = model,
					loadmode = "png",
					animation = {"normal"},
					autorelease = 1,
					normal = {
						[1] = {0,0,16,16,1},
					},
				}
				handleTable.modelIndex = hVar.tab_model:add(tabM)
				local texture = hResource.model:loadTexture(model,handleTable)
				if texture then
					local size = texture:getContentSize()
					tabM.normal[1][3] = size.width
					tabM.normal[1][4] = size.height
				end
			elseif loadMode=="plist_shared" then
				local tabM = {
					name = model,
					image = model,
					loadmode = "plist_shared",
					animation = {"normal"},
					normal = {
						[1] = {0,0,pW,pH,1},
					},
				}
				handleTable.modelIndex = hVar.tab_model:add(tabM)
			else
				hVar.tab_model.index[model] = 1
				handleTable.modelIndex = 1
			end
		else
			handleTable.modelIndex = 1
		end
	end
	if facing and facing>=0 then
		handleTable.modelmode = hVar.tab_model[handleTable.modelIndex].modelmode or 0
		handleTable.animationlink = 0
	else
		handleTable.modelmode = 0
		handleTable.animationlink = 0
	end
	return hVar.tab_model[handleTable.modelIndex]
end

hApi.safeAnimation = function(handleTable,aniKey)
	return hResource.model:safeAnimation(handleTable,hVar.tab_model[handleTable.modelIndex] or hVar.tab_model[1],aniKey)
end

hApi.getObjectModelPath = function(handleTable)
	if handleTable.__manager=="lua" then
		local tModel = hVar.tab_model[handleTable.modelIndex]
		local aniKey = handleTable.animation
		if tModel and aniKey and tModel[aniKey] then
			local sImagePath = tModel[aniKey].image or tModel.image
			local sPlistPath = tModel[aniKey].plist or tModel.plist
			return tModel.loadmode,sImagePath,sPlistPath
		end
	end
end

---------------------------------------------------------------------------
-- SpriteSet函数
local __SpriteSetScaleByWH = function(s,scale,w,h,imageW,imageH)
	local scaleX,scaleY = scale,scale
	if w>0 then scaleX = scaleX*w/imageW end
	if h>0 then scaleY = scaleY*h/imageH end
	if scaleX~=1 then s:setScaleX(scaleX) end
	if scaleY~=1 then s:setScaleY(scaleY) end
	return scaleX,scaleY,w*scale,h*scale
end
hApi.ImageCalculateWH = function(w,h,sizeW,sizeH)
	if w>0 and h<0 then
		h = sizeH*w/sizeW
		return w,h
	elseif w<0 and h>0 then
		w = sizeW*h/sizeH
		return w,h
	end
	w = w>0 and w or sizeW
	h = h>0 and h or sizeH
	return w,h
end

hApi.SpriteSetScaleByWH = function(handleTable,scale,w,h,imageW,imageH)
	w,h = hApi.ImageCalculateWH(w,h,imageW,imageH)
	return __SpriteSetScaleByWH(handleTable.s,scale,w,h,imageW,imageH)
end

hApi.SpriteInitBatchNode = function(handleTable,model)
	local _m = hApi.setModel(handleTable,model,-1)
	handleTable._bn = hResource.model:batchNode(_m.image)
	return handleTable._bn,_m
end
hApi.SpriteSetBatchParent = function(handleTable,model,batchParent)
	local _m = hApi.setModel(handleTable,model,-1)
	handleTable._bn = batchParent
	return handleTable._bn,_m
end
local __Align = hVar.UI_ALIGN
hApi.SpriteBatchNodeAddChild = function(handleTable,animation,align,imageW,imageH,rTab,nSizeW,nSizeH,nChildZ)
	local aniKey,IsSafe,modelTab = hApi.safeAnimation(handleTable,animation)
	local loadMode,image,pSpriteFrame = hResource.model:testModel(modelTab,aniKey)
	local ani = modelTab[aniKey]
	local _x,_y,sizeW,sizeH= unpack(ani[1])
	if nSizeW~=nil and nSizeW>0 and nSizeW<=sizeW then
		sizeW = nSizeW
	end
	if nSizeH~=nil and nSizeH>0 and nSizeH<=sizeH then
		sizeH = nSizeH
	end
	imageW,imageH = hApi.ImageCalculateWH(imageW,imageH,sizeW,sizeH)
	local childS
	if handleTable._bn then
		if loadMode=="plist_shared" and pSpriteFrame then
			if pSpriteFrame:getTexture()==handleTable._bn:getTexture() then
				--共享UI模式！
				childS = CCSprite:createWithSpriteFrame(pSpriteFrame)
			else
				xlLG("error","尝试将非法的batchChild加到texture不同的batchNode上! - "..image.."\n")
			end
		else--if loadMode=="png" then
			--png模式
			childS = CCSprite:createWithTexture(handleTable._bn:getTexture(),CCRectMake(_x,_y,sizeW,sizeH))
		end
	end
	if handleTable._bn and childS~=nil then
		if rTab and type(rTab)=="table" then
			rTab.x = _x
			rTab.y = _y
			rTab.w = sizeW
			rTab.h = sizeH
		end
		local scaleX,scaleY = __SpriteSetScaleByWH(childS,1,imageW,imageH,sizeW,sizeH)
		if __Align[align] then
			local a = __Align[align]
			childS:setAnchorPoint(ccp(a[1]/2,a[2]/2))
		end
		if ani.flipX==1 then
			childS:setFlipX(true)
		end
		if ani.flipY==1 then
			childS:setFlipY(true)
		end
		if ani.roll~=nil and ani.roll~=0 then
			childS:setRotation(-1*ani.roll)
		end
		handleTable._bn:addChild(childS,nChildZ or 0)
		return childS,imageW,imageH,scaleX,scaleY
	else
		return nil,imageW,imageH,1,1
	end
end

hApi.SpriteLoadOneFrame = function(handleTable,animation,scale,align,imageW,imageH,rTab,nSizeW,nSizeH)
	local aniKey,IsSafe,modelTab = hApi.safeAnimation(handleTable,animation)
	local loadMode,image,pSpriteFrame = hResource.model:testModel(modelTab,aniKey)
	local ani = modelTab[aniKey]
	local _x,_y,sizeW,sizeH= unpack(ani[1])
	local childS
	if nSizeW~=nil and nSizeW>0 and nSizeW<=sizeW then
		sizeW = nSizeW
	end
	if nSizeH~=nil and nSizeH>0 and nSizeH<=sizeH then
		sizeH = nSizeH
	end
	if loadMode=="plist_shared" and pSpriteFrame then
		--共享UI模式！
		childS = CCSprite:createWithSpriteFrame(pSpriteFrame)
	else--if loadMode=="png" then
		--png模式
		local path = ani.image or modelTab.image or "_"
		local texture = hResource.model:loadTexture(path,handleTable)
		if texture then
			childS = CCSprite:createWithTexture(texture,CCRectMake(_x,_y,sizeW,sizeH))
		end
	end
	if childS then
		if rTab and type(rTab)=="table" then
			rTab.x = _x
			rTab.y = _y
			rTab.w = sizeW
			rTab.h = sizeH
		end
		imageW,imageH = hApi.ImageCalculateWH(imageW,imageH,sizeW,sizeH)
		local scaleX,scaleY = __SpriteSetScaleByWH(childS,scale,imageW,imageH,sizeW,sizeH)
		if __Align[align] then
			local a = __Align[align]
			childS:setAnchorPoint(ccp(a[1]/2,a[2]/2))
		end
		if ani.flipX==1 then
			childS:setFlipX(true)
		end
		if ani.flipY==1 then
			childS:setFlipY(true)
		end
		if ani.roll~=nil and ani.roll~=0 then
			childS:setRotation(-1*ani.roll)
		end
		return childS,imageW,imageH,scaleX,scaleY
	else
		if rTab and type(rTab)=="table" then
			rTab.x = _x
			rTab.y = _y
			rTab.w = sizeW
			rTab.h = sizeH
		end
		return CCSprite:create(),16,16,1,1
	end
end

local __TempClipHandle
hApi.CreateClippingNode = function(pNode,tClipper,nZOrder,IsShowMask,sClipName)
	local tHandleTable
	if type(pNode)=="table" then
		--是objectUI
		local oUI = pNode
		if oUI.classname~="frame" then
			_DEBUG_MSG("[LUA WARNING]请勿在frame以外的ui控件上创建clipper！")
		end
		pNode = oUI.handle._n
		if type(oUI.handle._clipper)~="table" then
			oUI.handle._clipper = {}
		end
		tHandleTable = oUI.handle._clipper
	end
	if type(pNode)~="userdata" then
		_DEBUG_MSG("[LUA ERROR]ClippingNode创建失败！")
		return
	end
	if __TempClipHandle==nil then
		__TempClipHandle = {}
		hApi.setModel(__TempClipHandle,"MODEL:Default")
	end
	local pSpriteMask = hApi.SpriteLoadOneFrame(__TempClipHandle,"stand",1,"LT",tClipper[3],tClipper[4])
	if pSpriteMask then
		pSpriteMask:setPosition(ccp(tClipper[1],tClipper[2]))
		if IsShowMask~=1 then
			pSpriteMask:setOpacity(0)
		end
		local pSpriteMaskN = CCSprite:create()
		local pClipper = CCClippingNode:create(pSpriteMask)
		pClipper:setAnchorPoint(ccp(0,0))
		pClipper:addChild(pSpriteMask)
		pClipper:addChild(pSpriteMaskN)
		--if IsShowCenter==0 then
			--pClipper:setInverted(true)
		--end
		pNode:addChild(pClipper,(nZOrder or 0))
		if tHandleTable then
			tHandleTable[#tHandleTable+1] = {pClipper,pSpriteMask,pSpriteMaskN,sClipName or 0}
		end
		return pClipper,pSpriteMask,pSpriteMaskN
	end
end

hApi.EnableClipByName = function(oFrm,sClipName,enable)
	local tClipHandleList = oFrm.handle._clipper
	if type(tClipHandleList)~="table" then
		return
	end
	for i = 1,#tClipHandleList do
		local tClipHandle = tClipHandleList[i]
		if tClipHandle[4]~=0 then
			if tClipHandle[4]==sClipName then
				if enable==1 then
					tClipHandle[1]:setStencil(tClipHandle[2])
				else
					tClipHandle[1]:setStencil(tClipHandle[3])
				end
			else
				if enable==1 then
					tClipHandle[1]:setStencil(tClipHandle[3])
				else
					tClipHandle[1]:setStencil(tClipHandle[2])
				end
			end
		end
	end
end

--允许两个clipnode
hApi.EnableClip2ByName = function(oFrm,sClipName1,sClipName2,enable)
	local tClipHandleList = oFrm.handle._clipper
	if type(tClipHandleList)~="table" then
		return
	end
	for i = 1,#tClipHandleList do
		local tClipHandle = tClipHandleList[i]
		if tClipHandle[4]~=0 then
			if (tClipHandle[4]==sClipName1) or (tClipHandle[4]==sClipName2) then
				if enable==1 then
					tClipHandle[1]:setStencil(tClipHandle[2])
				else
					tClipHandle[1]:setStencil(tClipHandle[3])
				end
			else
				if enable==1 then
					tClipHandle[1]:setStencil(tClipHandle[3])
				else
					tClipHandle[1]:setStencil(tClipHandle[2])
				end
			end
		end
	end
end

hApi.EnableClipNode = function(tClipHandle,enable)
	if enable==1 then
		tClipHandle[1]:setStencil(tClipHandle[2])
	else
		tClipHandle[1]:setStencil(tClipHandle[3])
	end
end


--战车专用
local __TempClipHandle_Diablo
hApi.CreateClippingNode_Diablo = function(pNode,tClipper,nZOrder,IsShowMask,sClipName)
	local tHandleTable
	if type(pNode)=="table" then
		--是objectUI
		local oUI = pNode
		if oUI.classname~="frame" then
			_DEBUG_MSG("[LUA WARNING]请勿在frame以外的ui控件上创建clipper！")
		end
		pNode = oUI.handle._n
		if type(oUI.handle._clipper)~="table" then
			oUI.handle._clipper = {}
		end
		tHandleTable = oUI.handle._clipper
	end
	if type(pNode)~="userdata" then
		_DEBUG_MSG("[LUA ERROR]ClippingNode创建失败！")
		return
	end
	if __TempClipHandle_Diablo==nil then
		__TempClipHandle_Diablo = {}
		hApi.setModel(__TempClipHandle_Diablo,"misc/addition/story_panel_mask.png")
	end
	local pSpriteMask = hApi.SpriteLoadOneFrame(__TempClipHandle_Diablo,"stand",1,"LT",tClipper[3],tClipper[4])
	if pSpriteMask then
		pSpriteMask:setPosition(ccp(tClipper[1],tClipper[2]))
		if IsShowMask~=1 then
			pSpriteMask:setOpacity(0)
		end
		local pSpriteMaskN = CCSprite:create()
		local pClipper = CCClippingNode:create(pSpriteMask)
		pClipper:setAnchorPoint(ccp(0,0))
		pClipper:addChild(pSpriteMask)
		pClipper:addChild(pSpriteMaskN)
		--if IsShowCenter==0 then
			--pClipper:setInverted(true)
		--end
		pNode:addChild(pClipper,(nZOrder or 0))
		--pNode:addChild(pClipper,1)
		if tHandleTable then
			tHandleTable[#tHandleTable+1] = {pClipper,pSpriteMask,pSpriteMaskN,sClipName or 0}
		end
		return pClipper,pSpriteMask,pSpriteMaskN
	end
end

hApi.EnableClipByName_Diablo = function(oFrm,sClipName,enable)
	local tClipHandleList = oFrm.handle._clipper
	if type(tClipHandleList)~="table" then
		return
	end
	for i = 1,#tClipHandleList do
		local tClipHandle = tClipHandleList[i]
		if tClipHandle[4]~=0 then
			if tClipHandle[4]==sClipName then
				if enable==1 then
					tClipHandle[1]:setStencil(tClipHandle[2])
					--tClipHandle[1]:setInverted(false)
					tClipHandle[1]:setAlphaThreshold(0)
				else
					tClipHandle[1]:setStencil(tClipHandle[3])
				end
			else
				if enable==1 then
					tClipHandle[1]:setStencil(tClipHandle[3])
				else
					tClipHandle[1]:setStencil(tClipHandle[2])
				end
			end
		end
	end
end


hApi.IsInBox = function(x,y,tBox)
	return x>=tBox[1] and x<=tBox[1]+tBox[3] and y>=tBox[2]-tBox[4] and y<=tBox[2]
end

local __DefaultBox = hVar.DefaultBox
hApi.SpriteLoadBoundingBox = function(handleTable,tBox,sType,scale, xlPath)
	if handleTable._c==nil then
		return
	end
	if sType=="xlobj" then
		if handleTable.s~=nil then
			local size = handleTable.s:getContentSize()
			local w,h = size.width,size.height
			local x,y = -1*hApi.getint(w/2),-1*hApi.getint(h/2)
			if handleTable.__box~=nil then
				local b = handleTable.__box
				b[1],b[2],b[3],b[4] = x,y,w,h
				--geyachao: 同步日志: 设置场景物件障碍大小1__box1
				if (hVar.IS_SYNC_LOG == 1) then
					local msg = "xlChaSetBoundingBoxInfo1__box:" .. ",x=" .. tostring(x) .. ",y=" .. tostring(y) .. ",w=" .. tostring(w) .. ",h=" .. tostring(h) .. ",xlPath=" .. tostring(xlPath)
					hApi.SyncLog(msg)
				end
			else
				handleTable.__box = {x,y,w,h}
				--geyachao: 同步日志: 设置场景物件障碍大小1__box2
				if (hVar.IS_SYNC_LOG == 1) then
					local msg = "xlChaSetBoundingBoxInfo1__box2:" .. ",x=" .. tostring(x) .. ",y=" .. tostring(y) .. ",w=" .. tostring(w) .. ",h=" .. tostring(h).. ",xlPath=" .. tostring(xlPath)
					hApi.SyncLog(msg)
				end
			end
		elseif handleTable.__box==nil then
			handleTable.__box = {0,0,0,0}
			--geyachao: 同步日志: 设置场景物件障碍大小1__box3
			if (hVar.IS_SYNC_LOG == 1) then
				local msg = "xlChaSetBoundingBoxInfo1__box3:" .. ",x=" .. tostring(0) .. ",y=" .. tostring(0) .. ",w=" .. tostring(0) .. ",h=" .. tostring(0)
				hApi.SyncLog(msg)
			end
		end
	elseif tBox~=nil then
		handleTable.__box = hApi.ReadParam(tBox,nil,handleTable.__box or {})
		--geyachao: 同步日志: 设置场景物件障碍大小1__box4
		if (hVar.IS_SYNC_LOG == 1) then
			local msg = "xlChaSetBoundingBoxInfo1__box4"
			hApi.SyncLog(msg)
		end
	elseif __DefaultBox[sType] then
		handleTable.__box = hApi.ReadParam(__DefaultBox[sType],nil,handleTable.__box or {})
		--geyachao: 同步日志: 设置场景物件障碍大小1__box5
		if (hVar.IS_SYNC_LOG == 1) then
			local msg = "xlChaSetBoundingBoxInfo1__box5"
			hApi.SyncLog(msg)
		end
	else
		handleTable.__box = hApi.ReadParam(__DefaultBox["NONE"],nil,handleTable.__box or {})
		--geyachao: 同步日志: 设置场景物件障碍大小1__box6
		if (hVar.IS_SYNC_LOG == 1) then
			local msg = "xlChaSetBoundingBoxInfo1__box6"
			hApi.SyncLog(msg)
		end
	end
	if scale~=nil and scale>0 and scale~=100 then
		for i = 1,4 do
			handleTable.__box[i] = hApi.getint((handleTable.__box[i] or 0)*scale/100)
		end
	end
	if handleTable._c~=nil then
		local x,y,w,h = unpack(handleTable.__box)
		--geyachao: 同步日志: 设置场景物件障碍大小1
		if (hVar.IS_SYNC_LOG == 1) then
			local msg = "xlChaSetBoundingBoxInfo1: c=" .. type(handleTable._c) .. ",x=" .. tostring(x) .. ",y=" .. tostring(y) .. ",w=" .. tostring(w) .. ",h=" .. tostring(h)
			hApi.SyncLog(msg)
		end
		hApi.ChaLoadBoundingBox(handleTable._c,x,y,w,h)
	end
end

hApi.ChaLoadBoundingBox = function(c,x,y,w,h)
	--geyachao: 同步日志: 设置场景物件障碍大小
	--if (hVar.IS_SYNC_LOG == 1) then
	--	local msg = "xlChaSetBoundingBoxInfo: c=" .. type(c) .. ",x=" .. tostring(x) .. ",y=" .. tostring(y) .. ",w=" .. tostring(w) .. ",h=" .. tostring(h)
	--	hApi.SyncLog(msg)
	--end
	
	return xlChaSetBoundingBoxInfo(c,x,y,w,h)
end

hApi.SpriteGetBoundingBox = function(handleTable)
	if handleTable.__box then
		return unpack(handleTable.__box)
	end
end

hApi.SpriteLoadFacingDefault = function(handleTable,modelAnimation,isReset)
	if modelAnimation then
		handleTable._DEFAULT_roll = modelAnimation.roll or 0
		handleTable._DEFAULT_flipX = modelAnimation.flipX or 0
		handleTable._DEFAULT_flipY = modelAnimation.flipY or 0
		local ax,ay = 50,50
		if modelAnimation.anchor then
			ax,ay =  unpack(modelAnimation.anchor)
			ax = hApi.getint((ax or 0.5)*100)
			ay = hApi.getint((ay or 0.5)*100)
		end
		handleTable._DEFAULT_anchorX = ax
		handleTable._DEFAULT_anchorY = ay
		handleTable._DEFAULT_scale = hApi.getint((modelAnimation.scale or 1)*100)
	else
		handleTable._DEFAULT_roll = 0
		handleTable._DEFAULT_flipX = 0
		handleTable._DEFAULT_flipY = 0
		handleTable._DEFAULT_anchorX = 50
		handleTable._DEFAULT_anchorY = 50
		handleTable._DEFAULT_scale = 100
	end
	if isReset=="reset" or isReset=="reset_clear" then
		handleTable._LAST_roll = ""
		handleTable._LAST_flipX = ""
		handleTable._LAST_flipY = ""
		handleTable._LAST_scale = ""
		if isReset=="reset_clear" then
			handleTable.roll = nil
			handleTable.flipX = nil
			handleTable.flipY = nil
			handleTable.scale = nil
		end
	end
end

hApi.SpriteLoadFacing = function(handleTable)
	--print("hApi.SpriteLoadFacing(), roll=" .. tostring(handleTable.roll))
	local needSetAnchor = 0
	if handleTable._DEFAULT_scale==nil then
		hApi.SpriteLoadFacingDefault(handleTable,nil,"reset")
	end
	if handleTable.roll~=handleTable._LAST_roll then
		handleTable._LAST_roll = handleTable.roll
		local roll = (handleTable.roll or 0) + (handleTable._DEFAULT_roll or 0)
		if roll<0 then
			roll = roll + 360
		elseif roll>360 then
			roll = roll - 360
		end
		handleTable.s:setRotation(-1*roll)		--反数学坐标系坑爹啊！
		--print("hApi.SpriteLoadFacing(), setRotation=" .. (-1*roll))
	end
	if handleTable.flipX~=handleTable._LAST_flipX then
		handleTable._LAST_flipX = handleTable.flipX
		if handleTable._DEFAULT_flipX==1 then
			handleTable.s:setFlipX(handleTable.flipX~=1)
		else
			handleTable.s:setFlipX(handleTable.flipX==1)
		end
		needSetAnchor = 1
	end
	if handleTable.flipY~=handleTable._LAST_flipY then
		handleTable._LAST_flipY = handleTable.flipY
		if handleTable._DEFAULT_flipY==1 then
			handleTable.s:setFlipY(handleTable.flipY~=1)
		else
			handleTable.s:setFlipY(handleTable.flipY==1)
		end
		needSetAnchor = 1
	end
	if needSetAnchor~=0 then
		local ax,ay = handleTable._DEFAULT_anchorX,handleTable._DEFAULT_anchorY
		if handleTable._DEFAULT_flipX~=(handleTable.flipX or 0) then
			ax = 100-ax
		end
		if handleTable._DEFAULT_flipY~=(handleTable.flipY or 0) then
			ay = 100-ay
		end
		handleTable.s:setAnchorPoint(CCPoint(ax/100,(100-ay)/100))
	end
	if handleTable.scale~=handleTable._LAST_scale then
		handleTable.scale = (handleTable.scale or 100)
		handleTable._LAST_scale = handleTable.scale
		local s = handleTable.scale*handleTable._DEFAULT_scale/100
		handleTable.s:setScale(((s>0 and (s<=99 or s>=101) and s) or 100)/100)
	end
end

hApi.SpriteSetScale = function(handleTable,nScale,dur)
	if nScale~=handleTable._LAST_scale then
		handleTable.scale = nScale
		handleTable._LAST_scale = handleTable.scale
		if handleTable._DEFAULT_scale==nil then
			hApi.SpriteLoadFacingDefault(handleTable,nil,"reset")
		end
		local s = handleTable.scale*handleTable._DEFAULT_scale/100
		local fScale = ((s>0 and (s<=99 or s>=101) and s) or 100)/100
		if type(dur)=="number" then
			handleTable.s:runAction(CCScaleTo:create(dur,fScale))
		else
			handleTable.s:setScale(fScale)
		end
	end
end

if g_frame_CCArray==nil then
	g_frame_CCArray = CCArray:create()
	g_frame_CCArray:retain()
end
hApi.SpritePlayAnimation = function(handleTable,aniKey,repeatCount,forceToPlay)
	--print("hApi.SpritePlayAnimation(), modelIndex=" .. tostring(handleTable.modelIndex))
	local md = hVar.tab_model[handleTable.modelIndex]
	if handleTable.s and md then
		handleTable._animation = aniKey
		aniKey,IsSafe = hResource.model:safeAnimation(handleTable,md,aniKey)
		if IsSafe==hVar.RESULT_SUCESS then
		else
			handleTable._animation = aniKey
		end
		if forceToPlay==1 or handleTable.animation~=aniKey then
			handleTable.s:stopAllActions()
			local mArray = hResource.model:loadModel(md.image,md,aniKey,handleTable,g_frame_CCArray)
			if mArray and mArray~=0 then
				--记录信息
				handleTable.animation = aniKey
				local interval = 1000
				local frameCount = 1
				local speed = (handleTable.__speed or 100)
				if md[aniKey].interval==0 then
					--单帧图片加载
					frameCount = 1
					handleTable.loop = 0
					repeatCount = 1
				else
					--连续动画加载
					interval = md[aniKey].interval or 1000
					frameCount = mArray:count()
					handleTable.loop = 1
					if repeatCount==1 and speed~=100 and speed>0 then
						interval = hApi.getint(interval*100/speed)
					end
				end
				handleTable.animationtime = frameCount*interval
				local IsShow = 1
				--if handleTable._c~=nil and handleTable._n~=nil and handleTable.__manager=="lua" then
					--IsShow = 0
					--if handleTable._n:isVisible() then
					--else
						--IsShow = 0
						----不可见的角色sprite不显示动画
						--local w,h = md[aniKey][1][3],md[aniKey][1][4]
						--handleTable.s:setContentSize(CCSizeMake(w,h))
					--end
				--end
				if IsShow==1 then
					--设置动画
					local animation = CCAnimation:createWithSpriteFrames(mArray, interval/1000)
					if repeatCount and repeatCount>0 then
						if repeatCount==1 then
							handleTable.s:runAction(CCAnimate:create(animation))
						else
							handleTable.s:runAction(CCRepeat:create(CCAnimate:create(animation),repeatCount))
						end
					else
						handleTable.s:runAction(CCRepeatForever:create(CCAnimate:create(animation)))
					end
					if g_frame_CCArray then
						g_frame_CCArray:removeAllObjects()
					end
				end
				--读取基本偏移，翻转信息
				hApi.SpriteLoadFacingDefault(handleTable,md[aniKey],"reset")
			end
			--设置缩放
			--设置偏移
			--处理旋转
			hApi.SpriteLoadFacing(handleTable)
		end
		return handleTable.animationtime
	end
	return 0
end

hApi.SpriteShowDead = function(handleTable,nMode)
	if handleTable.__manager=="lua" or handleTable.__manager=="xlobj" then
		if nMode=="unit" and handleTable.s~=nil then
			handleTable.s:runAction(CCBlink:create(0.5,3))
			handleTable.s:runAction(CCFadeOut:create(1))
		end
	end
end

hApi.SpriteMoveAsMissile = function(oEffect,ox,oy,tx,ty,flyAngle,flySpeed,rollSpeed, oAction)
	--print("hApi.SpriteMoveAsMissile", ox,oy,tx,ty,flyAngle,flySpeed,rollSpeed)
	local handleTable = oEffect.handle
	local moveTime,moveRange = hApi.calMoveTime(ox,oy,tx,ty,flySpeed)
	--计算落点的公式
	local fJumpA = 0
	if handleTable.__manager=="lua" then
		local t = moveTime/1000
		--print(oEffect.data.id, "t=", t, ox,oy,tx,ty,flyAngle,flySpeed)
		--print(flyAngle, moveRange)
		if flyAngle<=0 or moveRange<=0 then
			local move = CCMoveTo:create(t,CCPointMake(tx-ox,-1*(ty-oy)))
			local callback = CCCallFunc:create(function()
				--飞行特效到动画到目标点的回调事件
				oEffect:OnFlyEffMoveToPoint_Ret(oAction)
			end)
			local sequence = CCSequence:createWithTwoActions(move, callback)
			handleTable.s:runAction(sequence)
		else
			fJumpA = hApi.getint(flyAngle*moveRange/2)
			--fJumpA = hApi.getint(flyAngle*200/2)
			local jump = CCJumpTo:create(t,CCPointMake(tx-ox,-1*(ty-oy)),fJumpA,1)
			--print("hApi.SpriteMoveAsMissile", "oEffect=", oEffect.data.id, "oAction=", oAction)
			local callback = CCCallFunc:create(function()
				--飞行特效到动画到目标点的回调事件
				--print("飞行特效到动画到目标点的回调事件 oAction=", oAction)
				oEffect:OnFlyEffMoveToPoint_Ret(oAction)
			end)
			local sequence = CCSequence:createWithTwoActions(jump, callback)
			handleTable.s:runAction(sequence)
		end
		if flyAngle<=-1 then
			--飞行弧度-1的话，不旋转
		elseif type(rollSpeed)~="number" then
			handleTable.roll = hApi.angleBetweenPoints(ox,oy,tx,ty)
			hApi.SpriteLoadFacing(handleTable)
		else
			local rLaunch,rFly = hApi.calArrowFacingXY(ox,oy,tx,ty,flyAngle)
			handleTable.roll = rLaunch - 180
			hApi.SpriteLoadFacing(handleTable)
			if rollSpeed~=0 then
				if t>0 then
					local v = 1
					if ox>tx then
						v = -1
					end
					handleTable.s:runAction(CCRotateBy:create(t,v*360*t*rollSpeed))
				end
			elseif flyAngle>0 and rFly~=0 then
				handleTable.s:runAction(CCRotateBy:create(t,rFly))
			end
		end
	end
	return moveTime,fJumpA
end

hApi.SpriteRollAsMissile = function(handleTable,ox,oy,tx,ty)
	local rLaunch = hApi.calArrowFacingXY(ox,oy,tx,ty,0)
	handleTable.roll = rLaunch - 180
	hApi.SpriteLoadFacing(handleTable)
end

hApi.SpriteSetAnimation = function(handleTable,aniKey)
	handleTable.animationList[1] = 0
	return hApi.SpritePlayAnimation(handleTable,aniKey,nil,nil)
end

hApi.SpriteSetAnimationCount = function(handleTable,aniKey,count)
	handleTable.animationList[1] = 0
	return hApi.SpritePlayAnimation(handleTable,aniKey,count,1)
end

hApi.SpriteUpdateAnimation = function(handleTable)
	local ha = handleTable.animationList
	local animationTime = ha[1]
	if animationTime==0 then
		return
	end
	local world = hGlobal.WORLD.LastWorldMap
	local timeNow = 0
	if world then
		timeNow = world:gametime()
	else
		timeNow = hApi.gametime()
	end
	if timeNow - animationTime>=0 then
		for i = 2,#ha,1 do
			if ha[i]==0 then
				--动画已经播放掉了,下一个
			--elseif ha[i]==1 then
				--播放结束了,全部停止
				--ha[1] = 0
				--return
			else
				local sAnimation
				local x,y,t
				if type(ha[i])=="table" then
					sAnimation = ha[i][1]
					x = ha[i][2]
					y = ha[i][3]
					t = ha[i][4]
				else
					sAnimation = ha[i]
				end
				if ha[i+1]==1 then
					--播放正常结束，最后一个动作为循环模式
					hApi.SpritePlayAnimation(handleTable, sAnimation,nil,1)
					ha[1] = 0
					ha[i] = 1
				else
					local dur = hApi.SpritePlayAnimation(handleTable, sAnimation,1,1)
					ha[1] = timeNow + dur
					ha[i] = 0
				end
				if x and y and handleTable.s~=nil and type(x)=="number" and type(y)=="number" then
					if type(t)=="number" then
						handleTable.s:runAction(CCMoveTo:create(t/1000,ccp(x,y)))
					else
						handleTable.s:setPosition(x,y)
						--print("更新",x,y)
					end
				end
				return
			end
		end
		ha[1] = 0
	end
end

local __CODE__LoadModelPart = function(handleTable,sAnimation,IfMustPlay,nRepeat)
	if handleTable._n~=nil and handleTable.__manager=="lua" then
		local tPartHandle = handleTable._prt
		--先隐藏之前显示的部件
		if tPartHandle then
			for i = 1,#tPartHandle do
				tPartHandle[i].s:setVisible(false)
			end
		end
		local md = hVar.tab_model[handleTable.modelIndex]
		if md and md[sAnimation] and md[sAnimation].part then
			--拥有额外部件(阴影)的模型
			local tPart = md[sAnimation].part
			if tPartHandle==nil then
				tPartHandle = {}
				handleTable._prt = tPartHandle
			end
			for i = 1,#tPart do
				local sPartName,m,x,y,z = unpack(tPart[i])
				x = x or 0
				y = y or 0
				z = z or 0
				if tPartHandle[i]==nil then
					tPartHandle[i] = {s=CCSprite:create()}
					handleTable._n:addChild(tPartHandle[i].s,z)
				else
					tPartHandle[i].s:setPosition(x,y)
					handleTable._n:reorderChild(tPartHandle[i].s,z)
				end
				local tHandle = tPartHandle[i]
				tHandle.s:setVisible(true)
				hApi.setModel(tHandle,md.name,0)
				tHandle.scale = handleTable.scale
				tHandle.animationlink = handleTable.animationlink
				hApi.SpritePlayAnimation(tHandle, sPartName,IfMustPlay,nRepeat)
			end
		end
	end
end

hApi.ChaSetAnimation = function(handleTable,aniKey)
	local nTick = hApi.SpriteSetAnimation(handleTable,aniKey)
	__CODE__LoadModelPart(handleTable,sAnimation,1,1)
	return nTick
end

hApi.ChaSetFacing = function(handleTable,angle,forceToPlay)
	--[[
	local world = hGlobal.WORLD.LastWorldMap
	if world then
		if world:GetPlayerMe() then
			local heros = world:GetPlayerMe().heros
			if heros and heros[1] then
				local oUnit = world:GetPlayerMe().heros[1]:getunit()
				if oUnit then
					if (handleTable == oUnit.handle) then
						print(angle)
						print(debug.traceback())
					end
				end
			end
		end
	end
	]]
	
	local tPartHandle = handleTable._prt
	if tPartHandle then
		for i = 1,#tPartHandle do
			hApi.ObjectSetFacing(tPartHandle[i],angle,forceToPlay)
		end
	end
	return hApi.ObjectSetFacing(handleTable,angle,forceToPlay)
end

hApi.ChaUpdateAnimation = function(handleTable)
	local ha = handleTable.animationList
	local animationTime = ha[1]
	if animationTime==0 then
		return
	end
	
	local world = hGlobal.WORLD.LastWorldMap
	local timeNow = 0
	if world then
		timeNow = world:gametime()
	else
		timeNow = hApi.gametime()
	end
	
	if timeNow - animationTime>=0 then
		--print("ChaUpdateAnimation", timeNow)
		for i = 2,#ha,1 do
			if ha[i]==0 then
				--动画已经播放掉了,下一个
			--elseif ha[i]==1 then
				--播放结束了,全部停止
				--ha[1] = 0
				--return
			else
				local sAnimation
				local x,y,t
				if type(ha[i])=="table" then
					sAnimation = ha[i][1]
					x = ha[i][2]
					y = ha[i][3]
					t = ha[i][4]
				else
					sAnimation = ha[i]
				end
				--加载额外部件
				if ha[i+1]==1 then
					--播放正常结束，最后一个动作为循环模式
					__CODE__LoadModelPart(handleTable,sAnimation,nil,1)
					hApi.SpritePlayAnimation(handleTable, sAnimation,nil,1)
					ha[1] = 0
					ha[i] = 1
				else
					__CODE__LoadModelPart(handleTable,sAnimation,1,1)
					ha[1] = timeNow + hApi.SpritePlayAnimation(handleTable, sAnimation,1,1)
					ha[i] = 0
				end
				if x and y and handleTable.s~=nil and type(x)=="number" and type(y)=="number" then
					if type(t)=="number" then
						--print("runAction", x,y)
						handleTable.s:runAction(CCMoveTo:create(t/1000,ccp(x,y)))
					else
						--print("setPosition", x,y)
						handleTable.s:setPosition(x,y)
					end
				end
				return
			end
		end
		ha[1] = 0
	end
end

local __CODE__ReadAnimationFromList = function(handleTable,animationTable,modelData,animationList)
	if animationList then
		animationTable[1] = -1
		for i = 1,#animationList do
			local ani = animationList[i]
			local case = type(ani)
			if case=="table" then
				ani = tostring(animationList[i][1])
			elseif case=="string" then
				ani = animationList[i]
			end
			if ani~=nil then
				local _,IsSafe = hResource.model:safeAnimation(handleTable,modelData,ani)
				if IsSafe==hVar.RESULT_SUCESS then
					animationTable[i+1] = animationList[i]
				else
					--单位的未知动作统一替换成attack
					animationTable[i+1] = "attack"
				end
			else
				animationTable[i+1] = "attack"
			end
		end
		animationTable[#animationList+2] = 1
	else
		animationTable[1] = 0
		animationTable[2] = 1
	end
	return animationTable[1]
end

--一般sprite的顺序播放动作
hApi.SpriteSetAnimationByList = function(handleTable,animationList)
	if animationList then
		if __CODE__ReadAnimationFromList(handleTable,handleTable.animationList, hVar.tab_model[handleTable.modelIndex], animationList)~=0 then
			if handleTable.animationList[2]~=1 then
				hApi.SpriteUpdateAnimation(handleTable)
			end
		end
	end
	return math.max(0,handleTable.animationList[1])
end

--角色专用的顺序播放动作！包含了阴影的处理
hApi.ChaSetAnimationByList = function(handleTable,animationList)
	if animationList then
		--geyachao: hVar.tab_model[handleTable.modelIndex]可能为空
		if hVar.tab_model[handleTable.modelIndex] and __CODE__ReadAnimationFromList(handleTable,handleTable.animationList, hVar.tab_model[handleTable.modelIndex], animationList)~=0 then
			if handleTable.animationList[2]~=1 then
				hApi.ChaUpdateAnimation(handleTable)
			end
		end
	end
	return math.max(0,handleTable.animationList[1])
end

hApi.IsSpriteHaveAnimationList = function(handleTable)
	if handleTable.animationList then
		local v = handleTable.animationList[1]
		if v~=0 and v~=nil then
			return true
		end
	end
end

hApi.SpriteStopAnimation = function(handleTable)
	handleTable.animation = ""
	if handleTable.s~=nil then
		handleTable.s:stopAllActions()
		handleTable.s:setVisible(false)
	end
end

hApi.ObjectUpdateAnimation = function(o)
	--print("hApi.ObjectUpdateAnimation", o.data.id)
	--if (o.data.id == 587) then
	--	print(o.handle, o.handle and o.handle.s and o.handle.animationList and o.handle.animationList[1])
	--end
	if o.handle and o.handle.s and o.handle.animationList and o.handle.animationList[1]~=0 then
		--print("hApi.ChaUpdateAnimation", o.data.id)
		return hApi.ChaUpdateAnimation(o.handle)
	end
end

hApi.ObjectPlayAnimation = function(handleTable,modelData,animation)
	if type(animation)=="table" then
		if hApi.SpriteSetAnimationByList(handleTable,animation)==0 then
			hApi.SpriteSetAnimation(handleTable, modelData.animation[1])
		end
	elseif type(animation)=="string" then
		--(优化)不稳定代码
		if handleTable.__appear==0 then
			handleTable._animation = animation
			return
		end
		hApi.SpriteSetAnimation(handleTable, animation)
	else
		hApi.SpriteSetAnimation(handleTable, modelData.animation[1])
	end
end

hApi.ObjectInitModel = function(handleTable,modelKey,scale,animation)
	local modelData,modelIndex = hApi.GetSafeModelByKey(modelKey)
	handleTable.modelIndex = modelIndex
	handleTable.animationList = {0}
	handleTable.scale = (scale or 1)*100
	return modelData
end

--设置任意sprite的朝向角度
hApi.ObjectSetFacing = function(handleTable,angle,forceToPlay)
	--print("hApi.ObjectSetFacing(), modelmode=", handleTable.modelmode, "angle=" .. angle, "forceToPlay=" .. tostring(forceToPlay))
	--(优化)不稳定代码
	if handleTable.__appear==0 then
		return
	end
	if (handleTable.modelmode or 0)==0 then
		--2方向
		if angle>90 and angle<=270 then
			handleTable.flipX = 0
		else
			handleTable.flipX = 1
		end
		hApi.SpriteLoadFacing(handleTable)
	elseif handleTable.modelmode==1 then
		--任意旋转
		handleTable.roll = math.mod(angle,360)
		hApi.SpriteLoadFacing(handleTable)
	else
		--x方向:DIRECTIONx16,DIRECTIONx8,DIRECTIONx4 --geyachao: 添加对16方向的支持
		--新加入了测试流程，因为这个会改变角色的动画标签
		local plus = "DIRECTION:"..tostring(hApi.calAngleD(handleTable.modelmode,angle)).."_"
		local tabM = hVar.tab_model[handleTable.modelIndex]
		if not(tabM and tabM[plus..(handleTable._animation or "")]) then
			return
		end
		handleTable.animationlink = plus
		--print("hApi.ObjectSetFacing(), plus=" .. plus)
		hApi.SpritePlayAnimation(handleTable,handleTable._animation,nil,forceToPlay)
	end
end
--设置任意sprite的朝向格子
hApi.ObjectSetFacingXY = function(handleTable,x,y,tx,ty)
	if not(x==tx and y==ty) then
		--调整朝向，使单位面向某个格子
		if (handleTable.modelmode or 0)==0 then
			--两方向，且所有角色默认角度都是180
			if tx<x then
				handleTable.flipX = 0
			elseif tx>x then
				handleTable.flipX = 1
			end
			hApi.SpriteLoadFacing(handleTable)
		elseif handleTable.modelmode==1 then
			--任意旋转
			if not(x==tx and y==ty) then
				handleTable.roll = hApi.angleBetweenPoints(x,y,tx,ty) or 0
				hApi.SpriteLoadFacing(handleTable)
			end
		else
			--x方向:DIRECTIONx16,DIRECTIONx8,DIRECTIONx4 --geyachao: 添加对16方向的支持
			local plus = "DIRECTION:"..tostring(hApi.calGridD(handleTable.modelmode,x,y,tx,ty)).."_"
			local tabM = hVar.tab_model[handleTable.modelIndex]
			if not(tabM and tabM[plus..(handleTable._animation or "")]) then
				return
			end
			handleTable.animationlink = plus
			hApi.SpritePlayAnimation(handleTable,handleTable._animation,nil,nil)
		end
	end
end

hApi.calArrowLaunchXY = function(x, y, oUnit)
	if oUnit and oUnit~=0 then
		local wx,wy = hApi.chaGetPos(oUnit.handle)
		return (wx + x), (wy - y)
		--return wx,wy --geyachao: why？ --geyachao: 怎么的都得有个偏移吧？
	end
	return x,y
end

hApi.calArrowFacingXY = function(x,y,tx,ty,angle)
	local baseD = math.atan2(y-ty,tx-x)
	local v = hApi.getint(math.deg(baseD))
	local p = hApi.getint(1.25*math.deg(math.atan(math.cos(baseD)*angle,1)))
	local rv = v+p
	if rv<0 then
		rv = rv + 360
	end
	return rv,p*2
end
-------------------------------------------
-- 编辑器专用
hApi.setEditorID = function(id)
	hGlobal.__EditorID = id
end

hApi.getEditorID = function()
	local r = hGlobal.__EditorID or 0
	hGlobal.__EditorID = 0
	return r
end

local __xlAddChaByID_WithData = xlAddChaByID_WithData
hApi.addChaByID = function(worldName,owner,id,x,y,facing,AttrOfCreate,DataOfCreate)
	return xlAddChaByID_WithData(worldName,owner,id,x,y,facing,AttrOfCreate,DataOfCreate)
end

hApi.addItemByID = function(worldName,owner,id,x,y,facing)
	return xlAddItemByID(worldName,owner,id,x,y,facing)
end
--------------------------------------------
--创建effect的sprite
hApi.ObjectInitSprite = function(handleTable,scene,mode,x,y,facing,zOrder)
	handleTable.__manager = "lua"
	handleTable.__speed = 100
	--mode:effect,effectU,effectG,effectA
	if mode=="effectU" then
		--随身特效
		handleTable.s = CCSprite:create()
		handleTable._n = CCNode:create()
		handleTable._n:addChild(handleTable.s)
		handleTable._n:setPosition(x,y)
		hApi.SpriteLoadFacingDefault(handleTable,nil,"reset_clear")
		return handleTable.s
	else--if mode=="effect" or mode=="effectG" or mode=="effectA" or mode=="effectAX" then
		handleTable.s = CCSprite:create()
		handleTable._n = CCNode:create()
		handleTable._n:addChild(handleTable.s)
		if scene~=nil then
			if hGlobal.WORLD_LAYER[scene] then
				handleTable._sce = hGlobal.WORLD_LAYER[scene]-- or xlScene_ToLayer(scene)
				handleTable._n:setPosition(x,-1*y)
				if handleTable._sce then
					if zOrder then
						handleTable._sce:addChild(handleTable._n,zOrder)
					end
				end
			--elseif zOrder then
				----认为这个东西是layer
				--scene:addChild(handleTable._n,zOrder)
				--handleTable._n:setPosition(x,y)
			end
		else
			_DEBUG_MSG("[LUA WARNING] hApi.ObjectInitSprite("..tostring(mode)..") 传入 scene==nil !")
		end
		hApi.SpriteLoadFacingDefault(handleTable,nil,"reset_clear")
		return handleTable.s
	end
	--设置管理者模式为lua,如果是程序管理者调回来的就什么都不做
	return CCSprite:create()
end
--------------------------------------------
--创建cha的sprite
hApi.ObjectInitSpriteCha = function(handleTable,scene,mode,x,y,facing,zOrder)
	handleTable.__manager = "lua"
	handleTable.__speed = 100
	--mode:cha,sceobj
	--单位，部分场景物件以及其他
	if scene~=nil then
		handleTable.s = CCSprite:create()
		handleTable._c = xlCreateCha(scene,hApi.getEditorID(),mode..(handleTable.name or ""), x, y, handleTable.s)
		handleTable._n = xlCha2Node(handleTable._c)
		handleTable._tn = xlChaGetTopNode(handleTable._c)
		handleTable._sce = hGlobal.WORLD_LAYER[scene] or xlScene_ToLayer(scene)
		
		-- 修改小战场tab里填的zOrder在进战场时生效 交换了下面两个接口 xlChaSetZOrderOffset 和 xlCha_SetPos 调用的顺序    2015-5-20 常乾辰
		xlChaSetZOrderOffset(handleTable._c,zOrder)
		xlCha_SetPos(handleTable._c,x,y)

		hApi.SpriteLoadFacingDefault(handleTable,nil, "reset_clear")
		return handleTable.s
	else
		_DEBUG_MSG("[LUA WARNING] hApi.ObjectInitSpriteCha() 传入 scene==nil !")
		return CCSprite:create()
	end
end

--------------------------------------------
--创建xlobj的sprite
hApi.ObjectInitSpriteXL = function(handleTable,scene,mode,x,y,facing,zOrder,xlobjKey,chaType)
	handleTable.__manager = "xlobj"
	handleTable.__speed = 100
	handleTable.xlPath = xlobjKey
	if scene~=nil then
		--xlLG("bud","建筑加载"..tostring(xlobjKey).."   "..tostring(facing).."   "..tostring(chaType).."\n")
		local editorID = hApi.getEditorID()
		handleTable._c = xlCreateBuilding(scene, editorID, xlobjKey, x, y, facing or 0, chaType)
		--geyachao: 同步日志: 创建xlobj的sprite
		if (hVar.IS_SYNC_LOG == 1) then
			local msg = "xlCreateBuilding: editorID=" .. tostring(editorID) .. ",xlobjKey=" .. tostring(xlobjKey) .. ",x=" .. tostring(x) .. ",y=" .. tostring(y) .. ",facing=" .. tostring(facing) .. ",chaType=" .. tostring(chaType) .. ",handleTable._c=" .. type(handleTable._c)
			hApi.SyncLog(msg)
		end
		if handleTable._c and zOrder~=0 then
			xlChaSetZOrderOffset(handleTable._c,zOrder)
		end
		handleTable._n = xlCha2Node(handleTable._c)
		handleTable._tn = xlChaGetTopNode(handleTable._c)
		handleTable.s = xlChaGetSprite(handleTable._c)
		--geyachao: 同步日志: 创建xlobj的sprite
		if (hVar.IS_SYNC_LOG == 1) then
			local msg = "xlChaGetSprite: handleTable.s=" .. type(handleTable.s)
			hApi.SyncLog(msg)
		end
		if handleTable.s==nil then
			handleTable.s = CCSprite:create()
			handleTable.s:setVisible(false)
			handleTable._n:addChild(handleTable.s)
		end
		handleTable._sce = hGlobal.WORLD_LAYER[scene] or xlScene_ToLayer(scene)
		hApi.SpriteLoadFacingDefault(handleTable,nil,"reset_clear")
		return handleTable.s
	else
		_DEBUG_MSG("[LUA WARNING] hApi.ObjectInitSpriteXL() 传入 scene==nil !")
		return CCSprite:create()
	end
end

hApi.ObjectReleaseSprite = function(handleTable)
	--xlLG("RoadPoint", "hApi.ObjectReleaseSprite()" .. "\n")
	--把动画信息删除
	handleTable.animation = ""
	handleTable.animationlink = 0
	hApi.SpriteStopAnimation(handleTable)
	handleTable.xlPath = nil
	handleTable.modelIndex = 0
	--把动画停掉
	if handleTable.__manager=="lua" then
		if handleTable._tn~=nil then
			--清干净topNode上面的东西
			handleTable._tn:removeAllChildrenWithCleanup(true)
		end
		if handleTable._prt~=nil and handleTable._n~=nil then
			for i = 1,#handleTable._prt do
				handleTable._n:removeChild(handleTable._prt[i].s,true)
			end
		end
		if handleTable._c then
			--cha类型的交给程序删
			--如果拥有阴影,把阴影移除
			if handleTable._sce~=nil then
				xlScene_RemoveCha(handleTable._sce,handleTable._c)
			end
		elseif handleTable._n then
			--非cha类型的走到一般流程删除
			if handleTable._n:getParent() then
				handleTable._n:getParent():removeChild(handleTable._n,true)
			else
				handleTable._n:removeAllChildrenWithCleanup(true)
			end
		end
	elseif handleTable.__manager=="xlobj" then
		--xlobj类型的必然是程序管理
		--handleTable._n:removeAllChildrenWithCleanup(true)
		if handleTable._tn~=nil then
			handleTable._tn:removeAllChildrenWithCleanup(true)
		end
		if handleTable._c then
			if handleTable._sce~=nil then
				xlScene_RemoveCha(handleTable._sce,handleTable._c)
			end
		end
	end
	handleTable.__manager = nil
	handleTable.s = nil
	handleTable._n = nil
	handleTable._tn = nil
	handleTable._c = nil
	handleTable._prt = nil
	handleTable._sce = nil			--脚本使用的父节点layer
end

--------------------------------------------
--------------------------------------------
--@创建自定义图片的地图(废弃，目前仅测试用)
hApi.CreateWorldMapPNG = function(handleTable,mapPath,offsetX,offsetY,gridX,gridY,gridW,gridH)
	if type(handleTable.worldScene)=="userdata" then
		xlScene_SetMapName(handleTable.worldScene, tostring(mapPath))
		xlScene_LoadBackground(handleTable.worldScene, "black")
	end
	if mapPath~=nil and mapPath~=0 and mapPath~="" and type(mapPath)=="string" and type(handleTable.worldLayer)=="userdata" then
		mapPath = hApi.GetFilePath(mapPath)
		if not(hApi.FileExists(mapPath)) then
			mapPath = hApi.GetImagePath("misc/mask.png")
		end
		local scene = handleTable.worldLayer
		handleTable.s = CCSprite:create(mapPath)
		handleTable._n = CCNode:create()
		handleTable._n:addChild(handleTable.s)
		handleTable.s:setAnchorPoint(ccp(0,1))
		handleTable.s:setPosition(offsetX,-1*offsetY)
		handleTable.worldLayer:addChild(handleTable._n)
		handleTable.worldLayer:reorderChild(handleTable._n, hVar.ObjectZ.MAP + 0)
	end
end

--------------------------------------------
--@创建自定义的地图(战场)
hApi.CreateWorldMapXL_BF = function(handleTable,mapName,mapPath,defaultPath)
	local w,h = 64,64
	if type(handleTable.worldScene)=="userdata" then
		xlScene_SetMapName(handleTable.worldScene, tostring(mapName))
		if mapPath~=nil and mapPath~=0 and mapPath~="" and type(mapPath)=="string" then
			w,h = xlScene_LoadBackground(handleTable.worldScene, mapPath)
		elseif type(defaultPath)=="string" then
			--如果不这么处理会down
			w,h = xlScene_LoadBackground(handleTable.worldScene, defaultPath)
		end
	else
		xlLG("error","对未读取scene的世界加载地图:"..tostring(mapPath))
	end
	if type(handleTable.worldLayer)=="userdata" then
		handleTable._n = CCNode:create()
		handleTable.worldLayer:addChild(handleTable._n,hVar.ObjectZ.MAP + 0)
	end
	return hApi.getint(w/16),hApi.getint(h/16),w,h
end
--------------------------------------------
--@创建世界地图
hApi.CreateWorldMapXL = function(handleTable,mapName,mapPath,defaultPath)
	local w,h = 64,64
	if type(handleTable.worldScene)=="userdata" then
		xlScene_SetMapName(handleTable.worldScene, tostring(mapName))
		if mapPath~=nil and mapPath~=0 and mapPath~="" and type(mapPath)=="string" then
			local terPath = mapPath
			local tabM = hVar.MAP_INFO[mapName]
			if tabM and tabM.terrainType and type(tabM.terrainType) == "table" then
				local r = math.random(1,#tabM.terrainType)
				terPath = tabM.terrainType[r]
			end
			w,h = xlScene_LoadBackground(handleTable.worldScene, terPath)
			print("测试测试测试测试hApi.CreateWorldMapXL:",terPath,defaultPath)
			--print(""..abc)
		elseif type(defaultPath)=="string" then
			--如果不这么处理会down
			w,h = xlScene_LoadBackground(handleTable.worldScene, defaultPath)
		end
	else
		xlLG("error","对未读取scene的世界加载地图:"..tostring(mapPath))
	end
	return hApi.getint(w/16),hApi.getint(h/16),w,h
end

hApi.GetWorldMapGridTable = function(handleTable,key)
	if handleTable.grid==nil then
		handleTable.grid = {}
	end
	if key then
		handleTable.grid[key] = handleTable.grid[key] or {}
		return handleTable.grid[key]
	end
end


local __ClearFloatNumber = function(o,p)
	if o.data.parent==p then
		--xlLG("RoadPoint", "__ClearFloatNumber(), unit=" .. tostring(o.data.name) .. "_" .. tostring(o.__ID) .. "\n")
		o:del()
	end
end
hApi.DestroyWorldMap = function(handleTable)
	if handleTable._n then
		handleTable._n:removeAllChildrenWithCleanup(true)
		handleTable._n:getParent():removeChild(handleTable._n,true)
	end
	if handleTable.grid then
		--for _,g in pairs(handleTable.grid)do
			--if type(g)=="table" then
				--for k in pairs(g)do
					--g[k] = nil
				--end
			--end
		--end
		handleTable.grid = nil
	end
	if handleTable.worldLayer~=nil and hUI.floatNumber then
		hUI.floatNumber:enum(__ClearFloatNumber,handleTable.worldLayer)
	end
	if handleTable.worldScene~=nil then
		xlScene_ClearAll(handleTable.worldScene)
	end
	for k,v in pairs(handleTable)do
		handleTable[k] = nil
	end
end

local __TempModelKey = {}
--------------------------------------------
--@创建单位模型
hApi.InitModelForUnit = function(handleTable,modelKey,scale,animation,facing,IsWithFacingEvent)
	--初始化动作
	--如果模型表里面没这个模型，尝试初始化一次
	if hVar.tab_model.index[modelKey]==nil and __TempModelKey[modelKey]~=1 then
		__TempModelKey[modelKey] = 1
		hApi.setModel({},modelKey,0)
	end
	local modelData = hApi.ObjectInitModel(handleTable,modelKey,scale,animation)
	--geyachao: 添加对16方向的支持
	if modelData.modelmode=="DIRECTIONx32" then
		--32方向单位模型
		handleTable.modelmode = "DIRECTIONx32"
		handleTable.animationlink = "DIRECTION:"..tostring(hApi.calAngleD("DIRECTIONx32",facing or 180)).."_"
	--geyachao: 添加对16方向的支持
	elseif modelData.modelmode=="DIRECTIONx16" then
		--16方向单位模型
		handleTable.modelmode = "DIRECTIONx16"
		handleTable.animationlink = "DIRECTION:"..tostring(hApi.calAngleD("DIRECTIONx16",facing or 180)).."_"
	elseif modelData.modelmode=="DIRECTIONx8" then
		--8方向单位模型
		handleTable.modelmode = "DIRECTIONx8"
		handleTable.animationlink = "DIRECTION:"..tostring(hApi.calAngleD("DIRECTIONx8",facing or 180)).."_"
	elseif modelData.modelmode=="DIRECTIONx4" then
		--4方向单位模型
		handleTable.modelmode = "DIRECTIONx4"
		handleTable.animationlink = "DIRECTION:"..tostring(hApi.calAngleD("DIRECTIONx4",facing or 180)).."_"
	else
		handleTable.modelmode = 0
		if type(modelData.modelmode)=="number" then
			handleTable.modelmode = modelData.modelmode
		end
		handleTable.animationlink = 0
	end
	handleTable.animation = 0
	if IsWithFacingEvent==1 and handleTable._sce then
		--这里是dat储存的角度，无需转换
		xlCha_FaceTo(handleTable._c,hApi.LeeAngleToRyanAngle(facing or 0))
	end
	hApi.ObjectPlayAnimation(handleTable,modelData,animation)
end
--------------------------------------------
--@单位操作函数
hApi.CreateUnit = function(handleTable,scene,modelKey,scale,worldX,worldY,height,facing,animation,IsHide)
	local zOffset = (height or 0) + hVar.ObjectZ.UNIT
	--初始化sprite
	handleTable.s = hApi.ObjectInitSpriteCha(handleTable,scene,"cha",worldX,worldY,facing,zOffset)
	xlCha_SetType(handleTable._c,hVar.UNIT_TYPE.UNIT)
	if IsHide==1 then
		handleTable._n:setVisible(false)
	end
	--存在时间设置
	handleTable.removetime = 0
	if modelKey~=nil then
		--初始化模型
		hApi.InitModelForUnit(handleTable,modelKey,scale,animation,facing,1)
	else
		--不画模型
		handleTable.modelIndex = 0
		handleTable.animation = 0
		handleTable.modelmode = 0
		handleTable.animationlink = 0
		handleTable.animationList = {0}
	end
	return handleTable._c
end

hApi.CreateIllusion = function(handleTable,handelTable_Base)
	local h = handleTable
	local b = handelTable_Base
	for k,v in pairs(b)do
		local t = type(v)
		if t=="number" or t=="string" then
			h[k] = v
		end
	end
	h.animationList = {0}
	h.removetime = 0
	--hApi.SpriteLoadFacingDefault(h,nil,"reset_clear")
	hApi.SpritePlayAnimation(h, b._animation, nil, 1)
	return handleTable
end

hApi.CreateUnitB = function(handleTable,scene,xlobjKey,worldX,worldY,facing,zOffset,chaType)
	chaType = chaType or 0
	--初始化sprite
	handleTable.s = hApi.ObjectInitSpriteXL(handleTable,scene,"xlobj",worldX,worldY,hApi.LeeAngleToRyanAngle(facing or 0),(zOffset or 0),xlobjKey,chaType)
	handleTable.removetime = 0
	hApi.ObjectInitModel(handleTable,"MODEL:default",1.0,"stand")
	return handleTable._c
end

local __ENUM__AutoReleaseWorldUnit = function(oUnit,nTick)
	--非法单位删除
	if not(oUnit.handle and oUnit.handle.removetime) then
		--xlLG("RoadPoint", "__ENUM__AutoReleaseWorldUnit(1), unit=" .. tostring(oUnit.data.name) .. "_" .. tostring(oUnit.__ID) .. "\n")
		return oUnit:del("safe")
	end
	--过期单位将被删除
	if oUnit.handle.removetime~=0 and nTick>=oUnit.handle.removetime then
		oUnit.handle.removetime = 0
		--xlLG("RoadPoint", "__ENUM__AutoReleaseWorldUnit(2), unit=" .. tostring(oUnit.data.name) .. "_" .. tostring(oUnit.__ID) .. "\n")
		return oUnit:del("safe")
	end
end

hApi.AutoReleaseWorldUnit = function(oWorld)
	if oWorld~=nil and oWorld.ID~=0 then
		local nTick = oWorld:gametime()
		oWorld:enumunit(__ENUM__AutoReleaseWorldUnit,nTick)
	end
end
--------------------------------------------
--------------------------------------------
--@特效操作函数
hApi.CreateEffect = function(effectMode,handleTable,scene,modelKey,scale,worldX,worldY,height,facing,animation,playCount,alpha)
	--print("CreateEffect")
	local zOffset = (height or 0) + hVar.ObjectZ.EFFECT
	zOffset = math.max(1,zOffset)	--此值不会小于1，不然钻到地下了
	--初始化sprite
	handleTable.s = hApi.ObjectInitSprite(handleTable,scene,effectMode,worldX,worldY,facing,zOffset)
	
	--设置特效透明度
	if handleTable.s then
		if alpha then
			if (type(alpha) == "number") then
				handleTable.s:setOpacity(alpha)
			end
		end
	end
	
	--存在时间设置
	handleTable.removetime = 0
	--播放时间设置
	handleTable.animationtime = 0
	--初始化动作
	if modelKey~=nil then
		--初始化模型
		local modelData = hApi.ObjectInitModel(handleTable,modelKey,scale,animation)
		if type(animation)~="table" and playCount>0 then
			hApi.SpriteSetAnimationCount(handleTable,animation,playCount)
		else
			hApi.ObjectPlayAnimation(handleTable,modelData,animation)
		end
	else
		--不画模型
		handleTable.modelIndex = 0
		handleTable.animation = 0
		handleTable.modelmode = 0
		handleTable.animationlink = 0
		handleTable.animationList = {0}
	end
	return handleTable._c
end

-- 创建随身特效需要传入两个object，坑爹
hApi.CreateEffectU = function(oEffect,oUnit,bindKey,modelKey,scale,offsetX,offsetY,height,facing,animation,playCount,alpha)
	local handleTable = oEffect.handle
	local handleTableU = oUnit.handle
	handleTable.s = hApi.ObjectInitSprite(handleTable,nil,"effectU",offsetX,offsetY,facing,0)
	
	--设置特效透明度
	if handleTable.s then
		if alpha then
			if (type(alpha) == "number") then
				handleTable.s:setOpacity(alpha)
			end
		end
	end
	
	--存在时间设置
	handleTable.removetime = 0
	--播放时间设置
	handleTable.animationtime = 0
	if modelKey==nil then
		--没填effect的情况下，空sprite
		if handleTableU._n then
			handleTable._n:setScale(scale)
			handleTableU._n:addChild(handleTable._n)
			handleTableU._n:reorderChild(handleTable._n,(height or 0))-- + hVar.ObjectZ.EFFECT)
		end
	else
		--初始化动作
		local modelData = hApi.ObjectInitModel(handleTable,modelKey,scale,animation)
		if handleTableU._n then
			handleTableU._n:addChild(handleTable._n)
			handleTableU._n:reorderChild(handleTable._n,(height or 0))-- + hVar.ObjectZ.EFFECT)
			if playCount>0 then
				hApi.SpriteSetAnimationCount(handleTable,animation,playCount)
			else
				hApi.ObjectPlayAnimation(handleTable,modelData,animation)
			end
		end
	end
end

hApi.RemoveEffectInTime = function(handleTable, rTime)
	local world = hGlobal.WORLD.LastWorldMap
	local currenttime = 0
	if world then
		currenttime = world:gametime()
	else
		currenttime = hApi.gametime()
	end
	handleTable.removetime = currenttime + rTime
	--print("hApi.RemoveEffectInTime", rTime)
end
--------------------------------------------
--------------------------------------------
--@场景物件操作函数
hApi.CreateSceobj = function(handleTable,scene,modelKey,scale,worldX,worldY,height,facing,animation)
	local zOffset = (height or 0) + hVar.ObjectZ.SCEOBJ
	--初始化sprite
	handleTable.s = hApi.ObjectInitSpriteCha(handleTable,scene,"sceobj",worldX,worldY,facing,zOffset)
	xlCha_SetType(handleTable._c,hVar.UNIT_TYPE.SCEOBJ)
	--存在时间设置
	handleTable.removetime = 0
	--播放时间设置
	handleTable.animationtime = 0
	if modelKey~=nil then
		--初始化动作
		local modelData = hApi.ObjectInitModel(handleTable,modelKey,scale,animation)
		hApi.ObjectPlayAnimation(handleTable,modelData,animation)
	else
		--不画模型
		handleTable.modelIndex = 0
		handleTable.animation = 0
		handleTable.modelmode = 0
		handleTable.animationlink = 0
		handleTable.animationList = {0}
	end
	return handleTable._c
end

hApi.CreateSceobjB = function(handleTable,scene,xlobjKey,worldX,worldY,zOffset,facing)
	--初始化sprite
	handleTable.s = hApi.ObjectInitSpriteXL(handleTable,scene,"xlobj",worldX,worldY,hApi.LeeAngleToRyanAngle(facing or 0),(zOffset or 0),xlobjKey,hVar.UNIT_TYPE.SCEOBJ)
	--存在时间设置
	handleTable.removetime = 0
	--播放时间设置
	handleTable.animationtime = 0
	--xlLG("sceobj","创建场景物件 "..tostring(xlobjKey).."("..tostring(hVar.UNIT_TYPE.SCEOBJ)..")\n")
	hApi.ObjectInitModel(handleTable,"MODEL:default",1.0,"stand")
	return handleTable._c
end

hApi.RemoveSceobj = function(handleTable)
	handleTable.removetime = 0
	hApi.ObjectReleaseSprite(handleTable)
end

------------------------------
-- 全局计时器
hGlobal.__gametime = 0		--计算机时间
hGlobal.gametime = 0		--游戏时间
hApi.gametime = function()
	return hGlobal.gametime
end
hApi.pctime = function()
	return hGlobal.__gametime
end
hGlobal.timer = {}
hGlobal.timerI = {}
hGlobal.timerSYS = {}
local _timer = hGlobal.timer
local _timerI = hGlobal.timerI
local _timerSYS = hGlobal.timerSYS
local __tick = 0		--定时器运行时实际的触发时间点
local __pasttime = 0		--定时器运行时实际的触发时间点与理论触发时间点的差值
local __timerCode		--定时器触发时的回调
local __timeScale = 1		--定时器的时间缩放值
local __timeInterval = 0	--定时器addtime时参数传进来的间隔

--设置定时器时间缩放(缩放在正负8倍速之间)
hApi.SetTimeScale = function(scale)
	__timeScale = math.min(math.max((scale or 1), 0.25), hVar.OPTIONS.MAX_GAME_SPEED)
	CCDirector:sharedDirector():getScheduler():setTimeScale(__timeScale)
end

--获取定时器时间缩放
hApi.GetTimeScale = function()
	return __timeScale
end

--加速（每次加速2倍，最多4倍）
hApi.SpeedUpTimer = function()
	local timeScale = hApi.GetTimeScale()
	--timeScale为0表示暂停，如果游戏暂停，不处理加速减速
	if timeScale > 0 then
		hApi.SetTimeScale(timeScale * 2)
	end
end

--减速（每次减速2倍，最多4倍）
hApi.SpeedDownTimer = function()
	local timeScale = hApi.GetTimeScale()
	--timeScale为0表示暂停，如果游戏暂停，不处理加速减速
	if timeScale > 0 then
		hApi.SetTimeScale(timeScale * 0.5)
	end
end

--暂停定时器
hApi.PauseTimer = function()
	--脚本逻辑定时器时间缩放
	__timeScale = 0.0
	--cocos默认scheduler时间缩放，主要是控制角色序列帧速度
	CCDirector:sharedDirector():getScheduler():setTimeScale(__timeScale)
end

--回复定时器
hApi.ResumeTimer = function()
	hApi.SetTimeScale(1.0)
end

local fTimerCode = function()
	return __timerCode(__tick,__pasttime,__timeInterval)
end

hApi.GetFrameCountByTick = function(nTick)
	return math.ceil(nTick/50)
end

hApi.__callback__FrameLoop = function()
	local curtick = xlGetTickCount()--os.clock()*1000
	local pasttime = (curtick - hGlobal.__gametime) * __timeScale --经过的时间 --geyachao: 这个才是正确的pasttime
	hGlobal.gametime = hGlobal.gametime + pasttime
	hGlobal.__gametime = curtick
	local gametick = hGlobal.gametime
	hApi.__timerLoop()
end

local __CALLBACK_FRAME_LOOP__
__CALLBACK_FRAME_LOOP__ = function()
	hGlobal.__gametime = xlGetTickCount()
	--第一帧时，对SYS_Timer进行排序
	local slotI = 1
	for i = 1,#_timer do
		local v = _timer[i]
		if _timerSYS[v[7]]==1 then
			for k = i,slotI+1,-1 do
				_timer[k] = _timer[k-1]
				_timerI[_timer[k][7]] = k
			end
			_timer[slotI] = v
			_timerI[v[7]] = slotI
			slotI = slotI + 1
		end
	end
	__CALLBACK_FRAME_LOOP__ = function()
		return hApi.__callback__FrameLoop()
	end
end

--防止二段更新又加载一遍
if (not G_SCHEDULE_SCRIPTS_FUNC) then
	G_SCHEDULE_SCRIPTS_FUNC = true
	
	CCDirector:sharedDirector():getScheduler():scheduleScriptFunc(function()
		hClass.world:__timer_loop(frame_count)
		if hGlobal.WORLD_INIT_SUCESS==1 then
			return __CALLBACK_FRAME_LOOP__()
		elseif hGlobal.WORLD_INIT_SUCESS~=0 then
			hGlobal.WORLD_INIT_SUCESS = 0
			_DEBUG_MSG("--------------------------------------------\n [script load error]	脚本初始化出错！\n--------------------------------------------")
		end 
	end, 0, false)	--全局回调
end

------------------------------------------------------------------------
-- timer
------------------------------------------------------------------------
local TIMER_LOOP_MODE_DISABLE = hVar.TIMER_LOOP_MODE.DISABLE
local TIMER_LOOP_MODE_RELEASE = hVar.TIMER_LOOP_MODE.RELEASE
local TIMER_MODE_GAMETIME = hVar.TIMER_MODE.GAMETIME
local __GetTimeByMode = function(m)
	if m==TIMER_MODE_GAMETIME then
		return hGlobal.gametime
	else
		return hGlobal.__gametime
	end
end
hApi.__timerLoop = function()
	for i = 1,#_timer do
		local v = _timer[i]
		--{[1] = enable,[2] = tickN,[3] = count,[4] = mode,[5] = interval,[6] = code,[7] = name}
		if v~=0 and v[1]~=TIMER_LOOP_MODE_DISABLE then
			local tickN = v[2]
			--模式等于1的话是游戏时间，0是实际时间
			local tick = __GetTimeByMode(v[4])
			if tick>=tickN then
				__timerCode = v[6]
				__tick = tick
				__pasttime = tick - tickN --当前实际时间与理论触发时间的差值
				__timeInterval = v[5] * __timeScale
				if v[3]>0 then
					v[3] = v[3] - 1
					if v[3]==0 then
						v[1] = 0
						v[6] = hApi.DoNothing
					end
				end
				if v[5]<=1 then
					v[2] = tick+1
				else
					--v[2] = v[2] + v[5]-- * __timeScale
					v[2] = tick + v[5] -- * __timeScale --geyachao: 程序进入后台，再回来时不需要触发几百次timer，这里只需调用一次
				end
				if (not __timerCode or type(__timerCode) ~= "function") then
					print("error timer:".. tostring(v[7]))
				end
				if xpcall(fTimerCode,hGlobal.__TRACKBACK__)==false then
					if v[1]~=TIMER_LOOP_MODE_RELEASE then
						v[1] = TIMER_LOOP_MODE_DISABLE
						v[6] = hApi.DoNothing
					end
				end
				__timerCode = nil
			end
		end
	end
end

hApi.enableTimer = function(key,enable)
	local k = _timerI[key]
	if k and _timer[k] then
		_timer[k][1] = ((enable==1 or enable==2) and enable) or 0
	end
end

hApi.clearTimer = function(key)
	local k = _timerI[key]
	if k then
		_timer[k][1] = 0
		_timer[k][6] = hApi.DoNothing
	end
end

hApi.addTimerOnce = function(key,interval,code)
	return hApi.addTimer(key,hVar.TIMER_MODE.GAMETIME,1,interval,code)
end

hApi.addTimerG = function(key,count,interval,code)
	return hApi.addTimer(key,hVar.TIMER_MODE.GAMETIME,count,interval,code)
end

hApi.addTimerForever = function(key,mode,interval,code,DoNotStopWithError)
	hApi.addTimer(key,mode,0,interval,code)
	if DoNotStopWithError==1 then
		hApi.enableTimer(key,2)
	end
end


hApi.getTimer = function(key)
	local k = _timerI[key]
	if k and _timer[k] and _timer[k][1]~=TIMER_LOOP_MODE_DISABLE then
		return _timer[k]
	end
end
-------------------------------------------
--创建系统timer
--以这种方式创建的timer只能在游戏尚未开始时创建
--在开始时，所有以此方式创建的timer将被排序到最前端
hApi.addTimerSYS = function(key,mode,interval,code)
	if hGlobal.WORLD_INIT_SUCESS==1 then
		_DEBUG_MSG("[LUA WARNING]游戏开始后禁止定义SYS_Timer，定义为普通Timer！["..tostring(key).."]")
	end
	if _timerI[key]~=nil then
		_DEBUG_MSG("[LUA WARNING]重复定义SYS_Timer:"..tostring(key).."！")
	else
		_timerSYS[key] = 1
	end
	hApi.addTimer(key,mode,0,interval,code)
	hApi.enableTimer(key,2)
end

hApi.addTimer = function(key,mode,count,interval,code)
	--{[1] = enable,[2] = tickN,[3] = count,[4] = mode,[5] = interval,[6] = code}
	local k = _timerI[key]
	local tick = __GetTimeByMode(mode)
	interval = math.max(0,interval or 0)
	if k and _timer[k] then
		local v = _timer[k]
		v[1] = 1
		v[2] = tick+interval
		v[3] = count
		v[4] = mode
		v[5] = math.max(0,interval)
		v[6] = code
		return
	end
	_timer[#_timer+1] = {1,tick+interval,count,mode,interval,code,key}
	_timerI[key] = #_timer
end

hApi.setTimerData = function(key,mode,count,interval,code)
	--{[1] = enable,[2] = tickN,[3] = count,[4] = mode,[5] = interval,[6] = code}
	local k = _timerI[key]
	if k and _timer[k] then
		local v = _timer[k]
		v[3] = count or v[3]
		v[4] = mode or v[4]
		v[5] = (interval and math.max(0,interval or 0)) or v[5]
		v[6] = code or v[6]
	end
end

--------------------------------------------
--加载最基本的timer
hApi.addTimerSYS("__SYS__ObjectAutoUpdate",hVar.TIMER_MODE.GAMETIME, 1, function(currentTime, deltaTime)
	--[[
	--挪到world里
	hApi.AutoReleaseWorldUnit(hGlobal.WORLD.LastWorldMap)
	hApi.UpdateGameEffect(deltaTime) --geyachao: 添加参数时间间隔，用于更新追踪类飞行特效的位置
	hApi.UpdateGameUnit()
	]]
end)

---------------------------------------------
local count = 0
hApi.ClassAutoReleaseByTick = function(class,mode,tickTag)
	local __cN = class
	local __cTick
	local function __cN_checkLifeTime(self)
		local t = self.data[tickTag] or 0
		if t~=0 and t<=__cTick then
			self:del("safe")
		end
	end
	if mode=="pctime" then
		mode = 0
		class.settick = function(self,t)
			self.data[tickTag] = hApi.pctime() + t
		end
	else
		mode = 1
		class.settick = function(self,t)
			self.data[tickTag] = hApi.gametime() + t
		end
	end
	count = count + 1
	local timerName = "__AutoRelease_"..(class.classname or tostring(count))
	if mode=="pctime" then
		hApi.addTimerForever(timerName,hVar.TIMER_MODE.PCTIME,1,function()
			__cTick = hApi.pctime()
			__cN:enum(__cN_checkLifeTime)
		end,1)
	else
		hApi.addTimerForever(timerName,hVar.TIMER_MODE.GAMETIME,1,function()
			__cTick = hApi.gametime()
			__cN:enum(__cN_checkLifeTime)
		end,1)
	end
end
------------------------------------------------------------------------
local __DefaultParam = {
	count = 0,		--循环数量控制
	s = 0,			--寻路开始点
	e = 0,			--寻路结束点
	i = 0,			--遍历用临时变量
	cur = -1,		--当前方格
	rMode = 0,		--迭代返回模式
	tempO = {n=0},		--开放节点
	tempOI = {},		--开放节点索引
	c = {},			--闭合节点
	p = {},			--节点的父节点
	f = {},			--节点的f值
	g = {},			--节点的g值
	v = {},			--节点的v(h)值
	x = {},			--node在网格中的x
	y = {},			--node在网格中的y
	block = {},		--阻挡
	w = 1,			--寻路W
	h = 1,			--寻路H
}
hGlobal.AxBasic = {
	new = function(self,t)
		--加载数据
		hApi.ReadParamWithDepth(__DefaultParam,nil,t,1)
		--enum函数
		--way函数
		--加载函数
		for k,v in pairs(self)do
			if t[k]==nil and k~="new" then
				t[k] = v
			end
		end
		t:__InitEnum()
		t:__InitWay()
		return t
	end,
	-----------------------------------------------------
	-- virtrual函数:Ax4
	-----------------------------------------------------
	name = "Ax4",
	nearNode = {
		--这里表示是四方向搜索格子，如果需要多方向寻路请扩展
		--{x偏移，y偏移，移动权值G}
		{0,-1,10},
		{-1,0,10},
		{1,0,10},
		{0,1,10},
		--打开下面的就变成八方向了
		--{-1,-1,14},
		--{-1,1,14},
		--{1,-1,14},
		--{1,1,14},
	},
	getNearNode = function(self,n,x,y)
		return self.nearNode
	end,
	calV = function(self,n,e,directV)	--改八方向或者六角格这里也许要改改
		--方格直线移动权值10，斜对角14
		directV = directV or 10
		local x,y = self:n2grid(n,self.w)
		local ex,ey = self:n2grid(e,self.w)
		local v = math.abs(x-ex)*directV+math.abs(y-ey)*directV
		self.v[n] = v
		return v
	end,
	isNodeSafe = function(self,gridX,gridY,plusX,plusY,nW,nH)
		local maxW = nW-1
		local maxH = nH-1
		local x = gridX + plusX
		local y = gridY + plusY
		if (x>=0 and x<=maxW) and (y>=0 and y<=maxH) then
			return hVar.RESULT_SUCESS,x,y
		end
		return hVar.RESULT_FAIL,-1,0
	end,
	-----------------------------------------------------
	-- Common
	-----------------------------------------------------
	grid2n = function(self,x,y,w)
		return x+y*w
	end,
	n2grid = function(self,n,w)
		return math.mod(n,w),math.floor(n/w)
	end,
	reset = function(self)
		self.cur = -1
		self.tempO.n = 0
		for i = 0,self.w*self.h-1,1 do
			self.tempO[i] = 0
			self.tempOI[i] = 0
			self.c[i] = 0
			self.p[i] = 0
			self.v[i] = 0
			self.f[i] = 0
			self.g[i] = 0
		end
		self.tempO[0] = 1
	end,
	open = function(self,n)
		local o = self.tempO
		local p = self.tempOI
		if p[n]<=0 then
			o.n = o.n + 1
			o[o.n] = n
			p[n] = o.n
		end
	end,
	close = function(self,n)
		self.c[n] = 1
		local o = self.tempO
		local p = self.tempOI
		if p[n]>0 then
			local t = o[o.n]
			local pn = p[n]
			p[t] = pn
			o[pn] = t
			p[n] = -1
			o.n = o.n - 1
		end
	end,
	getMinF = function(self,list)
		local r = list[1]
		for i = 1,(list.n or #list) do
			local n = list[i]
			if self.f[r]>self.f[n] then
				r = n
			end
		end
		return r
	end,
	checkBlockIN = function(self,n,blockList,unitBlock,availableNodeList)
		local nW,nH = blockList.w,blockList.h
		local x,y = self:n2grid(n,nW)
		local aNL = availableNodeList
		if unitBlock==nil or unitBlock==0 then
			if aNL and aNL[n]~=1 then
				return hVar.RESULT_FAIL
			end
			return hVar.RESULT_SUCESS
		elseif unitBlock~=1 and type(unitBlock)=="table" then
			for i = 1,#unitBlock do
				local plusX,plusY = unitBlock[i][1],unitBlock[i][2]
				local sus,newX,newY = self:isNodeSafe(x,y,plusX,plusY,nW,nH)
				if sus==hVar.RESULT_SUCESS then
					local n = self:grid2n(newX,newY,nW)
					if (aNL and aNL[n]~=1) or (blockList[n] and blockList[n]>0) then
						return hVar.RESULT_FAIL
					end
				else
					return hVar.RESULT_FAIL
				end
			end
			return hVar.RESULT_SUCESS
		else
			if (aNL and aNL[n]~=1) or (blockList[n] and blockList[n]>0) then
				return hVar.RESULT_FAIL
			end
			return hVar.RESULT_SUCESS
		end
	end,
	checkBlock = function(self,n,blockList,unitBlock,x,y)
		local nW,nH = self.w,self.h
		if x==nil or y==nil then
			nW,nH = blockList.w,blockList.h
			x,y = self:n2grid(n,nW)
		end
		if unitBlock==nil or unitBlock==0 then
			return hVar.RESULT_SUCES
		elseif unitBlock==255 then
			--特殊检测用,只检测建筑碰撞
			if blockList[n] and blockList[n]>=10 then
				return hVar.RESULT_FAIL
			end
			return hVar.RESULT_SUCESS
		elseif unitBlock~=1 and type(unitBlock)=="table" then
			for i = 1,#unitBlock do
				local plusX,plusY = unitBlock[i][1],unitBlock[i][2]
				local sus,newX,newY = self:isNodeSafe(x,y,plusX,plusY,nW,nH)
				if sus==hVar.RESULT_SUCESS then
					local c = self:grid2n(newX,newY,nW)
					if blockList[c] and blockList[c]>0 then
						return hVar.RESULT_FAIL
					end
				else
					return hVar.RESULT_FAIL
				end
			end
			return hVar.RESULT_SUCESS
		else
			if blockList[n] and blockList[n]>0 then
				return hVar.RESULT_FAIL
			end
			return hVar.RESULT_SUCESS
		end
	end,
	-----------------------------------------------------
	-- Enum
	-----------------------------------------------------
	enumAdd = function(self,v)
		local list = self.enumList
		list.n = list.n + 1
		list[list.n] = v
	end,
	enumGet = function(self,plus)
		local list = self.enumList
		local i = list.i+(plus or 1)
		if i<=list.n then
			list.i = i
			return list[list.i]
		end
	end,
	enumReset = function(self,v)
		local list = self.enumList
		list.i = 0
		list.n = 0
		list[0] = v
	end,
	__InitEnum = function(self)
		self.__InitEnum = nil
		self.enumList = {i=0,n=0}
		local __enumCode = function()
			return self:enumGet(1)
		end
		self.enum = function(self,v)
			if v~=nil then
				self.enumList.i = v
			end
			return __enumCode
		end
	end,
	-----------------------------------------------------
	-- NodeInReach
	-----------------------------------------------------
	__nodeInReachOne = function(self,blockList,unitBlock,c,count)
		if self.g[c]==nil then
			return
		end
		local tIndexPlus = 0
		local cx,cy = self:n2grid(c,self.w)
		local nearNode = self:getNearNode(c,cx,cy)
		local pG = self.g[c]
		local c,g,f = self.c,self.g,self.f
		local nW,nH = self.w,self.h
		for i = 1,#nearNode do
			local plusX,plusY,G = unpack(nearNode[i])
			local sus,newX,newY = self:isNodeSafe(cx,cy,plusX,plusY,nW,nH)
			if sus==hVar.RESULT_SUCESS then
				local n = self:grid2n(newX,newY,self.w)
				if c[n]==0 then
					if blockList~=nil then
						if self:checkBlock(n,blockList,unitBlock,newX,newY)==hVar.RESULT_SUCESS then
							c[n] = 2
						else
							c[n] = 1
						end
					else
						c[n] = 2
					end
				end
				if c[n]==2 and n~=o then
					local nG = pG + 1	--如果不同网格需要花费的行动力不同则需要修改这里(暂定为1)
					if g[n]==0 then
						self:enumAdd(n)
						g[n] = nG
					elseif g[n]>nG then
						g[n] = nG
					end
				end
			end
		end
	end,
	__nodeInReach = function(self,blockList,unitBlock,count,rCount,rValue)
		local nList = self.enumList
		local s,e = nList.i,nList.n
		if rValue==nil then
			rCount = (rCount or 0) - 1
			if rCount<=0 then
				rValue = e
			end
		end
		for i = s,e,1 do
			self:__nodeInReachOne(blockList,unitBlock,nList[i],count)
		end
		nList.i = e
		local newCount = count - 1
		if newCount>0 then
			return self:__nodeInReach(blockList,unitBlock,newCount,rCount,rValue)
		else
			return rValue or 0
		end
	end,
	__pushEnumNode = function(self,x,y,w,size)
		if size~=nil and size~=0 and size~=1 and type(size)=="table" then
			for i = 1,#size do
				local v = size[i]
				local c = self:grid2n(x+v[1],y+v[2],w)
				self.c[c] = 1
				self:enumAdd(c)
			end
		else
			local c = self:grid2n(x,y,w)
			self.c[c] = 1
			self:enumAdd(c)
		end
	end,
	setWH = function(self,w,h)
		self.w = w or self.w
		self.h = h or self.h
		return self
	end,
	nodeInReach = function(self,blockList,x,y,r,unitBlock)
		if not(blockList) then
			--_DEBUG_MSG("[LUA]寻路障碍信息错误！")
			return hApi.DoNothin
		end
		self:setWH(blockList.w,blockList.h)
		self:reset()
		self:enumReset()
		self:__pushEnumNode(x,y,self.w)
		self.enumList.i = 1
		self:__nodeInReach(blockList,unitBlock,r)
		return self:enum(0)
	end,
	-----------------------------------------------------
	-- NodeInRange
	-----------------------------------------------------
	nodeInRange = function(self,blockList,x,y,rMin,rMax,unitBlock)
		if not(blockList) then
			--_DEBUG_MSG("[LUA]寻路障碍信息错误！")
			return hApi.DoNothin
		end
		self:setWH(blockList.w,blockList.h)
		self:reset()
		self:enumReset()
		self:__pushEnumNode(x,y,self.w,unitBlock)
		self.enumList.i = 1
		if rMax>0 then
			local v = self:__nodeInReach(nil,nil,rMax,rMin)
			if rMin>0 then
				return self:enum(v)
			else
				return self:enum(0)
			end
		else
			return self:enum(0)
		end
	end,
	-----------------------------------------------------
	-- Way
	-----------------------------------------------------
	--无脑循环遍历(最多1w次)
	checkOpenNode = function(self,blockList,unitBlock,c,e,nodeAvailable)
		--以c作为当前方格进行搜索
		--同时计算G值
		--这里返回具体是几方向寻路
		local x,y = self:n2grid(c,self.w)
		local nearNode = self:getNearNode(c,x,y)
		for i = 1,#nearNode do
			local plusX,plusY,G = unpack(nearNode[i])
			local n
			--检测目标格子{n+偏移}是否可用
			local sus,newX,newY = self:isNodeSafe(x,y,plusX,plusY,self.w,self.h)
			if sus==hVar.RESULT_SUCESS then
				--该格子是合法的格子
				local r = self:grid2n(newX,newY,self.w)
				local nA = 1
				--是否限制仅能在这些格子内查找
				if nodeAvailable~=nil and (nodeAvailable[r]==nil or nodeAvailable[r]==0) then
					nA = 0
				end
				--该格子尚未封闭,且是安全的无阻挡格子
				if nA==1 and self.c[r]==0 and self:checkBlock(r,blockList,unitBlock,newX,newY)==hVar.RESULT_SUCESS then
					n = r
				end
			end
			if n and self.v[n] then
				if self.v[n]==0 then
					self:calV(n,e)			--计算v(h)值
				end
				local g = G + self.g[c]
				--判断从当前方格移动到此格的代价，如果大于本次移动的代价才进行转换
				if self.g[n]==0 or g<=self.g[n] then
					self.g[n] = G + self.g[c]
					self.f[n] = self.g[n] + self.v[n]
					self.p[n] = c				--设置父方格
				end
				if n==e then
					return self.tempO,true
				end
				self:open(n)				--设置开放方格
			end
		end
		self:close(c)						--关闭中心方格
		return self.tempO,false
	end,
	searchByXY = function(self,blockList,unitBlock,x,y,tx,ty)
		self.w = blockList.w or self.w
		self.h = blockList.h or self.h
		local n1 = self:grid2n(x,y,self.w)
		local n2 = self:grid2n(tx,ty,self.w)
		--blockList中包含了w,h参数
		return self:search(blockList,unitBlock,n1,n2,nil)
	end,
	search = function(self,blockList,unitBlock,s,e,nodeAvailable)
		self.count = 0
		if not(blockList) then
			--_DEBUG_MSG("[LUA]寻路障碍信息错误！")
			return false
		end
		self.w = blockList.w or self.w
		self.h = blockList.h or self.h
		if s==e then
			self.s = s
			self.e = e
			self.i = e
			--_DEBUG_MSG("[LUA]寻路成功！无需移动！")
			return true
		end
		local ex,ey = self:n2grid(e,self.w)
		if self:checkBlock(e,blockList,unitBlock,ex,ey)~=hVar.RESULT_SUCESS then
			--_DEBUG_MSG("[LUA]寻路失败！目标不可达！")
			return false
		end
		self.s = s
		self.e = e
		self.count = 10000
		self:reset()
		return self:__search(blockList,unitBlock,s,e,nodeAvailable)
	end,
	__search = function(self,blockList,unitBlock,s,e,nodeAvailable)
		if not(self.c[s] and self.c[e]) then
			return false					--非法寻路网格
		end
		self:open(s)						--开启中心方格
		self.cur = s						--设置当前方格
		self.count = self.count - 1
		--这个t是重用的~！t = {n=0}
		local t,sucess = self:checkOpenNode(blockList,unitBlock,s,e,nodeAvailable)
		if not sucess then
			if (t.n or 0)<=0 then
				--_DEBUG_MSG("[lua]A*寻路失败！")
				return false
			else
				local n = self:getMinF(t)
				if self.count>0 then
					return self:__search(blockList,unitBlock,n,e,nodeAvailable)
				else
					--_DEBUG_MSG("[lua]A*搜索超时！")
					return false
				end
			end
		else
			--_DEBUG_MSG("[LUA]寻路成功！")
			return true
		end
	end,
	__InitWay = function(self)
		self.__InitWay = nil
		local __way = function()
			--返回顺序是e->s
			if self.count<=0 or self.i==-1 then
				return
			else
				if self.i==self.s then
					self.count = 0
				end
				local r = self.i
				self.i = self.p[self.i] or r
				--禁止无限循环
				if r==self.i then
					self.count = 0
				end
				if self.rMode=="xy" then
					return self:n2grid(r,self.w)
				else
					return r
				end
			end
			self.count = self.count - 1
		end
		self.way = function(self,rMode)
			self:inverse()
			self.count = self.w*self.h
			self.i = self.e
			self.rMode = rMode or 0
			return __way
		end
		self.inverse = function(self)
			self.rMode = 0
			self.i = self.e
			self.count = self.w*self.h
			local p
			for n in __way do
				self.p[n],p = (p or -1),n
			end
			self.s,self.e = self.e,self.s
		end
	end,
}

--------------------------------------------------
-- AxFunc
--------------------------------------------------
hApi.InitAxFunc = function(FuncTable,_Ax,_toR,_decR)
	if type(_toR)=="number" then
		FuncTable.xy2grid = function(self,worldX,worldY)
			local d = self.data
			local xPlus = 0
			local gridY = hApi.getint((worldY-d.mapOriginY)/d.gridH)
			if math.mod(gridY,2)==_toR then
				xPlus = -1*hApi.getint(d.gridW/2)
			end
			return hApi.getint((worldX+xPlus-d.mapOriginX)/d.gridW),gridY
		end
		FuncTable.grid2xy = function(self,gridX,gridY,IsLT)
			local d = self.data
			local xPlus = 0
			if math.mod(gridY,2)==_toR then
				xPlus = hApi.getint(d.gridW/2)
			end
			return hApi.getint(d.mapOriginX + gridX*d.gridW + (IsLT~="LT" and d.gridOffsetX or 0))+xPlus,hApi.getint(d.mapOriginY + gridY*d.gridH + (IsLT~="LT" and d.gridOffsetY or 0))
		end
	else
		FuncTable.xy2grid = function(self,worldX,worldY)
			local d = self.data
			local xPlus = 0
			local gridY = hApi.getint((worldY-d.mapOriginY)/d.gridH)
			return hApi.getint((worldX+xPlus-d.mapOriginX)/d.gridW),gridY
		end
		FuncTable.grid2xy = function(self,gridX,gridY,IsLT)
			local d = self.data
			local xPlus = 0
			return hApi.getint(d.mapOriginX + gridX*d.gridW + (IsLT~="LT" and d.gridOffsetX or 0))+xPlus,hApi.getint(d.mapOriginY + gridY*d.gridH + (IsLT~="LT" and d.gridOffsetY or 0))
		end
	end
	if type(_decR)=="number" then
		FuncTable.safeGrid = function(self,gridX,gridY)
			local d = self.data
			local minW = d.borderW
			local minH = d.borderH
			local maxW = d.w-1-d.borderW
			local maxH = d.h-1-d.borderH
			if math.mod(gridY,2)==_decR then
				maxW = maxW - 1
			end
			return math.min(math.max(gridX,minW),maxW),math.min(math.max(gridY,minH),maxH)
		end
	else
		FuncTable.safeGrid = function(self,gridX,gridY)
			local d = self.data
			local minW = d.borderW
			local minH = d.borderH
			local maxW = d.w-1-d.borderW
			local maxH = d.h-1-d.borderH
			return math.min(math.max(gridX,minW),maxW),math.min(math.max(gridY,minH),maxH)
		end
	end

	FuncTable.distanceG = function(self,gridX,gridY,tGridX,tGridY,nVal)
		local d = self.data
		local x,y = FuncTable.safeGrid(self,gridX,gridY)
		if x==gridX and y==gridY then
			local tx,ty = FuncTable.safeGrid(self,tGridX,tGridY)
			if tx==tGridX and ty==tGridY then
				local s = self:grid2n(x,y)
				local e = self:grid2n(tx,ty)
				return _Ax:calV(s,e,nVal)
			end
		end
		return -1
	end

	FuncTable.findwayto = function(self,wayTable,unitBlock,gridX,gridY,tGridX,tGridY,isContiune,isFlyer)
		local wp = wayTable
		if isContiune==1 then
			if wp.n<wp.e then
				startX,startY = self:n2grid(wp[wp.e])
			end
		else
			wp.n = 0
			wp.e = 0
		end
		local wblock = self.data.block
		if isFlyer==1 then
			--空中单位直接移动到目标地点
			local n = _Ax:grid2n(tGridX,tGridY,wblock.w)
			if _Ax:checkBlock(n,wblock,unitBlock,tGridX,tGridY)==hVar.RESULT_SUCESS then
				wp.e = wp.e + 1
				wp[wp.e] = n
			end
		else
			--地面单位移动先寻路
			if _Ax:searchByXY(wblock,unitBlock,gridX,gridY,tGridX,tGridY) then
				for n in _Ax:way() do
					wp.e = wp.e + 1
					wp[wp.e] = n
				end
			end
		end
		return wp.e
	end
	FuncTable.gridinrange = function(self,gridTable,gridX,gridY,rMin,rMax,unitBlock)
		local gt = gridTable
		if rMax==nil then
			rMin,rMax = 1,rMin
		end
		gt.n = 0
		local bk = self.data.block
		for n in _Ax:nodeInRange(self.data.block,gridX,gridY,rMin,rMax,unitBlock) do
			gt.n = gt.n + 1
			local p = gt[gt.n] or {}
			gt[gt.n] = p
			p.x,p.y = self:n2grid(n)
		end
		return gridTable.n
	end
	FuncTable.gridinreach = function(self,gridTable,gridX,gridY,rMax,unitBlock,IsFlyer)
		local gt = gridTable
		if rMax==nil then
			rMin,rMax = 1,rMin
		end
		gt.n = 0
		local wblock = self.data.block
		if IsFlyer==1 then
			local cBlock = unitBlock==0 and 0 or 1
			--飞行单位寻路不太一样
			for n in _Ax:nodeInRange(wblock,gridX,gridY,0,rMax,cBlock) do
				if _Ax:checkBlock(n,wblock,unitBlock)==hVar.RESULT_SUCESS then
					gt.n = gt.n + 1
					local p = gt[gt.n] or {}
					gt[gt.n] = p
					p.x,p.y = self:n2grid(n)
				end
			end
		else
			--地面单位寻路
			for n in _Ax:nodeInReach(wblock,gridX,gridY,rMax,unitBlock) do
				gt.n = gt.n + 1
				local p = gt[gt.n] or {}
				gt[gt.n] = p
				p.x,p.y = self:n2grid(n)
			end
		end
		return gridTable.n
	end
	return _Ax
end

hApi.Ax6calV = function(_toR)
	return function(self,n,e,directV)
		--六角格通用距离预期计算
		directV = directV or 10
		local x,y = self:n2grid(n,self.w)
		local ex,ey = self:n2grid(e,self.w)
		local pex = 0
		local vx,vy = math.abs(ex-x),math.abs(ey-y)
		if vx~=0 and vy~=0 then
			if math.mod(y,2)==_toR then
				if ex>x then
					pex = -1*math.min(vx,(vy+math.mod(vy,2))/2)
				else
					pex = -1*math.min(vx,(vy-math.mod(vy,2))/2)
				end
			else
				if ex<x then
					pex = -1*math.min(vx,(vy+math.mod(vy,2))/2)
				else
					pex = -1*math.min(vx,(vy-math.mod(vy,2))/2)
				end
			end
		end
		local v = (vx+vy+pex)*directV
		self.v[n] = v
		return v
	end
end

hApi.Ax6isNodeSafe = function(_decR)
	return function(self,gridX,gridY,plusX,plusY,nW,nH)
		local maxW = nW-1
		local maxH = nH-1
		local x = gridX + plusX
		local y = gridY + plusY
		if math.mod(y,2)==_decR then
			maxW = maxW - 1
		end
		if (x>=0 and x<=maxW) and (y>=0 and y<=maxH) then
			return hVar.RESULT_SUCESS,x,y
		end
		return hVar.RESULT_FAIL,-1,0
	end
end

------------------
-- obj管理器
hGlobal.O = {o={},i={},
	del=function(t,k,rCode)
		local o = rawget(t,"o")
		local i = rawget(t,"i")
		if o[k] then
			if o[k].ID~=0 and o[k].__ID==i[k] and o[k].ID~=0 then
				if rCode then
					rCode(o[k])
				end
				o[k]:del()
			end
			o[k] = nil
			i[k] = nil
		end
	end,
	replace = function(t,k,v,rCode)
		local o = rawget(t,"o")
		local i = rawget(t,"i")
		if o[k] then
			--完全相同啊?
			if o[k]==v then
				i[k] = v.__ID
				return v
			else
				t:del(k,rCode)
			end
		end
		if v then
			o[k] = v
			i[k] = v.__ID
		else
			o[k] = nil
			i[k] = nil
		end
		return v
	end,
	get = function(t,k)
		local o = rawget(t,"o")
		local i = rawget(t,"i")
		if o[k] and o[k].__ID==i[k] and o[k].__ID~=0 then
			return o[k]
		end
	end,
}
setmetatable(hGlobal.O,{
	__index = function(t,k)
		return t:get(k)
	end,
	__newindex = function(t,k,v)
		return t:replace(k,v)
	end,
})

------------------------------
--单位升级相关函数
------------------------------
do
	--判断单位是否可以被升级
	hApi.CheckIfArmyHaveUpgrade = function(nUnitId)
		local tabU = hVar.tab_unit[nUnitId]
		if tabU==nil then
		elseif tabU.upgrade then
			return 1
		elseif tabU.upgradeTo then
			return 1
		end
		return 0
	end

	--获取单位的升级id
	hApi.GetArmyUpgradeListById = function(nUnitId)
		local tIDList = {}
		local tabU = hVar.tab_unit[nUnitId]
		if tabU~=nil then
			if tabU.upgrade then
				tIDList[#tIDList+1] = tabU.upgrade[1]
			end
			if tabU.upgradeTo then
				for i = 1,#tabU.upgradeTo do
					tIDList[#tIDList+1] = tabU.upgradeTo[i][1]
				end
			end
		end
		return tIDList
	end

	local __CODE__CheckIfHeroCanUpgradeUnit = function(oHero,nUpgradeId)
		local tabU = hVar.tab_unit[nUpgradeId]
		if tabU and type(tabU.require)=="table" and (tabU.require.skillID or 0)~=0 then
			local nSkillId = tabU.require.skillID
			if hApi.GetHeroTalentLv(oHero,nSkillId)>0 then
				--如果拥有该技能所需的天赋技能
				return nUpgradeId
			else
				--判断是否拥有该技能所需的道具
				local eq = oHero.data.equipment
				for i = 1,#eq do
					--changed by pangyong 2015/4/1
					if eq[i]~=0 and hVar.tab_item[eq[i][1]]		and				--eq[i]~=0: 说明身体某个部位有装备
					   hVar.tab_item[eq[i][1]].skillId == nSkillId	and				--主公身上的这个装备满足升级兵的需求
					   hApi.CheckItemAvailable( eq[i]) == 1		then				--主公身上的这个装备是有效的
						return nUpgradeId
					end
				end
			end
		end
		return 0
	end
	local __CODE__CheckIfUnitCanUpgrade = function(nUnitId,nUpgradeId)
		local tabU = hVar.tab_unit[nUnitId]
		if tabU==nil then
		elseif tabU.upgrade and tabU.upgrade[1]==nUpgradeId then
			return 1
		elseif tabU.upgradeTo then
			for i = 1,#tabU.upgradeTo do
				if tabU.upgradeTo[i][1]==nUpgradeId then
					return 1
				end
			end
		end
		return 0
	end
	-- 判断单位能否被英雄升级
	hApi.CheckIfCanUpgradeArmyByHero = function(oHero,nUnitId,nUpgradeId)
		if oHero==nil then
		elseif nUpgradeId~=nil then
			if __CODE__CheckIfUnitCanUpgrade(nUnitId,nUpgradeId)==1 then
				return __CODE__CheckIfHeroCanUpgradeUnit(oHero,nUpgradeId)
			end
		else
			local tabU = hVar.tab_unit[nUnitId]
			if tabU==nil then
			elseif tabU.upgrade then
				return __CODE__CheckIfHeroCanUpgradeUnit(oHero,tabU.upgrade[1])
			elseif tabU.upgradeTo then
				for i = 1,#tabU.upgradeTo do
					local nId = tabU.upgradeTo[i][1]
					if __CODE__CheckIfHeroCanUpgradeUnit(oHero,nId)~=0 then
						return nId
					end
				end
			end
		end
		return 0
	end
	--判断单位能否被主城升级
	hApi.CheckIfCanUpgradeArmyByTown = function(oTown,nUnitId,nUpgradeId)
		local tabU = hVar.tab_unit[nUnitId]
		if oTown==nil then
		elseif nUpgradeId~=nil then
			if __CODE__CheckIfUnitCanUpgrade(nUnitId,nUpgradeId)==1 then
				local d = oTown.data
				for i = 1,#d.townData do
					local v = d.townData[i]
					if type(v)=="table" and (d.upgradeState[v.indexOfCreate] or 0)>0 and type(v.hireList)=="table" then
						for n = 1,#v.hireList do
							local nId = v.hireList[n][1]
							if nId==nUpgradeId then
								return nId
							end
						end
					end
				end
			end
		else
			local d = oTown.data
			for i = 1,#d.townData do
				local v = d.townData[i]
				if type(v)=="table" and (d.upgradeState[v.indexOfCreate] or 0)>0 and type(v.hireList)=="table" then
					for n = 1,#v.hireList do
						local nId = v.hireList[n][1]
						if __CODE__CheckIfUnitCanUpgrade(nUnitId,nId)==1 then
							return nId
						end
					end
				end
			end
		end
		return 0
	end
end

--输入 uniqueID 返回当前世界的 unit实例
hApi.UniqueID2UnitByWorld = function(uniqueID)
	local world = hGlobal.WORLD.LastWorldMap
	if world then
		local unit,_  = world:tgrid2unit(uniqueID)
		if unit then
			return unit
		end
	end
	return nil
end

hApi.OpenMap = function(map_name)
	local mapPath = "data/map/"..tostring(map_name)..".dat"
	if not(hApi.FileExists(mapPath)) then
		print("地图文件["..mapPath.."]不存在，无法加载！")
	else
		if hGlobal.WORLD.LastWorldMap then
			hGlobal.WORLD.LastWorldMap:del()
			hGlobal.WORLD.LastWorldMap = nil
		end
		xlScene_Switch(g_loading)
		xlScene_LoadMap(g_world,map_name)
	end
end

--保存游戏选项
hApi.SaveGameOptions = function()
	local tSaveOptions = {}
	for k in pairs(hVar.USER_OPTIONS)do
		tSaveOptions[k] = hVar.OPTIONS[k]
	end
	local rTab = hApi.SaveTable(tSaveOptions,{"g_GAME_OPTIONS"})
	if type(g_localfilepath)=="string" then
		xlSaveGameData(g_localfilepath.."options.cfg",table.concat(rTab))
	end
end

--读取游戏选项
hApi.LoadGameOptions = function()
	g_GAME_OPTIONS = nil
	if type(g_localfilepath)=="string" and hApi.FileExists(g_localfilepath.."options.cfg","full") then
		xlLoadGameData(g_localfilepath.."options.cfg")
		if type(g_GAME_OPTIONS)=="table" then
			for k,v in pairs(hVar.OPTIONS)do
				if type(g_GAME_OPTIONS[k])=="number" then
					hVar.OPTIONS[k] = g_GAME_OPTIONS[k]
				end
			end
		end
	end
end

--计算直线方程
hApi.CalLineParam = function(cx,cy,tx,ty,rTab)
	local k,p,c,m
	if tx==cx then
		k = 1
		p = 0
		c = -1*cx
		m = 1
	elseif ty==cy then
		k = 0
		p = 1
		c = -1*cy
		m = 1
	else
		k = (ty-cy)/(tx-cx)
		p = -1
		c = cy-k*cx
		m = math.sqrt(k^2+1)
	end
	if rTab then
		rTab.k = k
		rTab.p = p
		rTab.c = c
		rTab.m = m
	end
	return k,p,c,m,rTab
end

hApi.GetXYByRadial = function(cx,cy,tx,ty,r)
	local h,w
	if cx==tx and cy==ty then
		h = 0
		w = 0
	elseif tx==cx then
		if ty>cy then
			h = 1
			w = 0
		else
			h = -1
			w = 0
		end
	elseif ty==cy then
		if tx>cx then
			h = 0
			w = 1
		else
			h = 0
			w = -1
		end
	else
		local a = (ty-cy)
		local b = (tx-cx)
		local c = math.sqrt(a^2+b^2)
		h = a/c
		w = b/c
	end
	return cx+r*w,cy+r*h
end

local __uBlock = {{0,0}}
local __w,__sus,__cx,__cy,__ux,__uy
local __TempCode = function(gx,gy,tempI,rGrid)
	if __sus==0 and tempI[gx.."|"..gy] then
		__sus = 1
		if __ux and __uy then
			rGrid[#rGrid+1] = {x=__cx,y=__cy,move=__w:distanceG(__cx,__cx,__ux,__uy,1)}
		else
			rGrid[#rGrid+1] = {x=__cx,y=__cy,move=0}
		end
	end
end
hApi.GetCrossGrid = function(oWorld,uBlock,mGrid,tGrid,rGrid,oX,oY)
	rGrid = rGrid or {}
	local tempI = {}
	for i = 1,#tGrid do
		local x,y = tGrid[i].x,tGrid[i].y
		tempI[x.."|"..y] = i
	end
	for i = 1,#mGrid do
		local cx,cy = mGrid[i].x,mGrid[i].y
		__w,__sus,__cx,__cy,__ux,__uy = oWorld,0,cx,cy,oX,oY
		hApi.enumNearGrid(cx,cy,uBlock,__TempCode,tempI,rGrid)
	end
	return rGrid
end

hApi.GetChargeGrid = function(oUnit,skillId,IsCalculateMove)
	local moveR = oUnit.attr.move
	if hVar.tab_skill[skillId] and hVar.tab_skill[skillId].range then
		_,moveR = unpack(hVar.tab_skill[skillId].range)
		local tabU = hVar.tab_unit[oUnit.data.id]
		if tabU and tabU.attr then
			moveR = moveR + math.max(0,(oUnit.attr.move - (tabU.attr.move or 0)))
		end
	end
	local tTarget = {}
	local w = oUnit:getworld()
	w:enumunit(function(u)
		if u.data.IsDead~=1 and (u.data.type==hVar.UNIT_TYPE.UNIT or u.data.type==hVar.UNIT_TYPE.HERO) then
			tTarget[#tTarget+1] = u
		end
	end)
	for i = 1,#tTarget do
		w:removeblockU(tTarget[i])
	end
	local mGrid = oUnit:getmovegrid(moveR)
	for i = 1,#tTarget do
		w:addblockU(tTarget[i])
	end
	local mGridF = oUnit:getmovegrid(moveR,1)
	if IsCalculateMove==1 then
		return hApi.GetCrossGrid(w,1,mGrid,mGridF,{},oUnit.data.gridX,oUnit.data.gridY)
	else
		return hApi.GetCrossGrid(w,1,mGrid,mGridF,{})
	end
end

local __MapValueByDifficulty = hVar.MAP_VALUE_BY_DIFFICULTY
--获得地图难度参数，并返回相应的数值
hApi.GetMapValueByDifficulty = function(oWorld,vKey)
	local lv = oWorld.data.MapDifficulty
	if lv>=1 and lv<=6 and __MapValueByDifficulty[vKey] then
		return __MapValueByDifficulty[vKey][lv] or 1
	end
	return 1
	--if vKey=="AI_Garrision" then
		----获得AI英雄生长比率
	--elseif vKey=="AI_Occupy" then
		----占领城池后，驻守的生物比率
	--elseif vKey=="NpcBorn" then
		----获得电脑控制单位初始生物比率
	--elseif vKey=="RandomNpc" then
		----随机电脑控制的单位比率
	--elseif vKey=="CreepGarrision" then
		----获得野外生物生长比率
	--elseif vKey=="CreepBorn" then
		----获得野外生物初始生物比率
	--elseif vKey=="RandomCreep" then
		----随机野外生物比率
	--end
end

--单位是否会随着地图难度调整带兵数量
hApi.IsUnitManagedByAI = function(oUnit)
	--return oUnit.data.owner~=1
	if oUnit.data.owner==1 then
		return 0
	elseif oUnit.data.owner==8 or oUnit.data.owner==9 then
		--8号和9号玩家是友军
		return -1
	else
		return 1
	end
	return 0
end

--根据玩家战斗力计算当前战斗等级
hApi.GetLvByPower = function(power)
	local lv = 1
	for i = 1,#hVar.PowerLvList do
		if hVar.PowerLvList[i][1] <= power and hVar.PowerLvList[i][2] > power then
			lv = i
			break
		elseif hVar.PowerLvList[i][1] <= power and hVar.PowerLvList[i][2] == -1 then
			lv = 15
			break
		end
	end
	return lv
end

--设置 shader 参数1 ccsprite , 参数 2 shader 类型名 
hApi.AddShader = function(s,fileName)
	--参数合法性判断
	if s and type(s) == "userdata" then
		if CCGLProgram then
			s:setShaderProgram(hApi.getShader(fileName))
			return
		end
	end
	print("AddShader erro")
end

--字符串转化为一维表
-- 参数:
-- 	strings: 字符串
-- 	separateType: 分隔符号
-- 	bInteger: 一维表的每个元素是否为整数值(默认值: false)
hApi.String2Type = function(strings, separateType, bInteger)
	local ret = {} --返回值
	
	--print("hApi.String2Type:".. tostring(strings))
	if (#strings > 0) then
		--如果第一个字符是分隔符, 那么删掉该分隔符
		if (strings[1] == separateType) then
			strings = string.sub(strings, 2, #strings)
		end
		
		--如果最后一个字符不是分隔符, 那么添加该分隔符
		if (strings[#strings] ~= separateType) then
			strings = ("%s%s"):format(strings, separateType)
		end
		
		--开始循环处理
		local buff = strings
		while true do
			local pos = string.find(buff, separateType)
			if pos and (pos > 0) then
				--找到分隔符
				local szValue = string.sub(buff, 1, pos - 1) --元素
				local value = szValue
				if bInteger then
					value = tonumber(szValue) or 0
				end
				
				table.insert(ret, value)
				buff = string.sub(buff, pos + 1, #buff)
			else
				--找不到分隔符了
				break
			end
		end
	end
	
	return ret
end

--geyachao: 检测圆是否和矩形相交
--参数: rx, ry, radius 圆心位置和半径
--参数: cx, cy, width, height 矩形中心点位置和宽高
--返回值： true / false
function hApi.CircleIntersectRect(rx, ry, radius, cx, cy, width, height)
	--检测矩形是否在圆内
	--取矩形的边上8个点
	--矩形点1
	local rectX1 = cx - width / 2
	local rectY1 = cy - height / 2
	--矩形点2
	local rectX2 = cx - width / 2
	local rectY2 = cy
	--矩形点3
	local rectX3 = cx - width / 2
	local rectY3 = cy + height / 2
	--矩形点4
	local rectX4 = cx
	local rectY4 = cy - height / 2
	--矩形点5
	local rectX5 = cx
	local rectY5 = cy + height / 2
	--矩形点6
	local rectX6 = cx + width / 2
	local rectY6 = cy - height / 2
	--矩形点7
	local rectX7 = cx + width / 2
	local rectY7 = cy
	--矩形点8
	local rectX8 = cx + width / 2
	local rectY8 = cy + height / 2
	
	--依次检测矩形每个点是否在圆内
	local dx1 = rectX1 - rx
	local dy1 = rectY1 - ry
	local dx2 = rectX2 - rx
	local dy2 = rectY2 - ry
	local dx3 = rectX3 - rx
	local dy3 = rectY3 - ry
	local dx4 = rectX4 - rx
	local dy4 = rectY4 - ry
	local dx5 = rectX5 - rx
	local dy5 = rectY5 - ry
	local dx6 = rectX6 - rx
	local dy6 = rectY6 - ry
	local dx7 = rectX7 - rx
	local dy7 = rectY7 - ry
	local dx8 = rectX8 - rx
	local dy8 = rectY8 - ry
	
	local dis1 = math.sqrt(dx1 * dx1 + dy1 * dy1)
	local dis2 = math.sqrt(dx2 * dx2 + dy2 * dy2)
	local dis3 = math.sqrt(dx3 * dx3 + dy3 * dy3)
	local dis4 = math.sqrt(dx4 * dx4 + dy4 * dy4)
	local dis5 = math.sqrt(dx5 * dx5 + dy5 * dy5)
	local dis6 = math.sqrt(dx6 * dx6 + dy6 * dy6)
	local dis7 = math.sqrt(dx7 * dx7 + dy7 * dy7)
	local dis8 = math.sqrt(dx8 * dx8 + dy8 * dy8)
	
	local intersect1 = (dis1 <= radius)
	local intersect2 = (dis2 <= radius)
	local intersect3 = (dis3 <= radius)
	local intersect4 = (dis4 <= radius)
	local intersect5 = (dis5 <= radius)
	local intersect6 = (dis6 <= radius)
	local intersect7 = (dis7 <= radius)
	local intersect8 = (dis8 <= radius)
	
	--检测圆心是否在矩形内
	--取圆的5个点
	--圆点1
	local rax1 = rx
	local ray1 = ry
	
	--圆点2
	local rax2 = rx - radius
	local ray2 = ry
	
	--圆点3
	local rax3 = rx + radius
	local ray3 = ry
	
	--圆点4
	local rax4 = rx
	local ray4 = ry - radius
	
	--圆点5
	local rax5 = rx
	local ray5 = ry + radius
	
	--矩形的边界
	local rectXL = cx - width / 2
	local rectXR = cx + width / 2
	local rectYL = cy - height / 2
	local rectYR = cy + height / 2
	
	local intersectR1 = (rax1 >= rectXL) and (rax1 <= rectXR) and (ray1 >= rectYL) and (ray1 <= rectYR)
	local intersectR2 = (rax2 >= rectXL) and (rax2 <= rectXR) and (ray2 >= rectYL) and (ray2 <= rectYR)
	local intersectR3 = (rax3 >= rectXL) and (rax3 <= rectXR) and (ray3 >= rectYL) and (ray3 <= rectYR)
	local intersectR4 = (rax4 >= rectXL) and (rax4 <= rectXR) and (ray4 >= rectYL) and (ray4 <= rectYR)
	local intersectR5 = (rax5 >= rectXL) and (rax5 <= rectXR) and (ray5 >= rectYL) and (ray5 <= rectYR)
	
	return (intersect1 or intersect2 or intersect3 or intersect4 or intersect5 or intersect6 or intersect7 or intersect8 or intersectR1 or intersectR2 or intersectR3 or intersectR4 or intersectR5)
end

--geyachao: 检测两个不规则的凸四边形是否相交
--
--参考: http://www.cnblogs.com/Kurodo/archive/2012/08/08/2628688.html
--
--其中需要的参数为矩形的四个点坐标（一共八个点），矩形四个点坐标要求按顺序（顺时针或者逆时针都可以）传入
--参数: A1, A2, A3, A4 矩形A的四个顶点
--参数: B1, B2, B3, B4 矩形B的四个顶点
--返回值： true / false
local _AX, _AY, _BX, _BY = {}, {}, {}, {}
local _AAAA = {}
local _BBBB = {}
function hApi.RectIntersectRect(A1, A2, A3, A4, B1, B2, B3, B4)
	
	--[[
	--初步筛选: 如果B的四个点都在A的外包围盒外，那么不需要继续判断
	local AX_min = math.min(A1.X, A2.X, A3.X, A4.X)
	local AX_max = math.max(A1.X, A2.X, A3.X, A4.X)
	local AY_min = math.min(A1.Y, A2.Y, A3.Y, A4.Y)
	local AY_max = math.max(A1.Y, A2.Y, A3.Y, A4.Y)
	if ((B1.X > AX_max) or (B1.X < AX_min)) and ((B2.X > AX_max) or (B2.X < AX_min)) and ((B3.X > AX_max) or (B3.X < AX_min)) and ((B4.X > AX_max) or (B4.X < AX_min))
	and ((B1.Y > AY_max) or (B1.Y < AY_min)) and ((B2.Y > AY_max) or (B2.Y < AY_min)) and ((B3.Y > AY_max) or (B3.Y < AY_min)) and ((B4.Y > AY_max) or (B4.Y < AY_min)) then
		--print("hApi.RectIntersectRect", "提前结束", os.clock())
		return false
	end
	]]
	
	--local _AX, _AY, _BX, _BY = {}, {}, {}, {}
	_AX.X = A1.X - A2.X
	_AX.Y = A1.Y - A2.Y
	_AY.X = A1.X - A4.X
	_AY.Y = A1.Y - A4.Y
	_BX.X = B1.X - B2.X
	_BX.Y = B1.Y - B2.Y
	_BY.X = B1.X - B3.X
	_BY.Y = B1.Y - B3.Y
	
	_AAAA[1] = A1
	_AAAA[2] = A2
	_AAAA[3] = A3
	_AAAA[4] = A4
	
	_BBBB[1] = B1
	_BBBB[2] = B2
	_BBBB[3] = B3
	_BBBB[4] = B4
	
	--对于AX上:
	if (hApi.RectIntersectRect_Tmp(_AX, _AAAA, _BBBB)) then
		return false
	end
	
	if (hApi.RectIntersectRect_Tmp(_AY, _AAAA, _BBBB)) then
		return false
	end
	
	if (hApi.RectIntersectRect_Tmp(_BX, _AAAA, _BBBB)) then
		return false
	end
	
	if (hApi.RectIntersectRect_Tmp(_BY, _AAAA, _BBBB)) then
		return false
	end
		
	return true
end

local _v = {}  
local _vv = {}
function hApi.RectIntersectRect_Tmp(IS, A, B)
	--local _v = {}
	for i = 1, 4, 1 do
		--local tmp = (IS.X * A[i].X + IS.Y * A[i].Y) / (IS.X * IS.X + IS.Y * IS.Y)
		--_v[i] = tmp * IS.X * IS.X + tmp * IS.Y * IS.Y
		local tmp = (IS.X * A[i].X + IS.Y * A[i].Y)
		_v[i] = math.floor(tmp * 100) / 100 --保留2位有效数字，用于同步
	end
	
	--local _vv = {}
	for i = 1, 4, 1 do
		--local tmp = (IS.X * B[i].X + IS.Y * B[i].Y) / (IS.X * IS.X + IS.Y * IS.Y)
		--_vv[i] = tmp * IS.X * IS.X + tmp * IS.Y * IS.Y
		local tmp = (IS.X * B[i].X + IS.Y * B[i].Y)
		_vv[i] = math.floor(tmp * 100) / 100 --保留2位有效数字，用于同步
	end
	
	if (math.max(math.max(_v[1], _v[2]), math.max(_v[3], _v[4])) > math.min(math.min(_vv[1], _vv[2]),math.min(_vv[3], _vv[4])) and math.min(math.min(_v[1], _v[2]), math.min(_v[3], _v[4])) < math.max(math.max(_vv[1], _vv[2]), math.max(_vv[3], _vv[4]))) then
		return false --表示暂时不知道是否碰撞
	else
		return true --表示知道未碰撞
	end
end

--停止角色所有正在释放的技能
function hApi.StopSkillCast(oUnit)
	--print("hApi.StopSkillCast", oUnit.data.name, debug.traceback())
	--依次遍历所有的action（非buff），删除施法者为角色的action
	hClass.action:enum(function(oAction)
		if (oAction.data.IsBuff == 0) then --非buff（是buff的话，这里存的是技能表"BecomeBuff"的第二个参数）
			local u = oAction.data.unit
			if (u == oUnit) then
				if (oAction.data.IsInterrupt == 1) then --会被打断
					oAction.data.maxtime = 0 --标记最大生存时间为0
					--print("停止角色所有正在释放的技能", oAction.data.skillId, u.data.name, oAction.data.IsBuff)
				end
			end
		end
	end)
end

--geyachao: TD测试单位开始移动
local UnitBeinMove_TD = function(oUnit, to_x, to_y, bNoPlayMoveAmin, move_speed, paramFacing, bNoChangeFacing, callbackSkillId, callbackSkillUnit)
	--设置角色朝向
	local world = oUnit:getworld()
	local node = oUnit.handle._n
	--local ox, oy = node:getPosition() --英雄的位置
	--oy = -oy --屏幕坐标系！！！！！！！！！！！！！！！
	local ox, oy = hApi.chaGetPos(oUnit.handle) --英雄的位置
	local facing = GetFaceAngle (ox, oy, to_x, to_y) --角色的朝向(角度制)
	if paramFacing then
		facing = paramFacing
	end
	
	if (not bNoChangeFacing) then
		if (oUnit.data.type ~= hVar.UNIT_TYPE.BUILDING) then --建筑、图腾，移动不转向
			if (move_speed == nil) or (move_speed == oUnit:GetMoveSpeed()) then --击退不变方向
				hApi.ChaSetFacing(oUnit.handle, facing)
				oUnit.data.facing = facing
			end
			
			--tank: 同步更新绑定的单位的位置（炮口）
			if (oUnit.data.bind_unit ~= 0) then
				if (oUnit.data.bind_unit:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
					hApi.ChaSetFacing(oUnit.data.bind_unit.handle, facing)
					oUnit.data.bind_unit.data.facing = facing
				end
			end
			
			--tank: 同步更新绑定的单位的位置（大灯光照）
			if (oUnit.data.bind_light ~= 0) then
				--if (oUnit.data.bind_light:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
					hApi.ChaSetFacing(oUnit.data.bind_light.handle, facing)
					oUnit.data.bind_light.data.facing = facing
				--end
			end
			
			--tank: 同步更新绑定的单位的位置（大灯轮子）
			if (oUnit.data.bind_wheel ~= 0) then
				--if (oUnit.data.bind_wheel:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
					hApi.ChaSetFacing(oUnit.data.bind_wheel.handle, facing)
					oUnit.data.bind_wheel.data.facing = facing
				--end
			end
			
			--tank: 同步更新绑定的单位的位置（大灯影子）
			if (oUnit.data.bind_shadow ~= 0) then
				--if (oUnit.data.bind_shadow:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
					hApi.ChaSetFacing(oUnit.data.bind_shadow.handle, facing)
					oUnit.data.bind_shadow.data.facing = facing
				--end
			end
			
			--tank: 同步更新绑定的单位的位置（大灯能量圈）
			if (oUnit.data.bind_energy ~= 0) then
				--if (oUnit.data.bind_energy:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
					hApi.ChaSetFacing(oUnit.data.bind_energy.handle, facing)
					oUnit.data.bind_energy.data.facing = facing
				--end
			end
			
			--tank: 同步更新绑定的单位的位置（机枪）
			if (oUnit.data.bind_weapon ~= 0) then
				--if (oUnit.data.bind_weapon:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
				if (world.data.weapon_attack_state == 0) then
					if ((world:gametime() - oUnit.data.bind_weapon.attr.last_attack_time) > hVar.ROLE_TANKWEAPON_SYNCTIME) then --机枪1秒后才和车身同步
						hApi.ChaSetFacing(oUnit.data.bind_weapon.handle, facing)
						oUnit.data.bind_weapon.data.facing = facing
					end
				elseif (world.data.weapon_attack_state > 0) then
					if (oUnit.data.bind_weapon.data.lockTarget == 0) then --未锁定目标攻击
						hApi.ChaSetFacing(oUnit.data.bind_weapon.handle, facing)
						oUnit.data.bind_weapon.data.facing = facing
					end
				end
			end
			
			--tank: 同步更新绑定的单位的位置（大灯）
			if (oUnit.data.bind_lamp ~= 0) then
				--if (oUnit.data.bind_lamp:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
					hApi.ChaSetFacing(oUnit.data.bind_lamp.handle, facing)
					oUnit.data.bind_lamp.data.facing = facing
				--end
			end
		end
	end
	--print(oUnit.data.name, "转向2", facing)
	--if (oUnit.data.type == 2) then
	--	print("hApi.UnitBeinMove_TD", oUnit.data.name)
	--end
	
	--播放移动动作
	--print("UnitBeinMove_TD", oUnit.data.name, "播放移动动作", oUnit.handle.UnitInMove)
	if (oUnit.handle.UnitInMove ~= 1) then
		if (not bNoPlayMoveAmin) then
			if (oUnit.attr.isInPoseAttack ~= 1) then --是否在播放攻击动作（摇杆时不播走路动作）
				oUnit:setanimation("walk")
			end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（炮口）
			--if (oUnit.data.bind_unit ~= 0) then
			--	oUnit.data.bind_unit:setanimation("walk")
			--end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（大灯光照）
			if (oUnit.data.bind_light ~= 0) then
				oUnit.data.bind_light:setanimation("walk")
			end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（大灯轮子）
			if (oUnit.data.bind_wheel ~= 0) then
				oUnit.data.bind_wheel:setanimation("walk")
			end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（大灯影子）
			if (oUnit.data.bind_shadow ~= 0) then
				oUnit.data.bind_shadow:setanimation("walk")
			end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（大灯能量圈）
			if (oUnit.data.bind_energy ~= 0) then
				oUnit.data.bind_energy:setanimation("walk")
			end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（大灯）
			if (oUnit.data.bind_lamp ~= 0) then
				oUnit.data.bind_lamp:setanimation("walk")
			end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（机枪）
			--if (oUnit.data.bind_weapon ~= 0) then
			--	oUnit.data.bind_weapon:setanimation("walk")
			--end
		end
		oUnit.handle.UnitInMove = 1
		
		--geyachao: 同步日志: 开始移动
		if (hVar.IS_SYNC_LOG == 1) then
			local msg = "beginMove: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC() .. ",to_x=" .. tostring(to_x) .. ",to_y=" .. tostring(to_y) .. ",UnitInMove=" .. "1" .. ",bNoPlayMoveAmin=" .. tostring(bNoPlayMoveAmin)
			hApi.SyncLog(msg)
		end
		
		--geyachao: 非同步日志: 开始移动
		if (hVar.IS_ASYNC_LOG == 1) then
			--local msg = "beginMove: oUnit=" .. oUnit.data.name .. ",__ID=" .. oUnit:getworldC() .. ",to_x=" .. tostring(to_x) .. ",to_y=" .. tostring(to_y) .. ",UnitInMove=" .. "1" .. ",bNoPlayMoveAmin=" .. tostring(bNoPlayMoveAmin) .. "\n" .. debug.traceback()
			local msg = "beginMove: oUnit=" .. oUnit.data.name .. ",u_ID=" .. oUnit:getworldC() .. ",to_x=" .. tostring(to_x) .. ",to_y=" .. tostring(to_y) .. ",UnitInMove=" .. "1" .. ",bNoPlayMoveAmin=" .. tostring(bNoPlayMoveAmin)
			hApi.AsyncLog(msg)
		end
	end
end

--geyachao: TD测试，角色移动到达
--参数 bIsNoStop: 本次不需要停止动作，传入 true
local tmp_UnitArrive_TD = function(oUnit, bIsNoStop)
	--英雄播停止动作
	if (not bIsNoStop) then
		if (oUnit.handle.UnitInMove ~= 0) then
			if (oUnit.attr.isInPoseAttack ~= 1) then --是否在播放攻击动作（摇杆时不播走路动作）
				oUnit:setanimation("stand")
			end
			
			oUnit.handle.UnitInMove = 0
			--print("UnitInMove      dddddd")
			
			--tank_test:测试用: 同步更新绑定的单位的位置（炮口）
			--if (oUnit.data.bind_unit ~= 0) then
			--	oUnit.data.bind_unit:setanimation("stand")
			--	oUnit.data.bind_unit.handle.UnitInMove = 0
			--end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（大灯光照）
			if (oUnit.data.bind_light ~= 0) then
				oUnit.data.bind_light:setanimation("stand")
				oUnit.data.bind_light.handle.UnitInMove = 0
			end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（大灯轮子）
			if (oUnit.data.bind_wheel ~= 0) then
				oUnit.data.bind_wheel:setanimation("stand")
				oUnit.data.bind_wheel.handle.UnitInMove = 0
			end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（大灯影子）
			if (oUnit.data.bind_shadow ~= 0) then
				oUnit.data.bind_shadow:setanimation("stand")
				oUnit.data.bind_shadow.handle.UnitInMove = 0
			end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（大灯能量圈）
			if (oUnit.data.bind_energy ~= 0) then
				oUnit.data.bind_energy:setanimation("stand")
				oUnit.data.bind_energy.handle.UnitInMove = 0
			end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（大灯）
			if (oUnit.data.bind_lamp ~= 0) then
				oUnit.data.bind_lamp:setanimation("stand")
				oUnit.data.bind_lamp.handle.UnitInMove = 0
			end
			
			--tank_test:测试用: 同步更新绑定的单位的位置（机枪）
			--if (oUnit.data.bind_weapon ~= 0) then
			--	oUnit.data.bind_weapon:setanimation("stand")
			--	oUnit.data.bind_weapon.handle.UnitInMove = 0
			--end
		end
	else
		oUnit.handle.UnitInMove = 0
	end
	
	--geyachao: 同步日志: 停止移动
	if (hVar.IS_SYNC_LOG == 1) then
		local msg = "stopMove: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC() .. ",to_x=" .. tostring(to_x) .. ",to_y=" .. tostring(to_y) .. ",UnitInMove=" .. "0" .. ",bIsNoStop=" .. tostring(bIsNoStop)
		hApi.SyncLog(msg)
	end
	
	--geyachao: 非同步日志: 停止移动
	if (hVar.IS_ASYNC_LOG == 1) then
		--local msg = "stopMove: oUnit=" .. oUnit.data.name .. ",u_ID=" .. oUnit:getworldC() .. ",to_x=" .. tostring(to_x) .. ",to_y=" .. tostring(to_y) .. ",UnitInMove=" .. "0" .. ",bIsNoStop=" .. tostring(bIsNoStop) .. "\n" .. debug.traceback()
		local msg = "stopMove: oUnit=" .. oUnit.data.name .. ",u_ID=" .. oUnit:getworldC() .. ",to_x=" .. tostring(to_x) .. ",to_y=" .. tostring(to_y) .. ",UnitInMove=" .. "0" .. ",bIsNoStop=" .. tostring(bIsNoStop)
		hApi.AsyncLog(msg)
	end
end

--获得点（x1, y1）->（x2, y2）的角度
--按照屏幕坐标系（逆时针）
--取值：[0, 360)
function GetLineAngle(x1, y1, x2, y2)
	local dx = x2 - x1
	local dy = y2 - y1
	
	local pa = 0
	
	local MINI_VAL = 0.01 --极小值
	if (math.abs(dx) >= MINI_VAL) then
		pa = math.atan(dy / dx)
	else --如果dx过小，认为是垂直的
		if (dy > 0) then
			pa = math.pi * 0.5
		else
			pa = math.pi * 1.5
		end
	end
	
	pa = math.floor(pa * 100) / 100 --保留2位有效数字，用于同步
	local angle = 180.0 * pa / math.pi
	angle = math.floor(angle * 100) / 100 --保留2位有效数字，用于同步
	--angle = angle + 90
	
	if (math.abs(dx) >= MINI_VAL) then --垂直的除外
		if (dx < 0) then
			angle = angle + 180
		end
	end
	
	--0~360度
	while (angle < 0) do
		angle = angle + 360
	end
	
	while (angle > 360) do
		angle = angle - 360
	end
	
	return angle
end

--获得点（x1, y1）->（x2, y2）的转向角度
--按照数学坐标系（逆时针）
--取值：[0, 360)
function GetFaceAngle(x1, y1, x2, y2)
	local dx = x2 - x1
	local dy = y2 - y1
	
	local pa = 0
	local MINI_VAL = 0.01 --极小值
	if (math.abs(dx) >= MINI_VAL) then
		pa = -math.atan(dy / dx)
	else --如果dx过小，认为是垂直的
		if (dy > 0) then
			pa = math.pi * 1.5
		else
			pa = math.pi * 0.5
		end
	end
	pa = math.floor(pa * 100) / 100 --保留2位有效数字，用于同步
	local angle = 180.0 * pa / math.pi
	angle = math.floor(angle * 100) / 100 --保留2位有效数字，用于同步
	--angle = angle + 90
	
	if (math.abs(dx) >= MINI_VAL) then --垂直的除外
		if (dx < 0) then
			angle = angle + 180
		end
	end
	
	--0~360度
	while (angle < 0) do
		angle = angle + 360
	end
	
	while (angle > 360) do
		angle = angle - 360
	end
	
	return angle
end

--判断一个整数是否是无效的数
function isnan(x)
	--only a number can not be a number
	if (type(x) ~= "number") then
		return false
	end
	
	--only NaNs will have the property of not being equal to themselves
	if (x ~= x) then
		--print(string.format("NaN: %s ~= %s", x, x));
		return true
	end
	
	--but not all NaN's will have the property of not being equal to themselves
	 
	--fails in cultures other than en-US, and sometimes fails in enUS depending on the compiler
	if (tostring(x) == "-1.#IND") then
		return true
	end
	
	--Slower, but works around the three above bugs in LUA
	if (tostring(x) == tostring((-1)^0.5)) then
		--print("NaN: x = sqrt(-1)");
		return true
	end
	
	--i really can't help you anymore. 
	--You're just going to have to live with the exception
	
	return false
end

--寻找一个最近能到达的目标点
--hApi.GetReachedPoint = function(oUnit, to_x, to_y)
function hApi.GetReachedPoint(oUnit, to_x, to_y)
	local ux, uy = hApi.chaGetPos(oUnit.handle) --角色当前的位置
	local dx = ux - to_x
	local dy = uy - to_y
	local distance = math.sqrt(dx * dx + dy * dy) --距离
	distance = math.floor(distance * 100) / 100  --保留2位有效数字，用于同步
	
	if (distance > 24) then
		--角度
		local angle = GetLineAngle(ux, uy, to_x, to_y)
		--local fangle = angle * math.pi / 180 --弧度制
		--fangle = math.floor(fangle * 100) / 100  --保留2位有效数字，用于同步
		local left_distance = distance --剩余的长度
		left_distance = math.floor(left_distance * 100) / 100  --保留2位有效数字，用于同步
		local STEP = 72 --步长
		while (left_distance >= 0) do
			--每次递减距离
			left_distance = left_distance - STEP
			
			if (left_distance > 0) then
				--local tx = ux + left_distance * math.cos(fangle) --尝试到达的x坐标
				--local ty = uy + left_distance * math.sin(fangle) --尝试到达的y坐标
				local tx = ux + left_distance * hApi.Math.Cos(angle) --尝试到达的x坐标
				local ty = uy + left_distance * hApi.Math.Sin(angle) --尝试到达的y坐标
				tx = math.floor(tx * 100) / 100  --保留2位有效数字，用于同步
				ty = math.floor(ty * 100) / 100  --保留2位有效数字，用于同步
				
				--不非法的坐标
				if (ux > 0) and (uy > 0) and (tx > 0) and (ty > 0) then
					local waypoint = xlCha_MoveToGrid(oUnit.handle._c, tx / 24, ty / 24, 0, nil)
					--print(left_distance, tx, ty)
					if (waypoint[0] > 0) and (hApi.IsPosInWater(tx, ty) == 0) then --寻路成功，并且不在水里
						return tx, ty
					end
				end
			end
		end
		
		--走到这里说明都不能到达
		return ux, uy
	else
		return ux, uy
	end
end

--geyachao: TD测试，停止移动
--hApi.UnitStop_TD = function(oUnit)
function hApi.UnitStop_TD(oUnit)
	if oUnit then
		local world = oUnit:getworld()
		--print("UnitStop_TD", oUnit.data.name .. il)
		--清空该角色的移动表
		--w.data.UnitArriving[oUnit] = nil
		--if w.data.UnitArriving[oUnit] then
		--	w.data.UnitArriving[oUnit].valid = false --geyachao: 采用内存优化方式处理，只标记为false，不删除表
		--end
		oUnit.data.MOVE_valid = false --geyachao: 采用内存优化方式处理，只标记为false，不删除表

		--if (oUnit.data.type == 2) then
		--	print("hApi.UnitStop_TD", oUnit.data.name)
		--end
		
		--如果角色正在移动中，那么停止角色的移动
		--停止移动的动作
		tmp_UnitArrive_TD(oUnit)
	end
end

--geyachao: TD测试单位移动到指定目标点
--参数: 单位, 坐标x, 坐标y, 是否计算障碍, 移动速度(默认为单位的移动速度), 是否不播移动动作
--hApi.UnitMoveToPoint_TD = function(
function hApi.UnitMoveToPoint_TD(oUnit, pos_x, pos_y, bBlock, move_speed, bNoPlayMoveAmin, paramFacing, bNoChangeFacing, callbackSkillId, callbackSkillUnit)
	--print("单位移动到指定目标点", oUnit.data.name, "move")
	
	--如果单位是空中单位，不计算碰撞
	if (oUnit:GetSpaceType() == hVar.UNIT_SPACE_TYPE.SPACE_FLY) then
		bBlock = false
	end
	
	--如果该目标点不能到达，或者在水里，寻找最近的可以到达的点
	if bBlock then
		local waypoint = nil
		--不非法的坐标
		if (pos_x > 0) and (pos_y > 0) then
			waypoint = xlCha_MoveToGrid(oUnit.handle._c, pos_x / 24, pos_y / 24, 0, nil)
		end
		--马上调用chaMoveToPoint(自己的点坐标),  就不会触发程序的走路了
		local ux, uy = hApi.chaGetPos(oUnit.handle) --目标的位置
		--xlChaMoveToPoint(oUnit.handle._c, ux, uy)
		if (pos_x <= 0) or (pos_y <= 0) or (waypoint == nil) or (waypoint[0] == 0) or (hApi.IsPosInWater(pos_x, pos_y) == 1) then --寻路失败，或者在水里
			--寻找最近的可以到达的点
			pos_x, pos_y = hApi.GetReachedPoint(oUnit, pos_x, pos_y)
			
			--目标点和当前点一致，说明彻底失败
			if (pos_x == ux) and (pos_y == uy) then
				--触发移动到达事件
				hApi.UnitStop_TD(oUnit)
				hGlobal.event:event("Event_UnitArrive_TD", oUnit, 0, callbackSkillId, callbackSkillUnit)
				return pos_x, pos_y
			end
		end
	end
	
	--[[
	local w = oUnit:getworld()
	local tMoveParam = w.data.UnitArriving[oUnit]
	
	if tMoveParam then --已存在此项
		tMoveParam.valid = true --geyachao: 是否有效（用于内存优化）
		tMoveParam.target = nil --非锁定目标模式，这里填nil
		tMoveParam.radius = 0 --非锁定目标模式，这里填0
		tMoveParam.pos_x = pos_x
		tMoveParam.pos_y = pos_y
		tMoveParam.move_speed = move_speed
		tMoveParam.bBlock = bBlock
		tMoveParam.waypoint = nil --路点信息（用于优化）
	else --新建一项
		w.data.UnitArriving[oUnit] =
		{
			valid = true, --geyachao: 是否有效（用于内存优化）
			
			target = nil, --非锁定目标模式，这里填nil
			radius = 0, --非锁定目标模式，这里填0
			
			pos_x = pos_x,
			pos_y = pos_y,
			move_speed = move_speed,
			
			bBlock = bBlock, --是否计算障碍（程序寻路）
			waypoint = nil, --路点信息（用于优化）
		}
	end
	]]
	local d = oUnit.data
	d.MOVE_valid = true --移动是否有效（用于内存优化）
	d.MOVE_target = nil --非锁定目标模式，这里填nil
	d.MOVE_target_worldC = 0 --移动到达的目标唯一id（目标模式）
	d.MOVE_radius = 0 --非锁定目标模式，这里填0
	d.MOVE_pos_x = pos_x --移动到达的半径（目标点模式）
	d.MOVE_pos_y = pos_y --移动到达的半径（目标点模式）
	d.MOVE_move_speed = move_speed --移动速度
	d.MOVE_bBlock = bBlock --移动是否计算碰撞
	d.MOVE_bChangeFacing = (not bNoChangeFacing) --移动是否转向
	d.MOVE_callbackSkillId = callbackSkillId --移动到达回调技能id
	d.MOVE_callbackSkillUnit = callbackSkillUnit --移动到达回调技能施法者
	d.MOVE_waypoint = nil --移动的程序返回的路点集（用于优化，目标点模式只计算一次程序路点，避免重复计算）
	
	--角色开始移动
	UnitBeinMove_TD(oUnit, pos_x, pos_y, bNoPlayMoveAmin, move_speed, paramFacing, bNoChangeFacing, callbackSkillId, callbackSkillUnit)
	
	return pos_x, pos_y
end

--geyachao: TD测试单位移动到指定目标
--参数: 单位, 目标, 半径(两者相离到指定距离就认为移动到达了), 是否计算障碍, 移动速度(默认为单位的移动速度), 是否不播移动动作
--hApi.UnitMoveToTarget_TD = function(
function hApi.UnitMoveToTarget_TD(oUnit, oTarget, radius, bBlock, move_speed, bNoPlayMoveAmin, paramFacing, bNoChangeFacing, callbackSkillId, callbackSkillUnit)
	--print("单位移动到指定目标", oUnit.data.name, oTarget.data,name, "move")
	
	--如果单位是空中单位，不计算碰撞
	if (oUnit:GetSpaceType() == hVar.UNIT_SPACE_TYPE.SPACE_FLY) then
		bBlock = false
	end
	
	--如果该目标点不能到达，或者在水里，寻找最近的可以到达的点
	if bBlock then
		local pos_x, pos_y = hApi.chaGetPos(oTarget.handle) --目标的位置
		--[[
		--geyachao: 寻路不用走到中心点，改为走到脚底板
		local t_bx, t_by, t_bw, t_bh = oTarget:getbox() --目标的包围盒
		pos_x = pos_x + (t_bx + t_bw / 2) --目标的中心点x位置
		pos_y = pos_y + (t_by + t_bh / 2) --目标的中心点y位置
		]]
		local waypoint = nil
		--不非法的坐标
		if (pos_x > 0) and (pos_y > 0) then
			waypoint = xlCha_MoveToGrid(oUnit.handle._c, pos_x / 24, pos_y / 24, 0, nil)
		end
		--马上调用chaMoveToPoint(自己的点坐标),  就不会触发程序的走路了
		local ux, uy = hApi.chaGetPos(oUnit.handle) --目标的位置
		--xlChaMoveToPoint(oUnit.handle._c, ux, uy)
		if (pos_x <= 0) or (pos_y <= 0) or (waypoint == nil) or (waypoint[0] == 0) or (hApi.IsPosInWater(pos_x, pos_y) == 1) then --寻路失败，或者在水里
			--寻找最近的可以到达的点
			pos_x, pos_y = hApi.GetReachedPoint(oUnit, pos_x, pos_y)
			--print("寻找最近的可以到达的点")
			--目标点和当前点一致，说明彻底失败
			if (pos_x == ux) and (pos_y == uy) then
				--触发移动到达事件
				hApi.UnitStop_TD(oUnit)
				hGlobal.event:event("Event_UnitArrive_TD", oUnit, 0, callbackSkillId, callbackSkillUnit)
				return pos_x, pos_y
			else --找到了最近可以到达的点，改为移动到目标点模式
				return hApi.UnitMoveToPoint_TD(oUnit, pos_x, pos_y, bBlock, move_speed, bNoPlayMoveAmin, paramFacing, bNoChangeFacing)
			end
		end
	end
	
	--[[
	local w = oUnit:getworld()
	local tMoveParam = w.data.UnitArriving[oUnit]
	
	if tMoveParam then --已存在此项
		tMoveParam.valid = true --geyachao: 是否有效（用于内存优化）
		tMoveParam.target = oTarget
		tMoveParam.radius = radius
		tMoveParam.pos_x = nil --非到达目标点模式，这里添nil
		tMoveParam.pos_y = nil --非到达目标点模式，这里添nil
		tMoveParam.move_speed = move_speed
		tMoveParam.bBlock = bBlock
		tMoveParam.waypoint = nil --路点信息（用于优化）
	else --新建一项
		w.data.UnitArriving[oUnit] =
		{
			valid = true, --geyachao: 是否有效（用于内存优化）
			
			target = oTarget,
			radius = radius,
			
			pos_x = nil,  --非到达目标点模式，这里填nil
			pos_y = nil,  --非到达目标点模式，这里填nil
			move_speed = move_speed,
			
			bBlock = bBlock, --是否计算障碍（程序寻路）
			waypoint = nil, --路点信息（用于优化）
		}
	end
	]]
	local d = oUnit.data
	d.MOVE_valid = true --移动是否有效（用于内存优化）
	d.MOVE_target = oTarget
	d.MOVE_target_worldC = oTarget:getworldC() --移动到达的目标唯一id（目标模式）
	d.MOVE_radius = radius
	d.MOVE_pos_x = nil --非到达目标点模式，这里填nil
	d.MOVE_pos_y = nil --非到达目标点模式，这里填nil
	d.MOVE_move_speed = move_speed --移动速度
	d.MOVE_bBlock = bBlock --移动是否计算碰撞
	d.MOVE_bChangeFacing = (not bNoChangeFacing) --移动是否转向
	d.MOVE_callbackSkillId = callbackSkillId --移动到达回调技能id
	d.MOVE_callbackSkillUnit = callbackSkillUnit --移动到达回调技能施法者
	d.MOVE_waypoint = nil --移动的程序返回的路点集（用于优化，目标点模式只计算一次程序路点，避免重复计算）
	
	--角色开始移动
	local tx, ty = hApi.chaGetPos(oTarget.handle) --角色的位置
	UnitBeinMove_TD(oUnit, tx, ty, bNoPlayMoveAmin, move_speed, paramFacing, bNoChangeFacing, callbackSkillId, callbackSkillUnit)
	
	return pos_x, pos_y
end

--脚本函数: 两个点是直线之间有障碍(0:没障碍 / 1:有障碍)
hApi.IsPathBlock = function(fromX, fromY, toX, toY)
	if (not g_world) then
		return 1
	else
		if xlScene_IsPathBlock then
			fromX = math.floor(fromX)
			fromY = math.floor(fromY)
			toX = math.floor(toX)
			toY = math.floor(toY)
			
			--非法的坐标
			if (fromX <= 0) or (fromY <= 0) or (toX <= 0) or (toY <= 0) then
				return 1
			end
			
			local result = xlScene_IsPathBlock(g_world, fromX, fromY, toX, toY)
			
			--geyachao: 同步日志: 两点直线到达判断
			if (hVar.IS_SYNC_LOG == 1) then
				local msg = "IsPathBlock: fromX=" .. tostring(fromX) .. ",fromY=" .. tostring(fromY) .. ",toX=" .. tostring(toX) .. ",toY=" .. tostring(toY) .. ",result=" .. tostring(result)
				hApi.SyncLog(msg)
			end
			
			return result
		else
			return 1
		end
	end
end

--脚本函数: 返回附近一个非障碍点
hApi.Scene_GetSpace = function(worldX, worldY, radius)
	local retX, retY = xlScene_GetSpace(worldX, worldY, radius)
	
	--如果该点是水里，那么去初始点
	if (hApi.IsPosInWater(retX, retY) == 1) then
		retX = worldX
		retY = worldY
		--print("如果该点是水里，那么去初始点")
	end
	
	--geyachao: 同步日志: GetSpace
	if (hVar.IS_SYNC_LOG == 1) then
		local msg = "GetSpace: worldX=" .. worldX .. ",worldY=" .. worldY .. ",radius=" .. tostring(radius) .. ",retX=" .. tostring(retX) .. ",retY=" .. tostring(retY)
		hApi.SyncLog(msg)
	end
	
	return retX, retY
end

--geyachao: TD实时更新角色移动
function TD_UnitArriveNew_Loop(tick)
	--暂停，直接跳出
	local world = hGlobal.WORLD.LastWorldMap
	if (world.data.IsPaused == 1) then
		return
	end
	
	--非TD地图，直接跳出
	local mapInfo = world.data.tdMapInfo
	if (not mapInfo) then
		return
	end
	
	--游戏暂停或结束，直接跳出
	if (mapInfo.mapState >= hVar.MAP_TD_STATE.PAUSE) then
		return
	end
	
	--print("TD_UnitArriveNew_Loop", tick)
	--local remove_table = {} --要删除的表key(角色死亡了)
	
	--local oPlayerMe = world:GetPlayerMe() --我的玩家对象
	--local nForceMe = oPlayerMe:getforce() --我的势力
	--local oNeutralPlayer = world:GetForce(nForceMe) --中立阵营玩家对象（蜀国/魏国）
	
	--[[
	--geyachao: 如果本次的tick过大，那么分割成多次执行，避免出现本次tick过长，人物本次位移极大，走出了屏幕
	local TICK = 100
	if (tick > TICK) then
		local extraTimes = math.ceil((tick - TICK) / 16)
		tick = 16
		
		for i = 1, extraTimes, 1 do
			TD_UnitArriveNew_Loop(16)
		end
	end
	]]
	
	--local counter = 0
	--for oUnit, tMoveParam in pairs(w.data.UnitArriving) do
	world:enumunit(function(oUnit)
		local tMoveParam = oUnit.data
		--self.data.MOVE_valid = true --移动是否有效（用于内存优化）
		--self.data.MOVE_target = oTarget
		--self.data.MOVE_radius = radius
		--self.data.MOVE_pos_x = nil --非到达目标点模式，这里填nil
		--self.data.MOVE_pos_y = nil --非到达目标点模式，这里填nil
		--self.data.MOVE_move_speed = move_speed --移动速度
		--self.data.MOVE_bBlock = bBlock --移动是否计算碰撞
		--self.data.MOVE_waypoint = nil --移动的程序返回的路点集（用于优化，目标点模式只计算一次程序路点，避免重复计算）
		
		--counter = counter + 1
		if tMoveParam.MOVE_valid then --geyachao: 是否有效（用于内存优化）
			--if (oUnit.data.IsDead ~= 1) then --非死亡的角色
				--if (oUnit.attr.stun_stack == 0) and ((hApi.gametime() - oUnit.data.castskillLastTime) >= oUnit.data.castskillStaticTime) then --角色非眩晕(滑行)、非僵直中
					local t_pos_x, t_pos_y = 0, 0 --本次要移动的目标点坐标
					local bBlock = tMoveParam.MOVE_bBlock --是否计算障碍
					--bBlock = false --geyachao: todo 暂时改为
					
					--目标(点)的坐标
					if tMoveParam.MOVE_target then --锁定目标模式
						if (tMoveParam.MOVE_target:getworldC() == tMoveParam.MOVE_target_worldC) and (tMoveParam.MOVE_target.data.IsDead ~= 1) then --非死亡的目标
							--print("非死亡的目标", oUnit.data.name, tMoveParam.MOVE_target.data.name, tMoveParam.MOVE_target.__ID)
							t_pos_x, t_pos_y = hApi.chaGetPos(tMoveParam.MOVE_target.handle) --目标的位置
							--t_pos_x, t_pos_y = tMoveParam.MOVE_target.handle._n:getPosition() --目标的位置
							--t_pos_y = -t_pos_y --屏幕坐标系！！！！！！！！！
							--大菠萝，如果目标是坦克，改为周围的点
							if (tMoveParam.MOVE_target.data.id == hVar.MY_TANK_ID) then
								if (oUnit:getowner():getforce() ~= tMoveParam.MOVE_target:getowner():getforce()) then --不是同一阵营
									local t_pos_x_new = t_pos_x + tMoveParam.MOVE_target.data.adjust_dx
									local t_pos_y_new = t_pos_y + tMoveParam.MOVE_target.data.adjust_dy
									
									local result = xlScene_IsGridBlock(g_world, t_pos_x_new / 24, t_pos_y_new / 24) --某个坐标是否是障碍
									if (result == 0) then
										t_pos_x = t_pos_x_new
										t_pos_y = t_pos_y_new
									end
								end
							end
						else --追踪的目标已死亡，停止移动
							--print("追踪的目标已死亡，停止移动", oUnit.data.name, tMoveParam.MOVE_target.data.name, tMoveParam.MOVE_target.__ID)
							--remove_table[oUnit] = true --添加到待删除列表
							tMoveParam.MOVE_valid = false --geyachao: 采用内存优化方式处理，只标记为false，不删除表
						end
					else --到达目标点模式
						t_pos_x = tMoveParam.MOVE_pos_x
						t_pos_y = tMoveParam.MOVE_pos_y
					end
					
					--if (not remove_table[oUnit]) then --目标未死亡
					if tMoveParam.MOVE_valid then --geyachao: 采用内存优化方式处理，只标记为false，不删除表
						local node = oUnit.handle._n
						local ox, oy = hApi.chaGetPos(oUnit.handle) --角色的位置
						--local ox, oy = node:getPosition() --角色的位置
						--oy = -oy  --角色的位置 --屏幕坐标系！！！！！！！！！
						if (oUnit.handle._c == nil) then
							local msg = "[LUA ERROR] node:getPosition() -> oUnit.handle._c为空!, oUnit=" .. tostring(oUnit.data.name) .. "\n"
							xlLG("isnan", msg)
							_DEBUG_MSG()
							ox, oy = 0, 0
						end
						if (isnan(ox) or isnan(oy)) then
							local msg = "[LUA ERROR] node:getPosition() 发现非法值, ox=" .. tostring(ox) .. ", oy=" .. tostring(oy) .. ", oUnit=" .. tostring(oUnit.data.name) .. "\n"
							xlLG("isnan", msg)
							_DEBUG_MSG(msg)
							--return
						end
						
						--begin
						--获得角色应该取的坐标（当前点）
						local unit_pos_x, unit_pos_y = 0, 0
						
						if tMoveParam.MOVE_target then --锁定目标模式，应该取角色中心点坐标
							--[[
							--取角色的中心点位置 
							local unit_bx, unit_by, unit_bw, unit_bh = oUnit:getbox() --角色的包围盒
							local unit_center_x = ox + (unit_bx + unit_bw / 2) --角色的中心点x位置
							local unit_center_y = oy + (unit_by + unit_bh / 2) --角色的中心点y位置
							unit_pos_x = unit_center_x
							unit_pos_y = unit_center_y
							]]
							--geyachao: 也取角色脚底板的位置
							unit_pos_x = ox
							unit_pos_y = oy
						else --到达目标点模式，取角色脚底板位置
							unit_pos_x = ox
							unit_pos_y = oy
						end
						
						--移动的速度
						local move_speed = tMoveParam.MOVE_move_speed
						if (move_speed == nil) then
							move_speed = oUnit:GetMoveSpeed() --移动速度
						end
						
						--end
						--取目标(点)的位置（终点）
						local target_pos_x, target_pos_y = 0, 0
						if tMoveParam.MOVE_target then --锁定目标模式，取目标的中心点位置
							--[[
							local t_bx, t_by, t_bw, t_bh = tMoveParam.MOVE_target:getbox() --目标的包围盒
							target_pos_x = t_pos_x + (t_bx + t_bw / 2) --目标的中心点x位置
							target_pos_y = t_pos_y + (t_by + t_bh / 2) --目标的中心点y位置
							]]
							--geyachao: 取目标脚底板位置
							--geyachao: 大菠萝，附加单位的调整点，防止有些关卡敌人围殴战车
							target_pos_x = t_pos_x + oUnit.data.adjust_dx
							target_pos_y = t_pos_y + oUnit.data.adjust_dy
							
							--如果目标是嘲讽单位，那么改为取目标的中心点位置
							if (tMoveParam.MOVE_target.attr.is_taunt == 1) then
								--取目标的中心点位置 
								local t_bx, t_by, t_bw, t_bh = tMoveParam.MOVE_target:getbox() --目标的包围盒
								target_pos_x = t_pos_x + (t_bx + t_bw / 2) --目标的中心点x位置
								target_pos_y = t_pos_y + (t_by + t_bh / 2) --目标的中心点y位置
							end
						else --到达目标点模式，用原值
							target_pos_x = t_pos_x
							target_pos_y = t_pos_y
						end
						
						--速度最低为0
						if (move_speed < 0) then
							move_speed = 0
						end
						
						--有移动速度的单位，速度有上下限
						if (move_speed > 0) then
							--移动速度下限
							if (move_speed < hVar.ROLE_MOVE_SPEED_MIN) then --20
								move_speed = hVar.ROLE_MOVE_SPEED_MIN
							end
							
							--移动速度上限
							if (move_speed > hVar.ROLE_MOVE_SPEED_MAX) then --500
								move_speed = hVar.ROLE_MOVE_SPEED_MAX
							end
						end
						
						--本次直线位移的距离
						local moves = math.floor((move_speed * tick / 1000) * 100) / 100 --geyachao: 保留2位有效数字，用于同步
						
						--两者当前的距离
						local dx = unit_pos_x - target_pos_x
						local dy = unit_pos_y - target_pos_y
						local distance = math.floor((math.sqrt(dx * dx + dy * dy)) * 100) / 100 --geyachao: 保留2位有效数字，用于同步
						
						--next
						--角色往前移动一小段距离（本轮到达点的中继路点终点）
						local real_current_to_x = target_pos_x --本次实际到移到的目标点x位置
						local real_current_to_y = target_pos_y --本次实际到移到的目标点y位置
						if tMoveParam.MOVE_target then --锁定目标模式，取角色的中心点位置
							--[[
							local u_bx, u_by, u_bw, u_bh = oUnit:getbox() --角色的包围盒
							real_current_to_x = real_current_to_x + (u_bx + u_bw / 2) --角色的中心点x位置
							real_current_to_y = real_current_to_y + (u_by + u_bh / 2) --角色的中心点y位置
							]]
							--geyachao: 取目标脚底板位置
						end
						--print(bBlock, distance)
						
						local bMoveSuccess = true --寻路是否成功
						--if bBlock and (distance > hVar.ROLE_COLLISION_EDGE) then
						if bBlock then
							local waypoint = nil
							
							--geyachao: 用于优化，如果是移动到目标点模式，并且计算过了一次路点，那么就读之前的值，不用重复计算程序路点
							if tMoveParam.MOVE_target then --锁定目标模式
								local IsBlock = hApi.IsPathBlock(unit_pos_x, unit_pos_y, target_pos_x, target_pos_y)
								if (IsBlock == 0) then
									waypoint = {[0] = 1, [1] = {[0] = target_pos_x, [1] = target_pos_y,}}
									--print("begin:寻路优化，检测两点是否直线到达")
									--[[
									--调试用
									--geyachao: 同步日志: 移动循环过程2
									if (hVar.IS_SYNC_LOG == 1) then
										local msg = "moveLoop_2: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC() .. ",IsBlock=" .. tostring(IsBlock) .. ",target_pos_x=" .. tostring(target_pos_x) .. ",target_pos_y=" .. tostring(target_pos_y)
										hApi.SyncLog(msg)
									end
									]]
								else
									--非法的坐标
									if (ox <= 0) or (oy <= 0) or (target_pos_x <= 0) or (target_pos_y <= 0) then
										waypoint = {[0] = 0,}
									else
										waypoint = xlCha_MoveToGrid(oUnit.handle._c, target_pos_x / 24, target_pos_y / 24, 0, nil)
									end
									
									--[[
									--调试用
									--geyachao: 同步日志: 移动循环过程3
									if (hVar.IS_SYNC_LOG == 1) then
										local msg = "moveLoop_3: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC() .. ",IsBlock=" .. tostring(IsBlock) .. ",target_pos_x=" .. tostring(target_pos_x) .. ",target_pos_y=" .. tostring(target_pos_y)
										hApi.SyncLog(msg)
									end
									]]
								end
							else --到达目标点模式
								if tMoveParam.MOVE_waypoint then 
									waypoint = tMoveParam.MOVE_waypoint
									--[[
									--调试用
									--geyachao: 同步日志: 移动循环过程4
									if (hVar.IS_SYNC_LOG == 4) then
										local msg = "moveLoop_4: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC()
										hApi.SyncLog(msg)
									end
									]]
								else
									local IsBlock = hApi.IsPathBlock(unit_pos_x, unit_pos_y, target_pos_x, target_pos_y)
									if (IsBlock == 0) then
										waypoint = {[0] = 1, [1] = {[0] = target_pos_x, [1] = target_pos_y,}}
										--print("begin:寻路优化，检测两点是否直线到达")
										--[[
										--调试用
										--geyachao: 同步日志: 移动循环过程5
										if (hVar.IS_SYNC_LOG == 1) then
											local msg = "moveLoop_5: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC() .. ",IsBlock=" .. tostring(IsBlock) .. ",target_pos_x=" .. tostring(target_pos_x) .. ",target_pos_y=" .. tostring(target_pos_y)
											hApi.SyncLog(msg)
										end
										]]
									else
										--非法的坐标
										if (ox <= 0) or (oy <= 0) or (target_pos_x <= 0) or (target_pos_y <= 0) then
											waypoint = {[0] = 0,}
										else
											waypoint = xlCha_MoveToGrid(oUnit.handle._c, target_pos_x / 24, target_pos_y / 24, 0, nil)
										end
										
										--[[
										--调试用
										--geyachao: 同步日志: 移动循环过程6
										if (hVar.IS_SYNC_LOG == 1) then
											local msg = "moveLoop_6: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC() .. ",IsBlock=" .. tostring(IsBlock) .. ",target_pos_x=" .. tostring(target_pos_x) .. ",target_pos_y=" .. tostring(target_pos_y)
											hApi.SyncLog(msg)
										end
										]]
									end
									
									tMoveParam.MOVE_waypoint = waypoint
								end
							end
							
							--马上调用chaMoveToPoint(自己的点坐标),  就不会触发程序的走路了
							--local ux, uy = hApi.chaGetPos(oUnit.handle) --目标的位置
							--xlChaMoveToPoint(oUnit.handle._c, ux, uy)
							
							if (waypoint[0] == 0) then
								--寻路失败
								bMoveSuccess = false
							else
								if (isnan(waypoint[1][0]) or isnan(waypoint[1][1])) then
									--local msg = "[LUA ERROR] xlCha_MoveToGrid(1), 发现非法值！unit_pos_x=" .. unit_pos_x .. ", unit_pos_y=" .. unit_pos_y .. ", real_current_to_x=" .. real_current_to_x .. ", real_current_to_y=" .. real_current_to_y .. "\n"
									--xlLG("isnan", msg)
									--_DEBUG_MSG(msg)
									return
								end
								real_current_to_x = waypoint[1][0]
								real_current_to_y = waypoint[1][1]
								--[[
								--调试用
								--geyachao: 同步日志: 移动循环过程7
								if (hVar.IS_SYNC_LOG == 1) then
									local msg = "moveLoop_7: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC() .. ",real_current_to_x=" .. tostring(real_current_to_x) .. ",real_current_to_y=" .. tostring(real_current_to_y)
									hApi.SyncLog(msg)
								end
								]]
							end
							--[[
							elseif (waypoint[0] == 1) then
								if (isnan(waypoint[1][0]) or isnan(waypoint[1][1])) then
									--local msg = "[LUA ERROR] xlCha_MoveToGrid(1), 发现非法值！unit_pos_x=" .. unit_pos_x .. ", unit_pos_y=" .. unit_pos_y .. ", real_current_to_x=" .. real_current_to_x .. ", real_current_to_y=" .. real_current_to_y .. "\n"
									--xlLG("isnan", msg)
									--_DEBUG_MSG(msg)
									return
								end
								real_current_to_x = waypoint[1][0]
								real_current_to_y = waypoint[1][1]
							else
								if (isnan(waypoint[2][0]) or isnan(waypoint[2][1])) then
									--local msg = "[LUA ERROR] xlCha_MoveToGrid(2), 发现非法值！unit_pos_x=" .. unit_pos_x .. ", unit_pos_y=" .. unit_pos_y .. ", real_current_to_x=" .. real_current_to_x .. ", real_current_to_y=" .. real_current_to_y .. "\n"
									--xlLG("isnan", msg)
									--_DEBUG_MSG(msg)
									return
								end
								real_current_to_x = waypoint[2][0]
								real_current_to_y = waypoint[2][1]
							end
							]]
						end
						
						if bMoveSuccess then --可以寻路并到达
							--[[
							local angle = GetLineAngle(unit_pos_x, unit_pos_y, real_current_to_x, real_current_to_y) --角度制
							--print(angle)
							local fangle = angle * math.pi / 180 --弧度制
							local tdx = moves * math.cos(fangle) --本地移动的x距离
							local tdy = moves * math.sin(fangle) --本地移动的y距离
							local to_x = ox + tdx
							local to_y = oy + tdy
							]]
							local dxi = real_current_to_x - unit_pos_x
							local dyi = real_current_to_y - unit_pos_y
							dxi = math.floor(dxi * 100) / 100 --geyachao: 保留2位有效数字，用于同步
							dyi = math.floor(dyi * 100) / 100 --geyachao: 保留2位有效数字，用于同步
							
							local disi = math.sqrt(dxi * dxi + dyi * dyi)
							--[[
							--调试用
							--geyachao: 同步日志: 移动循环过程8
							if (hVar.IS_SYNC_LOG == 1) then
								local msg = "moveLoop_8: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC() .. ",dxi=" .. tostring(dxi) .. ",dyi=" .. tostring(dyi) .. ",disi=" .. tostring(disi)
								hApi.SyncLog(msg)
							end
							]]
							disi = math.floor(disi * 100) / 100 --geyachao: 保留2位有效数字，用于同步
							
							local to_x = 0 --本次移动到的坐标x
							local to_y = 0 --本次移动到的坐标y
							
							--如果本次移动的距离，已经超过了路点提供的到达点的距离，那么最多移动到路点位置
							if (moves >= disi) then
								to_x = real_current_to_x
								to_y = real_current_to_y
								to_x = math.floor(to_x * 100) / 100 --geyachao: 保留2位有效数字，用于同步
								to_y = math.floor(to_y * 100) / 100 --geyachao: 保留2位有效数字，用于同步
								
								--如果有缓存的路点信息，那么移除这个路点信息
								if tMoveParam.MOVE_waypoint then
									local waypointNum = tMoveParam.MOVE_waypoint[0] --原路点的数量
									for i = 1, waypointNum - 1, 1 do
										tMoveParam.MOVE_waypoint[i][0] = tMoveParam.MOVE_waypoint[i + 1][0]
										tMoveParam.MOVE_waypoint[i][1] = tMoveParam.MOVE_waypoint[i + 1][1]
									end
									tMoveParam.MOVE_waypoint[waypointNum] = nil
									tMoveParam.MOVE_waypoint[0] = waypointNum - 1
									waypointNum = waypointNum - 1
									--print("tMoveParam.MOVE_waypoint[0]=" .. tMoveParam.MOVE_waypoint[0])
									
									--if (tMoveParam.MOVE_waypoint[0] == 0) then
									--	tMoveParam.MOVE_waypoint = nil
									--end
									
									--geyachao: 寻路优化，检测两点是否直线到达
									if (waypointNum > 0) then
										local IsBlock = hApi.IsPathBlock(unit_pos_x, unit_pos_y, target_pos_x, target_pos_y)
										if (IsBlock == 0) then
											tMoveParam.MOVE_waypoint[0] = 1
											tMoveParam.MOVE_waypoint[1] = {[0] = target_pos_x, [1] = target_pos_y,}
											--print("move:寻路优化，检测两点是否直线到达")
										end
									end
								end
							else
								to_x = ox + moves * dxi / disi
								to_y = oy + moves * dyi / disi
								to_x = math.floor(to_x * 100) / 100 --geyachao: 保留2位有效数字，用于同步
								to_y = math.floor(to_y * 100) / 100 --geyachao: 保留2位有效数字，用于同步
								
								--可到达边界
								local rangeL = world.data.rangeL
								local rangeR = world.data.rangeR
								local rangeU = world.data.rangeU
								local rangeD = world.data.rangeD
								
								if (oUnit.data.id == hVar.MY_TANK_ID) and ((to_x < rangeL) or (to_x > rangeR) or (to_y < rangeU) or (to_y > rangeD)) then
									--print(to_x, to_y)
									--print(rangeL, rangeR, rangeU, rangeD)
									--寻路失败
									bMoveSuccess = false
									--角色停止移动
									
									--再往前就是障碍了
									--local bIsNoStop = (oUnit:getRoadPoint() ~= 0) --有路点的单位，不需要停止动作
									local bIsNoStop = (oUnit:getRoadPointType() ~= hVar.ROLE_ROAD_POINT_TYPE.ROAD_POINT_NONE)
									tmp_UnitArrive_TD(oUnit, bIsNoStop)
									--print("移动到达0", oUnit.data.name, bIsNoStop)
									tMoveParam.MOVE_valid = false --geyachao: 采用内存优化方式处理，只标记为false，不删除表
									
									--触发移动到达事件
									hGlobal.event:event("Event_UnitArrive_TD", oUnit, 0, tMoveParam.MOVE_callbackSkillId, tMoveParam.MOVE_callbackSkillUnit)
								else
									--设置角色的转向
									if bBlock then
										local facing = GetFaceAngle(unit_pos_x, unit_pos_y, real_current_to_x, real_current_to_y) --角色的朝向(角度制)
										if (oUnit.data.type ~= hVar.UNIT_TYPE.BUILDING) then --建筑、图腾，移动不转向
											if tMoveParam.MOVE_bChangeFacing then --移动是否转向
												--print(oUnit.data.name, move_speed, oUnit:GetMoveSpeed())
												if (move_speed == oUnit:GetMoveSpeed()) then --击退不变方向
													hApi.ChaSetFacing(oUnit.handle, facing)
													oUnit.data.facing = facing
												end
												
												--tank_test:测试用: 同步更新绑定的单位的位置（炮口）
												if (oUnit.data.bind_unit ~= 0) then
													if (oUnit.data.bind_unit:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
														hApi.ChaSetFacing(oUnit.data.bind_unit.handle, facing)
														oUnit.data.bind_unit.data.facing = facing
													end
												end
												
												--tank_test:测试用: 同步更新绑定的单位的位置（大灯光照）
												if (oUnit.data.bind_light ~= 0) then
													--if (oUnit.data.bind_light:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
														hApi.ChaSetFacing(oUnit.data.bind_light.handle, facing)
														oUnit.data.bind_light.data.facing = facing
													--end
												end
												
												--tank_test:测试用: 同步更新绑定的单位的位置（大灯轮子）
												if (oUnit.data.bind_wheel ~= 0) then
													--if (oUnit.data.bind_wheel:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
														hApi.ChaSetFacing(oUnit.data.bind_wheel.handle, facing)
														oUnit.data.bind_wheel.data.facing = facing
													--end
												end
												
												--tank_test:测试用: 同步更新绑定的单位的位置（大灯影子）
												if (oUnit.data.bind_shadow ~= 0) then
													--if (oUnit.data.bind_shadow:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
														hApi.ChaSetFacing(oUnit.data.bind_shadow.handle, facing)
														oUnit.data.bind_shadow.data.facing = facing
													--end
												end
												
												--tank_test:测试用: 同步更新绑定的单位的位置（大灯能量圈）
												if (oUnit.data.bind_energy ~= 0) then
													--if (oUnit.data.bind_energy:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
														hApi.ChaSetFacing(oUnit.data.bind_energy.handle, facing)
														oUnit.data.bind_energy.data.facing = facing
													--end
												end
												
												--tank_test:测试用: 同步更新绑定的单位的位置（机枪）
												if (oUnit.data.bind_weapon ~= 0) then
													--if (oUnit.data.bind_weapon:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
													if (world.data.weapon_attack_state == 0) then
														--print(world:gametime() - oUnit.data.bind_weapon.attr.last_attack_time,hVar.ROLE_TANKWEAPON_SYNCTIME)
														if ((world:gametime() - oUnit.data.bind_weapon.attr.last_attack_time) > hVar.ROLE_TANKWEAPON_SYNCTIME) then --机枪1秒后才和车身同步
															hApi.ChaSetFacing(oUnit.data.bind_weapon.handle, facing)
															oUnit.data.bind_weapon.data.facing = facing
														end
													elseif (world.data.weapon_attack_state > 0) then
														if (oUnit.data.bind_weapon.data.lockTarget == 0) then --未锁定目标攻击
															hApi.ChaSetFacing(oUnit.data.bind_weapon.handle, facing)
															oUnit.data.bind_weapon.data.facing = facing
														end
													end
												end
												
												--tank_test:测试用: 同步更新绑定的单位的位置（大灯）
												if (oUnit.data.bind_lamp ~= 0) then
													--if (oUnit.data.bind_lamp:getAIState() ~= hVar.UNIT_AI_STATE.ATTACK) then
														hApi.ChaSetFacing(oUnit.data.bind_lamp.handle, facing)
														oUnit.data.bind_lamp.data.facing = facing
													--end
												end
											end
										end
									end
									
									--[[
									--调试用
									--geyachao: 同步日志: 移动循环过程1
									if (hVar.IS_SYNC_LOG == 1) then
										local msg = "moveLoop_1: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC() .. ",facing=" .. tostring(facing) .. ",ox=" .. tostring(ox) .. ",oy=" .. tostring(oy) .. ",dxi=" .. tostring(dxi) .. ",dyi=" .. tostring(dyi) .. ",disi=" .. tostring(disi)
										hApi.SyncLog(msg)
									end
									]]
								end
							end
							
							if bMoveSuccess then
								--[[
								--设置角色的转向
								local facing = GetFaceAngle(unit_pos_x, unit_pos_y, real_current_to_x, real_current_to_y) --角色的朝向(角度制)
								hApi.ChaSetFacing(oUnit.handle, facing)
								oUnit.data.facing = facing
								]]
								
								--设置角色的位置
								--to_x = math.floor(to_x * 100) / 100 --geyachao: 保留2位有效数字，用于同步
								--to_y = math.floor(to_y * 100) / 100 --geyachao: 保留2位有效数字，用于同步
								oUnit.data.worldX = to_x
								oUnit.data.worldY = to_y
								oUnit.data.gridX, oUnit.data.gridY = world:xy2grid(to_x, to_y)
								oUnit.handle.x = to_x
								oUnit.handle.y = to_y
								hApi.chaSetPos(oUnit.handle, to_x, to_y)
								node:setPosition(to_x, -to_y) --设置角色的位置
								--if (oUnit.data.id==6000)then
								--print("移动...", oUnit.data.name)
								--end
								--tank: 同步更新绑定的单位的位置（炮口）
								if (oUnit.data.bind_unit ~= 0) then
									oUnit.data.bind_unit.data.worldX = to_x
									oUnit.data.bind_unit.data.worldX = to_y
									oUnit.data.bind_unit.data.gridX, oUnit.data.bind_unit.data.gridY = world:xy2grid(to_x, to_y)
									oUnit.data.bind_unit.handle.x = to_x
									oUnit.data.bind_unit.handle.y = to_y
									hApi.chaSetPos(oUnit.data.bind_unit.handle, to_x, to_y)
									if oUnit.data.bind_unit.handle._n then
										oUnit.data.bind_unit.handle._n:setPosition(to_x, -to_y) --设置角色的位置
									end
									
									oUnit.data.bind_unit.data.defend_x = to_x
									oUnit.data.bind_unit.data.defend_y = to_y
									
									world:updateArea(oUnit.data.bind_unit, to_x, to_y)
								end
								
								--tank: 同步更新绑定的单位的位置（大灯光照）
								if (oUnit.data.bind_light ~= 0) then
									oUnit.data.bind_light.data.worldX = to_x
									oUnit.data.bind_light.data.worldX = to_y
									oUnit.data.bind_light.data.gridX, oUnit.data.bind_light.data.gridY = world:xy2grid(to_x, to_y)
									oUnit.data.bind_light.handle.x = to_x
									oUnit.data.bind_light.handle.y = to_y
									hApi.chaSetPos(oUnit.data.bind_light.handle, to_x, to_y)
									if oUnit.data.bind_light.handle._n then
										oUnit.data.bind_light.handle._n:setPosition(to_x, -to_y) --设置角色的位置
									end
									
									oUnit.data.bind_light.data.defend_x = to_x
									oUnit.data.bind_light.data.defend_y = to_y
									
									world:updateArea(oUnit.data.bind_light, to_x, to_y)
								end
								
								--tank: 同步更新绑定的单位的位置（大灯轮子）
								if (oUnit.data.bind_wheel ~= 0) then
									oUnit.data.bind_wheel.data.worldX = to_x
									oUnit.data.bind_wheel.data.worldX = to_y
									oUnit.data.bind_wheel.data.gridX, oUnit.data.bind_wheel.data.gridY = world:xy2grid(to_x, to_y)
									oUnit.data.bind_wheel.handle.x = to_x
									oUnit.data.bind_wheel.handle.y = to_y
									hApi.chaSetPos(oUnit.data.bind_wheel.handle, to_x, to_y)
									if oUnit.data.bind_wheel.handle._n then
										oUnit.data.bind_wheel.handle._n:setPosition(to_x, -to_y) --设置角色的位置
									end
									
									oUnit.data.bind_wheel.data.defend_x = to_x
									oUnit.data.bind_wheel.data.defend_y = to_y
									
									world:updateArea(oUnit.data.bind_wheel, to_x, to_y)
								end
								
								--tank: 同步更新绑定的单位的位置（大灯影子）
								if (oUnit.data.bind_shadow ~= 0) then
									local to_x_shadow = to_x + oUnit.data.bind_shadow.attr.bind_offsetX
									local to_y_shadow = to_y + oUnit.data.bind_shadow.attr.bind_offsetY
									
									oUnit.data.bind_shadow.data.worldX = to_x_shadow
									oUnit.data.bind_shadow.data.worldX = to_y_shadow
									oUnit.data.bind_shadow.data.gridX, oUnit.data.bind_shadow.data.gridY = world:xy2grid(to_x_shadow, to_y_shadow)
									oUnit.data.bind_shadow.handle.x = to_x_shadow
									oUnit.data.bind_shadow.handle.y = to_y_shadow
									hApi.chaSetPos(oUnit.data.bind_shadow.handle, to_x_shadow, to_y_shadow)
									if oUnit.data.bind_shadow.handle._n then
										oUnit.data.bind_shadow.handle._n:setPosition(to_x_shadow, -to_y_shadow) --设置角色的位置
									end
									
									oUnit.data.bind_shadow.data.defend_x = to_x_shadow
									oUnit.data.bind_shadow.data.defend_y = to_y_shadow
									
									world:updateArea(oUnit.data.bind_shadow, to_x_shadow, to_y_shadow)
								end
								
								--tank: 同步更新绑定的单位的位置（大灯能量圈）
								if (oUnit.data.bind_energy ~= 0) then
									oUnit.data.bind_energy.data.worldX = to_x
									oUnit.data.bind_energy.data.worldX = to_y
									oUnit.data.bind_energy.data.gridX, oUnit.data.bind_energy.data.gridY = world:xy2grid(to_x, to_y)
									oUnit.data.bind_energy.handle.x = to_x
									oUnit.data.bind_energy.handle.y = to_y
									hApi.chaSetPos(oUnit.data.bind_energy.handle, to_x, to_y)
									if oUnit.data.bind_energy.handle._n then
										oUnit.data.bind_energy.handle._n:setPosition(to_x, -to_y) --设置角色的位置
									end
									
									oUnit.data.bind_energy.data.defend_x = to_x
									oUnit.data.bind_energy.data.defend_y = to_y
									
									world:updateArea(oUnit.data.bind_energy, to_x, to_y)
								end
								
								--tank: 同步更新绑定的单位的位置（机枪）
								if (oUnit.data.bind_weapon ~= 0) then
									oUnit.data.bind_weapon.data.worldX = to_x
									oUnit.data.bind_weapon.data.worldX = to_y
									oUnit.data.bind_weapon.data.gridX, oUnit.data.bind_weapon.data.gridY = world:xy2grid(to_x, to_y)
									oUnit.data.bind_weapon.handle.x = to_x
									oUnit.data.bind_weapon.handle.y = to_y
									hApi.chaSetPos(oUnit.data.bind_weapon.handle, to_x, to_y)
									if oUnit.data.bind_weapon.handle._n then
										oUnit.data.bind_weapon.handle._n:setPosition(to_x, -to_y) --设置角色的位置
									end
									
									oUnit.data.bind_weapon.data.defend_x = to_x
									oUnit.data.bind_weapon.data.defend_y = to_y
									
									world:updateArea(oUnit.data.bind_weapon, to_x, to_y)
								end
								
								--tank: 同步更新绑定的单位的位置（大灯）
								if (oUnit.data.bind_lamp ~= 0) then
									oUnit.data.bind_lamp.data.worldX = to_x
									oUnit.data.bind_lamp.data.worldX = to_y
									oUnit.data.bind_lamp.data.gridX, oUnit.data.bind_lamp.data.gridY = world:xy2grid(to_x, to_y)
									oUnit.data.bind_lamp.handle.x = to_x
									oUnit.data.bind_lamp.handle.y = to_y
									hApi.chaSetPos(oUnit.data.bind_lamp.handle, to_x, to_y)
									if oUnit.data.bind_lamp.handle._n then
										oUnit.data.bind_lamp.handle._n:setPosition(to_x, -to_y) --设置角色的位置
									end
									
									oUnit.data.bind_lamp.data.defend_x = to_x
									oUnit.data.bind_lamp.data.defend_y = to_y
									
									world:updateArea(oUnit.data.bind_lamp, to_x, to_y)
								end
								
								--同步更新绑定的追踪特效的位置
								for i = 1, #oUnit.data.bind_tacingeffs, 1 do
									local tEff = oUnit.data.bind_tacingeffs[i]
									local eff = tEff.eff
									local effX = tEff.effX
									local effY = tEff.effY
									eff.handle._n:setPosition(to_x + effX, -to_y - effY)
								end
								
								--[[
								--调试用
								--geyachao: 同步日志: 移动循环
								if (hVar.IS_SYNC_LOG == 1) then
									local msg = "moveLoop: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC() .. ",to_x=" .. tostring(to_x) .. ",to_y=" .. tostring(to_y) .. ",moves=" .. moves
									hApi.SyncLog(msg)
								end
								]]
								
								--geyachao: 更新角色的区域信息（用于搜敌优化）
								world:updateArea(oUnit, to_x, to_y)
								
								if (isnan(to_x) or isnan(to_y)) then
									--local msg = "[LUA ERROR] hApi.chaSetPos() 发现非法值, to_x=" .. tostring(to_x) .. ", to_y=" .. tostring(to_y) .. "\n"
									--xlLG("isnan", msg)
									--_DEBUG_MSG(msg)
									--return
								end
								
								--如果是中立有路点单位、敌方有路点单位，那么设置守卫点坐标为当前坐标
								--if (oUnit:getowner() ~= nForceMe) then
									--if (oUnit:getRoadPoint() ~= 0) then --有路点的单位，才重置守卫点
									--if (oUnit:getRoadPointType() ~= hVar.ROLE_ROAD_POINT_TYPE.ROAD_POINT_NONE) then --大菠萝都设置
										oUnit.data.defend_x = to_x
										oUnit.data.defend_y = to_y
										
										--[[
										--geyachao: 瓦力守卫点是战车
										if (oUnit.data.id == hVar.MY_TANK_FOLLOW_ID) then
											--print("瓦力守卫点是战车")
											local oHero = world:GetPlayerMe().heros[1]
											if oHero then
												local oTank = oHero:getunit()
												if oTank then
													oUnit.data.defend_x = oTank.data.defend_x + oUnit.data.defend_x_walle
													oUnit.data.defend_y = oTank.data.defend_y + oUnit.data.defend_y_walle
												end
											end
										end
										]]
									--end
								--end
								
								--更新攻击箭头的特效
								if tMoveParam.MOVE_target then --锁定目标模式
									if (oUnit.data.AttackEffect ~= 0) then
										oUnit.data.AttackEffect.handle._n:setPosition(t_pos_x + 15, -t_pos_y + 20)
										--print("更新攻击箭头特效", t_pos_x + 15, -t_pos_y + 20, tMoveParam.MOVE_target and tMoveParam.MOVE_target.data.name)
									end
								end
								
								--检测角色是否移动到达
								local left_distance = distance - tMoveParam.MOVE_radius - moves --还剩余的距离
								--local left_distance = distance - moves --还剩余的距离
								
								--如果是追踪目标模式
								if tMoveParam.MOVE_target then
									--[[
									local t_bx, t_by, t_bw, t_bh = tMoveParam.MOVE_target:getbox() --目标的包围盒
									local t_extra_radius = math.sqrt(t_bw / 2 * t_bw / 2 + t_bh / 2 * t_bh / 2) --目标额外的攻击距离
									left_distance = left_distance - t_extra_radius
									]]
									--print(tMoveParam.MOVE_target.data.name, left_distance)
									--如果目标是嘲讽单位，那么取目标的额外盒子半径
									if (tMoveParam.MOVE_target.attr.is_taunt == 1) then
										--取目标的中心点位置
										local t_bx, t_by, t_bw, t_bh = tMoveParam.MOVE_target:getbox() --目标的包围盒
										local t_extra_radius = tMoveParam.MOVE_target.attr.taunt_radius --目标额外的攻击距离
										left_distance = left_distance - t_extra_radius
										--print("如果目标是嘲讽单位，那么取目标的额外盒子半径 left_distance", left_distance, t_extra_radius)
									else
										left_distance = left_distance - hVar.ROLE_COLLISION_EDGE
									end
								end
								
								--print("distance=" .. distance .. ",moves=" .. moves .. ",left_distance=" .. left_distance)
								if (left_distance <= 0) then --移动到达
									--角色停止移动
									--local bIsNoStop = (oUnit:getRoadPoint() ~= 0) --有路点的单位，不需要停止动作
									local bIsNoStop = (oUnit:getRoadPointType() ~= hVar.ROLE_ROAD_POINT_TYPE.ROAD_POINT_NONE)
									tmp_UnitArrive_TD(oUnit, bIsNoStop)
									--print("移动到达1", oUnit.data.name, bIsNoStop, "stop")
									--print("角色停止移动", distance, tMoveParam.MOVE_radius, moves)
									
									--添加到待删除列表
									--remove_table[oUnit] = true
									tMoveParam.MOVE_valid = false --geyachao: 采用内存优化方式处理，只标记为false，不删除表
									--print("移动到达 hApi.UnitStop_TD remove_table", oUnit.data.name)
									
									--触发回调事件
									if (type(tMoveParam.MOVE_callbackSkillId) == "number") then
										if (tMoveParam.MOVE_callbackSkillId > 0) then
											local gridX, gridY = world:xy2grid(to_x, to_y)
											--释放技能
											local tCastParam =
											{
												level = 1, --等级
											}
											hApi.CastSkill(tMoveParam.MOVE_callbackSkillUnit, tMoveParam.MOVE_callbackSkillId, 0, 100, oUnit, gridX, gridY, tCastParam) --技能
										end
									end
									
									--触发移动到达事件
									hGlobal.event:event("Event_UnitArrive_TD", oUnit, 1, tMoveParam.MOVE_callbackSkillId, tMoveParam.MOVE_callbackSkillUnit)
								end
								
								--主基地监控对话事件
								hGlobal.event:event("Event_CheckMainBaseTalkEvent")
								--主基地监控进出区域事件
								hGlobal.event:event("Event_CheckMainBaseAreaEvent")
							else
								--角色停止移动
								--local bIsNoStop = (oUnit:getRoadPoint() ~= 0) --有路点的单位，不需要停止动作
								local bIsNoStop = (oUnit:getRoadPointType() ~= hVar.ROLE_ROAD_POINT_TYPE.ROAD_POINT_NONE)
								tmp_UnitArrive_TD(oUnit, bIsNoStop)
								--print("移动到达2", oUnit.data.name, bIsNoStop)
								tMoveParam.MOVE_valid = false --geyachao: 采用内存优化方式处理，只标记为false，不删除表
								
								--主基地监控对话事件
								--hGlobal.event:event("Event_CheckMainBaseTalkEvent")
								--触发移动到达事件
								hGlobal.event:event("Event_UnitArrive_TD", oUnit, 0, tMoveParam.MOVE_callbackSkillId, tMoveParam.MOVE_callbackSkillUnit)
							end
						else --当前寻路发现无法往前走了
							--角色停止移动
							--再往前就是障碍了
							--local bIsNoStop = (oUnit:getRoadPoint() ~= 0) --有路点的单位，不需要停止动作
							local bIsNoStop = (oUnit:getRoadPointType() ~= hVar.ROLE_ROAD_POINT_TYPE.ROAD_POINT_NONE)
							tmp_UnitArrive_TD(oUnit, bIsNoStop)
							--print("移动到达3", oUnit.data.name, bIsNoStop)
							tMoveParam.MOVE_valid = false --geyachao: 采用内存优化方式处理，只标记为false，不删除表
							
							--主基地监控对话事件
							--hGlobal.event:event("Event_CheckMainBaseTalkEvent")
							
							--触发移动到达事件
							hGlobal.event:event("Event_UnitArrive_TD", oUnit, 0, tMoveParam.MOVE_callbackSkillId, tMoveParam.MOVE_callbackSkillUnit)
						end
					else --追踪的目标已死亡
						--角色停止移动
						--local bIsNoStop = (oUnit:getRoadPoint() ~= 0) --有路点的单位，不需要停止动作
						local bIsNoStop = (oUnit:getRoadPointType() ~= hVar.ROLE_ROAD_POINT_TYPE.ROAD_POINT_NONE)
						tmp_UnitArrive_TD(oUnit, bIsNoStop)
						--print("移动到达4", oUnit.data.name, bIsNoStop)
						tMoveParam.MOVE_valid = false --geyachao: 采用内存优化方式处理，只标记为false，不删除表
						
						--主基地监控对话事件
						--hGlobal.event:event("Event_CheckMainBaseTalkEvent")
						
						--触发移动到达事件
						hGlobal.event:event("Event_UnitArrive_TD", oUnit, 0, tMoveParam.MOVE_callbackSkillId, tMoveParam.MOVE_callbackSkillUnit)
					end
				--end
			--else --死亡的角色
			--	--remove_table[oUnit] = true --添加到待删除列表
			--	tMoveParam.MOVE_valid = false --geyachao: 采用内存优化方式处理，只标记为false，不删除表
			--end
		end
	--end
	end)
	--print("counter=" .. counter)
	--删除待删除的表项
	--for k, v in pairs(remove_table) do
	--	world.data.UnitArriving[k] = nil
	--end
end

--geyachao: TD检测技能目标是否合法
hApi.IsSkillTargetValid = function(oUnit, oTarget, skillId)
	local tabS = hVar.tab_skill[skillId] --技能表
	local oWorld = hGlobal.WORLD.LastWorldMap
	
	local oUnitPlayer = oUnit:getowner() --施法者的玩家对象
	local forceUnit = nil
	if oUnitPlayer then
		forceUnit = oUnitPlayer:getforce() --施法者的阵营
	end
	
	local forceTarget = 0 --目标的阵营
	if (oTarget) then
		local oTargetPlayer = oTarget:getowner() --目标的玩家对象
		--print(oTarget.data.name, "oTargetPlayer=", oTargetPlayer)
		if oTargetPlayer then
			forceTarget = oTargetPlayer:getforce() --目标的阵营
		end
	end
	
	--不存在的技能表项，返回失败
	if (not tabS) then
		--print("不存在的技能表项，返回失败")
		return hVar.RESULT_FAIL
	end
	
	--[[
	--不能对可破坏物件放技能，如果不是自己释放的技能，返回失败
	if (oTarget) then
		if (oTarget.data.type == hVar.UNIT_TYPE.UNITBROKEN) then
			--print("不能对可破坏物件放技能，如果不是自己释放的技能，返回失败")
			if (oUnit ~= oTarget) then
				return hVar.RESULT_FAIL
			end
		end
	end
	]]
	
	--[[
	--不能对可破坏房子放技能，如果不是自己释放的技能，返回失败
	if (oTarget) then
		if (oTarget.data.type == hVar.UNIT_TYPE.UNITBROKEN_HOUSE) then
			--print("不能对可破坏房子放技能，如果不是自己释放的技能，返回失败")
			if (oUnit ~= oTarget) then
				return hVar.RESULT_FAIL
			end
		end
	end
	]]
	
	--判断目标的阵营是否可以
	--目标列表
	local bSideEnable = false
	local targetList = tabS.target
	
	--无目标列表、空目标列表，返回失败
	if (not targetList) or (#targetList == 0) then
		--print("无目标列表、空目标列表，返回失败")
		return hVar.RESULT_FAIL
	end
	
	--print("IsSkillTargetValid", "skillId=" .. skillId, "oUnit=" .. oUnit.data.name, "oTarget=" .. (oTarget and oTarget.data.name or "nil"), "forceUnit=" .. tostring(forceUnit), "forceTarget=" .. tostring(forceTarget), targetList[1])
	--依次遍历所有的目标
	for i = 1, #targetList, 1 do
		local targetType = targetList[i]
		--print(skillId, #targetList, targetType)
		if (targetType == "ALL") then --全部
			bSideEnable = true
		elseif (targetType == "SELF") then --自己
			if (oUnit == oTarget) then
				bSideEnable = true
			end
		elseif (targetType == "OTHER") then --非自己
			if (oUnit ~= oTarget) then
				bSideEnable = true
			end
		elseif (targetType == "ALLY_OTHER") or (targetType == "OTHER_ALLY") then --友方非自己
			if (forceUnit == forceTarget) and (oUnit ~= oTarget) then
				bSideEnable = true
			end
		elseif (targetType == "ENEMY") then --敌人
			if (forceUnit ~= forceTarget) then
				bSideEnable = true
			end
		elseif (targetType == "ALLY") then --友方
			if (forceUnit == forceTarget) then
				bSideEnable = true
			end
		elseif (targetType == "SIDE1") then --蜀国
			if (forceTarget == hVar.FORCE_DEF.SHU) then
				bSideEnable = true
			end
		elseif (targetType == "SIDE2") then --魏国
			if (forceTarget == hVar.FORCE_DEF.WEI) then
				bSideEnable = true
			end
		elseif (targetType == "SIDE3") then --中立无敌意
			if (forceTarget == hVar.FORCE_DEF.NEUTRAL) then
				bSideEnable = true
			end
		elseif (targetType == "SIDE4") then --中立无敌意
			if (forceTarget == hVar.FORCE_DEF.NEUTRAL_ENEMY) then
				bSideEnable = true
			end
		elseif (type(targetType) == "number") then --指定id的角色
			if (oTarget and (oTarget.data.id == targetType)) then
				bSideEnable = true
			end
		else
			--不合法的参数
			_DEBUG_MSG("hApi.IsSkillTargetValid(), targetType = " .. tostring(targetType) .. " 非法！")
		end
		
		if bSideEnable then
			break
		end
	end
	
	--阵营不符合要求，直接返回
	if (not bSideEnable) then
		--print(oTarget.data.name, "阵营不符合要求，直接返回")
		return hVar.RESULT_FAIL
	end

	--敌方隐身单位不能被攻击到
	local yinshen_state = oTarget:GetYinShenState() --是否在隐身状态
	--if (forceUnit ~= forceTarget) and (yinshen_state == 1) and (oUnit ~= oWorld.data.tdMapInfo.godUnit) then --非相同阵营、隐身单位不能使法（除了上帝可以对任何隐身单位施法）
	if (forceUnit ~= forceTarget) and (yinshen_state == 1) and (oUnit ~= oUnitPlayer:getgod()) then
		--print("敌方隐身单位不能被攻击到")
		return hVar.RESULT_FAIL
	end
	
	--技能的生效目标，是否包含该单位类型
	--判断目标的类型是否可以
	local bSubTypeEnable = false --类型是否可用
	local cast_target_type = tabS.cast_target_type --对象列表
	if (not cast_target_type) or (cast_target_type == 0) then
		--目标的类型没有填写，说明任何类型都不可以
		bSubTypeEnable = false
	else
		local subType = oTarget.data.type --目标的子类型
		if cast_target_type[subType] then
			bSubTypeEnable = true
		else
			--特殊处理，如果对自己施法，什么目标类型都可以
			if (targetList[1] == "SELF") then --自己
				bSubTypeEnable = true
			end
		end
	end
	
	--类型不符合要求，直接返回
	if (not bSubTypeEnable) then
		--print("类型不符合要求，直接返回")
		return hVar.RESULT_FAIL
	end
	
	--都遍历完了，都没返回，说明有效
	return hVar.RESULT_SUCESS
end

--geyachao: 单位试图锁定目标
hApi.UnitTryToLockTarget = function(oUnit, oTarget, lockType)
	--存在要锁定的目标，检测是否能锁定到
	if oTarget and (oTarget ~= 0) then
		--检测攻击者可攻击的空间的类型和目标的空间类型
		local unit_atk_space_type = oUnit.attr.atk_space_type --攻击者可攻击的空间的类型
		if (unit_atk_space_type ~= hVar.UNIT_ATTACK_SPACE_TYPE.ATTACK_SPACE_ALL) then --如果攻击者可攻击目标的空间的类型不是全部类型都可以的话，再进一步检测
			local target_space_type = oTarget:GetSpaceType() --目标的空间类型
			
			--攻击者只能攻击地面单位，而目标是空中单位，那么直接返回
			if (unit_atk_space_type == hVar.UNIT_ATTACK_SPACE_TYPE.ATTACK_SPACE_GROUND) and (target_space_type == hVar.UNIT_SPACE_TYPE.SPACE_FLY) then
				return
			end
			
			--攻击者只能攻击空中单位，而目标是地面单位，那么直接返回
			if (unit_atk_space_type == hVar.UNIT_ATTACK_SPACE_TYPE.ATTACK_SPACE_FLY) and (target_space_type == hVar.UNIT_SPACE_TYPE.SPACE_GROUND) then
				return
			end
		end
	end
	
	--检测攻击者可攻击的单位类型，目标是否符合
	if oTarget and (oTarget ~= 0) then
		local bSubTypeEnable = false --类型是否可用
		local skill_id = oUnit.attr.attack[1]
		local tabS = hVar.tab_skill[skill_id] --技能表
		if (not tabS) then
			return
		end
		
		--目标的类型没有填写，说明任何类型都不可以
		local cast_target_type = tabS.cast_target_type --对象列表
		if (not cast_target_type) or (cast_target_type == 0) then
			return
		end
		
		local subType = oTarget.data.type --目标的子类型
		if cast_target_type[subType] then
			bSubTypeEnable = true
		end
		
		--道具可以拾取
		if (subType == hVar.UNIT_TYPE.ITEM) then
			bSubTypeEnable = true
		end
		
		if (not bSubTypeEnable) then
			return
		end
	end
	
	--目标无敌，不能被锁定
	if oTarget and (oTarget ~= 0) then
		if (oTarget.attr.immue_wudi_stack > 0) then
			return
		end
	end
	
	--单位在混乱中，不能锁定
	if (oUnit.attr.suffer_chaos_stack > 0) then
		return
	end
	
	oUnit.data.lockTarget = oTarget
	if oUnit and (oUnit ~= 0) and (oUnit.data.bind_unit ~= 0) then
		 oUnit.data.bind_unit.data.lockTarget = oTarget
	end
	oUnit.data.lockType = lockType or 0 --锁定攻击的类型(0:被动锁定 / 1:主动锁定)
	
	--print("UnitTryToLockTarget", oUnit.data.name .. "_" .. oUnit:getworldC(), (oTarget and (oTarget ~= 0)) and oTarget.data.name.. "_" .. oTarget:getworldC(), lockType)
	--print(debug.traceback())
	--print()
	
	--[[
	--调试用
	--geyachao: 同步日志: 锁定目标
	if (hVar.IS_SYNC_LOG == 1) then
		local msg = "lockTarget: oUnit=" .. oUnit.data.id .. ",u_ID=" .. oUnit:getworldC() .. ",oTarget=" .. ((oTarget == 0) and 0 or (oTarget.data.id)) .. ",lockType=" .. tostring(lockType)
		hApi.SyncLog(msg)
	end
	]]
	
	--geyachao: 非同步日志: 锁定目标
	if (hVar.IS_ASYNC_LOG == 1) then
		local msg = "lockTarget: oUnit=" .. oUnit.data.name .. ",u_ID=" .. oUnit:getworldC() .. ",oTarget=" .. ((oTarget == 0) and 0 or (oTarget.data.name)) .. ",lockType=" .. tostring(lockType) .. "\n" .. debug.traceback()
		hApi.AsyncLog(msg)
	end
end

--zhenkira: TD检测当前关卡是否是boss关卡
hApi.CheckMapIsBoss = function(mapName)
	local ret = false
	
	if not hVar.tab_chapter then
		return ret
	end
	
	for i = 1, #hVar.tab_chapter do
		if hVar.tab_chapter[i].bossMap and hVar.tab_chapter[i].bossMap == mapName then
			ret = true
			break
		end
	end
	
	return ret
end

--zhenkira: TD检测当前关卡是否是boss关卡
hApi.CheckMapIsChapter = function(mapName)
	local ret = false
	
	if not hVar.tab_chapter then
		return ret
	end
	
	for i = 1, #hVar.tab_chapter do
		if hVar.tab_chapter[i].map and hVar.tab_chapter[i].map == mapName then
			ret = true
			break
		end
	end
	
	return ret
end

--geyachao: 获得角色的属性列表
hApi.GetUnitAttrs = function(type_id, lv, star, equipment, treasure, treasureAttr)
	local a = {} --返回值(属性列表)
	local aBasic = {} --返回值(基础属性)
	local aEquip = {} --返回值(装备属性)
	local aTreasure = {} --返回值(宝物属性)
	
	local cardLv = lv --英雄的等级
	local cardStar = star --英雄星级
	
	local tabU = hVar.tab_unit[type_id] --tab表项
	
	--不存在表项，直接返回
	if (tabU == nil) then
		return a
	end
	
	local tabA = tabU.attr --tab表项的属性表
	
	a.lv = cardLv --存储等级
	a.star = cardStar --存储星级
	
	--属性每级成长值
	--血量每级成长值
	a.hp_lvup = 0
	if tabA.hp_lvup then
		if (type(tabA.hp_lvup) == "number") then --每个星级的成长值都一样
			a.hp_lvup = tabA.hp_lvup
		elseif (type(tabA.hp_lvup) == "table") then --每个星级对应不同的成长值
			a.hp_lvup = tabA.hp_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--回血速度（每秒）每级成长值
	a.hp_restore_lvup = 0
	if tabA.hp_restore_lvup then
		if (type(tabA.hp_restore_lvup) == "number") then --每个星级的成长值都一样
			a.hp_restore_lvup = tabA.hp_restore_lvup
		elseif (type(tabA.hp_restore_lvup) == "table") then --每个星级对应不同的成长值
			a.hp_restore_lvup = tabA.hp_restore_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--移动速度每级成长值
	a.move_speed_lvup = 0
	if tabA.move_speed_lvup then
		if (type(tabA.move_speed_lvup) == "number") then --每个星级的成长值都一样
			a.move_speed_lvup = tabA.move_speed_lvup
		elseif (type(tabA.move_speed_lvup) == "table") then --每个星级对应不同的成长值
			a.move_speed_lvup = tabA.move_speed_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--最小攻击力每级成长值
	a.atk_min_lvup = 0
	if tabA.atk_min_lvup then
		if (type(tabA.atk_min_lvup) == "number") then --每个星级的成长值都一样
			a.atk_min_lvup = tabA.atk_min_lvup
		elseif (type(tabA.atk_min_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_min_lvup = tabA.atk_min_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--最大攻击力每级成长值
	a.atk_max_lvup = 0
	if tabA.atk_max_lvup then
		if (type(tabA.atk_max_lvup) == "number") then --每个星级的成长值都一样
			a.atk_max_lvup = tabA.atk_max_lvup
		elseif (type(tabA.atk_max_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_max_lvup = tabA.atk_max_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--冰攻击力每级成长值
	a.atk_ice_lvup = 0
	if tabA.atk_ice_lvup then
		if (type(tabA.atk_ice_lvup) == "number") then --每个星级的成长值都一样
			a.atk_ice_lvup = tabA.atk_ice_lvup
		elseif (type(tabA.atk_ice_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_ice_lvup = tabA.atk_ice_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--雷攻击力每级成长值
	a.atk_thunder_lvup = 0
	if tabA.atk_thunder_lvup then
		if (type(tabA.atk_thunder_lvup) == "number") then --每个星级的成长值都一样
			a.atk_thunder_lvup = tabA.atk_thunder_lvup
		elseif (type(tabA.atk_thunder_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_thunder_lvup = tabA.atk_thunder_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--火攻击力每级成长值
	a.atk_fire_lvup = 0
	if tabA.atk_fire_lvup then
		if (type(tabA.atk_fire_lvup) == "number") then --每个星级的成长值都一样
			a.atk_fire_lvup = tabA.atk_fire_lvup
		elseif (type(tabA.atk_fire_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_fire_lvup = tabA.atk_fire_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--毒攻击力每级成长值
	a.atk_poison_lvup = 0
	if tabA.atk_poison_lvup then
		if (type(tabA.atk_poison_lvup) == "number") then --每个星级的成长值都一样
			a.atk_poison_lvup = tabA.atk_poison_lvup
		elseif (type(tabA.atk_poison_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_poison_lvup = tabA.atk_poison_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--子弹攻击力每级成长值
	a.atk_bullet_lvup = 0
	if tabA.atk_bullet_lvup then
		if (type(tabA.atk_bullet_lvup) == "number") then --每个星级的成长值都一样
			a.atk_bullet_lvup = tabA.atk_bullet_lvup
		elseif (type(tabA.atk_bullet_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_bullet_lvup = tabA.atk_bullet_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--爆炸攻击力每级成长值
	a.atk_bomb_lvup = 0
	if tabA.atk_bomb_lvup then
		if (type(tabA.atk_bomb_lvup) == "number") then --每个星级的成长值都一样
			a.atk_bomb_lvup = tabA.atk_bomb_lvup
		elseif (type(tabA.atk_bomb_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_bomb_lvup = tabA.atk_bomb_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--穿刺攻击力每级成长值
	a.atk_chuanci_lvup = 0
	if tabA.atk_chuanci_lvup then
		if (type(tabA.atk_chuanci_lvup) == "number") then --每个星级的成长值都一样
			a.atk_chuanci_lvup = tabA.atk_chuanci_lvup
		elseif (type(tabA.atk_chuanci_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_chuanci_lvup = tabA.atk_chuanci_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--攻击间隔每级成长值
	a.atk_interval_lvup = 0
	if tabA.atk_interval_lvup then
		if (type(tabA.atk_interval_lvup) == "number") then --每个星级的成长值都一样
			a.atk_interval_lvup = tabA.atk_interval_lvup
		elseif (type(tabA.atk_interval_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_interval_lvup = tabA.atk_interval_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--攻击速度每级成长值
	a.atk_speed_lvup = 0
	if tabA.atk_speed_lvup then
		if (type(tabA.atk_speed_lvup) == "number") then --每个星级的成长值都一样
			a.atk_speed_lvup = tabA.atk_speed_lvup
		elseif (type(tabA.atk_interval_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_speed_lvup = tabA.atk_speed_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--攻击范围每级成长值
	a.atk_radius_lvup = 0
	if tabA.atk_radius_lvup then
		if (type(tabA.atk_radius_lvup) == "number") then --每个星级的成长值都一样
			a.atk_radius_lvup = tabA.atk_radius_lvup
		elseif (type(tabA.atk_radius_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_radius_lvup = tabA.atk_radius_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--攻击范围最小值每级成长值
	a.atk_radius_min_lvup = 0
	if tabA.atk_radius_min_lvup then
		if (type(tabA.atk_radius_min_lvup) == "number") then --每个星级的成长值都一样
			a.atk_radius_min_lvup = tabA.atk_radius_min_lvup
		elseif (type(tabA.atk_radius_min_lvup) == "table") then --每个星级对应不同的成长值
			a.atk_radius_min_lvup = tabA.atk_radius_min_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--物防每级成长值
	a.def_physic_lvup = 0
	if tabA.def_physic_lvup then
		if (type(tabA.def_physic_lvup) == "number") then --每个星级的成长值都一样
			a.def_physic_lvup = tabA.def_physic_lvup
		elseif (type(tabA.def_physic_lvup) == "table") then --每个星级对应不同的成长值
			a.def_physic_lvup = tabA.def_physic_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--法防每级成长值
	a.def_magic_lvup = 0
	if tabA.def_magic_lvup then
		if (type(tabA.def_magic_lvup) == "number") then --每个星级的成长值都一样
			a.def_magic_lvup = tabA.def_magic_lvup
		elseif (type(tabA.def_magic_lvup) == "table") then --每个星级对应不同的成长值
			a.def_magic_lvup = tabA.def_magic_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--冰防每级成长值
	a.def_ice_lvup = 0
	if tabA.def_ice_lvup then
		if (type(tabA.def_ice_lvup) == "number") then --每个星级的成长值都一样
			a.def_ice_lvup = tabA.def_ice_lvup
		elseif (type(tabA.def_ice_lvup) == "table") then --每个星级对应不同的成长值
			a.def_ice_lvup = tabA.def_ice_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--雷防每级成长值
	a.def_thunder_lvup = 0
	if tabA.def_thunder_lvup then
		if (type(tabA.def_thunder_lvup) == "number") then --每个星级的成长值都一样
			a.def_thunder_lvup = tabA.def_thunder_lvup
		elseif (type(tabA.def_thunder_lvup) == "table") then --每个星级对应不同的成长值
			a.def_thunder_lvup = tabA.def_thunder_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--火防每级成长值
	a.def_fire_lvup = 0
	if tabA.def_fire_lvup then
		if (type(tabA.def_fire_lvup) == "number") then --每个星级的成长值都一样
			a.def_fire_lvup = tabA.def_fire_lvup
		elseif (type(tabA.def_fire_lvup) == "table") then --每个星级对应不同的成长值
			a.def_fire_lvup = tabA.def_fire_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--毒防每级成长值
	a.def_poison_lvup = 0
	if tabA.def_poison_lvup then
		if (type(tabA.def_poison_lvup) == "number") then --每个星级的成长值都一样
			a.def_poison_lvup = tabA.def_poison_lvup
		elseif (type(tabA.def_poison_lvup) == "table") then --每个星级对应不同的成长值
			a.def_poison_lvup = tabA.def_poison_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--子弹防每级成长值
	a.def_bullet_lvup = 0
	if tabA.def_bullet_lvup then
		if (type(tabA.def_bullet_lvup) == "number") then --每个星级的成长值都一样
			a.def_bullet_lvup = tabA.def_bullet_lvup
		elseif (type(tabA.def_bullet_lvup) == "table") then --每个星级对应不同的成长值
			a.def_bullet_lvup = tabA.def_bullet_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--爆炸防每级成长值
	a.def_bomb_lvup = 0
	if tabA.def_bomb_lvup then
		if (type(tabA.def_bomb_lvup) == "number") then --每个星级的成长值都一样
			a.def_bomb_lvup = tabA.def_bomb_lvup
		elseif (type(tabA.def_bomb_lvup) == "table") then --每个星级对应不同的成长值
			a.def_bomb_lvup = tabA.def_bomb_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--穿刺防每级成长值
	a.def_chuanci_lvup = 0
	if tabA.def_chuanci_lvup then
		if (type(tabA.def_chuanci_lvup) == "number") then --每个星级的成长值都一样
			a.def_chuanci_lvup = tabA.def_chuanci_lvup
		elseif (type(tabA.def_chuanci_lvup) == "table") then --每个星级对应不同的成长值
			a.def_chuanci_lvup = tabA.def_chuanci_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--携弹数量每级成长值
	a.bullet_capacity_lvup = 0
	if tabA.bullet_capacity_lvup then
		if (type(tabA.bullet_capacity_lvup) == "number") then --每个星级的成长值都一样
			a.bullet_capacity_lvup = tabA.bullet_capacity_lvup
		elseif (type(tabA.bullet_capacity_lvup) == "table") then --每个星级对应不同的成长值
			a.bullet_capacity_lvup = tabA.bullet_capacity_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--手雷数量每级成长值
	a.grenade_capacity_lvup = 0
	if tabA.grenade_capacity_lvup then
		if (type(tabA.grenade_capacity_lvup) == "number") then --每个星级的成长值都一样
			a.grenade_capacity_lvup = tabA.grenade_capacity_lvup
		elseif (type(tabA.grenade_capacity_lvup) == "table") then --每个星级对应不同的成长值
			a.grenade_capacity_lvup = tabA.grenade_capacity_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--子母雷数量每级成长值
	a.grenade_child_lvup = 0
	if tabA.grenade_child_lvup then
		if (type(tabA.grenade_child_lvup) == "number") then --每个星级的成长值都一样
			a.grenade_child_lvup = tabA.grenade_child_lvup
		elseif (type(tabA.grenade_child_lvup) == "table") then --每个星级对应不同的成长值
			a.grenade_child_lvup = tabA.grenade_child_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--手雷爆炸火焰每级成长值
	a.grenade_fire_lvup = 0
	if tabA.grenade_fire_lvup then
		if (type(tabA.grenade_fire_lvup) == "number") then --每个星级的成长值都一样
			a.grenade_fire_lvup = tabA.grenade_fire_lvup
		elseif (type(tabA.grenade_fire_lvup) == "table") then --每个星级对应不同的成长值
			a.grenade_fire_lvup = tabA.grenade_fire_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--手雷投弹距离每级成长值
	a.grenade_dis_lvup = 0
	if tabA.grenade_dis_lvup then
		if (type(tabA.grenade_dis_lvup) == "number") then --每个星级的成长值都一样
			a.grenade_dis_lvup = tabA.grenade_dis_lvup
		elseif (type(tabA.grenade_dis_lvup) == "table") then --每个星级对应不同的成长值
			a.grenade_dis_lvup = tabA.grenade_dis_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--手雷冷却时间每级成长值
	a.grenade_cd_lvup = 0
	if tabA.grenade_cd_lvup then
		if (type(tabA.grenade_cd_lvup) == "number") then --每个星级的成长值都一样
			a.grenade_cd_lvup = tabA.grenade_cd_lvup
		elseif (type(tabA.grenade_cd_lvup) == "table") then --每个星级对应不同的成长值
			a.grenade_cd_lvup = tabA.grenade_cd_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--手雷暴击每级成长值
	a.grenade_crit_lvup = 0
	if tabA.grenade_crit_lvup then
		if (type(tabA.grenade_crit_lvup) == "number") then --每个星级的成长值都一样
			a.grenade_crit_lvup = tabA.grenade_crit_lvup
		elseif (type(tabA.grenade_crit_lvup) == "table") then --每个星级对应不同的成长值
			a.grenade_crit_lvup = tabA.grenade_crit_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--手雷冷却前使用次数每级成长值
	a.grenade_multiply_lvup = 0
	if tabA.grenade_multiply_lvup then
		if (type(tabA.grenade_multiply_lvup) == "number") then --每个星级的成长值都一样
			a.grenade_multiply_lvup = tabA.grenade_multiply_lvup
		elseif (type(tabA.grenade_multiply_lvup) == "table") then --每个星级对应不同的成长值
			a.grenade_multiply_lvup = tabA.grenade_multiply_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--惯性每级成长值
	a.inertia_lvup = 0
	if tabA.inertia_lvup then
		if (type(tabA.inertia_lvup) == "number") then --每个星级的成长值都一样
			a.inertia_lvup = tabA.inertia_lvup
		elseif (type(tabA.inertia_lvup) == "table") then --每个星级对应不同的成长值
			a.inertia_lvup = tabA.inertia_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--水晶收益率（去百分号后的值）每级成长值
	a.crystal_rate_lvup = 0
	if tabA.crystal_rate_lvup then
		if (type(tabA.crystal_rate_lvup) == "number") then --每个星级的成长值都一样
			a.crystal_rate_lvup = tabA.crystal_rate_lvup
		elseif (type(tabA.crystal_rate_lvup) == "table") then --每个星级对应不同的成长值
			a.crystal_rate_lvup = tabA.crystal_rate_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--近战弹开每级成长值
	a.melee_bounce_lvup = 0
	if tabA.melee_bounce_lvup then
		if (type(tabA.melee_bounce_lvup) == "number") then --每个星级的成长值都一样
			a.melee_bounce_lvup = tabA.melee_bounce_lvup
		elseif (type(tabA.melee_bounce_lvup) == "table") then --每个星级对应不同的成长值
			a.melee_bounce_lvup = tabA.melee_bounce_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--近战反击每级成长值
	a.melee_fight_lvup = 0
	if tabA.melee_fight_lvup then
		if (type(tabA.melee_fight_lvup) == "number") then --每个星级的成长值都一样
			a.melee_fight_lvup = tabA.melee_fight_lvup
		elseif (type(tabA.melee_fight_lvup) == "table") then --每个星级对应不同的成长值
			a.melee_fight_lvup = tabA.melee_fight_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--近战碎石每级成长值
	a.melee_stone_lvup = 0
	if tabA.melee_stone_lvup then
		if (type(tabA.melee_stone_lvup) == "number") then --每个星级的成长值都一样
			a.melee_stone_lvup = tabA.melee_stone_lvup
		elseif (type(tabA.melee_stone_lvup) == "table") then --每个星级对应不同的成长值
			a.melee_stone_lvup = tabA.melee_stone_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础物理闪避几率（去百分号后的值）每级成长值
	a.dodge_rate_lvup = 0
	if tabA.dodge_rate_lvup then
		if (type(tabA.dodge_rate_lvup) == "number") then --每个星级的成长值都一样
			a.dodge_rate_lvup = tabA.dodge_rate_lvup
		elseif (type(tabA.dodge_rate_lvup) == "table") then --每个星级对应不同的成长值
			a.dodge_rate_lvup = tabA.dodge_rate_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础法术闪避几率（去百分号后的值）每级成长值
	a.dodge_magic_rate_lvup = 0
	if tabA.dodge_magic_rate_lvup then
		if (type(tabA.dodge_magic_rate_lvup) == "number") then --每个星级的成长值都一样
			a.dodge_magic_rate_lvup = tabA.dodge_magic_rate_lvup
		elseif (type(tabA.dodge_magic_rate_lvup) == "table") then --每个星级对应不同的成长值
			a.dodge_magic_rate_lvup = tabA.dodge_magic_rate_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础命中几率（去百分号后的值）每级成长值
	a.hit_rate_lvup = 0
	if tabA.hit_rate_lvup then
		if (type(tabA.hit_rate_lvup) == "number") then --每个星级的成长值都一样
			a.hit_rate_lvup = tabA.hit_rate_lvup
		elseif (type(tabA.hit_rate_lvup) == "table") then --每个星级对应不同的成长值
			a.hit_rate_lvup = tabA.hit_rate_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础暴击几率（去百分号后的值）每级成长值
	a.crit_rate_lvup = 0
	if tabA.crit_rate_lvup then
		if (type(tabA.crit_rate_lvup) == "number") then --每个星级的成长值都一样
			a.crit_rate_lvup = tabA.crit_rate_lvup
		elseif (type(tabA.crit_rate_lvup) == "table") then --每个星级对应不同的成长值
			a.crit_rate_lvup = tabA.crit_rate_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础暴击倍数每级成长值
	a.crit_value_lvup = 0.0
	if tabA.crit_value_lvup then
		if (type(tabA.crit_value_lvup) == "number") then --每个星级的成长值都一样
			a.crit_value_lvup = tabA.crit_value_lvup
		elseif (type(tabA.crit_value_lvup) == "table") then --每个星级对应不同的成长值
			a.crit_value_lvup = tabA.crit_value_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础暴击免伤每级成长值
	a.crit_immue_lvup = 0
	if tabA.crit_immue_lvup then
		if (type(tabA.crit_immue_lvup) == "number") then --每个星级的成长值都一样
			a.crit_immue_lvup = tabA.crit_immue_lvup
		elseif (type(tabA.crit_immue_lvup) == "table") then --每个星级对应不同的成长值
			a.crit_immue_lvup = tabA.crit_immue_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础复活时间每级成长值（毫秒）
	a.rebirth_time_lvup = 0
	if tabA.rebirth_time_lvup then
		if (type(tabA.rebirth_time_lvup) == "number") then --每个星级的成长值都一样
			a.rebirth_time_lvup = tabA.rebirth_time_lvup
		elseif (type(tabA.rebirth_time_lvup) == "table") then --每个星级对应不同的成长值
			a.rebirth_time_lvup = tabA.rebirth_time_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础吸血率每级成长值（去百分号后的值）
	a.suck_blood_rate_lvup = 0
	if tabA.suck_blood_rate_lvup then
		if (type(tabA.suck_blood_rate_lvup) == "number") then --每个星级的成长值都一样
			a.suck_blood_rate_lvup = tabA.suck_blood_rate_lvup
		elseif (type(tabA.suck_blood_rate_lvup) == "table") then --每个星级对应不同的成长值
			a.suck_blood_rate_lvup = tabA.suck_blood_rate_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础主动技能冷却时间变化值每级成长值（毫秒）
	a.active_skill_cd_delta_lvup = 0
	if tabA.active_skill_cd_delta_lvup then
		if (type(tabA.active_skill_cd_delta_lvup) == "number") then --每个星级的成长值都一样
			a.active_skill_cd_delta_lvup = tabA.active_skill_cd_delta_lvup
		elseif (type(tabA.active_skill_cd_delta_lvup) == "table") then --每个星级对应不同的成长值
			a.active_skill_cd_delta_lvup = tabA.active_skill_cd_delta_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础被动技能冷却时间变化值每级成长值（毫秒）
	a.passive_skill_cd_delta_lvup = 0
	if tabA.passive_skill_cd_delta_lvup then
		if (type(tabA.passive_skill_cd_delta_lvup) == "number") then --每个星级的成长值都一样
			a.passive_skill_cd_delta_lvup = tabA.passive_skill_cd_delta_lvup
		elseif (type(tabA.passive_skill_cd_delta_lvup) == "table") then --每个星级对应不同的成长值
			a.passive_skill_cd_delta_lvup = tabA.passive_skill_cd_delta_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础宠物回血每级成长值
	a.pet_hp_restore_lvup = 0
	if tabA.pet_hp_restore_lvup then
		if (type(tabA.pet_hp_restore_lvup) == "number") then --每个星级的成长值都一样
			a.pet_hp_restore_lvup = tabA.pet_hp_restore_lvup
		elseif (type(tabA.pet_hp_restore_lvup) == "table") then --每个星级对应不同的成长值
			a.pet_hp_restore_lvup = tabA.pet_hp_restore_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础宠物生命每级成长值
	a.pet_hp_lvup = 0
	if tabA.pet_hp_lvup then
		if (type(tabA.pet_hp_lvup) == "number") then --每个星级的成长值都一样
			a.pet_hp_lvup = tabA.pet_hp_lvup
		elseif (type(tabA.pet_hp_lvup) == "table") then --每个星级对应不同的成长值
			a.pet_hp_lvup = tabA.pet_hp_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础宠物攻击每级成长值
	a.pet_atk_lvup = 0
	if tabA.pet_atk_lvup then
		if (type(tabA.pet_atk_lvup) == "number") then --每个星级的成长值都一样
			a.pet_atk_lvup = tabA.pet_atk_lvup
		elseif (type(tabA.pet_atk_lvup) == "table") then --每个星级对应不同的成长值
			a.pet_atk_lvup = tabA.pet_atk_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础宠物攻速每级成长值
	a.pet_atk_speed_lvup = 0
	if tabA.pet_atk_speed_lvup then
		if (type(tabA.pet_atk_speed_lvup) == "number") then --每个星级的成长值都一样
			a.pet_atk_speed_lvup = tabA.pet_atk_speed_lvup
		elseif (type(tabA.pet_atk_speed_lvup) == "table") then --每个星级对应不同的成长值
			a.pet_atk_speed_lvup = tabA.pet_atk_speed_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础宠物携带数量每级成长值
	a.pet_capacity_lvup = 0
	if tabA.pet_capacity_lvup then
		if (type(tabA.pet_capacity_lvup) == "number") then --每个星级的成长值都一样
			a.pet_capacity_lvup = tabA.pet_capacity_lvup
		elseif (type(tabA.pet_capacity_lvup) == "table") then --每个星级对应不同的成长值
			a.pet_capacity_lvup = tabA.pet_capacity_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础陷阱时间（单位：毫秒）每级成长值
	a.trap_ground_lvup = 0
	if tabA.trap_ground_lvup then
		if (type(tabA.trap_ground_lvup) == "number") then --每个星级的成长值都一样
			a.trap_ground_lvup = tabA.trap_ground_lvup
		elseif (type(tabA.trap_ground_lvup) == "table") then --每个星级对应不同的成长值
			a.trap_ground_lvup = tabA.trap_ground_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础陷阱施法间隔（单位：毫秒）每级成长值
	a.trap_groundcd_lvup = 0
	if tabA.trap_groundcd_lvup then
		if (type(tabA.trap_groundcd_lvup) == "number") then --每个星级的成长值都一样
			a.trap_groundcd_lvup = tabA.trap_groundcd_lvup
		elseif (type(tabA.trap_groundcd_lvup) == "table") then --每个星级对应不同的成长值
			a.trap_groundcd_lvup = tabA.trap_groundcd_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础陷阱困敌时间（单位：毫秒）每级成长值
	a.trap_groundenemy_lvup = 0
	if tabA.trap_groundenemy_lvup then
		if (type(tabA.trap_groundenemy_lvup) == "number") then --每个星级的成长值都一样
			a.trap_groundenemy_lvup = tabA.trap_groundenemy_lvup
		elseif (type(tabA.trap_groundenemy_lvup) == "table") then --每个星级对应不同的成长值
			a.trap_groundenemy_lvup = tabA.trap_groundenemy_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础天网时间（单位：毫秒）每级成长值
	a.trap_fly_lvup = 0
	if tabA.trap_fly_lvup then
		if (type(tabA.trap_fly_lvup) == "number") then --每个星级的成长值都一样
			a.trap_fly_lvup = tabA.trap_fly_lvup
		elseif (type(tabA.trap_fly_lvup) == "table") then --每个星级对应不同的成长值
			a.trap_fly_lvup = tabA.trap_fly_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础天网施法间隔（单位：毫秒）每级成长值
	a.trap_flycd_lvup = 0
	if tabA.trap_flycd_lvup then
		if (type(tabA.trap_flycd_lvup) == "number") then --每个星级的成长值都一样
			a.trap_flycd_lvup = tabA.trap_flycd_lvup
		elseif (type(tabA.trap_flycd_lvup) == "table") then --每个星级对应不同的成长值
			a.trap_flycd_lvup = tabA.trap_flycd_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础天网困敌时间（单位：毫秒）每级成长值
	a.trap_flyenemy_lvup = 0
	if tabA.trap_flyenemy_lvup then
		if (type(tabA.trap_flyenemy_lvup) == "number") then --每个星级的成长值都一样
			a.trap_flyenemy_lvup = tabA.trap_flyenemy_lvup
		elseif (type(tabA.trap_flyenemy_lvup) == "table") then --每个星级对应不同的成长值
			a.trap_flyenemy_lvup = tabA.trap_flyenemy_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础迷惑几率（去百分号后的值）每级成长值
	a.puzzle_lvup = 0
	if tabA.puzzle_lvup then
		if (type(tabA.puzzle_lvup) == "number") then --每个星级的成长值都一样
			a.puzzle_lvup = tabA.puzzle_lvup
		elseif (type(tabA.puzzle_lvup) == "table") then --每个星级对应不同的成长值
			a.puzzle_lvup = tabA.puzzle_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础射击暴击每级成长值
	a.weapon_crit_shoot_lvup = 0
	if tabA.weapon_crit_shoot_lvup then
		if (type(tabA.weapon_crit_shoot_lvup) == "number") then --每个星级的成长值都一样
			a.weapon_crit_shoot_lvup = tabA.weapon_crit_shoot_lvup
		elseif (type(tabA.weapon_crit_shoot_lvup) == "table") then --每个星级对应不同的成长值
			a.weapon_crit_shoot_lvup = tabA.weapon_crit_shoot_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础冰冻暴击每级成长值
	a.weapon_crit_frozen_lvup = 0
	if tabA.weapon_crit_frozen_lvup then
		if (type(tabA.weapon_crit_frozen_lvup) == "number") then --每个星级的成长值都一样
			a.weapon_crit_frozen_lvup = tabA.weapon_crit_frozen_lvup
		elseif (type(tabA.weapon_crit_frozen_lvup) == "table") then --每个星级对应不同的成长值
			a.weapon_crit_frozen_lvup = tabA.weapon_crit_frozen_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础火焰暴击每级成长值
	a.weapon_crit_fire_lvup = 0
	if tabA.weapon_crit_fire_lvup then
		if (type(tabA.weapon_crit_fire_lvup) == "number") then --每个星级的成长值都一样
			a.weapon_crit_fire_lvup = tabA.weapon_crit_fire_lvup
		elseif (type(tabA.weapon_crit_fire_lvup) == "table") then --每个星级对应不同的成长值
			a.weapon_crit_fire_lvup = tabA.weapon_crit_fire_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础装备暴击每级成长值
	a.weapon_crit_equip_lvup = 0
	if tabA.weapon_crit_equip_lvup then
		if (type(tabA.weapon_crit_equip_lvup) == "number") then --每个星级的成长值都一样
			a.weapon_crit_equip_lvup = tabA.weapon_crit_equip_lvup
		elseif (type(tabA.weapon_crit_equip_lvup) == "table") then --每个星级对应不同的成长值
			a.weapon_crit_equip_lvup = tabA.weapon_crit_equip_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础击退暴击每级成长值
	a.weapon_crit_hit_lvup = 0
	if tabA.weapon_crit_hit_lvup then
		if (type(tabA.weapon_crit_hit_lvup) == "number") then --每个星级的成长值都一样
			a.weapon_crit_hit_lvup = tabA.weapon_crit_hit_lvup
		elseif (type(tabA.weapon_crit_hit_lvup) == "table") then --每个星级对应不同的成长值
			a.weapon_crit_hit_lvup = tabA.weapon_crit_hit_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础吹风暴击每级成长值
	a.weapon_crit_blow_lvup = 0
	if tabA.weapon_crit_blow_lvup then
		if (type(tabA.weapon_crit_blow_lvup) == "number") then --每个星级的成长值都一样
			a.weapon_crit_blow_lvup = tabA.weapon_crit_blow_lvup
		elseif (type(tabA.weapon_crit_blow_lvup) == "table") then --每个星级对应不同的成长值
			a.weapon_crit_blow_lvup = tabA.weapon_crit_blow_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--基础毒液暴击每级成长值
	a.weapon_crit_poison_lvup = 0
	if tabA.weapon_crit_poison_lvup then
		if (type(tabA.weapon_crit_poison_lvup) == "number") then --每个星级的成长值都一样
			a.weapon_crit_poison_lvup = tabA.weapon_crit_poison_lvup
		elseif (type(tabA.weapon_crit_poison_lvup) == "table") then --每个星级对应不同的成长值
			a.weapon_crit_poison_lvup = tabA.weapon_crit_poison_lvup[a.star] or 0
		else --不合法的格式
			--
		end
	end
	
	--print(type_id, tabA.hp, a.lv, a.hp_lvup)
	a.hp_max = (tabA.hp or 1) + ((a.lv - 1) * a.hp_lvup) --基础血量最大值
	--a.hp = a.hp_max --当前血量（一开始等于最大值）
	a.atk_min = (tabA.attack and tabA.attack[4] or 0) + ((a.lv - 1) * a.atk_min_lvup) --攻击力最小值
	a.atk_max = (tabA.attack and tabA.attack[5] or 0) + ((a.lv - 1) * a.atk_max_lvup) --攻击力最大值
	local atk_basic = math.floor((a.atk_min + a.atk_min) / 2)
	a.atk_ice = (tabA.atk_ice or 0) + ((a.lv - 1) * a.atk_ice_lvup) + atk_basic --基础冰攻击力
	a.atk_thunder = (tabA.atk_thunder or 0) + ((a.lv - 1) * a.atk_thunder_lvup) + atk_basic --基础雷攻击力
	a.atk_fire = (tabA.atk_fire or 0) + ((a.lv - 1) * a.atk_fire_lvup) + atk_basic --基础火攻击力
	a.atk_poison = (tabA.atk_poison or 0) + ((a.lv - 1) * a.atk_poison_lvup) + atk_basic --基础毒攻击力
	a.atk_bullet = (tabA.atk_bullet or 0) + ((a.lv - 1) * a.atk_bullet_lvup) + atk_basic --基础子弹攻击力
	a.atk_bomb = (tabA.atk_bomb or 0) + ((a.lv - 1) * a.atk_bomb_lvup) + atk_basic --基础爆炸攻击力
	a.atk_chuanci = (tabA.atk_chuanci or 0) + ((a.lv - 1) * a.atk_chuanci_lvup) + atk_basic --基础穿刺攻击力
	a.hp_restore = (tabA.hp_restore or 0) + ((a.lv - 1) * a.hp_restore_lvup) --基础回血速度（每秒）（支持小数）
	a.move_speed = (tabA.move_speed or hVar.BATTLEFIELD_MOVE_SPEED) + ((a.lv - 1) * a.move_speed_lvup) --基础移动速度
	a.atk_radius = (tabA.atk_radius or 0) + ((a.lv - 1) * a.atk_radius_lvup) --基础攻击范围
	a.atk_radius_min = (tabA.atk_radius_min or 0) + ((a.lv - 1) * a.atk_radius_min_lvup) --基础攻击范围最小值
	--a.atk_search_radius = tabA.atk_search_radius or 0 --基础攻击搜敌范围
	a.atk_interval = (tabA.atk_interval or 0) + ((a.lv - 1) * a.atk_interval_lvup) --基础攻击间隔（毫秒）
	a.atk_speed_basic = (tabA.atk_speed or 100) + ((a.lv - 1) * a.atk_speed_lvup) --基础攻击速度（去百分号后的值）
	a.atk_speed = 0 --附加攻击速度（去百分号后的值）
	a.def_physic = (tabA.def_physic or 0) + ((a.lv - 1) * a.def_physic_lvup) --基础物理防御
	a.def_magic = (tabA.def_magic or 0) + ((a.lv - 1) * a.def_magic_lvup) --基础法术防御
	a.def_ice = (tabA.def_ice or 0) + ((a.lv - 1) * a.def_ice_lvup) --基础冰防御
	a.def_thunder = (tabA.def_thunder or 0) + ((a.lv - 1) * a.def_thunder_lvup) --基础雷防御
	a.def_fire = (tabA.def_fire or 0) + ((a.lv - 1) * a.def_fire_lvup) --基础火防御
	a.def_poison = (tabA.def_poison or 0) + ((a.lv - 1) * a.def_poison_lvup) --基础毒防御
	a.def_bullet = (tabA.def_bullet or 0) + ((a.lv - 1) * a.def_bullet_lvup) --基础子弹防御
	a.def_bomb = (tabA.def_bomb or 0) + ((a.lv - 1) * a.def_bomb_lvup) --基础爆炸防御
	a.def_chuanci = (tabA.def_chuanci or 0) + ((a.lv - 1) * a.def_chuanci_lvup) --基础穿刺防御
	a.bullet_capacity = (tabA.bullet_capacity or 0) + ((a.lv - 1) * a.bullet_capacity_lvup) --基础携弹数量
	a.grenade_capacity = (tabA.grenade_capacity or 0) + ((a.lv - 1) * a.grenade_capacity_lvup) --基础手雷数量
	a.grenade_child = (tabA.grenade_child or 0) + ((a.lv - 1) * a.grenade_child_lvup) --基础子母雷数量
	a.grenade_fire = (tabA.grenade_fire or 0) + ((a.lv - 1) * a.grenade_fire_lvup) --基础手雷爆炸火焰
	a.grenade_dis = (tabA.grenade_dis or 100) + ((a.lv - 1) * a.grenade_dis_lvup) --基础手雷投弹距离
	a.grenade_cd = (tabA.grenade_cd or 0) + ((a.lv - 1) * a.grenade_cd_lvup) --基础手雷冷却时间
	a.grenade_crit = (tabA.grenade_crit or 0) + ((a.lv - 1) * a.grenade_crit_lvup) --基础手雷暴击
	a.grenade_multiply = (tabA.grenade_multiply or 1) + ((a.lv - 1) * a.grenade_multiply_lvup) --基础手雷冷却前使用次数
	a.inertia = (tabA.inertia or 0) + ((a.lv - 1) * a.inertia_lvup) --基础惯性
	a.crystal_rate = (tabA.crystal_rate or 0) + ((a.lv - 1) * a.crystal_rate_lvup) --基础水晶收益率（去百分号后的值）
	a.melee_bounce = (tabA.melee_bounce or 0) + ((a.lv - 1) * a.melee_bounce_lvup) --基础近战弹开
	a.melee_fight = (tabA.melee_fight or 0) + ((a.lv - 1) * a.melee_fight_lvup) --基础近战反击
	a.melee_stone = (tabA.melee_stone or 0) + ((a.lv - 1) * a.melee_stone_lvup) --基础近战碎石
	a.dodge_rate = (tabA.dodge_rate or 0) + ((a.lv - 1) * a.dodge_rate_lvup) --基础物理闪避几率（去百分号后的值）
	a.dodge_magic_rate = (tabA.dodge_magic_rate or 0) + ((a.lv - 1) * a.dodge_magic_rate_lvup) --基础法术闪避几率（去百分号后的值）
	a.hit_rate = (tabA.hit_rate or 0) + ((a.lv - 1) * a.hit_rate_lvup) --基础命中几率（去百分号后的值）
	a.crit_rate = (tabA.crit_rate or 0) + ((a.lv - 1) * a.crit_rate_lvup) --基础暴击几率（去百分号后的值）
	a.crit_value = (tabA.crit_value or 2.0) + ((a.lv - 1) * a.crit_value_lvup) --基础暴击倍数（支持小数）
	a.crit_immue = (tabA.crit_immue or 0) + ((a.lv - 1) * a.crit_immue_lvup) --基础暴击免伤
	a.escape_punish = tabA.escape_punish or 0 --基础逃怪惩罚
	a.kill_gold = tabA.kill_gold or 0 --基础击杀奖励金币
	a.rebirth_time = (tabA.rebirth_time or 10000) + ((a.lv - 1) * a.rebirth_time_lvup) --基础复活时间（毫秒）
	a.suck_blood_rate = (tabA.suck_blood_rate or 0) + ((a.lv - 1) * a.suck_blood_rate_lvup) --基础吸血率（去百分号后的值）
	a.active_skill_cd_delta = (tabA.active_skill_cd_delta or 0) + ((a.lv - 1) * a.active_skill_cd_delta_lvup) --基础主动技能冷却时间变化值（毫秒）
	a.passive_skill_cd_delta = (tabA.passive_skill_cd_delta or 0) + ((a.lv - 1) * a.passive_skill_cd_delta_lvup) --基础被动技能冷却时间变化值（毫秒）
	a.active_skill_cd_delta_rate = 0 --基础主动技能冷却时间变化比例值（去百分号后的值）
	a.passive_skill_cd_delta_rate = 0 --基础被动技能冷却时间变化比例值（去百分号后的值）
	a.hp_restore_delta_rate = 0 --回血倍率比例值（去百分号后的值）
	a.pet_hp_restore = (tabA.pet_hp_restore or 0) + ((a.lv - 1) * a.pet_hp_restore_lvup) --基础宠物回血
	a.pet_hp = (tabA.pet_hp or 0) + ((a.lv - 1) * a.pet_hp_lvup) --基础宠物生命
	a.pet_atk = (tabA.pet_atk or 0) + ((a.lv - 1) * a.pet_atk_lvup) --基础宠物攻击
	a.pet_atk_speed = (tabA.pet_atk_speed or 0) + ((a.lv - 1) * a.pet_atk_speed_lvup) --基础宠物攻速
	a.pet_capacity = (tabA.pet_capacity or 0) + ((a.lv - 1) * a.pet_capacity_lvup) --基础宠物携带数量
	a.trap_ground = (tabA.trap_ground or 0) + ((a.lv - 1) * a.trap_ground_lvup) --基础陷阱时间（单位：毫秒）
	a.trap_groundcd = (tabA.trap_groundcd or 30000) + ((a.lv - 1) * a.trap_groundcd_lvup) --基础陷阱施法间隔（单位：毫秒）
	a.trap_groundenemy = (tabA.trap_groundenemy or 2000) + ((a.lv - 1) * a.trap_groundenemy_lvup) --基础陷阱困敌时间（单位：毫秒）
	a.trap_fly = (tabA.trap_fly or 0) + ((a.lv - 1) * a.trap_fly_lvup) --基础天网时间（单位：毫秒）
	a.trap_flycd = (tabA.trap_flycd or 30000) + ((a.lv - 1) * a.trap_flycd_lvup) --基础天网施法间隔（单位：毫秒）
	a.trap_flyenemy = (tabA.trap_flyenemy or 2000) + ((a.lv - 1) * a.trap_flyenemy_lvup) --基础天网困敌时间（单位：毫秒）
	a.puzzle = (tabA.puzzle or 0) + ((a.lv - 1) * a.puzzle_lvup) --基础迷惑几率（去百分号后的值）
	a.weapon_crit_shoot = (tabA.weapon_crit_shoot or 0) + ((a.lv - 1) * a.weapon_crit_shoot_lvup) --基础射击暴击
	a.weapon_crit_frozen = (tabA.weapon_crit_frozen or 0) + ((a.lv - 1) * a.weapon_crit_frozen_lvup) --基础冰冻暴击
	a.weapon_crit_fire = (tabA.weapon_crit_fire or 0) + ((a.lv - 1) * a.weapon_crit_fire_lvup) --基础火焰暴击
	a.weapon_crit_equip = (tabA.weapon_crit_equip or 0) + ((a.lv - 1) * a.weapon_crit_equip_lvup) --基础装备暴击
	a.weapon_crit_hit = (tabA.weapon_crit_hit or 0) + ((a.lv - 1) * a.weapon_crit_hit_lvup) --基础击退暴击
	a.weapon_crit_blow = (tabA.weapon_crit_blow or 0) + ((a.lv - 1) * a.weapon_crit_blow_lvup) --基础吹风暴击
	a.weapon_crit_poison = (tabA.weapon_crit_poison or 0) + ((a.lv - 1) * a.weapon_crit_poison_lvup) --基础毒液暴击
	
	a.AI_attribute = tabA.AI_attribute or hVar.AI_ATTRIBUTE_TYPE.POSITIVE --AI行为类型
	a.skill_AI_sequence = (tabA.skill_AI_sequence or 0)--geyachao: 新加数据 技能释放AI规则表
	
	a.is_taunt = tabA.is_taunt or 0 --geyachao: 新加数据 是否是嘲讽单位（敌人见到就打）
	a.taunt_radius = tabA.taunt_radius or 0 --geyachao: 新加数据 嘲讽半径
	
	a.space_type = tabA.space_type or hVar.UNIT_SPACE_TYPE.SPACE_GROUND --单位的空间类型（0:地面单位 / 1:空中单位）
	a.atk_space_type = tabA.atk_space_type or hVar.UNIT_ATTACK_SPACE_TYPE.ATTACK_SPACE_GROUND --单位可攻击的目标空间的类型（0: 可攻击地面单位 / 1:可攻击地面单位和空中单位 / 2:可攻击空中单位）
	
	--print("name=" .. hVar.tab_unit[type_id].name .. ", level=" .. a.lv .. ", star=" .. a.star .. ", hp_max=" .. a.hp_max .. ", atk_min=" .. a.atk_min .. ", atk_max=" .. a.atk_max .. ", hp_restore=" .. a.hp_restore .. ", move_speed=" .. a.move_speed .. ", atk_radius=" .. a.atk_radius .. ", atk_interval=" .. a.atk_interval .. ", def_physic=" .. a.def_physic .. ", def_magic=" .. a.def_magic .. ", dodge_rate=" .. a.dodge_rate .. ", dodge_magic_rate=" .. a.dodge_magic_rate .. ", hit_rate=" .. a.hit_rate .. ", crit_rate=" .. a.crit_rate .. ", crit_value=" .. a.crit_value .. ", crit_immue=" .. a.crit_immue)
	
	--如果是战车，附加天赋属性作为基础属性
	if (type_id == hVar.MY_TANK_ID) then --我的坦克
		local tTalentTree = LuaGetTalentTree()
		for it = 1, #tTalentTree, 1 do
			local tTalent = tTalentTree[it]
			local id = tTalent[1]
			local lv = tTalent[2]
			--print(id, id)
			local tAttr = hVar.TANK_TAKENT_TREE[id]
			if tAttr then
				local attrType = tAttr.attrType --属性类型
				local attrValueAdd = tAttr.attrAdd[lv] or 0 --属性值
				local attrTypeAdd = attrType .. "" --attrType .. "_basic"
				if (attrType == "atk") then --攻击力存储到战术卡上
					attrTypeAdd = attrType .. "" --attrType .. "_tactic"
				end
				--print("attrType=", attrType, "attrTypeAdd=", attrTypeAdd)
				if attrTypeAdd then
					a[attrTypeAdd] = a[attrTypeAdd] + attrValueAdd
				end
			end
		end
	end
	
	--如果是战车，附加自身的天赋技能
	if (type_id == hVar.MY_TANK_ID) then --我的坦克
		local tTalentTree = tabU.talent_tree
		for skillIdx = 1, #tTalentTree, 1 do
			local talentid = tTalentTree[skillIdx]
			local skillLv = LuaGetHeroTalentSkillLv(type_id, talentid)
			local tTalent = hVar.tab_chariottalent[talentid]
			if tTalent and (skillLv > 0) then
				--print(skillIdx, skillLv)
				local attrAdd = tTalent.attrAdd
				--print("attrAdd=", attrAdd)
				if attrAdd then
					local tAttr = attrAdd[skillLv]
					if tAttr then
						for ai = 1, #tAttr, 1 do
							local tAttr_i = tAttr[ai]
							local attrType = tAttr_i[1] --属性类型
							local attrValue = tAttr_i[2] --属性值
							--print("attrType=", attrType)
							--print("attrValue=", attrValue)
							local attrTypeAdd = attrType .. "" --attrType .. "_basic"
							if (attrType == "atk") then --攻击力存储到战术卡上
								attrTypeAdd = attrType .. "" --attrType .. "_tactic"
							end
							if attrTypeAdd then
								a[attrTypeAdd] = (a[attrTypeAdd] or 0) + attrValue
							end
						end
					end
				end
			end
		end
	end
	
	--读取技能里被动技能，永久增加自身属性的
	local talentNum = 0
	local starInfo = hVar.HERO_STAR_INFO[type_id] and hVar.HERO_STAR_INFO[type_id][star]
	if starInfo and (type(starInfo) == "table") then
		talentNum = starInfo.unlockSkillNum or 0
		if (talentNum > 0) then
			--if (lv == starInfo.maxLv) then --该英雄的等级达到了星级要求的最大等级
				local tTalent = tabU.talent
				if tTalent then
					--for s = 1, #tTalent, 1 do
					for s = 1, talentNum, 1 do
						local tSkill = tTalent[s] or {}
						local skillId = tSkill[1] or 0 --天赋技能id
						if (skillId > 0) then
							local tabS = hVar.tab_skill[skillId]
							if tabS then
								local skillType = tabS.cast_type
								local action = tabS.action
								if (skillType == hVar.CAST_TYPE.AUTO) then --被动技能
									--遍历action，找出类型是"AddAttr_Buff"的
									for ac = 1, #action, 1 do
										--{"AddAttr_Buff", "hp_max", "@lv*100+100"},
										local ac1 = action[ac][1]
										if (ac1 == "AddAttr_Buff") then
											local ac2 = action[ac][2]
											local ac3 = action[ac][3]
											local num = 0
											
											--解析表达式中的"@lv"
											if (type(ac3) == "string") then
												--[[
												local pp = "@lv"
												local atlv = string.find(ac3, pp)
												while (atlv ~= nil) do
													--前
													local prep = ""
													if (atlv > 1) then
														prep = string.sub(ac3, 1, atlv - 1)
													end
													
													--后
													local post = ""
													if (atlv < (#ac3 - 3 + 1)) then
														post = string.sub(ac3, atlv + 3, #ac3)
													end
													
													--重组
													--print()
													--print(":", ac3)
													ac3 = prep .. lv .. post
													--print("~", ac3)
													
													--继续查找
													atlv = string.find(ac3, pp)
												end
												
												--解析表达式
												local sac3 = "local tmp = "..(ac3).." return tmp"
												num = assert(loadstring(sac3))()
												]]
												--local lv = 1
												local strExpress = ac3
												num = hApi.AnalyzeValueExpr(nil, nil, {["@lv"] = lv,}, strExpress, 0)
											elseif (type(ac3) == "number") then
												num = ac3
											end
											
											--print()
											--print(ac2, num)
											
											if (ac2 == "hp_max") then --血量
												a.hp_max = a.hp_max + num
												--a.hp = a.hp + num
											elseif (ac2 == "atk") then --攻击力
												a.atk_min = a.atk_min + num
												a.atk_max = a.atk_max + num
											elseif (ac2 == "atk_min") then --最小攻击力
												a.atk_min = a.atk_min + num
											elseif (ac2 == "atk_max") then --最大攻击力
												a.atk_max = a.atk_max + num
											elseif (ac2 == "atk_ice") then --冰攻击力
												a.atk_ice = a.atk_ice + num
											elseif (ac2 == "atk_thunder") then --雷攻击力
												a.atk_thunder = a.atk_thunder + num
											elseif (ac2 == "atk_fire") then --火攻击力
												a.atk_fire = a.atk_fire + num
											elseif (ac2 == "atk_poison") then --毒攻击力
												a.atk_poison = a.atk_poison + num
											elseif (ac2 == "atk_bullet") then --子弹攻击力
												a.atk_bullet = a.atk_bullet + num
											elseif (ac2 == "atk_bomb") then --爆炸攻击力
												a.atk_bomb = a.atk_bomb + num
											elseif (ac2 == "atk_chuanci") then --穿刺攻击力
												a.atk_chuanci = a.atk_chuanci + num
											elseif (ac2 == "atk_interval") then --攻击间隔（毫秒）
												a.atk_interval = a.atk_interval + num
											elseif (ac2 == "atk_speed") then --攻击速度（去百分号后的值）
												a.atk_speed = a.atk_speed + num
											elseif (ac2 == "move_speed") then --移动速度
												a.move_speed = a.move_speed + num
											elseif (ac2 == "atk_radius") then --攻击范围
												a.atk_radius = a.atk_radius + num
											elseif (ac2 == "atk_radius_min") then --攻击范围最小值
												a.atk_radius_min = a.atk_radius_min + num
											elseif (ac2 == "def_physic") then --物理防御
												a.def_physic = a.def_physic + num
											elseif (ac2 == "def_magic") then --法术防御
												a.def_magic = a.def_magic + num
											elseif (ac2 == "def_ice") then --冰防御
												a.def_ice = a.def_ice + num
											elseif (ac2 == "def_thunder") then --雷防御
												a.def_thunder = a.def_thunder + num
											elseif (ac2 == "def_fire") then --火防御
												a.def_fire = a.def_fire + num
											elseif (ac2 == "def_poison") then --毒防御
												a.def_poison = a.def_poison + num
											elseif (ac2 == "def_bullet") then --子弹防御
												a.def_bullet = a.def_bullet + num
											elseif (ac2 == "def_bomb") then --爆炸防御
												a.def_bomb = a.def_bomb + num
											elseif (ac2 == "def_chuanci") then --穿刺防御
												a.def_chuanci = a.def_chuanci + num
											elseif (ac2 == "bullet_capacity") then --携弹数量
												a.bullet_capacity = a.bullet_capacity + num
											elseif (ac2 == "grenade_capacity") then --手雷数量
												a.grenade_capacity = a.grenade_capacity + num
											elseif (ac2 == "grenade_child") then --子母雷数量
												a.grenade_child = a.grenade_child + num
											elseif (ac2 == "grenade_fire") then --手雷爆炸火焰
												a.grenade_fire = a.grenade_fire + num
											elseif (ac2 == "grenade_dis") then --手雷投弹距离
												a.grenade_dis = a.grenade_dis + num
											elseif (ac2 == "grenade_cd") then --手雷冷却时间（单位：毫秒）
												a.grenade_cd = a.grenade_cd + num
											elseif (ac2 == "grenade_crit") then --手雷暴击
												a.grenade_crit = a.grenade_crit + num
											elseif (ac2 == "grenade_multiply") then --手雷冷却前使用次数
												a.grenade_multiply = a.grenade_multiply + num
											elseif (ac2 == "inertia") then --惯性
												a.inertia = a.inertia + num
											elseif (ac2 == "crystal_rate") then --水晶收益率（去百分号后的值）
												a.crystal_rate = a.crystal_rate + num
											elseif (ac2 == "melee_bounce") then --近战弹开
												a.melee_bounce = a.melee_bounce + num
											elseif (ac2 == "melee_fight") then --近战反击
												a.melee_fight = a.melee_fight + num
											elseif (ac2 == "melee_stone") then --近战碎石
												a.melee_stone = a.melee_stone + num
											elseif (ac2 == "dodge_rate") or (ac2 == "dodge_physic_rate") then --物理闪避几率（去百分号后的值）
												a.dodge_rate = a.dodge_rate + num
											elseif (ac2 == "dodge_magic_rate") then --法术闪避几率（去百分号后的值）
												a.dodge_magic_rate = a.dodge_magic_rate + num
											elseif (ac2 == "hit_rate") then --命中几率（去百分号后的值）
												a.hit_rate = a.hit_rate + num
											elseif (ac2 == "crit_rate") then --暴击几率（去百分号后的值）
												a.crit_rate = a.crit_rate + num
											elseif (ac2 == "crit_value") then --暴击倍数（支持小数）
												a.crit_value = a.crit_value + num
											elseif (ac2 == "crit_immue") then --暴击免伤
												a.crit_immue = a.crit_immue + num
											elseif (ac2 == "kill_gold") then --击杀获得的金币
												a.kill_gold = a.kill_gold + num
											elseif (ac2 == "escape_punish") then --逃怪惩罚
												a.escape_punish = a.escape_punish + num
											elseif (ac2 == "hp_restore") then --回血速度（每秒）（支持小数）
												a.hp_restore = a.hp_restore + num
											elseif (ac2 == "AI_attribute") then --AI行为（0：被动怪 / 1:主动怪）
												a.AI_attribute = a.AI_attribute + num
											elseif (ac2 == "rebirth_time") then --复活时间（毫秒）
												a.rebirth_time = a.rebirth_time + num
											elseif (ac2 == "suck_blood_rate") then --吸血率（去百分号后的值）
												a.suck_blood_rate = a.suck_blood_rate + num
											elseif (ac2 == "active_skill_cd_delta") then --主动技能冷却时间变化值（毫秒）
												a.active_skill_cd_delta = a.active_skill_cd_delta + num
											elseif (ac2 == "passive_skill_cd_delta") then --被动技能冷却时间变化值（毫秒）
												a.passive_skill_cd_delta = a.passive_skill_cd_delta + num
											elseif (ac2 == "active_skill_cd_delta_rate") then --主动技能冷却时间变化比例值（去百分号后的值）
												a.active_skill_cd_delta_rate = a.active_skill_cd_delta_rate + num
											elseif (ac2 == "passive_skill_cd_delta_rate") then --被动技能冷却时间变化比例值（去百分号后的值）
												a.passive_skill_cd_delta_rate = a.passive_skill_cd_delta_rate + num
											elseif (ac2 == "hp_restore_delta_rate") then --回血倍率比例值（去百分号后的值）
												a.hp_restore_delta_rate = a.hp_restore_delta_rate + num
											elseif (ac2 == "hp_max_rate") then --血量（去百分号后的值）
												local value = math.floor(hp_max_basic * num / 100)
												a.hp_max = a.hp_max + value
											elseif (ac2 == "atk_rate") then --攻击力（去百分号后的值）
												local value = math.floor(atk_basic * num / 100)
												a.atk_min = a.atk_min + value
												a.atk_max = a.atk_max + value
											elseif (ac2 == "atk_radius_rate") then --攻击范围（去百分号后的值）
												local value = math.floor(atk_radius_basic * num / 100)
												a.atk_radius = a.atk_radius + value
											elseif (ac2 == "pet_hp_restore") then --宠物回血
												a.pet_hp_restore = a.pet_hp_restore + num
											elseif (ac2 == "pet_hp") then --宠物生命
												a.pet_hp = a.pet_hp + num
											elseif (ac2 == "pet_atk") then --宠物攻击
												a.pet_atk = a.pet_atk + num
											elseif (ac2 == "pet_atk_speed") then --宠物攻速
												a.pet_atk_speed = a.pet_atk_speed + num
											elseif (ac2 == "pet_capacity") then --宠物携带数量
												a.pet_capacity = a.pet_capacity + num
											elseif (ac2 == "trap_ground") then --陷阱时间（单位：毫秒）
												a.trap_ground = a.trap_ground + num
											elseif (ac2 == "trap_groundcd") then --陷阱施法间隔（单位：毫秒）
												a.trap_groundcd = a.trap_groundcd + num
											elseif (ac2 == "trap_groundenemy") then --陷阱困敌时间（单位：毫秒）
												a.trap_groundenemy = a.trap_groundenemy + num
											elseif (ac2 == "trap_fly") then --天网时间（单位：毫秒）
												a.trap_fly = a.trap_fly + num
											elseif (ac2 == "trap_flycd") then --天网施法间隔（单位：毫秒）
												a.trap_flycd = a.trap_flycd + num
											elseif (ac2 == "trap_flyenemy") then --天网困敌时间（单位：毫秒）
												a.trap_flyenemy = a.trap_flyenemy + num
											elseif (ac2 == "puzzle") then --迷惑几率（去百分号后的值）
												a.puzzle = a.puzzle + num
											elseif (ac2 == "weapon_crit_shoot") then --武器暴击
												a.weapon_crit_shoot = a.weapon_crit_shoot + num
											elseif (ac2 == "weapon_crit_frozen") then --冰冻暴击
												a.weapon_crit_frozen = a.weapon_crit_frozen + num
											elseif (ac2 == "weapon_crit_fire") then --火焰暴击
												a.weapon_crit_fire = a.weapon_crit_fire + num
											elseif (ac2 == "weapon_crit_equip") then --装备暴击
												a.weapon_crit_equip = a.weapon_crit_equip + num
											elseif (ac2 == "weapon_crit_hit") then --击退暴击
												a.weapon_crit_hit = a.weapon_crit_hit + num
											elseif (ac2 == "weapon_crit_blow") then --吹风暴击
												a.weapon_crit_blow = a.weapon_crit_blow + num
											elseif (ac2 == "weapon_crit_poison") then --毒液暴击
												a.weapon_crit_poison = a.weapon_crit_poison + num
											end
										end
									end
								end
							end
						end
					end
				end
			--end
		end
	end
	
	-------------------------------------------------
	--存储基础属性
	aBasic.hp_max = a.hp_max
	aBasic.atk_min = a.atk_min
	aBasic.atk_max = a.atk_max
	aBasic.atk_radius = a.atk_radius
	aBasic.atk_ice = a.atk_ice --基础冰攻击力
	aBasic.atk_thunder = a.atk_thunder --基础雷攻击力
	aBasic.atk_fire = a.atk_fire --基础火攻击力
	aBasic.atk_poison = a.atk_poison --基础毒攻击力
	aBasic.atk_bullet = a.atk_bullet --基础子弹攻击力
	aBasic.atk_bomb = a.atk_bomb --基础爆炸攻击力
	aBasic.atk_chuanci = a.atk_chuanci --基础穿刺攻击力
	aBasic.move_speed = a.move_speed
	aBasic.atk_interval = a.atk_interval
	aBasic.atk_speed = a.atk_speed
	aBasic.def_physic = a.def_physic
	aBasic.def_magic = a.def_magic
	aBasic.def_ice = a.def_ice --基础冰防御
	aBasic.def_thunder = a.def_thunder --基础雷防御
	aBasic.def_fire = a.def_fire --基础火防御
	aBasic.def_poison = a.def_poison --基础毒防御
	aBasic.def_bullet = a.def_bullet --基础子弹防御
	aBasic.def_bomb = a.def_bomb --基础爆炸防御
	aBasic.def_chuanci = a.def_chuanci --基础穿刺防御
	aBasic.bullet_capacity = a.bullet_capacity --基础携弹数量
	aBasic.grenade_capacity = a.grenade_capacity --基础手雷数量
	aBasic.grenade_child = a.grenade_child --基础子母雷数量
	aBasic.grenade_fire = a.grenade_fire --基础手雷爆炸火焰
	aBasic.grenade_dis = a.grenade_dis --基础手雷投弹距离
	aBasic.grenade_cd = a.grenade_cd --基础手雷冷却时间
	aBasic.grenade_crit = a.grenade_crit --基础手雷暴击
	aBasic.grenade_multiply = a.grenade_multiply --基础手雷冷却前使用次数
	aBasic.inertia = a.inertia --基础惯性
	aBasic.crystal_rate = a.crystal_rate --基础水晶收益率（去百分号后的值）
	aBasic.melee_bounce = a.melee_bounce --基础近战弹开
	aBasic.melee_fight = a.melee_fight --基础--近战反击
	aBasic.melee_stone = a.melee_stone --基础--近战碎石
	aBasic.crit_rate = a.crit_rate
	aBasic.crit_value = a.crit_value
	aBasic.pet_hp_restore = a.pet_hp_restore --基础宠物回血
	aBasic.pet_hp = a.pet_hp --基础宠物生命
	aBasic.pet_atk = a.pet_atk --基础宠物攻击
	aBasic.pet_atk_speed = a.pet_atk_speed --基础宠物攻速
	aBasic.pet_capacity = a.pet_capacity --基础宠物携带数量
	aBasic.trap_ground = a.trap_ground --基础陷阱时间（单位：毫秒）
	aBasic.trap_groundcd = a.trap_groundcd --基础陷阱施法间隔（单位：毫秒）
	aBasic.trap_groundenemy = a.trap_groundenemy --基础陷阱困敌时间（单位：毫秒）
	aBasic.trap_fly = a.trap_fly --基础天网时间（单位：毫秒）
	aBasic.trap_flycd = a.trap_flycd --基础天网施法间隔（单位：毫秒）
	aBasic.trap_flyenemy = a.trap_flyenemy --基础天网困敌时间（单位：毫秒）
	aBasic.puzzle = a.puzzle --基础迷惑几率（去百分号后的值）
	aBasic.weapon_crit_shoot = a.weapon_crit_shoot --基础武器暴击
	aBasic.weapon_crit_frozen = a.weapon_crit_frozen --基础冰冻暴击
	aBasic.weapon_crit_fire = a.weapon_crit_fire --基础火焰暴击
	aBasic.weapon_crit_equip = a.weapon_crit_equip --基础装备暴击
	aBasic.weapon_crit_hit = a.weapon_crit_hit --基础击退暴击
	aBasic.weapon_crit_blow = a.weapon_crit_blow --基础吹风暴击
	aBasic.weapon_crit_poison = a.weapon_crit_poison --基础毒液暴击
	
	-------------------------------------------------
	local atk_basic = math.floor((a.atk_min + a.atk_min) / 2)
	local hp_max_basic = a.hp_max
	local atk_radius_basic = a.atk_radius
	
	--读取装备栏的附加属性
	if equipment and (type(equipment) == "table") then
		for k = 1, #equipment, 1 do
			--装备表
			--local item = equipment[k]
			local uniqueId = equipment[k]
			--print("uniqueId=", uniqueId)
			local _, item = LuaFindEquipByUniqueId(uniqueId)
			
			if (type(item) == "table") then
				local item_id = item[1] --道具id
				
				if item_id and (item_id ~= 0) then
					local tabItem = hVar.tab_item[item_id] --道具静态
					local reward = tabItem.reward --道具奖励的属性表
					local randreward = tabItem.randreward --道具随机奖励的属性表
					local slotAttrRatio = tabItem.slotAttrRatio or 1 --孔的属性倍数
					
					--道具的基础属性
					if (type(reward) == "table") then
						for index, list in ipairs(reward) do
							local typ = list[1] --属性类型
							local num = list[2] --属性值
							--print("typ=" ..typ, "num="..num)
							if (type(num) == "string") then
								local strExpress = num
								local lv = 1
								--local quality = equipment[hVar.ITEM_DATA_INDEX.QUALITY] --品质
								local quality = item[hVar.ITEM_DATA_INDEX.QUALITY] --品质
								--print("quality=".. quality)
								num = hApi.AnalyzeValueExpr(nil, nil, {["@lv"] = lv,["@quality"] = quality,}, strExpress, 0)
							elseif (type(num) == "number") then
								num = num
							end
							
							if (typ == "hp_max") then --血量
								a.hp_max = a.hp_max + num
								--a.hp = a.hp + num
							elseif (typ == "atk") then --攻击力
								a.atk_min = a.atk_min + num[1]
								a.atk_max = a.atk_max + num[2]
							elseif (typ == "atk_min") then --最小攻击力
								a.atk_min = a.atk_min + num
							elseif (typ == "atk_max") then --最大攻击力
								a.atk_max = a.atk_max + num
							elseif (typ == "atk_ice") then --冰攻击力
								a.atk_ice = a.atk_ice + num
							elseif (typ == "atk_thunder") then --雷攻击力
								a.atk_thunder = a.atk_thunder + num
							elseif (typ == "atk_fire") then --火攻击力
								a.atk_fire = a.atk_fire + num
							elseif (typ == "atk_poison") then --毒攻击力
								a.atk_poison = a.atk_poison + num
							elseif (typ == "atk_bullet") then --子弹攻击力
								a.atk_bullet = a.atk_bullet + num
							elseif (typ == "atk_bomb") then --爆炸攻击力
								a.atk_bomb = a.atk_bomb + num
							elseif (typ == "atk_chuanci") then --穿刺攻击力
								a.atk_chuanci = a.atk_chuanci + num
							elseif (typ == "atk_interval") then --攻击间隔（毫秒）
								a.atk_interval = a.atk_interval + num
							elseif (typ == "atk_speed") then --攻击速度（去百分号后的值）
								a.atk_speed = a.atk_speed + num
							elseif (typ == "move_speed") then --移动速度
								a.move_speed = a.move_speed + num
							elseif (typ == "atk_radius") then --攻击范围
								a.atk_radius = a.atk_radius + num
							elseif (typ == "atk_radius_min") then --攻击范围最小值
								a.atk_radius_min = a.atk_radius_min + num
							elseif (typ == "def_physic") then --物理防御
								a.def_physic = a.def_physic + num
							elseif (typ == "def_magic") then --法术防御
								a.def_magic = a.def_magic + num
							elseif (typ == "def_ice") then --冰防御
								a.def_ice = a.def_ice + num
							elseif (typ == "def_thunder") then --雷防御
								a.def_thunder = a.def_thunder + num
							elseif (typ == "def_fire") then --火防御
								a.def_fire = a.def_fire + num
							elseif (typ == "def_poison") then --毒防御
								a.def_poison = a.def_poison + num
							elseif (typ == "def_bullet") then --子弹防御
								a.def_bullet = a.def_bullet + num
							elseif (typ == "def_bomb") then --爆炸防御
								a.def_bomb = a.def_bomb + num
							elseif (typ == "def_chuanci") then --穿刺防御
								a.def_chuanci = a.def_chuanci + num
							elseif (typ == "bullet_capacity") then --携弹数量
								a.bullet_capacity = a.bullet_capacity + num
							elseif (typ == "grenade_capacity") then --手雷数量
								a.grenade_capacity = a.grenade_capacity + num
							elseif (typ == "grenade_child") then --子母雷数量
								a.grenade_child = a.grenade_child + num
							elseif (typ == "grenade_fire") then --手雷爆炸火焰
								a.grenade_fire = a.grenade_fire + num
							elseif (typ == "grenade_dis") then --手雷投弹距离
								a.grenade_dis = a.grenade_dis + num
							elseif (typ == "grenade_cd") then --手雷冷却时间（单位：毫秒）
								a.grenade_cd = a.grenade_cd + num
							elseif (typ == "grenade_crit") then --手雷暴击
								a.grenade_crit = a.grenade_crit + num
							elseif (typ == "grenade_multiply") then --手雷冷却前使用次数
								a.grenade_multiply = a.grenade_multiply + num
							elseif (typ == "inertia") then --惯性
								a.inertia = a.inertia + num
							elseif (typ == "crystal_rate") then --水晶收益率（去百分号后的值）
								a.crystal_rate = a.crystal_rate + num
							elseif (typ == "melee_bounce") then --近战弹开
								a.melee_bounce = a.melee_bounce + num
							elseif (typ == "melee_fight") then --近战反击
								a.melee_fight = a.melee_fight + num
							elseif (typ == "melee_stone") then --近战碎石
								a.melee_stone = a.melee_stone + num
							elseif (typ == "dodge_rate") or (typ == "dodge_physic_rate") then --物理闪避几率（去百分号后的值）
								a.dodge_rate = a.dodge_rate + num
							elseif (typ == "dodge_magic_rate") then --法术闪避几率（去百分号后的值）
								a.dodge_magic_rate = a.dodge_magic_rate + num
							elseif (typ == "hit_rate") then --命中几率（去百分号后的值）
								a.hit_rate = a.hit_rate + num
							elseif (typ == "crit_rate") then --暴击几率（去百分号后的值）
								a.crit_rate = a.crit_rate + num
							elseif (typ == "crit_value") then --暴击倍数（支持小数）
								a.crit_value = a.crit_value + num
							elseif (typ == "crit_immue") then --暴击免伤
								a.crit_immue = a.crit_immue + num
							elseif (typ == "kill_gold") then --击杀获得的金币
								a.kill_gold = a.kill_gold + num
							elseif (typ == "escape_punish") then --逃怪惩罚
								a.escape_punish = a.escape_punish + num
							elseif (typ == "hp_restore") then --回血速度（每秒）（支持小数）
								a.hp_restore = a.hp_restore + num
							elseif (typ == "AI_attribute") then --AI行为（0：被动怪 / 1:主动怪）
								a.AI_attribute = a.AI_attribute + num
							elseif (typ == "rebirth_time") then --复活时间（毫秒）
								a.rebirth_time = a.rebirth_time + num
							elseif (typ == "suck_blood_rate") then --吸血率（去百分号后的值）
								a.suck_blood_rate = a.suck_blood_rate + num
							elseif (typ == "active_skill_cd_delta") then --主动技能冷却时间变化值（毫秒）
								a.active_skill_cd_delta = a.active_skill_cd_delta + num
							elseif (typ == "passive_skill_cd_delta") then --被动技能冷却时间变化值（毫秒）
								a.passive_skill_cd_delta = a.passive_skill_cd_delta + num
							elseif (typ == "active_skill_cd_delta_rate") then --主动技能冷却时间变化比例值（去百分号后的值）
								a.active_skill_cd_delta_rate = a.active_skill_cd_delta_rate + num
							elseif (typ == "passive_skill_cd_delta_rate") then --被动技能冷却时间变化比例值（去百分号后的值）
								a.passive_skill_cd_delta_rate = a.passive_skill_cd_delta_rate + num
							elseif (typ == "hp_restore_delta_rate") then --回血倍率比例值（去百分号后的值）
								a.hp_restore_delta_rate = a.hp_restore_delta_rate + num
							elseif (typ == "hp_max_rate") then --血量（去百分号后的值）
								local value = math.floor(hp_max_basic * num / 100)
								a.hp_max = a.hp_max + value
							elseif (typ == "atk_rate") then --攻击力（去百分号后的值）
								local value = math.floor(atk_basic * num / 100)
								a.atk_min = a.atk_min + value
								a.atk_max = a.atk_max + value
							elseif (typ == "atk_radius_rate") then --攻击范围（去百分号后的值）
								local value = math.floor(atk_radius_basic * num / 100)
								a.atk_radius = a.atk_radius + value
							elseif (typ == "pet_hp_restore") then --宠物回血
								a.pet_hp_restore = a.pet_hp_restore + num
							elseif (typ == "pet_hp") then --宠物生命
								a.pet_hp = a.pet_hp + num
							elseif (typ == "pet_atk") then --宠物攻击
								a.pet_atk = a.pet_atk + num
							elseif (typ == "pet_atk_speed") then --宠物攻速
								a.pet_atk_speed = a.pet_atk_speed + num
							elseif (typ == "pet_capacity") then --宠物携带数量
								a.pet_capacity = a.pet_capacity + num
							elseif (typ == "trap_ground") then --陷阱时间（单位：毫秒）
								a.trap_ground = a.trap_ground + num
							elseif (typ == "trap_groundcd") then --陷阱施法间隔（单位：毫秒）
								a.trap_groundcd = a.trap_groundcd + num
							elseif (typ == "trap_groundenemy") then --陷阱困敌时间（单位：毫秒）
								a.trap_groundenemy = a.trap_groundenemy + num
							elseif (typ == "trap_fly") then --天网时间（单位：毫秒）
								a.trap_fly = a.trap_fly + num
							elseif (typ == "trap_flycd") then --天网施法间隔（单位：毫秒）
								a.trap_flycd = a.trap_flycd + num
							elseif (typ == "trap_flyenemy") then --天网困敌时间（单位：毫秒）
								a.trap_flyenemy = a.trap_flyenemy + num
							elseif (typ == "puzzle") then --迷惑几率（去百分号后的值）
								a.puzzle = a.puzzle + num
							elseif (typ == "weapon_crit_shoot") then --武器暴击
								a.weapon_crit_shoot = a.weapon_crit_shoot + num
							elseif (typ == "weapon_crit_frozen") then --冰冻暴击
								a.weapon_crit_frozen = a.weapon_crit_frozen + num
							elseif (typ == "weapon_crit_fire") then --火焰暴击
								a.weapon_crit_fire = a.weapon_crit_fire + num
							elseif (typ == "weapon_crit_equip") then --装备暴击
								a.weapon_crit_equip = a.weapon_crit_equip + num
							elseif (typ == "weapon_crit_hit") then --击退暴击
								a.weapon_crit_hit = a.weapon_crit_hit + num
							elseif (typ == "weapon_crit_blow") then --吹风暴击
								a.weapon_crit_blow = a.weapon_crit_blow + num
							elseif (typ == "weapon_crit_poison") then --毒液暴击
								a.weapon_crit_poison = a.weapon_crit_poison + num
							end
						end
					end
					
					--道具的随机属性
					if (type(randreward) == "table") then
						--将随机属性加入列表
						local reward = {}
						local randIdx1 = item[hVar.ITEM_DATA_INDEX.RAND_IDX1]
						local randVal1 = item[hVar.ITEM_DATA_INDEX.RAND_VAL1]
						if (randIdx1 > 0) then
							if randreward[randIdx1] then
								local key = randreward[randIdx1][1]
								local value = randVal1
								--print("随机属性1", key, value)
								reward[#reward+1] = {key, value,}
							end
						end
						
						--随机属性2
						local randIdx2 = item[hVar.ITEM_DATA_INDEX.RAND_IDX2]
						local randVal2 = item[hVar.ITEM_DATA_INDEX.RAND_VAL2]
						if (randIdx2 > 0) then
							if randreward[randIdx2] then
								local key = randreward[randIdx2][1]
								local value = randVal2
								--print("随机属性2", key, value)
								reward[#reward+1] = {key, value,}
							end
						end
						
						--随机属性3
						local randIdx3 = item[hVar.ITEM_DATA_INDEX.RAND_IDX3]
						local randVal3 = item[hVar.ITEM_DATA_INDEX.RAND_VAL3]
						if (randIdx3 > 0) then
							if randreward[randIdx3] then
								local key = randreward[randIdx3][1]
								local value = randVal3
								--print("随机属性3", key, value)
								reward[#reward+1] = {key, value,}
							end
						end
						
						--随机属性4
						local randIdx4 = item[hVar.ITEM_DATA_INDEX.RAND_IDX4]
						local randVal4 = item[hVar.ITEM_DATA_INDEX.RAND_VAL4]
						if (randIdx4 > 0) then
							if randreward[randIdx4] then
								local key = randreward[randIdx4][1]
								local value = randVal4
								--print("随机属性4", key, value)
								reward[#reward+1] = {key, value,}
							end
						end
						
						--随机属性5
						local randIdx5 = item[hVar.ITEM_DATA_INDEX.RAND_IDX5]
						local randVal5 = item[hVar.ITEM_DATA_INDEX.RAND_VAL5]
						if (randIdx5 > 0) then
							if randreward[randIdx5] then
								local key = randreward[randIdx5][1]
								local value = randVal5
								--print("随机属性5", key, value)
								reward[#reward+1] = {key, value,}
							end
						end
						
						for index, list in ipairs(reward) do
							local typ = list[1] --属性类型
							local num = list[2] --属性值
							--print("随机属性" .. index, "typ=" ..typ, "num="..num)
							
							if (typ == "hp_max") then --血量
								a.hp_max = a.hp_max + num
								--a.hp = a.hp + num
							elseif (typ == "atk") then --攻击力
								a.atk_min = a.atk_min + num[1]
								a.atk_max = a.atk_max + num[2]
							elseif (typ == "atk_min") then --最小攻击力
								a.atk_min = a.atk_min + num
							elseif (typ == "atk_max") then --最大攻击力
								a.atk_max = a.atk_max + num
							elseif (typ == "atk_ice") then --冰攻击力
								a.atk_ice = a.atk_ice + num
							elseif (typ == "atk_thunder") then --雷攻击力
								a.atk_thunder = a.atk_thunder + num
							elseif (typ == "atk_fire") then --火攻击力
								a.atk_fire = a.atk_fire + num
							elseif (typ == "atk_poison") then --毒攻击力
								a.atk_poison = a.atk_poison + num
							elseif (typ == "atk_bullet") then --子弹攻击力
								a.atk_bullet = a.atk_bullet + num
							elseif (typ == "atk_bomb") then --爆炸攻击力
								a.atk_bomb = a.atk_bomb + num
							elseif (typ == "atk_chuanci") then --穿刺攻击力
								a.atk_chuanci = a.atk_chuanci + num
							elseif (typ == "atk_interval") then --攻击间隔（毫秒）
								a.atk_interval = a.atk_interval + num
							elseif (typ == "atk_speed") then --攻击速度（去百分号后的值）
								a.atk_speed = a.atk_speed + num
							elseif (typ == "move_speed") then --移动速度
								a.move_speed = a.move_speed + num
							elseif (typ == "atk_radius") then --攻击范围
								a.atk_radius = a.atk_radius + num
							elseif (typ == "atk_radius_min") then --攻击范围最小值
								a.atk_radius_min = a.atk_radius_min + num
							elseif (typ == "def_physic") then --物理防御
								a.def_physic = a.def_physic + num
							elseif (typ == "def_magic") then --法术防御
								a.def_magic = a.def_magic + num
							elseif (typ == "def_ice") then --冰防御
								a.def_ice = a.def_ice + num
							elseif (typ == "def_thunder") then --雷防御
								a.def_thunder = a.def_thunder + num
							elseif (typ == "def_fire") then --火防御
								a.def_fire = a.def_fire + num
							elseif (typ == "def_poison") then --毒防御
								a.def_poison = a.def_poison + num
							elseif (typ == "def_bullet") then --子弹防御
								a.def_bullet = a.def_bullet + num
							elseif (typ == "def_bomb") then --爆炸防御
								a.def_bomb = a.def_bomb + num
							elseif (typ == "def_chuanci") then --穿刺防御
								a.def_chuanci = a.def_chuanci + num
							elseif (typ == "bullet_capacity") then --携弹数量
								a.bullet_capacity = a.bullet_capacity + num
							elseif (typ == "grenade_capacity") then --手雷数量
								a.grenade_capacity = a.grenade_capacity + num
							elseif (typ == "grenade_child") then --子母雷数量
								a.grenade_child = a.grenade_child + num
							elseif (typ == "grenade_fire") then --手雷爆炸火焰
								a.grenade_fire = a.grenade_fire + num
							elseif (typ == "grenade_dis") then --手雷投弹距离
								a.grenade_dis = a.grenade_dis + num
							elseif (typ == "grenade_cd") then --手雷冷却时间（单位：毫秒）
								a.grenade_cd = a.grenade_cd + num
							elseif (typ == "grenade_crit") then --手雷暴击
								a.grenade_crit = a.grenade_crit + num
							elseif (typ == "grenade_multiply") then --手雷冷却前使用次数
								a.grenade_multiply = a.grenade_multiply + num
							elseif (typ == "inertia") then --惯性
								a.inertia = a.inertia + num
							elseif (typ == "crystal_rate") then --水晶收益率（去百分号后的值）
								a.crystal_rate = a.crystal_rate + num
							elseif (typ == "melee_bounce") then --近战弹开
								a.melee_bounce = a.melee_bounce + num
							elseif (typ == "melee_fight") then --近战反击
								a.melee_fight = a.melee_fight + num
							elseif (typ == "melee_stone") then --近战碎石
								a.melee_stone = a.melee_stone + num
							elseif (typ == "dodge_rate") or (typ == "dodge_physic_rate") then --物理闪避几率（去百分号后的值）
								a.dodge_rate = a.dodge_rate + num
							elseif (typ == "dodge_magic_rate") then --法术闪避几率（去百分号后的值）
								a.dodge_magic_rate = a.dodge_magic_rate + num
							elseif (typ == "hit_rate") then --命中几率（去百分号后的值）
								a.hit_rate = a.hit_rate + num
							elseif (typ == "crit_rate") then --暴击几率（去百分号后的值）
								a.crit_rate = a.crit_rate + num
							elseif (typ == "crit_value") then --暴击倍数（支持小数）
								a.crit_value = a.crit_value + num
							elseif (typ == "crit_immue") then --暴击免伤
								a.crit_immue = a.crit_immue + num
							elseif (typ == "kill_gold") then --击杀获得的金币
								a.kill_gold = a.kill_gold + num
							elseif (typ == "escape_punish") then --逃怪惩罚
								a.escape_punish = a.escape_punish + num
							elseif (typ == "hp_restore") then --回血速度（每秒）（支持小数）
								a.hp_restore = a.hp_restore + num
							elseif (typ == "AI_attribute") then --AI行为（0：被动怪 / 1:主动怪）
								a.AI_attribute = a.AI_attribute + num
							elseif (typ == "rebirth_time") then --复活时间（毫秒）
								a.rebirth_time = a.rebirth_time + num
							elseif (typ == "suck_blood_rate") then --吸血率（去百分号后的值）
								a.suck_blood_rate = a.suck_blood_rate + num
							elseif (typ == "active_skill_cd_delta") then --主动技能冷却时间变化值（毫秒）
								a.active_skill_cd_delta = a.active_skill_cd_delta + num
							elseif (typ == "passive_skill_cd_delta") then --被动技能冷却时间变化值（毫秒）
								a.passive_skill_cd_delta = a.passive_skill_cd_delta + num
							elseif (typ == "active_skill_cd_delta_rate") then --主动技能冷却时间变化比例值（去百分号后的值）
								a.active_skill_cd_delta_rate = a.active_skill_cd_delta_rate + num
							elseif (typ == "passive_skill_cd_delta_rate") then --被动技能冷却时间变化比例值（去百分号后的值）
								a.passive_skill_cd_delta_rate = a.passive_skill_cd_delta_rate + num
							elseif (typ == "hp_restore_delta_rate") then --回血倍率比例值（去百分号后的值）
								a.hp_restore_delta_rate = a.hp_restore_delta_rate + num
							elseif (typ == "hp_max_rate") then --血量（去百分号后的值）
								local value = math.floor(hp_max_basic * num / 100)
								a.hp_max = a.hp_max + value
							elseif (typ == "atk_rate") then --攻击力（去百分号后的值）
								local value = math.floor(atk_basic * num / 100)
								a.atk_min = a.atk_min + value
								a.atk_max = a.atk_max + value
							elseif (typ == "atk_radius_rate") then --攻击范围（去百分号后的值）
								local value = math.floor(atk_radius_basic * num / 100)
								a.atk_radius = a.atk_radius + value
							elseif (typ == "pet_hp_restore") then --宠物回血
								a.pet_hp_restore = a.pet_hp_restore + num
							elseif (typ == "pet_hp") then --宠物生命
								a.pet_hp = a.pet_hp + num
							elseif (typ == "pet_atk") then --宠物攻击
								a.pet_atk = a.pet_atk + num
							elseif (typ == "pet_atk_speed") then --宠物攻速
								a.pet_atk_speed = a.pet_atk_speed + num
							elseif (typ == "pet_capacity") then --宠物携带数量
								a.pet_capacity = a.pet_capacity + num
							elseif (typ == "trap_ground") then --陷阱时间（单位：毫秒）
								a.trap_ground = a.trap_ground + num
							elseif (typ == "trap_groundcd") then --陷阱施法间隔（单位：毫秒）
								a.trap_groundcd = a.trap_groundcd + num
							elseif (typ == "trap_groundenemy") then --陷阱困敌时间（单位：毫秒）
								a.trap_groundenemy = a.trap_groundenemy + num
							elseif (typ == "trap_fly") then --天网时间（单位：毫秒）
								a.trap_fly = a.trap_fly + num
							elseif (typ == "trap_flycd") then --天网施法间隔（单位：毫秒）
								a.trap_flycd = a.trap_flycd + num
							elseif (typ == "trap_flyenemy") then --天网困敌时间（单位：毫秒）
								a.trap_flyenemy = a.trap_flyenemy + num
							elseif (typ == "puzzle") then --迷惑几率（去百分号后的值）
								a.puzzle = a.puzzle + num
							elseif (typ == "weapon_crit_shoot") then --武器暴击
								a.weapon_crit_shoot = a.weapon_crit_shoot + num
							elseif (typ == "weapon_crit_frozen") then --冰冻暴击
								a.weapon_crit_frozen = a.weapon_crit_frozen + num
							elseif (typ == "weapon_crit_fire") then --火焰暴击
								a.weapon_crit_fire = a.weapon_crit_fire + num
							elseif (typ == "weapon_crit_equip") then --装备暴击
								a.weapon_crit_equip = a.weapon_crit_equip + num
							elseif (typ == "weapon_crit_hit") then --击退暴击
								a.weapon_crit_hit = a.weapon_crit_hit + num
							elseif (typ == "weapon_crit_blow") then --吹风暴击
								a.weapon_crit_blow = a.weapon_crit_blow + num
							elseif (typ == "weapon_crit_poison") then --毒液暴击
								a.weapon_crit_poison = a.weapon_crit_poison + num
							end
						end
					end
					
					--道具的孔的属性
					local rewardEx = item[hVar.ITEM_DATA_INDEX.SLOT]
					if (type(rewardEx) == "table") then
						for j = 1, #rewardEx, 1 do
							local arrtEx = rewardEx[j] --道具孔属性位
							if (type(arrtEx) == "string") and hVar.ITEM_ATTR_VAL[arrtEx] then
								local attrVal = hVar.ITEM_ATTR_VAL[arrtEx] --道具孔的属性表
								local typ = attrVal.attrAdd --属性类型
								local num = attrVal.value1 * slotAttrRatio --属性值(乘以孔的属性倍数)
								--print(typ, num)
								
								if (typ == "hp_max") then --血量
									a.hp_max = a.hp_max + num
									--a.hp = a.hp + num
								elseif (typ == "atk") then --攻击力
									a.atk_min = a.atk_min + num
									a.atk_max = a.atk_max + attrVal.value2 * slotAttrRatio --属性值(乘以孔的属性倍数)
								elseif (typ == "atk_min") then --最小攻击力
									a.atk_min = a.atk_min + num
								elseif (typ == "atk_max") then --最大攻击力
									a.atk_max = a.atk_max + num
								elseif (typ == "atk_ice") then --冰攻击力
									a.atk_ice = a.atk_ice + num
								elseif (typ == "atk_thunder") then --雷攻击力
									a.atk_thunder = a.atk_thunder + num
								elseif (typ == "atk_fire") then --火攻击力
									a.atk_fire = a.atk_fire + num
								elseif (typ == "atk_poison") then --毒攻击力
									a.atk_poison = a.atk_poison + num
								elseif (typ == "atk_bullet") then --子弹攻击力
									a.atk_bullet = a.atk_bullet + num
								elseif (typ == "atk_bomb") then --爆炸攻击力
									a.atk_bomb = a.atk_bomb + num
								elseif (typ == "atk_chuanci") then --穿刺攻击力
									a.atk_chuanci = a.atk_chuanci + num
								elseif (typ == "atk_interval") then --攻击间隔（毫秒）
									a.atk_interval = a.atk_interval + num
								elseif (typ == "atk_speed") then --攻击速度（去百分号后的值）
									a.atk_speed = a.atk_speed + num
								elseif (typ == "move_speed") then --移动速度
									a.move_speed = a.move_speed + num
								elseif (typ == "atk_radius") then --攻击范围
									a.atk_radius = a.atk_radius + num
								elseif (typ == "atk_radius_min") then --攻击范围最小值
									a.atk_radius_min = a.atk_radius_min + num
								elseif (typ == "def_physic") then --物理防御
									a.def_physic = a.def_physic + num
								elseif (typ == "def_magic") then --法术防御
									a.def_magic = a.def_magic + num
								elseif (typ == "def_ice") then --冰防御
									a.def_ice = a.def_ice + num
								elseif (typ == "def_thunder") then --雷防御
									a.def_thunder = a.def_thunder + num
								elseif (typ == "def_fire") then --火防御
									a.def_fire = a.def_fire + num
								elseif (typ == "def_poison") then --毒防御
									a.def_poison = a.def_poison + num
								elseif (typ == "def_bullet") then --子弹防御
									a.def_bullet = a.def_bullet + num
								elseif (typ == "def_bomb") then --爆炸防御
									a.def_bomb = a.def_bomb + num
								elseif (typ == "def_chuanci") then --穿刺防御
									a.def_chuanci = a.def_chuanci + num
								elseif (typ == "bullet_capacity") then --携弹数量
									a.bullet_capacity = a.bullet_capacity + num
								elseif (typ == "grenade_capacity") then --手雷数量
									a.grenade_capacity = a.grenade_capacity + num
								elseif (typ == "grenade_child") then --子母雷数量
									a.grenade_child = a.grenade_child + num
								elseif (typ == "grenade_fire") then --手雷爆炸火焰
									a.grenade_fire = a.grenade_fire + num
								elseif (typ == "grenade_dis") then --手雷投弹距离
									a.grenade_dis = a.grenade_dis + num
								elseif (typ == "grenade_cd") then --手雷冷却时间（单位：毫秒）
									a.grenade_cd = a.grenade_cd + num
								elseif (typ == "grenade_crit") then --手雷暴击
									a.grenade_crit = a.grenade_crit + num
								elseif (typ == "grenade_multiply") then --手雷冷却前使用次数
									a.grenade_multiply = a.grenade_multiply + num
								elseif (typ == "inertia") then --惯性
									a.inertia = a.inertia + num
								elseif (typ == "crystal_rate") then --水晶收益率（去百分号后的值）
									a.crystal_rate = a.crystal_rate + num
								elseif (typ == "melee_bounce") then --近战弹开
									a.melee_bounce = a.melee_bounce + num
								elseif (typ == "melee_fight") then --近战反击
									a.melee_fight = a.melee_fight + num
								elseif (typ == "melee_stone") then --近战碎石
									a.melee_stone = a.melee_stone + num
								elseif (typ == "dodge_rate") or (typ == "dodge_physic_rate") then --物理闪避几率（去百分号后的值）
									a.dodge_rate = a.dodge_rate + num
								elseif (typ == "dodge_magic_rate") then --物理闪避几率（去百分号后的值）
									a.dodge_magic_rate = a.dodge_magic_rate + num
								elseif (typ == "hit_rate") then --命中几率（去百分号后的值）
									a.hit_rate = a.hit_rate + num
								elseif (typ == "crit_rate") then --暴击几率（去百分号后的值）
									a.crit_rate = a.crit_rate + num
								elseif (typ == "crit_value") then --暴击倍数（支持小数）
									a.crit_value = a.crit_value + num
								elseif (typ == "crit_immue") then --暴击免伤
									a.crit_immue = a.crit_immue + num
								elseif (typ == "kill_gold") then --击杀获得的金币
									a.kill_gold = a.kill_gold + num
								elseif (typ == "escape_punish") then --逃怪惩罚
									a.escape_punish = a.escape_punish + num
								elseif (typ == "hp_restore") then --回血速度（每秒）（支持小数）
									a.hp_restore = a.hp_restore + num
								elseif (typ == "AI_attribute") then --AI行为（0：被动怪 / 1:主动怪）
									a.AI_attribute = a.AI_attribute + num
								elseif (typ == "rebirth_time") then --复活时间（毫秒）
									a.rebirth_time = a.rebirth_time + num
								elseif (typ == "suck_blood_rate") then --吸血率（去百分号后的值）
									a.suck_blood_rate = a.suck_blood_rate + num
								elseif (typ == "active_skill_cd_delta") then --主动技能冷却时间变化值（毫秒）
									a.active_skill_cd_delta = a.active_skill_cd_delta + num
								elseif (typ == "passive_skill_cd_delta") then --被动技能冷却时间变化值（毫秒）
									a.passive_skill_cd_delta = a.passive_skill_cd_delta + num
								elseif (typ == "active_skill_cd_delta_rate") then --主动技能冷却时间变化比例值（去百分号后的值）
									a.active_skill_cd_delta_rate = a.active_skill_cd_delta_rate + num
								elseif (typ == "passive_skill_cd_delta_rate") then --被动技能冷却时间变化比例值（去百分号后的值）
									a.passive_skill_cd_delta_rate = a.passive_skill_cd_delta_rate + num
								elseif (typ == "hp_restore_delta_rate") then --回血倍率比例值（去百分号后的值）
									a.hp_restore_delta_rate = a.hp_restore_delta_rate + num
								elseif (typ == "hp_max_rate") then --血量（去百分号后的值）
									local value = math.floor(a.hp_max_basic * num / 100)
									hp_max_item_add = hp_max_item_add + value
								elseif (typ == "atk_rate") then --攻击力（去百分号后的值）
									local value = math.floor(a.atk_basic * num / 100)
									atk_min_add = atk_min_add + value
									atk_max_add = atk_max_add + value
								elseif (typ == "atk_radius_rate") then --攻击范围（去百分号后的值）
									local value = math.floor(a.atk_radius_basic * num / 100)
									atk_radius_item_add = atk_radius_item_add + value
								elseif (typ == "pet_hp_restore") then --宠物回血
									a.pet_hp_restore = a.pet_hp_restore + num
								elseif (typ == "pet_hp") then --宠物生命
									a.pet_hp = a.pet_hp + num
								elseif (typ == "pet_atk") then --宠物攻击
									a.pet_atk = a.pet_atk + num
								elseif (typ == "pet_atk_speed") then --宠物攻速
									a.pet_atk_speed = a.pet_atk_speed + num
								elseif (typ == "pet_capacity") then --宠物携带数量
									a.pet_capacity = a.pet_capacity + num
								elseif (typ == "trap_ground") then --陷阱时间（单位：毫秒）
									a.trap_ground = a.trap_ground + num
								elseif (typ == "trap_groundcd") then --陷阱施法间隔（单位：毫秒）
									a.trap_groundcd = a.trap_groundcd + num
								elseif (typ == "trap_groundenemy") then --陷阱困敌时间（单位：毫秒）
									a.trap_groundenemy = a.trap_groundenemy + num
								elseif (typ == "trap_fly") then --天网时间（单位：毫秒）
									a.trap_fly = a.trap_fly + num
								elseif (typ == "trap_flycd") then --天网施法间隔（单位：毫秒）
									a.trap_flycd = a.trap_flycd + num
								elseif (typ == "trap_flyenemy") then --天网困敌时间（单位：毫秒）
									a.trap_flyenemy = a.trap_flyenemy + num
								elseif (typ == "puzzle") then --迷惑几率（去百分号后的值）
									a.puzzle = a.puzzle + num
								elseif (typ == "weapon_crit_shoot") then --武器暴击
									a.weapon_crit_shoot = a.weapon_crit_shoot + num
								elseif (typ == "weapon_crit_frozen") then --冰冻暴击
									a.weapon_crit_frozen = a.weapon_crit_frozen + num
								elseif (typ == "weapon_crit_fire") then --火焰暴击
									a.weapon_crit_fire = a.weapon_crit_fire + num
								elseif (typ == "weapon_crit_equip") then --装备暴击
									a.weapon_crit_equip = a.weapon_crit_equip + num
								elseif (typ == "weapon_crit_hit") then --击退暴击
									a.weapon_crit_hit = a.weapon_crit_hit + num
								elseif (typ == "weapon_crit_blow") then --吹风暴击
									a.weapon_crit_blow = a.weapon_crit_blow + num
								elseif (typ == "weapon_crit_poison") then --毒液暴击
									a.weapon_crit_poison = a.weapon_crit_poison + num
								end
							end
						end
					end
				end
			end
		end
	end
	
	--英雄觉醒，永久增加自身属性的
	--英雄的觉醒等级
	local heroWakenLv, weaponWakenLv, bodyWakenLv, ornamentsWakenLv, horseWakenLv = hApi.GetWakenLevel(equipment) --英雄觉醒等级
	--print("heroWakenLv=", heroWakenLv)
	if (heroWakenLv > 0) then
		--找出该英雄属于哪个神兽
		local animalType = hVar.ANIMAL_TD_TYPE.NONE
		for k = 1, #hVar.HERO_AVAILABLE_LIST, 1 do
			if (hVar.HERO_AVAILABLE_LIST[k].id == type_id) then
				animalType = hVar.HERO_AVAILABLE_LIST[k].animalType --找到了
				break
			end
		end
		local skillId = hVar.ANIMAL_WAKEN_SKILL[animalType] or 0
		--print("skillId=", skillId)
		if (skillId > 0) then
			local lv = heroWakenLv
			local tabS = hVar.tab_skill[skillId]
			if tabS then
				local skillType = tabS.cast_type
				local action = tabS.action
				if (skillType == hVar.CAST_TYPE.AUTO) then --被动技能
					--遍历action，找出类型是"AddAttr_Buff"的
					for ac = 1, #action, 1 do
						--{"AddAttr_Buff", "hp_max", "@lv*100+100"},
						local ac1 = action[ac][1]
						if (ac1 == "AddAttr_Buff") then
							local ac2 = action[ac][2]
							local ac3 = action[ac][3]
							local num = 0
							
							--解析表达式中的"@lv"
							if (type(ac3) == "string") then
								--[[
								local pp = "@lv"
								local atlv = string.find(ac3, pp)
								while (atlv ~= nil) do
									--前
									local prep = ""
									if (atlv > 1) then
										prep = string.sub(ac3, 1, atlv - 1)
									end
									
									--后
									local post = ""
									if (atlv < (#ac3 - 3 + 1)) then
										post = string.sub(ac3, atlv + 3, #ac3)
									end
									
									--重组
									--print()
									--print(":", ac3)
									ac3 = prep .. lv .. post
									--print("~", ac3)
									
									--继续查找
									atlv = string.find(ac3, pp)
								end
								
								--解析表达式
								local sac3 = "local tmp = "..(ac3).." return tmp"
								num = assert(loadstring(sac3))()
								]]
								local strExpress = ac3
								num = hApi.AnalyzeValueExpr(nil, nil, {["@lv"] = lv,}, strExpress, 0)
							elseif (type(ac3) == "number") then
								num = ac3
							end
							
							--print()
							--print(ac2, num)
							
							if (ac2 == "hp_max") then --血量
								a.hp_max = a.hp_max + num
								--a.hp = a.hp + num
							elseif (ac2 == "atk") then --攻击力
								a.atk_min = a.atk_min + num
								a.atk_max = a.atk_max + num
							elseif (ac2 == "atk_min") then --最小攻击力
								a.atk_min = a.atk_min + num
							elseif (ac2 == "atk_max") then --最大攻击力
								a.atk_max = a.atk_max + num
							elseif (ac2 == "atk_ice") then --冰攻击力
								a.atk_ice = a.atk_ice + num
							elseif (ac2 == "atk_thunder") then --雷攻击力
								a.atk_thunder = a.atk_thunder + num
							elseif (ac2 == "atk_fire") then --火攻击力
								a.atk_fire = a.atk_fire + num
							elseif (ac2 == "atk_poison") then --毒攻击力
								a.atk_poison = a.atk_poison + num
							elseif (ac2 == "atk_bullet") then --子弹攻击力
								a.atk_bullet = a.atk_bullet + num
							elseif (ac2 == "atk_bomb") then --爆炸攻击力
								a.atk_bomb = a.atk_bomb + num
							elseif (ac2 == "atk_chuanci") then --穿刺攻击力
								a.atk_chuanci = a.atk_chuanci + num
							elseif (ac2 == "atk_interval") then --攻击间隔（毫秒）
								a.atk_interval = a.atk_interval + num
							elseif (ac2 == "atk_speed") then --攻击速度（去百分号后的值）
								a.atk_speed = a.atk_speed + num
							elseif (ac2 == "move_speed") then --移动速度
								a.move_speed = a.move_speed + num
							elseif (ac2 == "atk_radius") then --攻击范围
								a.atk_radius = a.atk_radius + num
							elseif (ac2 == "atk_radius_min") then --攻击范围最小值
								a.atk_radius_min = a.atk_radius_min + num
							elseif (ac2 == "def_physic") then --物理防御
								a.def_physic = a.def_physic + num
							elseif (ac2 == "def_magic") then --法术防御
								a.def_magic = a.def_magic + num
							elseif (ac2 == "def_ice") then --冰防御
								a.def_ice = a.def_ice + num
							elseif (ac2 == "def_thunder") then --雷防御
								a.def_thunder = a.def_thunder + num
							elseif (ac2 == "def_fire") then --火防御
								a.def_fire = a.def_fire + num
							elseif (ac2 == "def_poison") then --毒防御
								a.def_poison = a.def_poison + num
							elseif (ac2 == "def_bullet") then --子弹防御
								a.def_bullet = a.def_bullet + num
							elseif (ac2 == "def_bomb") then --爆炸防御
								a.def_bomb = a.def_bomb + num
							elseif (ac2 == "def_chuanci") then --穿刺防御
								a.def_chuanci = a.def_chuanci + num
							elseif (ac2 == "bullet_capacity") then --携弹数量
								a.bullet_capacity = a.bullet_capacity + num
							elseif (ac2 == "grenade_capacity") then --手雷数量
								a.grenade_capacity = a.grenade_capacity + num
							elseif (ac2 == "grenade_child") then --子母雷数量
								a.grenade_child = a.grenade_child + num
							elseif (ac2 == "grenade_fire") then --手雷爆炸火焰
								a.grenade_fire = a.grenade_fire + num
							elseif (ac2 == "grenade_dis") then --手雷投弹距离
								a.grenade_dis = a.grenade_dis + num
							elseif (ac2 == "grenade_cd") then --手雷冷却时间（单位：毫秒）
								a.grenade_cd = a.grenade_cd + num
							elseif (ac2 == "grenade_crit") then --手雷暴击
								a.grenade_crit = a.grenade_crit + num
							elseif (ac2 == "grenade_multiply") then --手雷冷却前使用次数
								a.grenade_multiply = a.grenade_multiply + num
							elseif (ac2 == "inertia") then --惯性
								a.inertia = a.inertia + num
							elseif (ac2 == "crystal_rate") then --水晶收益率（去百分号后的值）
								a.crystal_rate = a.crystal_rate + num
							elseif (ac2 == "melee_bounce") then --近战弹开
								a.melee_bounce = a.melee_bounce + num
							elseif (ac2 == "melee_fight") then --近战反击
								a.melee_fight = a.melee_fight + num
							elseif (ac2 == "melee_stone") then --近战碎石
								a.melee_stone = a.melee_stone + num
							elseif (ac2 == "dodge_rate") or (ac2 == "dodge_physic_rate") then --物理闪避几率（去百分号后的值）
								a.dodge_rate = a.dodge_rate + num
							elseif (ac2 == "dodge_magic_rate") then --法术闪避几率（去百分号后的值）
								a.dodge_magic_rate = a.dodge_magic_rate + num
							elseif (ac2 == "hit_rate") then --命中几率（去百分号后的值）
								a.hit_rate = a.hit_rate + num
							elseif (ac2 == "crit_rate") then --暴击几率（去百分号后的值）
								a.crit_rate = a.crit_rate + num
							elseif (ac2 == "crit_value") then --暴击倍数（支持小数）
								a.crit_value = a.crit_value + num
							elseif (ac2 == "crit_immue") then --暴击免伤
								a.crit_immue = a.crit_immue + num
							elseif (ac2 == "kill_gold") then --击杀获得的金币
								a.kill_gold = a.kill_gold + num
							elseif (ac2 == "escape_punish") then --逃怪惩罚
								a.escape_punish = a.escape_punish + num
							elseif (ac2 == "hp_restore") then --回血速度（每秒）（支持小数）
								a.hp_restore = a.hp_restore + num
							elseif (ac2 == "AI_attribute") then --AI行为（0：被动怪 / 1:主动怪）
								a.AI_attribute = a.AI_attribute + num
							elseif (ac2 == "rebirth_time") then --复活时间（毫秒）
								a.rebirth_time = a.rebirth_time + num
							elseif (ac2 == "suck_blood_rate") then --吸血率（去百分号后的值）
								a.suck_blood_rate = a.suck_blood_rate + num
							elseif (ac2 == "active_skill_cd_delta") then --主动技能冷却时间变化值（毫秒）
								a.active_skill_cd_delta = a.active_skill_cd_delta + num
							elseif (ac2 == "passive_skill_cd_delta") then --被动技能冷却时间变化值（毫秒）
								a.passive_skill_cd_delta = a.passive_skill_cd_delta + num
							elseif (ac2 == "active_skill_cd_delta_rate") then --主动技能冷却时间变化比例值（去百分号后的值）
								a.active_skill_cd_delta_rate = a.active_skill_cd_delta_rate + num
							elseif (ac2 == "passive_skill_cd_delta_rate") then --被动技能冷却时间变化比例值（去百分号后的值）
								a.passive_skill_cd_delta_rate = a.passive_skill_cd_delta_rate + num
							elseif (ac2 == "hp_restore_delta_rate") then --回血倍率比例值（去百分号后的值）
								a.hp_restore_delta_rate = a.hp_restore_delta_rate + num
							elseif (ac2 == "hp_max_rate") then --血量（去百分号后的值）
								local value = math.floor(hp_max_basic * num / 100)
								a.hp_max = a.hp_max + value
							elseif (ac2 == "atk_rate") then --攻击力（去百分号后的值）
								local value = math.floor(atk_basic * num / 100)
								a.atk_min = a.atk_min + value
								a.atk_max = a.atk_max + value
							elseif (ac2 == "atk_radius_rate") then --攻击范围（去百分号后的值）
								local value = math.floor(atk_radius_basic * num / 100)
								a.atk_radius = a.atk_radius + value
							elseif (ac2 == "pet_hp_restore") then --宠物回血
								a.pet_hp_restore = a.pet_hp_restore + num
							elseif (ac2 == "pet_hp") then --宠物生命
								a.pet_hp = a.pet_hp + num
							elseif (ac2 == "pet_atk") then --宠物攻击
								a.pet_atk = a.pet_atk + num
							elseif (ac2 == "pet_atk_speed") then --宠物攻速
								a.pet_atk_speed = a.pet_atk_speed + num
							elseif (ac2 == "pet_capacity") then --宠物携带数量
								a.pet_capacity = a.pet_capacity + num
							elseif (ac2 == "trap_ground") then --陷阱时间（单位：毫秒）
								a.trap_ground = a.trap_ground + num
							elseif (ac2 == "trap_groundcd") then --陷阱施法间隔（单位：毫秒）
								a.trap_groundcd = a.trap_groundcd + num
							elseif (ac2 == "trap_groundenemy") then --陷阱困敌时间（单位：毫秒）
								a.trap_groundenemy = a.trap_groundenemy + num
							elseif (ac2 == "trap_fly") then --天网时间（单位：毫秒）
								a.trap_fly = a.trap_fly + num
							elseif (ac2 == "trap_flycd") then --天网施法间隔（单位：毫秒）
								a.trap_flycd = a.trap_flycd + num
							elseif (ac2 == "trap_flyenemy") then --天网困敌时间（单位：毫秒）
								a.trap_flyenemy = a.trap_flyenemy + num
							elseif (ac2 == "puzzle") then --迷惑几率（去百分号后的值）
								a.puzzle = a.puzzle + num
							elseif (ac2 == "weapon_crit_shoot") then --武器暴击
								a.weapon_crit_shoot = a.weapon_crit_shoot + num
							elseif (ac2 == "weapon_crit_frozen") then --冰冻暴击
								a.weapon_crit_frozen = a.weapon_crit_frozen + num
							elseif (ac2 == "weapon_crit_fire") then --火焰暴击
								a.weapon_crit_fire = a.weapon_crit_fire + num
							elseif (ac2 == "weapon_crit_equip") then --装备暴击
								a.weapon_crit_equip = a.weapon_crit_equip + num
							elseif (ac2 == "weapon_crit_hit") then --击退暴击
								a.weapon_crit_hit = a.weapon_crit_hit + num
							elseif (ac2 == "weapon_crit_blow") then --吹风暴击
								a.weapon_crit_blow = a.weapon_crit_blow + num
							elseif (ac2 == "weapon_crit_poison") then --毒液暴击
								a.weapon_crit_poison = a.weapon_crit_poison + num
							end
						end
					end
				end
			end
		end
	end
	
	-------------------------------------------------
	--存储装备属性
	aEquip.hp_max = a.hp_max - aBasic.hp_max
	aEquip.atk_min = a.atk_min - aBasic.atk_min
	aEquip.atk_max = a.atk_max - aBasic.atk_max
	aEquip.atk_ice = a.atk_ice - aBasic.atk_ice --装备冰攻击力
	aEquip.atk_thunder = a.atk_thunder - aBasic.atk_thunder --装备雷攻击力
	aEquip.atk_fire = a.atk_fire - aBasic.atk_fire --装备火攻击力
	aEquip.atk_poison = a.atk_poison - aBasic.atk_poison --装备毒攻击力
	aEquip.atk_bullet = a.atk_bullet - aBasic.atk_bullet --装备子弹攻击力
	aEquip.atk_bomb = a.atk_bomb - aBasic.atk_bomb --装备爆炸攻击力
	aEquip.atk_chuanci = a.atk_chuanci - aBasic.atk_chuanci --装备穿刺攻击力
	aEquip.atk_radius = a.atk_radius - aBasic.atk_radius
	aEquip.move_speed = a.move_speed - aBasic.move_speed
	aEquip.atk_interval = a.atk_interval - aBasic.atk_interval
	aEquip.atk_speed = a.atk_speed - aBasic.atk_speed
	aEquip.def_physic = a.def_physic - aBasic.def_physic
	aEquip.def_magic = a.def_magic - aBasic.def_magic
	aEquip.def_ice = a.def_ice - aBasic.def_ice --装备冰防御
	aEquip.def_thunder = a.def_thunder - aBasic.def_thunder --装备雷防御
	aEquip.def_fire = a.def_fire - aBasic.def_fire --装备火防御
	aEquip.def_poison = a.def_poison - aBasic.def_poison --装备毒防御
	aEquip.def_bullet = a.def_bullet - aBasic.def_bullet --装备子弹防御
	aEquip.def_bomb = a.def_bomb - aBasic.def_bomb --装备爆炸防御
	aEquip.def_chuanci = a.def_chuanci - aBasic.def_chuanci --装备穿刺防御
	aEquip.bullet_capacity = a.bullet_capacity - aBasic.bullet_capacity --装备携弹数量
	aEquip.grenade_capacity = a.grenade_capacity - aBasic.grenade_capacity --装备手雷数量
	aEquip.grenade_child = a.grenade_child - aBasic.grenade_child --装备子母雷数量
	aEquip.grenade_fire = a.grenade_fire - aBasic.grenade_fire --装备手雷爆炸火焰
	aEquip.grenade_dis = a.grenade_dis - aBasic.grenade_dis --装备手雷投弹距离
	aEquip.grenade_cd = a.grenade_cd - aBasic.grenade_cd --装备手雷冷却时间
	aEquip.grenade_crit = a.grenade_crit - aBasic.grenade_crit --装备手雷暴击
	aEquip.grenade_multiply = a.grenade_multiply - aBasic.grenade_multiply --装备手雷冷却前使用次数
	aEquip.inertia = a.inertia - aBasic.inertia --装备惯性
	aEquip.crystal_rate = a.crystal_rate - aBasic.crystal_rate --装备水晶收益率（去百分号后的值）
	aEquip.melee_bounce = a.melee_bounce - aBasic.melee_bounce --装备近战弹开
	aEquip.melee_fight = a.melee_fight - aBasic.melee_fight --装备近战反击
	aEquip.melee_stone = a.melee_stone - aBasic.melee_stone --装备近战碎石
	aEquip.crit_rate = a.crit_rate - aBasic.crit_rate
	aEquip.crit_value = a.crit_value - aBasic.crit_value
	aEquip.pet_hp_restore = a.pet_hp_restore - aBasic.pet_hp_restore --装备宠物回血
	aEquip.pet_hp = a.pet_hp - aBasic.pet_hp --装备宠物生命
	aEquip.pet_atk = a.pet_atk - aBasic.pet_atk --装备宠物攻击
	aEquip.pet_atk_speed = a.pet_atk_speed - aBasic.pet_atk_speed --装备宠物攻速
	aEquip.pet_capacity = a.pet_capacity - aBasic.pet_capacity --装备宠物携带数量
	aEquip.trap_ground = a.trap_ground - aBasic.trap_ground --装备陷阱时间（单位：毫秒）
	aEquip.trap_groundcd = a.trap_groundcd - aBasic.trap_groundcd --装备陷阱施法间隔（单位：毫秒）
	aEquip.trap_groundenemy = a.trap_groundenemy - aBasic.trap_groundenemy --装备陷阱困敌时间（单位：毫秒）
	aEquip.trap_fly = a.trap_fly - aBasic.trap_fly --装备天网时间（单位：毫秒）
	aEquip.trap_flycd = a.trap_flycd - aBasic.trap_flycd --装备天网施法间隔（单位：毫秒）
	aEquip.trap_flyenemy = a.trap_flyenemy - aBasic.trap_flyenemy --装备天网困敌时间（单位：毫秒）
	aEquip.puzzle = a.puzzle - aBasic.puzzle --装备迷惑几率（去百分号后的值）
	aEquip.weapon_crit_shoot = a.weapon_crit_shoot - aBasic.weapon_crit_shoot --装备武器暴击
	aEquip.weapon_crit_frozen = a.weapon_crit_frozen - aBasic.weapon_crit_frozen --装备冰冻暴击
	aEquip.weapon_crit_fire = a.weapon_crit_fire - aBasic.weapon_crit_fire --装备火焰暴击
	aEquip.weapon_crit_equip = a.weapon_crit_equip - aBasic.weapon_crit_equip --装备装备暴击
	aEquip.weapon_crit_hit = a.weapon_crit_hit - aBasic.weapon_crit_hit --装备击退暴击
	aEquip.weapon_crit_blow = a.weapon_crit_blow - aBasic.weapon_crit_blow --装备吹风暴击
	aEquip.weapon_crit_poison = a.weapon_crit_poison - aBasic.weapon_crit_poison --装备毒液暴击
	
	-------------------------------------------------
	
	--宝物为英雄附加属性
	if (type(treasure) == "table") and (type(treasureAttr) == "table") then
		for tr = 1, #treasure, 1 do
			local id = treasure[tr][1] --宝物id
			local star = treasure[tr][2] --宝物星级
			local num = treasure[tr][3] --宝物碎片数量
			
			if (star > 0) then
				local tabTreasure = hVar.tab_treasure[id] or {}
				local takeEffect = tabTreasure.takeEffect or {}
				local tTakeEffect = takeEffect[star] or {}
				for te = 1, #tTakeEffect, 1 do
					local attrType = tTakeEffect[te].attrType --宝物属性位
					local attrCountDivisor = tTakeEffect[te].attrCountDivisor --加属性次数计算的除数
					local attrCountMax = tTakeEffect[te].attrCountMax --最大统计次数
					local attrAdd = tTakeEffect[te].attrAdd or {}
					local addHero = tTakeEffect[te].addHero or {}
					local attrCount = treasureAttr[attrType] or 0 --宝物属性位值
					if (attrType == hVar.TREASURE_ATTR.NONE) then --不需要读取宝物属性位值
						attrCount = 1
					end
					if (attrCountMax > 0) then
						if (attrCount > attrCountMax) then
							attrCount = attrCountMax
						end
					end
					local attrCountMul = attrCount --宝物属性位值倍率
					if (attrCountDivisor > 0) then
						attrCountMul = math.floor(attrCount / attrCountDivisor)
					end
					
					--遍历可加成的英雄，本次英雄是否在内
					for h = 1, #addHero, 1 do
						local hId = addHero[h]
						if (hId == type_id) or (hId == "ALL") then --找到了
							--依次遍历每个增加的角色属性
							for attr = 1, #attrAdd, 1 do
								local typ = attrAdd[attr].attr --属性类型
								local num = attrAdd[attr].value * attrCountMul --属性值
								--print(typ, num)
								--解析表达式中的"@lv"
								if (type(num) == "string") then
									local strExpress = num
									local lv = 1
									num = hApi.AnalyzeValueExpr(nil, nil, {["@lv"] = lv,}, strExpress, 0)
								elseif (type(num) == "number") then
									num = num
								end
								
								if (typ == "hp_max") then --血量
									a.hp_max = a.hp_max + num
									--a.hp = a.hp + num
								elseif (typ == "atk") then --攻击力
									a.atk_min = a.atk_min + num
									a.atk_max = a.atk_max + num
								elseif (typ == "atk_min") then --最小攻击力
									a.atk_min = a.atk_min + num
								elseif (typ == "atk_max") then --最大攻击力
									a.atk_max = a.atk_max + num
								elseif (typ == "atk_ice") then --冰攻击力
									a.atk_ice = a.atk_ice + num
								elseif (typ == "atk_thunder") then --雷攻击力
									a.atk_thunder = a.atk_thunder + num
								elseif (typ == "atk_fire") then --火攻击力
									a.atk_fire = a.atk_fire + num
								elseif (typ == "atk_poison") then --毒攻击力
									a.atk_poison = a.atk_poison + num
								elseif (typ == "atk_bullet") then --子弹攻击力
									a.atk_bullet = a.atk_bullet + num
								elseif (typ == "atk_bomb") then --爆炸攻击力
									a.atk_bomb = a.atk_bomb + num
								elseif (typ == "atk_chuanci") then --穿刺攻击力
									a.atk_chuanci = a.atk_chuanci + num
								elseif (typ == "atk_interval") then --攻击间隔（毫秒）
									a.atk_interval = a.atk_interval + num
								elseif (typ == "atk_speed") then --攻击速度（去百分号后的值）
									a.atk_speed = a.atk_speed + num
								elseif (typ == "move_speed") then --移动速度
									a.move_speed = a.move_speed + num
								elseif (typ == "atk_radius") then --攻击范围
									a.atk_radius = a.atk_radius + num
								elseif (typ == "atk_radius_min") then --攻击范围最小值
									a.atk_radius_min = a.atk_radius_min + num
								elseif (typ == "def_physic") then --物理防御
									a.def_physic = a.def_physic + num
								elseif (typ == "def_magic") then --法术防御
									a.def_magic = a.def_magic + num
								elseif (typ == "def_ice") then --冰防御
									a.def_ice = a.def_ice + num
								elseif (typ == "def_thunder") then --雷防御
									a.def_thunder = a.def_thunder + num
								elseif (typ == "def_fire") then --火防御
									a.def_fire = a.def_fire + num
								elseif (typ == "def_poison") then --毒防御
									a.def_poison = a.def_poison + num
								elseif (typ == "def_bullet") then --子弹防御
									a.def_bullet = a.def_bullet + num
								elseif (typ == "def_bomb") then --爆炸防御
									a.def_bomb = a.def_bomb + num
								elseif (typ == "def_chuanci") then --穿刺防御
									a.def_chuanci = a.def_chuanci + num
								elseif (typ == "bullet_capacity") then --携弹数量
									a.bullet_capacity = a.bullet_capacity + num
								elseif (typ == "grenade_capacity") then --手雷数量
									a.grenade_capacity = a.grenade_capacity + num
								elseif (typ == "grenade_child") then --子母雷数量
									a.grenade_child = a.grenade_child + num
								elseif (typ == "grenade_fire") then --手雷爆炸火焰
									a.grenade_fire = a.grenade_fire + num
								elseif (typ == "grenade_dis") then --手雷投弹距离
									a.grenade_dis = a.grenade_dis + num
								elseif (typ == "grenade_cd") then --手雷冷却时间（单位：毫秒）
									a.grenade_cd = a.grenade_cd + num
								elseif (typ == "grenade_crit") then --手雷暴击
									a.grenade_crit = a.grenade_crit + num
								elseif (typ == "grenade_multiply") then --手雷冷却前使用次数
									a.grenade_multiply = a.grenade_multiply + num
								elseif (typ == "inertia") then --惯性
									a.inertia = a.inertia + num
								elseif (typ == "crystal_rate") then --水晶收益率（去百分号后的值）
									a.crystal_rate = a.crystal_rate + num
								elseif (typ == "melee_bounce") then --近战弹开
									a.melee_bounce = a.melee_bounce + num
								elseif (typ == "melee_fight") then --近战反击
									a.melee_fight = a.melee_fight + num
								elseif (typ == "melee_stone") then --近战碎石
									a.melee_stone = a.melee_stone + num
								elseif (typ == "dodge_rate") or (typ == "dodge_physic_rate") then --物理闪避几率（去百分号后的值）
									a.dodge_rate = a.dodge_rate + num
								elseif (typ == "dodge_magic_rate") then --法术闪避几率（去百分号后的值）
									a.dodge_magic_rate = a.dodge_magic_rate + num
								elseif (typ == "hit_rate") then --命中几率（去百分号后的值）
									a.hit_rate = a.hit_rate + num
								elseif (typ == "crit_rate") then --暴击几率（去百分号后的值）
									a.crit_rate = a.crit_rate + num
								elseif (typ == "crit_value") then --暴击倍数（支持小数）
									a.crit_value = a.crit_value + num
								elseif (typ == "crit_immue") then --暴击免伤
									a.crit_immue = a.crit_immue + num
								elseif (typ == "kill_gold") then --击杀获得的金币
									a.kill_gold = a.kill_gold + num
								elseif (typ == "escape_punish") then --逃怪惩罚
									a.escape_punish = a.escape_punish + num
								elseif (typ == "hp_restore") then --回血速度（每秒）（支持小数）
									a.hp_restore = a.hp_restore + num
								elseif (typ == "AI_attribute") then --AI行为（0：被动怪 / 1:主动怪）
									a.AI_attribute = a.AI_attribute + num
								elseif (typ == "rebirth_time") then --复活时间（毫秒）
									a.rebirth_time = a.rebirth_time + num
								elseif (typ == "suck_blood_rate") then --吸血率（去百分号后的值）
									a.suck_blood_rate = a.suck_blood_rate + num
								elseif (typ == "active_skill_cd_delta") then --主动技能冷却时间变化值（毫秒）
									a.active_skill_cd_delta = a.active_skill_cd_delta + num
								elseif (typ == "passive_skill_cd_delta") then --被动技能冷却时间变化值（毫秒）
									a.passive_skill_cd_delta = a.passive_skill_cd_delta + num
								elseif (typ == "active_skill_cd_delta_rate") then --主动技能冷却时间变化比例值（去百分号后的值）
									a.active_skill_cd_delta_rate = a.active_skill_cd_delta_rate + num
								elseif (typ == "passive_skill_cd_delta_rate") then --被动技能冷却时间变化比例值（去百分号后的值）
									a.passive_skill_cd_delta_rate = a.passive_skill_cd_delta_rate + num
								elseif (typ == "hp_restore_delta_rate") then --回血倍率比例值（去百分号后的值）
									a.hp_restore_delta_rate = a.hp_restore_delta_rate + num
								elseif (typ == "hp_max_rate") then --血量（去百分号后的值）
									local value = math.floor(hp_max_basic * num / 100)
									a.hp_max = a.hp_max + value
								elseif (typ == "atk_rate") then --攻击力（去百分号后的值）
									local value = math.floor(atk_basic * num / 100)
									a.atk_min = a.atk_min + value
									a.atk_max = a.atk_max + value
								elseif (typ == "atk_radius_rate") then --攻击范围（去百分号后的值）
									local value = math.floor(atk_radius_basic * num / 100)
									a.atk_radius = a.atk_radius + value
								elseif (typ == "pet_hp_restore") then --宠物回血
									a.pet_hp_restore = a.pet_hp_restore + num
								elseif (typ == "pet_capacity") then --宠物携带数量
									a.pet_capacity = a.pet_capacity + num
								elseif (typ == "trap_ground") then --陷阱时间（单位：毫秒）
									a.trap_ground = a.trap_ground + num
								elseif (typ == "trap_groundcd") then --陷阱施法间隔（单位：毫秒）
									a.trap_groundcd = a.trap_groundcd + num
								elseif (typ == "trap_groundenemy") then --陷阱困敌时间（单位：毫秒）
									a.trap_groundenemy = a.trap_groundenemy + num
								elseif (typ == "trap_fly") then --天网时间（单位：毫秒）
									a.trap_fly = a.trap_fly + num
								elseif (typ == "trap_flycd") then --天网施法间隔（单位：毫秒）
									a.trap_flycd = a.trap_flycd + num
								elseif (typ == "trap_flyenemy") then --天网困敌时间（单位：毫秒）
									a.trap_flyenemy = a.trap_flyenemy + num
								elseif (typ == "puzzle") then --迷惑几率（去百分号后的值）
									a.puzzle = a.puzzle + num
								elseif (typ == "weapon_crit_shoot") then --武器暴击
									a.weapon_crit_shoot = a.weapon_crit_shoot + num
								elseif (typ == "weapon_crit_frozen") then --冰冻暴击
									a.weapon_crit_frozen = a.weapon_crit_frozen + num
								elseif (typ == "weapon_crit_fire") then --火焰暴击
									a.weapon_crit_fire = a.weapon_crit_fire + num
								elseif (typ == "weapon_crit_equip") then --装备暴击
									a.weapon_crit_equip = a.weapon_crit_equip + num
								elseif (typ == "weapon_crit_hit") then --击退暴击
									a.weapon_crit_hit = a.weapon_crit_hit + num
								elseif (typ == "weapon_crit_blow") then --吹风暴击
									a.weapon_crit_blow = a.weapon_crit_blow + num
								elseif (typ == "weapon_crit_poison") then --毒液暴击
									a.weapon_crit_poison = a.weapon_crit_poison + num
								end
							end
							
							break
						end
					end
				end
			end
		end
	end
	
	-------------------------------------------------
	--存储宝物属性
	aTreasure.hp_max = a.hp_max - aBasic.hp_max - aEquip.hp_max
	aTreasure.atk_min = a.atk_min - aBasic.atk_min - aEquip.atk_min
	aTreasure.atk_max = a.atk_max - aBasic.atk_max - aEquip.atk_max
	aTreasure.atk_ice = a.atk_ice - aBasic.atk_ice - aEquip.atk_ice --宝物冰攻击力
	aTreasure.atk_thunder = a.atk_thunder - aBasic.atk_thunder - aEquip.atk_thunder --宝物雷攻击力
	aTreasure.atk_fire = a.atk_fire - aBasic.atk_fire - aEquip.atk_fire --宝物火攻击力
	aTreasure.atk_poison = a.atk_poison - aBasic.atk_poison - aEquip.atk_poison --宝物毒攻击力
	aTreasure.atk_bullet = a.atk_bullet - aBasic.atk_bullet - aEquip.atk_bullet --宝物子弹攻击力
	aTreasure.atk_bomb = a.atk_bomb - aBasic.atk_bomb - aEquip.atk_bomb --宝物爆炸攻击力
	aTreasure.atk_chuanci = a.atk_chuanci - aBasic.atk_chuanci - aEquip.atk_chuanci --宝物穿刺攻击力
	aTreasure.atk_radius = a.atk_radius - aBasic.atk_radius - aEquip.atk_radius
	aTreasure.move_speed = a.move_speed - aBasic.move_speed - aEquip.move_speed
	aTreasure.atk_interval = a.atk_interval - aBasic.atk_interval - aEquip.atk_interval
	aTreasure.atk_speed = a.atk_speed - aBasic.atk_speed - aEquip.atk_speed
	aTreasure.def_physic = a.def_physic - aBasic.def_physic - aEquip.def_physic
	aTreasure.def_ice = a.def_ice - aBasic.def_ice - aEquip.def_ice --宝物冰防御
	aTreasure.def_thunder = a.def_thunder - aBasic.def_thunder - aEquip.def_thunder --宝物雷防御
	aTreasure.def_fire = a.def_fire - aBasic.def_fire - aEquip.def_fire --宝物火防御
	aTreasure.def_poison = a.def_poison - aBasic.def_poison - aEquip.def_poison --宝物毒防御
	aTreasure.def_bullet = a.def_bullet - aBasic.def_bullet - aEquip.def_bullet --宝物子弹防御
	aTreasure.def_bomb = a.def_bomb - aBasic.def_bomb - aEquip.def_bomb --宝物爆炸防御
	aTreasure.def_chuanci = a.def_chuanci - aBasic.def_chuanci - aEquip.def_chuanci --宝物穿刺防御
	aTreasure.bullet_capacity = a.bullet_capacity - aBasic.bullet_capacity - aEquip.bullet_capacity --宝物携弹数量
	aTreasure.grenade_capacity = a.grenade_capacity - aBasic.grenade_capacity - aEquip.grenade_capacity --宝物手雷数量
	aTreasure.grenade_child = a.grenade_child - aBasic.grenade_child - aEquip.grenade_child --宝物子母雷数量
	aTreasure.grenade_fire = a.grenade_fire - aBasic.grenade_fire - aEquip.grenade_fire --宝物手雷爆炸火焰
	aTreasure.grenade_dis = a.grenade_dis - aBasic.grenade_dis - aEquip.grenade_dis --宝物手雷投弹距离
	aTreasure.grenade_cd = a.grenade_cd - aBasic.grenade_cd - aEquip.grenade_cd --宝物手雷冷却时间
	aTreasure.grenade_crit = a.grenade_crit - aBasic.grenade_crit - aEquip.grenade_crit --宝物手雷暴击
	aTreasure.grenade_multiply = a.grenade_multiply - aBasic.grenade_multiply - aEquip.grenade_multiply --宝物手雷冷却前使用次数
	aTreasure.inertia = a.inertia - aBasic.inertia - aEquip.inertia --宝物惯性
	aTreasure.crystal_rate = a.crystal_rate - aBasic.crystal_rate - aEquip.crystal_rate --宝物水晶收益率（去百分号后的值）
	aTreasure.melee_bounce = a.melee_bounce - aBasic.melee_bounce - aEquip.melee_bounce --宝物近战弹开
	aTreasure.melee_fight = a.melee_fight - aBasic.melee_fight - aEquip.melee_fight --宝物近战反击
	aTreasure.melee_stone = a.melee_stone - aBasic.melee_stone - aEquip.melee_stone --宝物近战碎石
	aTreasure.def_magic = a.def_magic - aBasic.def_magic - aEquip.def_magic
	aTreasure.crit_rate = a.crit_rate - aBasic.crit_rate - aEquip.crit_rate
	aTreasure.crit_value = a.crit_value - aBasic.crit_value - aEquip.crit_value
	aTreasure.pet_hp_restore = a.pet_hp_restore - aBasic.pet_hp_restore - aEquip.pet_hp_restore --宝物宠物回血
	aTreasure.pet_capacity = a.pet_capacity - aBasic.pet_capacity - aEquip.pet_capacity --宝物宠物携带数量
	aTreasure.trap_ground = a.trap_ground - aBasic.trap_ground - aEquip.trap_ground --宝物陷阱时间（单位：毫秒）
	aTreasure.trap_groundcd = a.trap_groundcd - aBasic.trap_groundcd - aEquip.trap_groundcd --宝物陷阱施法间隔（单位：毫秒）
	aTreasure.trap_groundenemy = a.trap_groundenemy - aBasic.trap_groundenemy - aEquip.trap_groundenemy --宝物陷阱困敌时间（单位：毫秒）
	aTreasure.trap_fly = a.trap_fly - aBasic.trap_fly - aEquip.trap_fly --宝物天网时间（单位：毫秒）
	aTreasure.trap_flycd = a.trap_flycd - aBasic.trap_flycd - aEquip.trap_flycd --宝物天网施法间隔（单位：毫秒）
	aTreasure.trap_flyenemy = a.trap_flyenemy - aBasic.trap_flyenemy - aEquip.trap_flyenemy --宝物天网困敌时间（单位：毫秒）
	aTreasure.puzzle = a.puzzle - aBasic.puzzle - aEquip.puzzle --宝物迷惑几率（去百分号后的值）
	aTreasure.weapon_crit_shoot = a.weapon_crit_shoot - aBasic.weapon_crit_shoot - aEquip.weapon_crit_shoot --宝物武器暴击
	aTreasure.weapon_crit_frozen = a.weapon_crit_frozen - aBasic.weapon_crit_frozen - aEquip.weapon_crit_frozen --宝物冰冻暴击
	aTreasure.weapon_crit_fire = a.weapon_crit_fire - aBasic.weapon_crit_fire - aEquip.weapon_crit_fire --宝物火焰暴击
	aTreasure.weapon_crit_equip = a.weapon_crit_equip - aBasic.weapon_crit_equip - aEquip.weapon_crit_equip --宝物装备暴击
	aTreasure.weapon_crit_hit = a.weapon_crit_hit - aBasic.weapon_crit_hit - aEquip.weapon_crit_hit --宝物击退暴击
	aTreasure.weapon_crit_blow = a.weapon_crit_blow - aBasic.weapon_crit_blow - aEquip.weapon_crit_blow --宝物吹风暴击
	aTreasure.weapon_crit_poison = a.weapon_crit_poison - aBasic.weapon_crit_poison - aEquip.weapon_crit_poison --宝物毒液暴击
	
	-------------------------------------------------
	
	--特殊处理：攻速重新计算
	--a.atk_interval = math.floor(a.atk_interval * (100 / a.atk_speed))
	--攻速为正数
	--print("a.atk_speed=", a.atk_speed)
	--print("a.atk_interval=", a.atk_interval)
	--print("a.atk_speed_basic=", a.atk_speed_basic)
	if (a.atk_speed >= 0) then
		if (a.atk_speed > hVar.ROLE_ATK_SPEED_MAX) then --攻击速度（去百分号后的值）上限
			a.atk_speed = hVar.ROLE_ATK_SPEED_MAX
		end
		
		a.atk_interval = math.floor(a.atk_interval * (a.atk_speed_basic / (a.atk_speed_basic + a.atk_speed)))
	end
	
	--攻速为负数
	if (a.atk_speed < 0) then
		if (a.atk_speed < hVar.ROLE_ATK_SPEED_MIN) then --攻击速度（去百分号后的值）下限
			a.atk_speed = hVar.ROLE_ATK_SPEED_MIN
		end
		
		a.atk_interval = math.floor(a.atk_interval * ((a.atk_speed_basic - a.atk_speed) / a.atk_speed_basic))
	end
	
	--复活时间最小值
	if (a.rebirth_time < hVar.ROLE_REBIRTH_MIN_TIME) then
		a.rebirth_time = hVar.ROLE_REBIRTH_MIN_TIME
	end
	if (a.rebirth_time > hVar.ROLE_REBIRTH_MAX_TIME) then
		a.rebirth_time = hVar.ROLE_REBIRTH_MAX_TIME
	end
	
	return a, aBasic, aEquip, aTreasure
end

--geyachao: 获得存档角色的属性列表
hApi.GetUnitAttrsByHeroCard = function(type_id)
	local cardLv = 1 --英雄的等级
	local cardStar = 1 --英雄星级
	local cardEquipment = nil --英雄装备
	
	local tabU = hVar.tab_unit[type_id] --tab表项
	local tabA = tabU.attr --tab表项的属性表
	
	--检测角色是否在存档中，如果存在，读取存档中的等级和星级
	local HeroCard = hApi.GetHeroCardById(type_id)
	if HeroCard and (type(HeroCard) == "table") and HeroCard.attr and (type(HeroCard.attr) == "table") then
		cardLv = HeroCard.attr.level or 1
		cardStar = HeroCard.attr.star or 1
	else --存档中不存在，那么读取tab表中的默认等级和星级
		cardLv = tabA.level or 1
		cardStar = tabA.star or 1
	end
	
	--读取装备栏的附加属性
	if HeroCard and (type(HeroCard) == "table") and HeroCard.equipment and (type(HeroCard.equipment) == "table") then
		cardEquipment = HeroCard.equipment
	end
	
	--读取宝物的附加属性
	local treasure = LuaGetTreasureBook() --宝物表
	local treasureAttr = LuaGetTreasureAttrList() --宝物属性位值表
	
	return hApi.GetUnitAttrs(type_id, cardLv, cardStar, cardEquipment, treasure, treasureAttr)
end


--获取装备的觉醒等级(1件4红神器算1级)
--返回值 觉醒等级, 武器觉醒等级, 防具觉醒等级, 宝物觉醒等级, 马觉醒等级
hApi.GetWakenLevel = function(equipment)
	local heroWakenLv = 0 --英雄觉醒等级
	local weaponWakenLv = 0 --武器觉醒等级
	local bodyWakenLv = 0 --防具觉醒等级
	local ornamentsWakenLv = 0 --宝物觉醒等级
	local horseWakenLv = 0 --马觉醒等级
	
	--战车暂无觉醒功能
	--...
	
	return heroWakenLv, weaponWakenLv, bodyWakenLv, ornamentsWakenLv, horseWakenLv
end

--[[
--弹出对话框，是否跳过引导（已废弃）
function MsgBox_GuideSkip(okCallback, cancelCallback, title)
	local MsgSelections = nil
	MsgSelections = {
		style = "mini",
		select = 0,
		ok = function()
			if okCallback then
				okCallback(MsgSelections.userflag)
			end
		end,
		cancel = function()
			if cancelCallback then
				cancelCallback(MsgSelections.userflag)
			end
		end,
		--cancelFun = cancelCallback, --点否的回调函数
		textOk = "跳过引导",
		textCancel = "否",
		userflag = 0, --用户的标记
	}
	local showTitle = "是否跳过引导？"
	if title then
		showTitle = "是否跳过引导 - " .. title .. "？"
	end
	local msgBox = hGlobal.UI.MsgBox(showTitle, MsgSelections)
	msgBox:active()
	msgBox:show(1,"fade",{time=0.08})
	
	local _frm = msgBox
	local _parent = _frm.handle._n
	local _childUI = _frm.childUI
	local _scoreLabX = 270
	local _scoreLabY = -160
	
	--文字
	_childUI["text"] = hUI.label:new({
		parent = _parent,
		size = 14,
		align = "LC",
		font = hVar.DEFAULT_FONT,
		x = _scoreLabX + 17,
		y = _scoreLabY,
		width = 300,
		border = 1,
		text = "记住选择并不再显示",
	})
	
	--选择框
	_childUI["selectbox"] = hUI.image:new({
		parent = _parent,
		model = "UI:Button_SelectBorder",
		x = _scoreLabX,
		y = _scoreLabY,
		w = 25,
		h = 25,
	})

	--选中的特效
	_childUI["selectbox_finish"] = hUI.image:new({
		parent = _parent,
		model = "UI:finish",
		x = _scoreLabX,
		y = _scoreLabY,
		w = 25,
		h = 25,
		scale = 0.01,
	})
	_childUI["selectbox_finish"].handle._n:setVisible(false)
	
	_childUI["language_sc_btn"] = hUI.button:new({
		parent = _frm,
		model = -1,
		--model = "UI:Button_SelectBorder",
		dragbox = _childUI["dragBox"],
		x = _scoreLabX,
		y = _scoreLabY,
		w = 25,
		h = 25,
		code = function(self)
			if (MsgSelections.userflag == 0) then
				MsgSelections.userflag = 1
				
				--动画表现
				local act1 = CCCallFunc:create(function() _childUI["selectbox_finish"].handle._n:setVisible(true) end)
				local act2 = CCScaleTo:create(0.05, 0.9)
				local sequence = CCSequence:createWithTwoActions(act1, act2)
				_childUI["selectbox_finish"].handle._n:runAction(sequence)
			else
				MsgSelections.userflag = 0
				
				--动画表现
				local act1 = CCScaleTo:create(0.05, 0.01)
				local act2 = CCCallFunc:create(function() _childUI["selectbox_finish"].handle._n:setVisible(false) end)
				local sequence = CCSequence:createWithTwoActions(act1, act2)
				_childUI["selectbox_finish"].handle._n:runAction(sequence)
			end
		end,
	})
end
]]

--弹出对话框，是否跳过引导
function MsgBox_GuideSkip(okCallback, cancelCallback, title)
	local W = 320
	local H = 300
	local tmpFrm = hUI.frame:new({
		x = hVar.SCREEN.w / 2 - W / 2,
		y = hVar.SCREEN.h / 2 + H / 2,
		w = W,
		h = H,
		--z = -1,
		show = 1,
		dragable = 2,
		--buttononly = 1,
		autoactive = 1,
		--background = "UI:PANEL_INFO_MINI",
	})
	tmpFrm:active() --最前端显示
	
	--文字
	tmpFrm.childUI["title"] = hUI.label:new({
		parent = tmpFrm.handle._n,
		x = 20,
		y = -50,
		w = 100,
		h = 80,
		width = 420,
		align = "LC",
		font = hVar.FONTC,
		text = "欢迎进入新手引导。",
		size = 26,
		--RGB = {255,0,0},
	})
	
	--点击“不需要引导”按钮
	tmpFrm.childUI["okBtn"] = hUI.button:new({
		parent = tmpFrm.handle._n,
		dragbox = tmpFrm.childUI["dragBox"],
		model = "misc/ButtonWide.png",
		--icon = "ui/hall.png",
		--iconWH = 28,
		label = "我不需要引导，谢谢",
		font = hVar.FONTC,
		border = 1,
		align = "MC",
		scaleT = 0.95,
		x = W / 2,
		y = -H / 2 - 70,
		w = 300,
		size = 10,
		h = 50,
		z = 100,
		scale = btnScale,
		code = function(self)
			if okCallback then
				okCallback(1)
			end
			
			tmpFrm:del()
		end,
	})
	
	--点击“需要引导”按钮
	tmpFrm.childUI["cancelBtn"] = hUI.button:new({
		parent = tmpFrm.handle._n,
		dragbox = tmpFrm.childUI["dragBox"],
		model = "misc/ButtonWide.png",
		--icon = "ui/hall.png",
		--iconWH = 28,
		label = "我是新手，需要引导",
		font = hVar.FONTC,
		border = 1,
		align = "MC",
		scaleT = 0.95,
		x = W / 2,
		y = -H / 2 + 20,
		w = 300,
		size = 10,
		h = 50,
		z = 100,
		scale = btnScale,
		code = function(self)
			if cancelCallback then
				cancelCallback(1)
			end
			
			tmpFrm:del()
		end,
	})
end

--检测存档中是否存在可以升级的战术技能卡
hApi.IsEnableUpgrateTacticCard = function()
	local tTactics = LuaGetPlayerSkillBook()
	local nowScore = LuaGetPlayerScore() --当前的积分
	
	--不存在战术技能卡，返回不能升级
	if (not tTactics) then
		return false
	end
	
	--遍历所有的战术技能卡
	for i = 1, #tTactics, 1 do
		if (type(tTactics[i]) == "table") then
			local id, lv, num = unpack(tTactics[i])
			--print("find tower:".. tostring(id).. ",".. tostring(lv).. ",".. tostring(num))
			
			--存在表项
			if hVar.tab_tactics[id] then
				local type = hVar.tab_tactics[id].type --战术技能卡类型
				if (type == hVar.TACTICS_TYPE.OTHER) or (type == hVar.TACTICS_TYPE.TOWER) or (type == hVar.TACTICS_TYPE.SPECIAL) then --只处理塔类战术技能卡、一般战术技能卡、特殊塔
					--升级战术技能卡需要的碎片数量
					local tacticLv = lv --战术技能卡的等级
					local costDebris = 0 --需要的碎片数量
					local nowDebris = num --当前的碎片数量
					local costScore = 0 --需要的积分
					
					--未升满级
					if (tacticLv < hVar.TACTIC_LVUP_INFO.maxTacticLv) then
						local tacticLvUpInfo = hVar.TACTIC_LVUP_INFO[tacticLv]
						costDebris = tacticLvUpInfo.costDebris or 0 --需要的碎片数量
						local shopItemId = tacticLvUpInfo.shopItemId or 0
						local tabShopItem = hVar.tab_shopitem[shopItemId]
						if tabShopItem then
							--costRmb = tabShopItem.rmb or 0
							costScore = tabShopItem.score or 0 --需要的积分
							
							--积分、碎片数量都符合，并且等级未到顶级
							if (nowDebris >= costDebris) and (nowScore >= costScore) and (tacticLv < hVar.TACTIC_LVUP_INFO.maxTacticLv) then
								return true
							end
						end
					else --到顶级了
						--
					end
					
				end
			end
		end
	end
	
	--走到这里说明都不符合
	return false
end

--检测存档中是否有可以升级的英雄技能
hApi.IsEnableUpgrateHeroSkill = function()
	--不存在存档表，返回false
	if (not Save_PlayerData) then
		return false
	end
	
	--不存在玩家卡片，返回false
	if (not Save_PlayerData.herocard) then
		return false
	end
	
	--无效的玩家卡片类型，返回false
	if (type(Save_PlayerData.herocard) ~= "table") then
		return false
	end
	
	local nowScore = LuaGetPlayerScore() --当前积分
	
	--依次遍历每一个英雄卡牌
	for i = 1, #Save_PlayerData.herocard, 1 do
		local hero = Save_PlayerData.herocard[i]
		if (type(hero) == "table") then
			local heroId = hero.id
			local heroLv = hero.attr and hero.attr.level or 0 --英雄的等级
			local heroStar = hero.attr and hero.attr.star or 0 --英雄的星级
			local starInfo = hVar.HERO_STAR_INFO[heroId] and hVar.HERO_STAR_INFO[heroId][heroStar]
			if starInfo then
				local maxLv = starInfo.maxLv --当前星级下的等级上限
				
				--检测技能是否有可以升级的
				local talent = hero.talent
				if (type(talent) == "table") then
					for i = 1, #talent, 1 do
						if (type(talent[i]) == "table") then
							local id = talent[i].id --技能id
							local lv = talent[i].lv --技能等级
							
							--有效的技能id
							if id and (id > 0) then
								--如果技能未到顶级，并且小于英雄的等级，并且积分足够，那么提示升级
								local costScore = 0 --升级需要的积分
								local shopItemId = hVar.SKILL_LVUP_COST[lv] or 0
								local tabShopItem = hVar.tab_shopitem[shopItemId]
								if tabShopItem then
									costScore = tabShopItem.score or 0
								end
								
								--如果技能未到顶级，并且小于英雄的等级，并且积分足够，那么提示升级
								if (lv > 0) and (lv < maxLv) and (lv < heroLv) and (nowScore >= costScore) then --技能可以升级
									return true
								end
							end
						end
					end
				end
				
				--检测战术技能是否有可以升级的
				local tactic = hero.tactic
				if (type(tactic) == "table") then
					for i = 1, #tactic, 1 do
						if (type(tactic[i]) == "table") then
							local id = tactic[i].id --技能id
							local lv = tactic[i].lv --技能等级
							
							--有效的技能id
							if id and (id > 0) then
								--如果技能未到顶级，并且小于英雄的等级，并且积分足够，那么提示升级
								local costScore = 0 --升级需要的积分
								local shopItemId = hVar.SKILL_LVUP_COST[lv] or 0
								local tabShopItem = hVar.tab_shopitem[shopItemId]
								if tabShopItem then
									costScore = tabShopItem.score or 0
								end
								
								--如果技能未到顶级，并且小于英雄的等级，并且积分足够，那么提示升级
								if (lv > 0) and (lv < maxLv) and (lv < heroLv) and (nowScore >= costScore) then --技能可以升级
									return true
								end
							end
						end
					end
				end
			end
		end
	end
	
	--走到这里说明没有可以升级的技能
	return false
end

--检测指定英雄是否有可以升级的技能
hApi.IsEnableUpgrateSkill = function(type_id)
	--不存在存档表，返回false
	if (not Save_PlayerData) then
		return false
	end
	
	--不存在玩家卡片，返回false
	if (not Save_PlayerData.herocard) then
		return false
	end
	
	--无效的玩家卡片类型，返回false
	if (type(Save_PlayerData.herocard) ~= "table") then
		return false
	end
	
	--依次遍历每一个英雄卡牌，检测是否为指定英雄
	for i = 1, #Save_PlayerData.herocard, 1 do
		local hero = Save_PlayerData.herocard[i]
		if (type(hero) == "table") then
			if (hero.id == type_id) then --指定的英雄
				local heroLv = hero.attr and hero.attr.level or 0 --英雄的等级
				local nowScore = LuaGetPlayerScore() --当前积分
				local star = hero.attr and hero.attr.star or 0 --英雄的星级
				local starInfo = hVar.HERO_STAR_INFO[type_id][star]
				local maxLv = starInfo.maxLv --等级上限
				
				--检测技能是否有可以升级的
				local talent = hero.talent
				if (type(talent) == "table") then
					for i = 1, #talent, 1 do
						if (type(talent[i]) == "table") then
							local id = talent[i].id --技能id
							local lv = talent[i].lv --技能等级
							
							--有效的技能id
							if id and (id > 0) then
								--如果技能未到顶级，并且小于英雄的等级，并且积分足够，那么提示升级
								local costScore = 0 --升级需要的积分
								local shopItemId = hVar.SKILL_LVUP_COST[lv] or 0
								local tabShopItem = hVar.tab_shopitem[shopItemId]
								if tabShopItem then
									costScore = tabShopItem.score or 0
								end
								
								--如果技能未到顶级，并且小于英雄的等级，并且积分足够，那么提示升级
								if (lv > 0) and (lv < maxLv) and (lv < heroLv) and (nowScore >= costScore) then --技能可以升级
									return true
								end
							end
						end
					end
				end
				
				--检测战术技能是否有可以升级的
				local tactic = hero.tactic
				if (type(tactic) == "table") then
					for i = 1, #tactic, 1 do
						if (type(tactic[i]) == "table") then
							local id = tactic[i].id --技能id
							local lv = tactic[i].lv --技能等级
							
							--有效的技能id
							if id and (id > 0) then
								--如果技能未到顶级，并且小于英雄的等级，并且积分足够，那么提示升级
								local costScore = 0 --升级需要的积分
								local shopItemId = hVar.SKILL_LVUP_COST[lv] or 0
								local tabShopItem = hVar.tab_shopitem[shopItemId]
								if tabShopItem then
									costScore = tabShopItem.score or 0
								end
								
								--如果技能未到顶级，并且小于英雄的等级，并且积分足够，那么提示升级
								if (lv > 0) and (lv < maxLv) and (lv < heroLv) and (nowScore >= costScore) then --技能可以升级
									return true
								end
							end
						end
					end
				end
			end
		end
	end
	
	--走到这里说明该英雄没有可以升级的技能
	return false
end

--检测存档中是否有可以升星的英雄
hApi.IsEnableUpgrateHeroStar = function()
	--不存在存档表，返回false
	if (not Save_PlayerData) then
		return false
	end
	
	--不存在玩家卡片，返回false
	if (not Save_PlayerData.herocard) then
		return false
	end
	
	--无效的玩家卡片类型，返回false
	if (type(Save_PlayerData.herocard) ~= "table") then
		return false
	end
	
	--依次遍历每一个英雄卡牌
	for i = 1, #Save_PlayerData.herocard, 1 do
		local hero = Save_PlayerData.herocard[i]
		if (type(hero) == "table") then
			local heroId = hero.id
			local heroLv = hero.attr and hero.attr.level or 0 --英雄的等级
			--local nowScore = LuaGetPlayerScore() --当前积分
			local heroStar = hero.attr and hero.attr.star or 0 --英雄的星级
			local starInfo = hVar.HERO_STAR_INFO[heroId] and hVar.HERO_STAR_INFO[heroId][heroStar]
			if starInfo then
				--当前此英雄的碎片数量
				local heroDebris = 0 --英雄将魂碎片的数量
				heroDebris = g_myPvP_BaseInfo.heroInfo[heroId] and g_myPvP_BaseInfo.heroInfo[heroId].soulstone or 0
				
				local maxStarLv = hVar.HERO_STAR_INFO.maxStarLv --最高星级
				local maxLv = 0 --当前星级的等级上限
				local costSoulStone = 0 --升到下一星需要的碎片数量
				if (heroStar < maxStarLv) then
					costSoulStone = starInfo.costSoulStone
					maxLv = starInfo.maxLv
				else
					costSoulStone = hVar.HERO_STAR_INFO[heroId][maxStarLv].costSoulStone
					maxLv = starInfo.maxLv
				end
				
				--如果等级升到最高级，碎片数量足够，星未到顶级，那么提示可升星箭头
				if (heroLv >= maxLv) and (heroDebris >= costSoulStone) and (heroStar < maxStarLv) then
					return true
				end
			end
		end
	end
	
	--走到这里说明没有可以升星的英雄
	return false
end

--检测存档中是否有可以升级的兵种卡
hApi.IsEnableUpgrateArmyCard = function()
	--不存在竞技场基础信息，返回false
	if (not g_myPvP_BaseInfo) then
		return false
	end
	
	--不存在竞技场基础信息的兵种卡表，返回false
	if (not g_myPvP_BaseInfo.tacticInfo) then
		return false
	end
	
	--依次遍历
	for k, v in pairs(g_myPvP_BaseInfo.tacticInfo) do
		local tacticId = k
		local tacticLv = v.lv
		local debris = v.debris
		
		--显示不超过最大等级
		local maxLv = hVar.TACTIC_LVUP_INFO.maxArmyLv or 1
		if (tacticLv > maxLv) then
			tacticLv = maxLv
		end
		--如果碎片数量足够，未到顶级，那么提示可升级
		if hVar.tab_tactics[tacticId] then
			local armLvupInfo = hVar.tab_tactics[tacticId].armLvupInfo
			local material = armLvupInfo[tacticLv] and armLvupInfo[tacticLv].material or {} --升到下一级需要材料
			
			--兵种碎片足够，未到顶级，才能升级
			local bDebrisEnough = true --碎片是否足够
			for i = 1, #material, 1 do
				--兵种卡升级信息
				local requireTacticId = material[i].id --升到下一级需要的兵种id
				local requireDebris = material[i].num or 9999 --升到下一级需要的碎片
				local debris = g_myPvP_BaseInfo.tacticInfo[requireTacticId] and g_myPvP_BaseInfo.tacticInfo[requireTacticId].debris or 0 --本兵种卡当前碎片数量
				--print("requireTacticId=" .. requireTacticId, debris, requireDebris)
				if (debris < requireDebris) then
					bDebrisEnough = false --碎片不足
				end
			end
			--local maxLv = hVar.TACTIC_LVUP_INFO.maxArmyLv or 1
			if (bDebrisEnough) and (tacticLv < maxLv) then
				--print(bDebrisEnough, tacticLv, maxLv)
				return true
			end
		end
	end
	
	--走到这里说明没有可以升级的兵种卡
	return false
end

--检测是否有可以开的宝箱
local CHEST_OPEN_TIME_TABLE =
{
	[9913] = 0, --免费箱子
	[9914] = 3600 * 3, --蓝色箱子
	[9915] = 3600 * 8, --紫色箱子
	[99999] = 3600 * 8, --免费箱子等待开启
}
hApi.IsEnablePvpChestOpen = function()
	local bHaveChestOpening = false
	
	--[[
	--在竞技场按钮开放的情况下，自动连接pvp服务器
	if (g_pvp_button_open == 1) then
		--未连接
		if (Pvp_Server:GetState() ~= 1) then
			Pvp_Server:Connect()
			--print("hApi.IsEnablePvpChestOpenhApi.IsEnablePvpChestOpenhApi.IsEnablePvpChestOpenhApi.IsEnablePvpChestOpen", "未连接")
			return bHaveChestOpening
		end
		
		--未登入
		if (not hGlobal.LocalPlayer:getonline()) then
			Pvp_Server:UserLogin()
			--print("hApi.IsEnablePvpChestOpenhApi.IsEnablePvpChestOpenhApi.IsEnablePvpChestOpenhApi.IsEnablePvpChestOpen", "未登入")
			return bHaveChestOpening
		end
	end
	]]
	
	for i = 1, 4, 1 do
		local localTime_pvp = os.time() --pvp客户端时间
		local hostTime_pvp = localTime_pvp - g_localDeltaTime_pvp --pvp服务器时间(Local = Host + deltaTime)
		local listI = g_myPvP_BaseInfo.chestList[i - 1] or {} --第i项
		if (i == 1) then
			listI = g_myPvP_BaseInfo.freechest or {}
		end
		local id = listI.id or 0 --道具id
		local gettime = 0
		local requiretime = 0
		if (id ~= 0) then
			gettime = listI.gettime or 0 --上次领取的时间
			requiretime = CHEST_OPEN_TIME_TABLE[id] --需要开箱子的时间
		end
		
		--print(id, gettime)
		local deltatime = hostTime_pvp - gettime --相差间隔
		local lefttime = requiretime - deltatime --剩余的总时间(秒)
		--local deltaHours = math.floor(lefttime / 3600) --时
		--local deltaMinutes = math.floor((lefttime - deltaHours * 3600) / 60) --分
		--local deltaSeconds = lefttime - deltaHours * 3600 - deltaMinutes * 60 --秒
		
		--如果未连接、未登入，不能操作宝箱
		--if (Pvp_Server:GetState() ~= 1) or (not hGlobal.LocalPlayer:getonline()) then
			--
		if (id == 0) or (gettime == 0) then --未购买的宝箱
			--
		elseif (lefttime >= 0) then --未开启
			--
		else --已开启
			bHaveChestOpening = true
		end
	end
	
	return bHaveChestOpening
end

--by zhenkira 2016.3.9
--获取道具合成信息
hApi.GetItemMergeInfo = function(mergeItemLv, materialItemLv)
	return hVar.ITEM_MERGE_INFO[mergeItemLv or hVar.ITEM_QUALITY.WHITE][materialItemLv or hVar.ITEM_QUALITY.WHITE]
end

--by zhenkira 2016.3.9
--获取道具装备等级限制的层级
hApi.GetItemLvLimitLevel = function(itemId)
	local ret = 1
	
	if hVar.tab_item[itemId] and hVar.tab_item[itemId].require and type(hVar.tab_item[itemId].require) == "table" then
		for i = 1, #hVar.tab_item[itemId].require do
			local info = hVar.tab_item[itemId].require[i]
			if info[1] and info[1] == "level" then
				local idx = math.min((info[2] or 1), hVar.ITEM_LVLIMIT_LEVEL.maxLimitLv)
				ret = hVar.ITEM_LVLIMIT_LEVEL[idx]
				break
			end
		end
	end
	return ret
end

--by zhenkira 2016.3.9
--检测道具是否是装备
hApi.CheckItemIsEquip = function(itemId)
	local ret = false
	if hVar.tab_item[itemId] and hVar.tab_item[itemId].type >= hVar.ITEM_TYPE.HEAD and hVar.tab_item[itemId].type <= hVar.ITEM_TYPE.FOOT then
		ret = true
	end
	
	return ret
end

--by zhenkira 2016.3.9
--计算道具价值转化为金币
hApi.CaculateItemValueToGold = function(oItem)
	--道具价值
	local itemValue = 1
	
	local itemId = oItem[hVar.ITEM_DATA_INDEX.ID]			--材料道具id
	local itemSlot = oItem[hVar.ITEM_DATA_INDEX.SLOT]		--材料道具属性
	
	--如果道具表存在
	if hVar.tab_item[itemId] then
		
		itemValue = math.ceil((hVar.tab_item[itemId].itemValue or 1) / 2)			--道具基本价值
		
		local itemLv = hVar.tab_item[itemId].itemLv or hVar.ITEM_QUALITY.WHITE	--道具品质
		local maxSlot = hVar.ITEM_ATTR_EX_LIMIT[itemLv]				--道具品质对应最大属性数
		
		--道具扩展属性存在，并且该品质道具有扩展属性
		if itemSlot and type(itemSlot) == "table" and maxSlot > 0 then
			local attrNum = 0
			--遍历所有扩展属性
			for i = 1, #itemSlot do
				local attr = itemSlot[i]
				--如果是新属性
				if attr and type(attr) == "string" then
					--计算属性价值
					local attrQuality = hVar.ITEM_ATTR_VAL[attr].quality
					local attrValue = hVar.ITEM_ATTR_EX_VALUE[attrQuality] or 1
					itemValue = itemValue + attrValue * 2
					attrNum = attrNum + 1
				end
				--如果属性已经大于该品质的最大属性，则退出
				if attrNum >= maxSlot then
					break
				end
			end
		end
	end
	
	return itemValue
end

--by zhenkira 2016.3.9
--计算道具价值
hApi.CaculateItemValue = function(oItem)
	--道具价值
	local itemValue = 1
	
	local itemId = oItem[hVar.ITEM_DATA_INDEX.ID]			--材料道具id
	local itemSlot = oItem[hVar.ITEM_DATA_INDEX.SLOT]		--材料道具属性
	
	--如果道具表存在
	if hVar.tab_item[itemId] then
		
		itemValue = hVar.tab_item[itemId].itemValue or 1			--道具基本价值
		
		local itemLv = hVar.tab_item[itemId].itemLv or hVar.ITEM_QUALITY.WHITE	--道具品质
		local maxSlot = hVar.ITEM_ATTR_EX_LIMIT[itemLv]				--道具品质对应最大属性数
		
		--道具扩展属性存在，并且该品质道具有扩展属性
		if itemSlot and type(itemSlot) == "table" and maxSlot > 0 then
			local attrNum = 0
			--遍历所有扩展属性
			for i = 1, #itemSlot do
				local attr = itemSlot[i]
				--如果是新属性
				if attr and type(attr) == "string" then
					--计算属性价值
					local attrQuality = hVar.ITEM_ATTR_VAL[attr].quality
					local attrValue = hVar.ITEM_ATTR_EX_VALUE[attrQuality] or 1
					itemValue = itemValue + attrValue
					attrNum = attrNum + 1
				end
				--如果属性已经大于该品质的最大属性，则退出
				if attrNum >= maxSlot then
					break
				end
			end
		end
	end
	
	return itemValue
end

--by zhenkira 2016.3.9
--计算道具价值
hApi.GetItemMergePool = function(itemLv, equipLv, itemType)
	--local ret = {}
	--if hVar.ITEM_MERGE_POOL[itemLv] and hVar.ITEM_MERGE_POOL[itemLv][equipLv] and hVar.ITEM_MERGE_POOL[itemLv][equipLv][itemType] then
	--	local pool = hVar.ITEM_MERGE_POOL[itemLv][equipLv][itemType]
	--	--遍历道具池，筛选出符合道具池装备品质的道具
	--	for i = 1, #pool do
	--		local itemId = pool[i]
	--		if hVar.tab_item[itemId] and ((hVar.tab_item[itemId].itemLv or hVar.ITEM_QUALITY.WHITE)) == itemLv then
	--			ret[#ret + 1] = itemId
	--		end
	--	end
	--end
	--return ret

	local ret = {}
	if hVar.ITEM_MERGE_POOL[itemLv] and hVar.ITEM_MERGE_POOL[itemLv][itemType]  then
		local pool = hVar.ITEM_MERGE_POOL[itemLv][itemType]
		--遍历道具池，筛选出符合道具池装备品质的道具
		for i = 1, #pool do
			local itemId = pool[i]
			if hVar.tab_item[itemId] and ((hVar.tab_item[itemId].itemLv or hVar.ITEM_QUALITY.WHITE)) == itemLv then
				for n = 1, #hVar.tab_item[itemId].require do
					local info = hVar.tab_item[itemId].require[n]
					if info[1] and info[1] == "level" then
						local requireLv = math.min((info[2] or 1), hVar.ITEM_LVLIMIT_LEVEL.maxLimitLv)
						if equipLv <= 6 then
							if requireLv <= 6 then
								ret[#ret + 1] = itemId
							end
						elseif equipLv > 6 then
							if requireLv > 6 then
								ret[#ret + 1] = itemId
							end
						end
					end
				end
			end
		end
	end
	return ret
end

--by zhenkira 2016.3.16
--产生道具洗练属性品质
hApi.MakeItemXiLianAttrLv = function(itemLv)
	--返回属性品质
	local ret
	--属性权重范围临时值
	local tmpAttrInfo = {}
	--总权值
	local sumWeight = 0
	
	--获取当前道具品质等级对应的属性权值信息
	if hVar.ITEM_XILIAN_INFO[itemLv] and hVar.ITEM_XILIAN_INFO[itemLv].attr then
		
		--属性权重信息
		local attrInfo = hVar.ITEM_XILIAN_INFO[itemLv].attr
		
		--遍历所有权重信息，记录每一个属性权重范围，计算总的权重
		for attr,weight in pairs(attrInfo) do
			--权重为0直接跳过
			if weight > 0 then
				tmpAttrInfo[attr] = {}
				tmpAttrInfo[attr].min = sumWeight
				sumWeight = sumWeight + weight
				tmpAttrInfo[attr].max = sumWeight
			end
		end
		
		--在总权重范围内随机
		local rWeight = hApi.random(1, sumWeight)
		
		--遍历权重范围临时值,看随机权值落在哪个区间
		for attr, weightInfo in pairs(tmpAttrInfo) do
			if rWeight > weightInfo.min and rWeight <= weightInfo.max then
				ret = attr
				break
			end
		end
	end

	return ret
end

--获得道具洗练需要的积分
hApi.GetItemXiLianScore = function(itemLv)
	local ret = 0
	--获取当前道具品质等级对应的属性权值信息
	if hVar.ITEM_XILIAN_INFO[itemLv] and hVar.ITEM_XILIAN_INFO[itemLv].cost then
		ret = hVar.ITEM_XILIAN_INFO[itemLv].cost
	end
	return ret
end

--获得洗练道具锁孔需要的金币和对应的道具id
hApi.GetItemLockInfo = function(lockNum)
	local rmb = 0
	local itemId = 9902
	
	if hVar.ITEM_XILIAN_INFO.lockInfo then
		local num = math.min(math.max((lockNum or 0), 0), hVar.ITEM_XILIAN_INFO.lockInfo.maxLock)
		local lockInfo = hVar.ITEM_XILIAN_INFO.lockInfo[num]
		rmb = lockInfo[1] or 0
		itemId = lockInfo[2] or 9902
	end

	return rmb, itemId
end

--获得道具重铸扩孔第几个孔
hApi.GetItemRebuildInfo = function(attrNum)
	local rmb = 0
	local itemId = 9906
	
	if hVar.ITEM_REBUILD_INFO then
		local attrInfo = hVar.ITEM_REBUILD_INFO[attrNum]
		rmb = attrInfo[1] or 0
		itemId = attrInfo[2] or 9906
	end
	
	return rmb, itemId
end

--add by zhenkira 2016.4.6
--时间转化为数值
hApi.Date2Num = function(sDate)
	if (sDate and type(sDate)~="string") then
		return 0
	end
	
	local a,b,yy,mm,dd = string.find(sDate,"(%d+)-(%d+)-(%d+)")
	if yy then
		return tonumber(yy)*10000+tonumber(mm)*100+tonumber(dd)
	else
		return 0
	end
end

--成就完成检测函数
hApi.CheckMadel = function(madelType)
	--记录新达成成就列表
	local finishMedal = {}
	local retVal = false --是否存在可领取的成就
	for MedalID, medal in pairs(hVar.tab_medal) do
		local medalState = LuaGetPlayerMedal(MedalID)
		--如果该成就是已完成，那么返回值为true
		if (medalState == 1) then
			retVal = true
		end
		
		--print("medalState", MedalID, medalState)
		--只检测状态是未完成的
		if (medalState < 1) then
			local condition = medal["conditions"]
			if condition ~= nil then
				local checkFlag = false
				if (not madelType) or (madelType and condition[madelType]) then
					checkFlag = true
				end
				local conditionNum = 0
				local conditionFinish = 0
				for conditionsStr, conditionInfo in pairs(condition) do
					conditionNum = conditionNum + 1
					
					--地图通关信息
					if (conditionsStr == hVar.MEDAL_TYPE.map) then
						--过第N关
						--[hVar.MEDAL_TYPE.map] = "world/td_001_lsc",	
						local mapName = conditionInfo
						local isFinish = LuaGetPlayerMapAchi(mapName,hVar.ACHIEVEMENT_TYPE.LEVEL) or 0
						if isFinish > 0 then
							conditionFinish = conditionFinish + 1
						end
					elseif (conditionStr == hVar.MEDAL_TYPE.mapCondition) or (conditionStr == hVar.MEDAL_TYPE.chapterCondition) then
						--不处理
					elseif (conditionsStr == hVar.MEDAL_TYPE.killUT) or (conditionsStr == hVar.MEDAL_TYPE.buildTT) or (conditionsStr == hVar.MEDAL_TYPE.killUS) or (conditionsStr == hVar.MEDAL_TYPE.buyItem) then
						local unitInfo = conditionInfo
						if conditionInfo and type(conditionInfo) == "table" then
							local typeU = conditionInfo[1]
							local finishN = conditionInfo[2]
							local nowN = LuaGetPlayerCountVal(conditionsStr, typeU)
							
							if (nowN >= finishN) then
								conditionFinish = conditionFinish + 1
							end
						end
					elseif (conditionsStr == hVar.MEDAL_TYPE.td_wj_001) or (conditionsStr == hVar.MEDAL_TYPE.td_wj_002) then
						if conditionInfo then
							local finishN = conditionInfo
							local nowN = LuaGetPlayerGamecenter_Challenge(conditionsStr)
							
							if (nowN >= finishN) then
								conditionFinish = conditionFinish + 1
							end
						end
					elseif (conditionsStr == hVar.MEDAL_TYPE.starCount) then --获得的星星
						if conditionInfo then
							local finishN = conditionInfo
							local nowN = LuaGetPlayerStarCountVal()
							
							if (nowN >= finishN) then
								conditionFinish = conditionFinish + 1
							end
							--print("获得的星星", nowN, finishN)
						end
					elseif (conditionsStr == hVar.MEDAL_TYPE.rescueScientist) then --累计拯救科学家的数量
						if conditionInfo then
							local finishN = conditionInfo
							local nowN = LuaGetTankScientistNum()
							
							if (nowN >= finishN) then
								conditionFinish = conditionFinish + 1
							end
							--print("累计拯救科学家的数量", nowN, finishN)
						end
					elseif (conditionsStr == hVar.MEDAL_TYPE.tankDeadthCount) then --累计战车死亡的数量
						if conditionInfo then
							local finishN = conditionInfo
							local nowN = LuaGetTankDeadthNum()
							
							if (nowN >= finishN) then
								conditionFinish = conditionFinish + 1
							end
							--print("累计战车死亡的数量", nowN, finishN)
						end
					else
						local unitInfo = conditionInfo
						if conditionInfo then
							local finishN = conditionInfo
							local nowN = LuaGetPlayerCountVal(conditionsStr)
							
							if (nowN >= finishN) then
								conditionFinish = conditionFinish + 1
							end
						end
					end
				end
				
				--如果所有条件都满足,则设置为完成成就状态
				if (conditionNum > 0) and (conditionFinish == conditionNum) then
					LuaSetPlayerMedal(MedalID, 1)
					--print("LuaSetPlayerMedal(MedalID,1)") --测试
					finishMedal[#finishMedal + 1] = MedalID
				end
			end
		end
	end
	
	--触发事件：新成就达成
	if (#finishMedal > 0) then
		retVal = true --存在新完成的成就，返回值是true
		hGlobal.event:event("LocalEvent_PlayerMadelChange", finishMedal)
	end
	
	--返回值：是否有已完成的成就
	return retVal
end

--指定的成就类型是否完成检测函数
hApi.CheckMadelByType = function(medalType)
	
	--先检测一遍全部成就，更新完成标记
	hApi.CheckMadel()
	
	local retVal = false --是否存在可领取的成就
	
	--检测已达成的成就
	for i = 1, #hVar.tab_medalEx, 1 do
		local medalId = hVar.tab_medalEx[i] --成就id
		local tabAchievement = hVar.tab_medal[medalId]
		local condition = ""
		for k, v in pairs(tabAchievement.conditions) do
			condition = k
		end
		--成就类型一致
		if (condition == medalType) then
			local state = LuaGetPlayerMedal(medalId) --成就状态(0:未完成 / 1:已达成 / 2:已领取)
			if (state == 1) then --已达成
				retVal = true
				break
			end
		end
	end
	
	return retVal
end

--检测是否满足条件：只使用xxx
local __checkUseOnly = function(tCondition, tUse, sParamType)
	local allMeetFlag = true
	local pType = sParamType or "number"
	local tmpCondition = {}
	for n = 2, #tCondition do
		if not allMeetFlag then
			break
		end
		local id = tCondition[n] or "0"
		--如果参数类型为数字
		if pType == "number" then
			id = tonumber(id)
		end
		tmpCondition[id] = true
	end
	
	--如果使用了目标战术技能卡，则检测是否还使用了其他的战术技能卡
	--print("__checkUseOnly1:", id)
	
	local useNum = 0
	for useId, v in pairs(tUse) do
		useNum = useNum + 1
		--print("__checkUseOnly2:", useId, v, id)
		if (v and not tmpCondition[useId] ) then
			allMeetFlag = false
			break
		end
	end
	--if useNum == 0 then
	--	allMeetFlag = false
	--end

	return allMeetFlag
end

--检测是否满足条件：未使用xxx
local __checkUnuse = function(tCondition, tUse, sParamType)
	local allMeetFlag = true
	local pType = sParamType or "number"

	local find = false
	for n = 2, #tCondition do
		if not allMeetFlag then
			break
		end
		
		local id = tCondition[n] or "0"

		
		--如果含参数all，表示不允许使用所有内容，如果使用任何一个则不满足条件
		if string.upper(id) == "ALL" then
			for k, v in pairs(tUse) do
				if v then
					find = true
					break
				end
			end
			--break
		else
			--如果参数类型为数字
			if pType == "number" then
				id = tonumber(id)
			end
			
			if tUse[id] then
				find = true
				break
			end
		end
		
	end

	if find then
		allMeetFlag = false
	end
	return allMeetFlag
end

--检测地图完成是否符合条件
hApi.CheckMapCondition = function(conditionType, mapName, condition)
	
	
	local ret = false
	local oWorld = hGlobal.WORLD.LastWorldMap
	
	--如果不存在，则返回
	if not oWorld then
		return ret
	end
	
	local mapInfo = oWorld.data.tdMapInfo
	if not mapInfo then
		return ret
	end
	
	local d = oWorld.data
	
	--检测参数合法性
	if mapName and condition and type(mapName) == "string" and type(condition) == "string" then
		--地图所在章节
		local tabM = hVar.MAP_INFO[mapName]

		if not tabM then
			return ret
		end

		local chapterId = tabM.chapter or 0

		if chapterId <= 0 or not hVar.tab_chapter[chapterId] then
			return ret
		end

		local nowName = mapName
		if conditionType == hVar.MEDAL_TYPE.chapterCondition then
			nowName = tostring(chapterId)
		end
		--print("hApi.CheckMapCondition1")
		--分割条件字符串
		local tCondition = hApi.Split(condition, "|")
		--print("hApi.CheckMapCondition2:", #tCondition)
		--如果条件字符串存在
		if tCondition and #tCondition > 0 then
			local checkInfo = tCondition[1] or ""
			local tCheckInfo = hApi.Split(checkInfo, ":")
			local checkName = tCheckInfo[1] or ""
			local checkDiff = tonumber(tCheckInfo[2] or "-1")
			--print("hApi.CheckMapCondition3:", checkName, mapName,checkDiff,mapInfo.mapMode,tCondition[1],tCondition[2])
			--如果地图名相等则继续解析
			if nowName == checkName then
				--如果checkdiff为-1标示对所有模式生效 或者 如果checkdiff为0并且当前是普通模式或者无尽模式  或者 checkDiff与当前挑战难度相等并且当前为挑战难度
				if (checkDiff == -1) or (checkDiff == 0 and (mapInfo.mapMode == hVar.MAP_TD_TYPE.NORMAL or mapInfo.mapMode == hVar.MAP_TD_TYPE.ENDLESS)) or (checkDiff > 0 and checkDiff == mapInfo.mapDifficulty and mapInfo.mapMode == hVar.MAP_TD_TYPE.DIFFICULT) then
				
					--如果条件表长度大于1则继续解析
					if #tCondition > 1 then
						local allMeetFlag = true
						--遍历，处理条件
						for i = 2, #tCondition do
							if not allMeetFlag then
								--print("hApi.CheckMapCondition5:")
								ret = false
								break
							end
							local sOneC = tCondition[i]
							--print("hApi.CheckMapCondition4:", sOneC)
							local tOneC = hApi.Split(sOneC, ":")
							if tOneC and #tOneC > 0 then
								local conType = tOneC[1]
								--只使用某种战术技能卡
								if conType == "useS" then
									local useS = d.statistics.tactic
									allMeetFlag = __checkUseOnly(tOneC, useS)
								--不使用某种战术技能卡
								elseif conType == "unuseS" then
									local useS = d.statistics.tactic
									allMeetFlag = __checkUnuse(tOneC, useS)
									--print("abc"..abc)
								--只使用某种塔
								elseif conType == "useT" then
									local useT = d.statistics.tower
									allMeetFlag = __checkUseOnly(tOneC, useT)
								--不使用某种塔
								elseif conType == "unuseT" then
									local useT = d.statistics.tower
									allMeetFlag = __checkUnuse(tOneC, useT)
								--英雄死亡次数限制
								elseif conType == "deadH" then
								
									local maxDead = tonumber(tOneC[2] or "0") or 0
									local nDead = d.statistics.deadCount or 0
									
									if nDead > maxDead then
										allMeetFlag = false
									end
								--只使用某个英雄
								elseif conType == "useH" then
									local useH = d.statistics.hero
									allMeetFlag = __checkUseOnly(tOneC, useH)
								--不使用某个英雄
								elseif conType == "unuseH" then
									local useH = d.statistics.hero
									allMeetFlag = __checkUnuse(tOneC, useH)
								elseif conType == "star" then
									
									local maxStar = tonumber(tOneC[2] or "0") or 0
									local nStar = 1
									local totalLife = mapInfo.totalLife
									--local life = mapInfo.life
									local life = 0
									local me = oWorld:GetPlayerMe()
									if me then
										local force = me:getforce()
										local forcePlayer = oWorld:GetForce(force)
										if forcePlayer then
											life = forcePlayer:getresource(hVar.RESOURCE_TYPE.LIFE) or 0
										end
									end
									if life >= 9 then
										nStar = 3
									elseif life >= 5 and life <= 8 then
										nStar = 2
									end

									if nStar >= maxStar then
										allMeetFlag = false
									end
								end
							end
						end
						
						if allMeetFlag then
							ret = true
						end
						
					--如果地图完成无额外条件则直接返回true
					elseif #tCondition == 1 then
						ret = true
					end
					
				end
			end
		end
	end

	--print("hApi.CheckMapCondition10:",ret)
	return ret
end

--日常任务完成检测函数
hApi.CheckDailyQuest = function()
	--[[
	local timeStamp = LuaGetDailyQuestTimeStamp()
	local retVal = false --是否存在完成的任务
	
	--如果时间戳不存在，则非法
	if (timeStamp ~= "") then
		--记录新达的任务
		local tFinishQIdx = {}
		
		--遍历3个任务
		for i = 1, 3, 1 do
			local id, state, val, param, conditions = LuaGetDailyQuestCompletion(i)
			
			--如果状态为1，说明是已完成，那么返回值也是true
			if (state == 1) then
				retVal = true
			end
			--如果任务id存在，并且任务当前未完成
			if (id > 0) and (state == 0) then
				local flag = false
				local condition = conditions[1] 
				local val1 = conditions[2]
				local val2 = conditions[3]
				--val1
				if condition == hVar.MEDAL_TYPE.map then
					if val >= 1 then
						flag = true
					end
				elseif condition == hVar.MEDAL_TYPE.mapCondition or condition == hVar.MEDAL_TYPE.chapterCondition then
					local tCondition = hApi.Split(val1, "|")
					--print("hApi.CheckMapCondition2:", #tCondition)
					--如果条件字符串存在
					if tCondition and #tCondition > 0 then
						local checkInfo = tCondition[1] or ""
						local tCheckInfo = hApi.Split(checkInfo, ":")
						--print("hApi.CheckDailyQuest:",val ,(tCheckInfo[3] or 1))
						if val >= (tonumber(tCheckInfo[3]) or 1) then
							flag = true
						end
					end
				elseif condition == hVar.MEDAL_TYPE.killUT or condition == hVar.MEDAL_TYPE.buildTT or condition == hVar.MEDAL_TYPE.killUS or condition == hVar.MEDAL_TYPE.buyItem then
					if val >= val2 then
						flag = true
					end
				else
					if val >= val1 then
						flag = true
					end
				end
				
				if flag then
					tFinishQIdx[#tFinishQIdx + 1] = i
				end
			end
		end
		
		--触发事件：新成就达成
		if (#tFinishQIdx > 0) then
			retVal = true --存在新完成的任务，返回值是true
			hGlobal.event:event("LocalEvent_PlayerDailyQuestChange", tFinishQIdx)
		end
	end
	
	return retVal
	]]
	
	--任务（新）
	local flag = LuaGetTaskFinishFlag(g_curPlayerName)
	if (flag == 1) then
		return true
	else
		return false
	end
end

--领取日常任务奖励
hApi.RewardDailyQuestByCmd = function(sCmd)
	
	--解析日志id
	local tPrizeId = hApi.GetParamByCmd("pid:",sCmd)
	local nPrizeId
	for i = 1, #tPrizeId do
		local v = tPrizeId[1] or {}
		nPrizeId = tonumber(v[1])
	end
	
	--解析任务数据
	local tQuest = hApi.GetParamByCmd("qst:",sCmd)
	local reward = {}
	local tag = ""
	
	local idx = 0
	local id = 0
	for i = 1,(math.min(#tQuest, 1)) do
		local v = tQuest[i]
		idx = tonumber(v[1])
		id = tonumber(v[2])
		
		--任务奖励
		for n = 1, 3 do
			reward[n] = hApi.SplitNEx(v[2 + n],",")
		end
		
		tag = hApi.GetReawrdGift(reward, 3)
	end
	
	hGlobal.event:event("LocalEvent_RewardDailyQuest", idx, id, reward)
	
	--为服务器返回日志
	if nPrizeId > 0 then
		SendCmdFunc["update_reward_log"](nPrizeId)
		print(tag)
	end
end

--读取日常任务协议
hApi.ReadDailyQuestByCmd = function(sCmd)
	local sMyTimeStamp = LuaGetDailyQuestTimeStamp()
	local nMyTimeStamp = hApi.Date2Num(sMyTimeStamp)
	local sHostTimeStamp = ""
	local nHostTimeStamp = 0
	
	--解析任务时间戳
	local tQuestTime = hApi.GetParamByCmd("qt:",sCmd)
	for i = 1, #tQuestTime do
		local v = tQuestTime[1] or {}
		sHostTimeStamp = v[1]
		nHostTimeStamp = hApi.Date2Num(sHostTimeStamp)
	end
	
	--如果服务器下发的时间戳异常则直接退出
	if nHostTimeStamp == 0 then
		print("hApi.ReadDailyQuestByCmd error:host time stamp is 0")
		return
	end
	
	local refreshSave = false
	local refreshTemp = false
	--print("@@@@@@@@@sHostTimeStamp:",sHostTimeStamp,sMyTimeStamp)
	if nMyTimeStamp ~= nHostTimeStamp or sHostTimeStamp ~= sMyTimeStamp then
		--如果时间戳不一致，设置时间戳
		LuaSetDailyQuestTimeStamp(sHostTimeStamp)
		
		refreshSave = true
		refreshTemp = true
	end
	
	--全局任务列表
	if (not g_dailyQuestInfo) then
		g_dailyQuestInfo = {}
		--如果还未初始化数据，则需要刷新
		refreshTemp = true
	end
	
	--保存时间戳
	--g_dailyQuestInfo.timeStamp = sHostTimeStamp
	
	--解析任务数据
	local tQuest = hApi.GetParamByCmd("qst:",sCmd)
	--for k, v in pairs(tQuest) do
	--	print("tQuest:", k, v)
	--	if type(v) == "table" then
	--		for m, n in pairs(v) do
	--			print("tQuest son:",m, n)
	--		end
	--	end
	--end
	for i = 1,(math.min(#tQuest, 3)) do
		local v = tQuest[i]
		
		--刷新内存数据
		if refreshTemp then
			if not g_dailyQuestInfo[i] then
				g_dailyQuestInfo[i] = {}
			end
			
			--任务id
			g_dailyQuestInfo[i].id = tonumber(v[1])		--id
			--任务id
			g_dailyQuestInfo[i].name = hApi.FormatLobbyString(v[5])		--name
			g_dailyQuestInfo[i].desc = hApi.FormatLobbyString(v[6])		--desc
			local condition = hApi.FormatLobbyString(v[7])
			
			--val1
			if condition == hVar.MEDAL_TYPE.map then
				g_dailyQuestInfo[i].maxNum = 1
			elseif condition == hVar.MEDAL_TYPE.mapCondition or condition == hVar.MEDAL_TYPE.chapterCondition then
				g_dailyQuestInfo[i].maxNum = 1
				local conditionInfo = hApi.FormatLobbyString(v[8])
				local tCondition = hApi.Split(conditionInfo, "|")
				if tCondition and #tCondition > 0 then
					local checkInfo = tCondition[1] or ""
					local tCheckInfo = hApi.Split(checkInfo, ":")
					g_dailyQuestInfo[i].maxNum = tonumber(tCheckInfo[3]) or 1
				end
			elseif condition == hVar.MEDAL_TYPE.killUT or condition == hVar.MEDAL_TYPE.buildTT or condition == hVar.MEDAL_TYPE.killUS or condition == hVar.MEDAL_TYPE.buyItem then
				g_dailyQuestInfo[i].maxNum = tonumber(v[9])
			else
				g_dailyQuestInfo[i].maxNum = tonumber(v[8])
			end
			
			--任务奖励
			if not g_dailyQuestInfo[i].reward then
				g_dailyQuestInfo[i].reward = {}
			end
			for n = 1, 3 do
				g_dailyQuestInfo[i].reward[n] = hApi.SplitNEx(v[9 + n],",")
			end
		end
		
		--如果时间戳一致，需要检测，客户端每个任务是否正常，如果与服务器不一致，视为作弊，直接刷掉
		local savedId = LuaGetDailyQuestCompletionAttr(i,1)
		if savedId ~= tonumber(v[1]) then
			refreshSave = true
		end
		
		--刷新存档数据
		if refreshSave then
			local qInfo = {}
			
			qInfo[1] = tonumber(v[1])	--id
			qInfo[2] = tonumber(v[2])	--state
			qInfo[3] = tonumber(v[3])	--num
			qInfo[4] = tonumber(v[4])	--param
			
			qInfo["condition"] = {}
			--condition
			qInfo["condition"][1] = hApi.FormatLobbyString(v[7])
			--val1
			if qInfo["condition"][1] == hVar.MEDAL_TYPE.map or qInfo["condition"][1] == hVar.MEDAL_TYPE.buildTT or qInfo["condition"][1] == hVar.MEDAL_TYPE.mapCondition or qInfo["condition"][1] == hVar.MEDAL_TYPE.chapterCondition then
				qInfo["condition"][2] = hApi.FormatLobbyString(v[8])
			else
				qInfo["condition"][2] = tonumber(v[8])
			end
			--val2
			qInfo["condition"][3] = tonumber(v[9])
			--更新存档信息
			LuaSetDailyQuestCompletion(i, qInfo)
			
		else
			
			--更新存档信息
			local state = tonumber(v[2])
			local oldState = LuaGetDailyQuestCompletionAttr(i, 2)

			if oldState < 2 and state == 2 then
				LuaAddPlayerCountVal(hVar.MEDAL_TYPE.missionN)
				LuaAddDailyQuestCountVal(hVar.MEDAL_TYPE.missionN)
			end

			LuaSetDailyQuestCompletionAttr(i, 2, state)
		end
	end
	
	--存档
	LuaSavePlayerData(g_localfilepath,g_curPlayerName,Save_PlayerData,Save_PlayerLog)
	
	--[[
	print("g_dailyQuestInfo")
	print("{")
		for i = 1, #g_dailyQuestInfo do
			print("    ["..i.."] = {")
				for k,v in pairs(g_dailyQuestInfo[i]) do
					if type(v) ~= "table" then
						print("        "..tostring(k).." = ".. tostring(v))
					else
						print("        ["..k.."] = {")
						for m,n in pairs(v) do
							if type(n) ~= "table" then
								print("            "..tostring(m).." = "..tostring(n))
							else
								print("            ["..m.."] = {")
								for o, p in pairs(n) do
									if type(p) ~= "table" then
										print("                "..tostring(o).." = "..tostring(p))
									else
										print("                ["..m.."] = {")
											for r, s in pairs(p) do
												print("                    "..tostring(r).." = "..tostring(s))
											end
										print("                }")
									end
								end
								print("            }")
							end
						end
						print("        }")
					end
				end
			print("    }")
		end
	print("}")
	
	print("Save_PlayerLog.quest.daily = {")
		print("timestamp = ".. tostring(Save_PlayerLog.quest.daily.timeStamp) )
		for i = 1, #Save_PlayerLog.quest.daily do
			local k = i
			local v = Save_PlayerLog.quest.daily[i]
			print("    ["..tostring(k).."] = {")
			print("        {".. tostring(v[1]) ..",".. tostring(v[2]).. ",".. tostring(v[3]).. ",".. tostring(v[4]).."}")
			print("        condition = {".. tostring(v.condition[1]).. ",".. tostring(v.condition[2]).. ",".. tostring(v.condition[3]).."}")
			print("    }")
		end
	print("}")
	]]
	
	
end

--将字符串转化为时间戳，并可以叠加特定的时间
--参数: "2015-01-01 00:00:00"
--返回值: 时间戳（整数值）
hApi.GetNewDate = function(srcDateTime, dateUnit, interval)
	--无效的格式
	if (type(srcDateTime) ~= "string") then
		return 0
	end
	
	--无效的日期格式
	if (#srcDateTime ~= 19) then
		return 0
	end
	
	--防止数据库读到0值
	if (srcDateTime == "0000-00-00 00:00:00") then
		return 0
	end
	
	--从日期字符串中截取出年月日时分秒
	local Y = string.sub(srcDateTime, 1, 4)
	local M = string.sub(srcDateTime, 6, 7)
	local D = string.sub(srcDateTime, 9, 10)
	local H = string.sub(srcDateTime, 12, 13)
	local MM = string.sub(srcDateTime,15, 16)
	local SS = string.sub(srcDateTime, 18, 19)
	
	--把日期时间字符串转换成对应的日期时间
	local dt1 = os.time{year = Y, month = M, day = D, hour = H, min = MM, sec = SS}
	--print(Y, M, D, H, MM, SS)
	
	--1970年以前会返回nil
	if (dt1 == nil) then
		dt1 = 0
	end
	
	--根据时间单位和偏移量得到具体的偏移数据
	local ofset = 0
	if (dateUnit =='DAY') then
		ofset = 60 *60 * 24 * interval
	elseif (dateUnit == 'HOUR') then
		ofset = 60 *60 * interval
	elseif (dateUnit == 'MINUTE') then
		ofset = 60 * interval
	elseif (dateUnit == 'SECOND') then
		ofset = interval
	end
	
	--指定的时间+时间偏移量
	local newTime = os.date("*t", dt1 + tonumber(ofset))
	local iIime = os.time(newTime)
	return iIime
end

--领取，获得奖励东西
--参数: reward:奖励表, rewardLength:只领前n个奖品(不传参数,表示所有奖品都领)
hApi.GetReawrdGift = function(reward, rewardLength)
	local tag = {}
	local rewardEx = {}
	
	if reward then
		rewardLength = rewardLength or (#reward)
		
		 --只奖励前n个东西
		for i = 1, rewardLength, 1 do
			local rewardT = reward[i]
			if rewardT then
				local rewardType = tonumber(rewardT[1]) or 0 --获取类型
				--print(rewardType)
				
				--(1:积分 / 2:战术技能卡 / 3:道具 / 4:英雄 / 5:英雄将魂 / 6:战术技能卡碎片 / 7:游戏币 / 8:网络宝箱 / 9:抽奖类战术技能卡
				--  / 10:神器 / 11:神器晶石 / 12:红装兑换券 / 13:服务器抽卡 / 14:英雄经验卡 / 15:直接开锦囊 / 16:铁 / 17:木材 / 18:粮食
				--  / 20:军团币 / 21:强化免费券 / 22:宝物碎片 / 23:藏宝图碎片 / 24:高级藏宝图碎片 / 25:兵符 / 26:抽奖免费券
				--  /100:任务之石
				--  / 101:武器枪碎片 / 103:宠物碎片 / 104:科学家碎片 / 105:武器枪宝箱 / 106:战术卡宝箱 / 107:宠物宝箱/ 108:装备宝箱 / 109:科学家宝箱)
				if (rewardType == 1) then --1:积分
					local rewardID = tonumber(rewardT[2]) or 0
					local addScore = rewardID --奖励的积分
					
					--新写法：读取奖励道具里面的奖励的积分
					if hVar.tab_item[rewardID] and (hVar.tab_item[rewardID].type == hVar.ITEM_TYPE.RESOURCES) then
						local resT = hVar.tab_item[rewardID].resource
						if resT and (type(resT) == "table") and (resT[1] == "score") then
							addScore = resT[2] or 0
						else
							addScore = 0
						end
					end
					
					--获得积分奖励
					if (addScore > 0) then
						LuaAddPlayerScore(addScore, false)
						tag[#tag + 1] = "1:".. tostring(addScore)..";"
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 2) then --2:战术技能卡
					local tacticId = tonumber(rewardT[2]) or 0
					local tacticNum = tonumber(rewardT[3]) or 0
					local tacticLv = tonumber(rewardT[4]) or 1
					if (tacticId > 0) and (tacticNum > 0) and (hVar.tab_tactics[tacticId]) then
						local maxLv = hVar.tab_tactics[tacticId].level or 1
						if tacticLv > maxLv then
							tacticLv = maxLv
						end
						
						--获得战术技能卡
						LuaAddPlayerSkillBook(tacticId, tacticLv, tacticNum, false)
						
						--如果获得的战术卡是一般战术卡类型，并且品质是4级以上，那么广播全服消息获得战术卡
						local tacticType = hVar.tab_tactics[tacticId].type
						local tacticQuality = hVar.tab_tactics[tacticId].quality or 1
						if (tacticType == hVar.TACTICS_TYPE.OTHER) and (tacticQuality >= 4) then
							--本地获得战术卡，上传PVP服务器，请求广播此消息
							local strInfo = hVar.tab_string["MadelGiftGet"] --"领取"
							SendPvpCmdFunc["request_broad_get_tacticcard"](rewardType, tacticId, tacticNum, strInfo)
						end
						
						tag[#tag + 1] = "2:".. tostring(tacticId)..":"..tostring(tacticLv)..":"..tostring(tacticNum)..";"
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 3) then --3:道具
					local itemId = tonumber(rewardT[2]) or 0
					local exValueRatio = tonumber(rewardT[3]) or 0
					
					--获得道具
					if (itemId > 0) and hVar.tab_item[itemId] then
						
						local rewardEx
						if not tonumber(rewardT[3]) then
							if type(rewardT[3]) == "string" and rewardT[3] ~= "" then
								rewardEx = hApi.Split(rewardT[3] or "","_")
								if #rewardEx > 0 then
									exValueRatio = 0
								end
							end
						end
						print("rewardEx:",rewardT[3],exValueRatio)
						local _,_,oItem = LuaAddItemToPlayerBag(itemId,rewardEx,nil,exValueRatio)
						
						if oItem then
							--统一塞到仓库里
							LuaGainNewEquip(oItem)
							
							local itemSlot = oItem[hVar.ITEM_DATA_INDEX.SLOT]
							if itemSlot and type(itemSlot) == "table" then
								tag[#tag + 1] = "3:".. tostring(itemId)
								for i = 1, #itemSlot do
									local attr = itemSlot[i]
									if attr and type(attr) == "string" and hVar.ITEM_ATTR_VAL[attr] then
										tag[#tag] = tag[#tag]..":"..attr
									end
								end
								tag[#tag] = tag[#tag]..";"
							end
						end
						
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 4) then --4:英雄
					local heroId = tonumber(rewardT[2]) or 0
					local star = tonumber(rewardT[3]) or 1
					local lv = tonumber(rewardT[4]) or 1
					
					--获得英雄
					if (heroId > 0) and (hVar.tab_unit[heroId]) then
						hGlobal.event:event("LocalEvent_BuyHeroCardSucceed",heroId, star, lv)
						tag[#tag + 1] = "4:".. tostring(heroId)..":"..tostring(star)..":"..tostring(lv)..";"
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 5) then --5:英雄将魂
					local itemId = tonumber(rewardT[2]) or 0
					local itemNum = tonumber(rewardT[3]) or 0
					if (itemId > 0) and (hVar.tab_item[itemId]) and (itemNum > 0) then
						local heroId = hVar.tab_item[itemId].heroID or 0
						
						--获得英雄将魂
						if (heroId > 0) and (hVar.tab_unit[heroId]) then
							LuaAddHeroCardSoulStone(heroId, itemNum)
							tag[#tag + 1] = "5:".. tostring(heroId)..":"..tostring(itemNum)..";"
						end
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
					
					--标记pvp基础数据不是最新数据了
					g_myPvP_BaseInfo.updated = 0
				elseif (rewardType == 6) then --6:战术技能卡碎片
					local itemId = tonumber(rewardT[2]) or 0
					local itemNum = tonumber(rewardT[3]) or 0
					--print("skkjdjgoidjoihj:",itemId, itemNum)
					if (itemId > 0) and (hVar.tab_item[itemId]) and (itemNum > 0) then
						local tacticId = hVar.tab_item[itemId].tacticID or 0
						
						--获得战术技能卡碎片
						if (tacticId > 0) and (hVar.tab_tactics[tacticId]) then
							local ret = LuaAddPlayerTacticDebris(tacticId, itemNum, true)
							
							--[[
							--如果获得的战术卡碎片是一般战术卡类型，并且品质是4级以上，那么广播全服消息获得战术卡
							local tacticType = hVar.tab_tactics[tacticId].type
							local tacticQuality = hVar.tab_tactics[tacticId].quality or 1
							if (tacticType == hVar.TACTICS_TYPE.OTHER) and (tacticQuality >= 4) then
								--本地获得战术卡碎片，上传PVP服务器，请求广播此消息
								local strInfo = hVar.tab_string["MadelGiftGet"] --"领取"
								SendPvpCmdFunc["request_broad_get_tacticcard"](rewardType, tacticId, itemNum, strInfo)
							end
							]]
							
							tag[#tag + 1] = "6:".. tostring(tacticId)..":"..tostring(itemNum)..";"
						end
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
					
					--标记pvp基础数据不是最新数据了
					g_myPvP_BaseInfo.updated = 0
				elseif (rewardType == 7) then --7:游戏币(服务器处理，客户端只拼日志)
					local rmb = tonumber(rewardT[2]) or 0
					tag[#tag + 1] = "7:".. tostring(rmb)..";"
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
					
					--更新客户端游戏币界面
					SendCmdFunc["gamecoin"]()
				elseif (rewardType == 8) then --8:网络宝箱(服务器处理，客户端只拼日志)
					local itemId = tonumber(rewardT[2]) or 0
					local itemNum = tonumber(rewardT[3]) or 0
					if (itemId >= 9004 or itemId <= 9006) and (hVar.tab_item[itemId]) and (itemNum > 0) then
						tag[#tag + 1] = "8:".. tostring(itemId)..":"..tostring(itemNum)..";"
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 9) then --9:抽奖类战术技能卡
					local rewardID = tonumber(rewardT[2]) or 0 --奖励ID
					local rewardNum = tonumber(rewardT[3]) or 1 --奖励数量
					
					--获得抽奖类战术技能卡
					local item_id = rewardID
					if (hApi.CheckEntityItem(item_id) == 1) then
						for rr = 1, rewardNum, 1 do
							local typ,ex,val = unpack(hVar.tab_item[item_id].used)
							--geyachao:此处改为直接给结果，不用再有动画抽卡过程了
							--[[
							hApi.UnitGetLoot(nil,typ,ex,val,nil,nil,nil,nil,{item_id})
							]]
							--直接发前n个抽卡结果的碎片
							local rTab = hApi.RandomTacticsIdFromPack(item_id)
							for i = 1, val, 1 do
								local tacticInfo = rTab[i]
								local tacticId = tacticInfo[1]
								local tacticLv = tacticInfo[2]
								local tacticNum = 1 --数量
								LuaAddPlayerSkillBook(tacticId, tacticLv, tacticNum, false)
								
								--实际领奖结果
								rewardEx[#rewardEx+1] = {2, tacticId, tacticNum, tacticLv}
								
								--如果获得的战术卡是一般战术卡类型，并且品质是4级以上，那么广播全服消息获得战术卡
								local tacticType = hVar.tab_tactics[tacticId].type
								local tacticQuality = hVar.tab_tactics[tacticId].quality or 1
								if (tacticType == hVar.TACTICS_TYPE.OTHER) and (tacticQuality >= 4) then
									--本地获得战术卡，上传PVP服务器，请求广播此消息
									local strInfo = hVar.tab_string["__ITEM_PANEL__PAGE_DRAWCARD"] --"抽到"
									SendPvpCmdFunc["request_broad_get_tacticcard"](2, tacticId, tacticNum, strInfo)
								end
							end
						end
						
						--LuaAddBuyCardInfo(item_id,ticketNum)
						--LuaCheckBuyCardList()
						SendCmdFunc["get_VIP_REC_State"]()
					end
					
					--界面层处理抽卡逻辑
					local itemId = rewardID
					if ((itemId == 9101) or (itemId == 9102) or (itemId == 9108) or (itemId == 10249)) and (hVar.tab_item[itemId]) then
						tag[#tag + 1] = "9:".. tostring(itemId)..";"
					end
				elseif (rewardType == 10) then --10:神器
					local itemId = tonumber(rewardT[2]) or 0 --奖励ID
					local itemEntity = rewardT[3] or ""
					--print("itemEntity=", itemEntity)
					--30160|20110|1|atk3||0|1|11|12|21|22|31|32|41|42|51|52|61|62|71|72|81|82
					--local quality = tonumber(rewardT[4]) or 0 --品质
					local entity = {}
					local tEntity = hApi.Split(itemEntity,"|")
					
					entity.dbid = tonumber(tEntity[1]) or 0
					entity.typeId = tonumber(tEntity[2]) or 0
					entity.slotnum = tonumber(tEntity[3]) or 0
					entity.attr = {}
					local idx = 3
					for i = 1, entity.slotnum do
						entity.attr[#entity.attr + 1] = tEntity[idx + i]
					end
					
					idx = idx + entity.slotnum + 1
				
					entity.CUnique = tonumber(tEntity[idx+1]) or 0
					entity.quality = tonumber(tEntity[idx+2]) or 0
					entity.randIdx1 = tonumber(tEntity[idx+3]) or 0 --随机属性索引1
					entity.randVal1 = tonumber(tEntity[idx+4]) or 0 --随机属性值1
					entity.randIdx2 = tonumber(tEntity[idx+5]) or 0 --随机属性索引2
					entity.randVal2 = tonumber(tEntity[idx+6]) or 0 --随机属性值2
					entity.randIdx3 = tonumber(tEntity[idx+7]) or 0 --随机属性索引3
					entity.randVal3 = tonumber(tEntity[idx+8]) or 0 --随机属性值3
					entity.randIdx4 = tonumber(tEntity[idx+9]) or 0 --随机属性索引4
					entity.randVal4 = tonumber(tEntity[idx+10]) or 0 --随机属性值4
					entity.randIdx5 = tonumber(tEntity[idx+11]) or 0 --随机属性索引5
					entity.randVal5 = tonumber(tEntity[idx+12]) or 0 --随机属性值5
					entity.randSkillIdx1 = tonumber(tEntity[idx+13]) or 0 --随机技能索引1
					entity.randSkillLv1 = tonumber(tEntity[idx+14]) or 0 --随机技能等级1
					entity.randSkillIdx2 = tonumber(tEntity[idx+15]) or 0 --随机技能索引2
					entity.randSkillLv2 = tonumber(tEntity[idx+16]) or 0 --随机技能等级2
					entity.randSkillIdx3 = tonumber(tEntity[idx+17]) or 0 --随机技能索引3
					entity.randSkillLv3 = tonumber(tEntity[idx+18]) or 0 --随机技能等级3
					
					--获得道具
					--print("hApi.GetReawrdGift:",itemId,hVar.tab_item[itemId],entity.typeId,entity.dbid,rewardT[3])
					if (itemId > 0) and hVar.tab_item[itemId] and itemId == entity.typeId and entity.dbid > 0 then
						if (LuaCheckPlayerBagCanUse() ~= 0) then
							local _,_,oItem = LuaAddItemToPlayerBag(itemId,nil,nil,nil,entity,entity.quality)
							if oItem then
								--统一塞到仓库里
								LuaGainNewEquip(oItem)
								
								tag[#tag + 1] = "10:".. tostring(itemId)
								for i = 1, entity.slotnum do
									local attr = entity.attr[i]
									if attr and type(attr) == "string" and hVar.ITEM_ATTR_VAL[attr] then
										tag[#tag] = tag[#tag]..":"..attr
									end
								end
								tag[#tag] = tag[#tag]..";"
							end
						else
							--提示
							hGlobal.UI.MsgBox(hVar.tab_string["__TEXT_Cant_BagItemIsFull_Net1"], {
								font = hVar.FONTC,
								ok = function()
								end,
							})
						end
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
					
				elseif (rewardType == 11) then --11:神器晶石
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 12) then --12:红装兑换券
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 13) then --13:服务器抽卡类的奖励
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 14) then --14:英雄经验
					local heroId = tonumber(rewardT[2]) or 0
					local expAdd = tonumber(rewardT[3]) or 0
					local param4 = tonumber(rewardT[4]) or 0
					
					--英雄加经验值
					if (heroId > 0) and (hVar.tab_unit[heroId]) then
						LuaAddHeroExp(heroId, expAdd)
						tag[#tag + 1] = "14:".. tostring(heroId)..":"..tostring(expAdd)..":"..tostring(param4)..";"
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 15) then --15:直接开锦囊
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 16) then --16:铁 --geyachao: 新加房间的配置项 军团
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 17) then --17:木材 --geyachao: 新加房间的配置项 军团
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 18) then --18:粮食 --geyachao: 新加房间的配置项 军团
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 20) then --20:军团币
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 21) then --21:强化免费券
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 22) then --22:宝物碎片
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 23) then --23:藏宝图碎片
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
					
					--需要重新查询玩家宝物数据
					--同步玩家宝物和宝物属性位值信息
					SendCmdFunc["query_treasure_info"]()
				elseif (rewardType == 24) then --24:高级藏宝图碎片
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
					--需要重新查询玩家宝物数据
					
					--同步玩家宝物和宝物属性位值信息
					SendCmdFunc["query_treasure_info"]()
				elseif (rewardType == 25) then --25:兵符
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
					
					--标记pvp基础数据不是最新数据了
					g_myPvP_BaseInfo.updated = 0
					
					--获取体力数据
					SendCmdFunc["get_mycoin"]()
					
				elseif (rewardType == 26) then --26:抽奖免费券
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 100) then --100:任务之石
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 101) then --101:武器枪碎片
					local itemId = tonumber(rewardT[2]) or 0
					local itemNum = tonumber(rewardT[3]) or 0
					if (itemId > 0) and (hVar.tab_item[itemId]) and (itemNum > 0) then
						local weaponId = hVar.tab_item[itemId].weaponId or 0
						
						--获得武器枪碎片
						if (weaponId > 0) then
							local weaponIdx = LuaGetHeroWeaponIndexById(hVar.MY_TANK_ID, weaponId)
							if (weaponIdx > 0) then
								LuaAddHeroWeaponDebrisNum(hVar.MY_TANK_ID, weaponIdx, itemNum)
							end
						end
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 103) then --103:宠物碎片
					local itemId = tonumber(rewardT[2]) or 0
					local itemNum = tonumber(rewardT[3]) or 0
					if (itemId > 0) and (hVar.tab_item[itemId]) and (itemNum > 0) then
						local petId = hVar.tab_item[itemId].petId or 0
						
						--获得宠物碎片
						if (petId > 0) then
							local petIdx = LuaGetHeroPetIndexById(hVar.MY_TANK_ID, petId)
							if (petIdx > 0) then
								LuaAddHeroPetDebrisNum(hVar.MY_TANK_ID, petIdx, itemNum)
							end
						end
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 104) then --104:科学家碎片
					--
				elseif (rewardType == 105) then --105:武器枪宝箱
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddTankWeaponGunChestNum(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 106) then --106:战术卡宝箱
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddTankTacticChestNum(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 107) then --107:宠物宝箱
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddTankPetChestNum(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 108) then --108:装备宝箱
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddTankEquipChestNum(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 109) then --109:科学家宝箱
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 110) then --110:科学家成就1
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddScientistsAchievnemtn1(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 111) then --111:科学家成就2
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddScientistsAchievnemtn2(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 112) then --112:科学家成就3
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddScientistsAchievnemtn3(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 113) then --113:科学家成就4
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddScientistsAchievnemtn4(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 114) then --114:地鼠币
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddTankDiShuCoinNum(itemNum, notSaveFlag)
					end
					
					--获取体力数据
					SendCmdFunc["get_mycoin"]()
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 115) then --115:垃圾堆成就1
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddTankDeadthsAchievnemtn1(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 116) then --116:垃圾堆成就2
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddTankDeadthsAchievnemtn2(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 117) then --117:垃圾堆成就3
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddTankDeadthsAchievnemtn3(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 118) then --118:垃圾堆成就4
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddTankDeadthsAchievnemtn4(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 119) then --119:垃圾堆成就5
					local itemNum = tonumber(rewardT[2]) or 0
					if (itemNum > 0) then
						local notSaveFlag = true
						LuaAddTankDeadthsAchievnemtn5(itemNum, notSaveFlag)
					end
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
				elseif (rewardType == 120) then --120:天赋点
					--
					
					--实际领奖结果
					rewardEx[#rewardEx+1] = rewardT
					
					--获取战车技能点数同步数据
					SendCmdFunc["tank_sync_talentpoint_info"]()
				end
			end
		end
	end
	
	--奖励发放完毕，统一存档
	--存档
	LuaSavePlayerData(g_localfilepath,g_curPlayerName,Save_PlayerData,Save_PlayerLog)
	
	--奖励发放完毕
	local keyList = {"card", "skill", "bag", "map", "material",}
	LuaSavePlayerData_Android_Upload(keyList, "奖励发放完毕")
	
	if (#tag > 0) then
		return table.concat(tag), rewardEx
	else
		return "", rewardEx
	end
end

--检测是否显示 gameCenter
hApi.CheckGCShow = function()
	--if getChannelInfo() == 1 or getChannelInfo() == 2 or getChannelInfo() == 1001 then
	if (getChannelInfo() == 1) then --1:???
		return 1
	else
		return 0
	end
end

--登入gamecenter成功的回调
hApi.connect2GameCenter = function()
	--上传成就到排行榜
	if (xlGameCenter_isAuthenticated and xlGameCenter_isAuthenticated() == 1) then
		hApi.xlGameCenter_reportScore(LuaGetPlayerGamecenter_DaFuWeng(),"td.p.fortune")
		hApi.xlGameCenter_reportScore(LuaGetPlayerCountVal(hVar.MEDAL_TYPE.apNum), "td.p.achievement")
		hApi.xlGameCenter_reportScore(LuaGetPlayerGamecenter_Hero(),"td.p.hero")
		hApi.xlGameCenter_reportScore(LuaGetPlayerGamecenter_Tactics(), "td.p.tactics")
		hApi.xlGameCenter_reportScore(LuaGetPlayerCountVal(hVar.MEDAL_TYPE.starCount), "td.p.star")
		--更新所有无尽关卡积分
		if hVar.tab_chapter then
			for i = 1, #hVar.tab_chapter do
				local endlessMap = hVar.tab_chapter[i].endlessMap or {}
				for j = 1, #endlessMap do
					local mapname = endlessMap[j]
					local tmp = hApi.Split(mapname, "/")
					local sMap = tmp[#tmp]
					hApi.xlGameCenter_reportScore(LuaGetPlayerGamecenter_Challenge(mapname), "td.p."..sMap)
				end
			end
		end
	end
	
	if(xlGameCenter_showGameCenter) then
		xlGameCenter_showGameCenter()
	end
	--xlGameCenter_reportAchievement("hero3_a_money")
	
	--触发事件：登入gamecenter成功
	hGlobal.event:event("Event_GameCenter_ConnectSuccess")
end

--函数：获得奖励的UI相关参数
--返回值: tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h
hApi.GetRewardParams = function(rewardT)
	local rewardType = tonumber(rewardT[1]) --奖励类型
	local rewardID = tonumber(rewardT[2]) --奖励ID
	local rewardNum = tonumber(rewardT[3]) --奖励数量
	local param4 = rewardT[4] --参数4
	--print(rewardType, rewardID, rewardNum)
	
	local tmpModel = "misc/mask.png" --模型
	--local itemName = "无" --名称 --language
	local itemName = hVar.tab_string["__TEXT_Nothing"] --名称 --language
	local itemNum = 0 --数量
	local itemWidth = 0 --控件宽度
	local itemHeight = 0 --控件高度
	
	--子控件的参数
	local sub_tmpModel = nil --子控件模型
	local sub_pos_x = 0 --子控件位置x
	local sub_pos_y = 0 --子控件位置y
	local sub_pos_w = 0 --子控件宽度
	local sub_pos_h = 0 --子控件高度

	--print("show:",rewardType,rewardID)
	
	if (rewardType == 1) then --1:积分
		tmpModel = "misc/skillup/mu_coin_world.png" --积分模型
		itemName = hVar.tab_string["ios_score"] --积分名称
		itemNum = rewardID --积分数量
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
		
		--新写法：读取奖励道具里面的奖励的积分
		if hVar.tab_item[rewardID] and (hVar.tab_item[rewardID].type == hVar.ITEM_TYPE.RESOURCES) then
			local resT = hVar.tab_item[rewardID].resource
			if resT and (type(resT) == "table") and (resT[1] == "score") then
				itemNum = resT[2] or 0
			else
				itemNum = rewardNum
			end
		end
	elseif (rewardType == 2) then --2:战术技能卡
		if hVar.tab_tactics[rewardID] then
			tmpModel = hVar.tab_tactics[rewardID].icon --战术技能卡模型
		end
		if hVar.tab_stringT[rewardID] then
			itemName = hVar.tab_stringT[rewardID][1] --战术技能卡名称
		else
			itemName = "未知战术技能卡" .. tostring(rewardID)
		end
		itemNum = rewardNum --战术技能卡数量
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
	elseif (rewardType == 3) then --3:道具
		--tmpModel = "UI:SkillSlot" --道具模型
		local itemLv = hVar.tab_item[rewardID] and hVar.tab_item[rewardID].itemLv or 1
		tmpModel = hVar.ITEMLEVEL[itemLv].BORDERMODEL --抽奖类战术技能卡模型边框
		if hVar.tab_stringI[rewardID] then
			itemName = hVar.tab_stringI[rewardID][1] --道具名称
		else
			itemName = "未知道具" .. tostring(rewardID)
		end
		itemName = LuaGetObjectName(rewardID,2)
		itemNum = 1 --道具数量（道具一次只会给一个）
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
		
		--绘制子控件：道具图标
		if hVar.tab_item[rewardID] then
			sub_tmpModel = hVar.tab_item[rewardID].icon --道具模型
		end
		sub_pos_x = 0 --子控件位置x
		sub_pos_y = 0 --子控件位置y
		sub_pos_w = 38 --子控件宽度
		sub_pos_h = 38 --子控件高度
		
		--资源类型的道具，不需要边框
		if hVar.tab_item[rewardID] then
			if (hVar.tab_item[rewardID].type == hVar.ITEM_TYPE.RESOURCES) then
				tmpModel = hVar.tab_item[rewardID].icon --道具模型
				sub_tmpModel = nil
			end
		end
		
		--战车，不要边框了
		tmpModel = hVar.tab_item[rewardID] and hVar.tab_item[rewardID].icon --道具模型
		sub_tmpModel = nil
	elseif (rewardType == 4) then --4:英雄
		if hVar.tab_unit[rewardID] then
			tmpModel = hVar.tab_unit[rewardID].icon --英雄模型
		end
		if hVar.tab_stringU[rewardID] then
			itemName = hVar.tab_stringU[rewardID][1] --英雄名称
		else
			itemName = "未知英雄" .. tostring(rewardID)
		end
		itemName = LuaGetObjectName(rewardID,1)
		itemNum = 1 --英雄数量（英雄一次只会给一个）
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
	elseif (rewardType == 5) then --5:英雄将魂
		if hVar.tab_item[rewardID] then
			tmpModel = hVar.tab_item[rewardID].icon --英雄将魂模型
		end
		if hVar.tab_stringI[rewardID] then
			itemName = hVar.tab_stringI[rewardID][1] --英雄将魂名称
		else
			itemName = "未知英雄将魂" .. tostring(rewardID)
		end
		itemName = ""--LuaGetObjectName(rewardID,2)..hVar.tab_string["__TEXT_CHIP"]
		itemNum = rewardNum --将魂数量
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
		
		--绘制子控件：英雄将魂
		sub_tmpModel = "UI:SoulStoneFlag" --英雄将魂模型
		sub_pos_x = 8 --子控件位置x
		sub_pos_y = -8 --子控件位置y
		sub_pos_w = 32 --子控件宽度
		sub_pos_h = 32 --子控件高度
	elseif (rewardType == 6) then --6:战术技能卡碎片
		if hVar.tab_item[rewardID] then
			tmpModel = hVar.tab_item[rewardID].icon --战术技能卡碎片模型
		end
		if hVar.tab_stringI[rewardID] then
			--itemName = hVar.tab_stringI[rewardID][1] --战术技能卡碎片名称 --language
			itemName = hVar.tab_stringI[rewardID][1] --战术技能卡碎片名称 --language
		else
			itemName = "未知战术技能卡碎片" .. tostring(rewardID)
		end
		itemName = ""--LuaGetObjectName(rewardID,2)..hVar.tab_string["__TEXT_CHIP"]
		itemNum = rewardNum --战术技能卡数量
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
		
		--绘制子控件：战术技能卡碎片
		sub_tmpModel = "UI:SoulStoneFlag" --战术技能卡碎片模型
		sub_pos_x = 10 --子控件位置x
		sub_pos_y = -6 --子控件位置y
		sub_pos_w = 24 --子控件宽度
		sub_pos_h = 24 --子控件高度
	elseif (rewardType == 7) then --7:游戏币
		tmpModel = "misc/skillup/keshi.png" --游戏币模型
		itemName = hVar.tab_string["__TEXT_PAGE_PURCHASE"] --游戏币名称
		itemNum = rewardID --游戏币数量
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
	elseif (rewardType == 8) then --8:网络宝箱
		if hVar.tab_item[rewardID] then
			--tmpModel = hVar.tab_item[rewardID].icon --网络宝箱模型
			local itemLv = hVar.tab_item[rewardID].itemLv or 1
			tmpModel = hVar.ITEMLEVEL[itemLv].BORDERMODEL --抽奖类战术技能卡模型边框
		end
		if hVar.tab_stringI[rewardID] then
			itemName = hVar.tab_stringI[rewardID][1] --网络宝箱名称
		else
			itemName = "未知网络宝箱" .. tostring(rewardID)
		end
		itemName = LuaGetObjectName(rewardID,2)
		itemNum = rewardNum --网络宝箱数量
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
		
		if hVar.tab_item[rewardID] then
			--绘制子控件：战术技能卡碎片
			sub_tmpModel = hVar.tab_item[rewardID].icon --网络宝箱子模型
			sub_pos_x = 0 --子控件位置x
			sub_pos_y = 0 --子控件位置y
			sub_pos_w = 40 --子控件宽度
			sub_pos_h = 40 --子控件高度
		end
	elseif (rewardType == 9) then --9:抽奖类战术技能卡
		if hVar.tab_item[rewardID] then
			--tmpModel = hVar.tab_item[rewardID].icon --抽奖类战术技能卡模型
			local itemLv = hVar.tab_item[rewardID].itemLv or 1
			tmpModel = hVar.ITEMLEVEL[itemLv].BORDERMODEL --抽奖类战术技能卡模型边框
		end
		if hVar.tab_stringI[rewardID] then
			itemName = hVar.tab_stringI[rewardID][1] --抽奖类战术技能卡名称
		else
			itemName = "未知抽奖类战术技能卡" .. tostring(rewardID)
		end
		itemName = LuaGetObjectName(rewardID,2)
		--itemNum = (rewardNum and (rewardNum > 1)) and rewardNum or 1 --抽奖类战术技能卡数量
		itemNum = (rewardNum or 0) --抽奖类战术技能卡数量
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
		
		if hVar.tab_item[rewardID] then
			--绘制子控件：战术技能卡碎片
			sub_tmpModel = hVar.tab_item[rewardID].icon --抽奖类战术技能卡模型
			sub_pos_x = 0 --子控件位置x
			sub_pos_y = 0 --子控件位置y
			sub_pos_w = 38 --子控件宽度
			sub_pos_h = 38 --子控件高度
		end
	elseif (rewardType == 10) then --10:神器
		--tmpModel = "UI:SkillSlot" --道具模型
		local itemLv = hVar.tab_item[rewardID] and hVar.tab_item[rewardID].itemLv or 1
		
		--tmpModel = "ICON:Back_red3"  --神器tip模型
		--根据品质决定背景
		--local quality = tonumber(param4) or 0
		--tmpModel = hVar.ITEM_QUALITY_BG[quality]
		tmpModel = hVar.ITEMLEVEL[itemLv].BACKMODEL
		
		if hVar.tab_stringI[rewardID] then
			itemName = hVar.tab_stringI[rewardID][1] --道具名称
		else
			itemName = "未知道具" .. tostring(rewardID)
		end
		itemName = LuaGetObjectName(rewardID,2)
		itemNum = 1 --道具数量（道具一次只会给一个）
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
		
		--绘制子控件：道具图标
		if hVar.tab_item[rewardID] then
			sub_tmpModel = hVar.tab_item[rewardID].icon --道具模型
		end
		sub_pos_x = 0 --子控件位置x
		sub_pos_y = 0 --子控件位置y
		sub_pos_w = 38 --子控件宽度
		sub_pos_h = 38 --子控件高度
	elseif (rewardType == 11) then --11:神器晶石
		tmpModel = "ICON:CHIP_BROKEN" --积分模型
		itemName = hVar.tab_string["__SHENQI_CRTSTAL"] --积分名称
		itemNum = rewardID --积分数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 12) then --12:红装兑换券
		tmpModel = "ICON:BF" --积分模型
		itemName = hVar.tab_string["__FB_EXCHANGE"] --积分名称
		itemNum = rewardID --积分数量
		itemWidth = 42 --控件宽度
		itemHeight = 35 --控件高度
	elseif (rewardType == 13) then --13:服务器将魂抽卡类
		tmpModel = "icon/item/gift_lv3.png"
		itemName = hVar.tab_string["__TEXT_Activity"] .. hVar.tab_string["__TEXT_ITEM_TYPE_GIFTITEM"] --"活动礼包"
		itemNum = rewardNum
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
		
		--默认图标是紫色箱子，如果里面包含神器，那么替换成金箱子
		local cardList = hApi.Split(param4, "|")
		local totalCardNum = #cardList --抽卡总数量
		for i = #cardList, 1, -1 do
			if (#cardList[i] == 0) then --防止最后一项是空表
				cardList[i] = nil
				totalCardNum = totalCardNum - 1
			else
				cardList[i] = hApi.Split(cardList[i], "_")
				cardList[i][1] = tonumber(cardList[i][1]) or 0
				cardList[i][2] = tonumber(cardList[i][2]) or 0
				cardList[i][3] = tonumber(cardList[i][3]) or 0
				cardList[i][4] = tonumber(cardList[i][4]) or 0
				--print(unpack(cardList[i]))
			end
		end
		
		--检测是否包含神器
		local bExistedRedEquip = false
		for i = 1, totalCardNum, 1 do
			local rewardT = cardList[i]
			local rewardType = tonumber(rewardT[1]) --奖励类型
			if (rewardType == 10) then --10:红装神器
				bExistedRedEquip = true --找到了
				tmpModel = "ui/chest_8.png"
				itemName = hVar.tab_string["__TEXT_ShenQi"] .. hVar.tab_string["__TEXT_ITEM_TYPE_GIFTITEM"] --"神器礼包"
				itemWidth = 48 --控件宽度
				itemHeight = 48 --控件高度
				break
			end
		end
		
		--如果里面包含战术卡碎片，那么替换成金盒子
		local bExistedTacticDerbris = false
		if (not bExistedRedEquip) then
			--检测是否包含战术卡碎片
			for i = 1, totalCardNum, 1 do
				local rewardT = cardList[i]
				local rewardType = tonumber(rewardT[1]) --奖励类型
				if (rewardType == 6) then --6:战术技能卡碎片
					bExistedTacticDerbris = true --找到了
					tmpModel = "icon/item/card_lv3.png"
					itemName = hVar.tab_string["TacticCardRow"] .. hVar.tab_string["__TEXT_ITEM_TYPE_GIFTITEM"] --"战术礼包"
					itemWidth = 48 --控件宽度
					itemHeight = 48 --控件高度
					
					--如果是防御塔，改为防御塔礼包
					local itemId = tonumber(rewardT[2]) --战术卡道具id
					local tabI = hVar.tab_item[itemId] or {}
					local tacticID = tabI.tacticID or 0
					local tabT = hVar.tab_tactics[tacticID] or {}
					local tabTType = tabT.type
					if (tabTType == hVar.TACTICS_TYPE.TOWER) then
						tmpModel = "UI:TOWERDERBIRS_GIFTCARD"
						itemName = hVar.tab_string["__Attr_Hint_Led"] .. hVar.tab_string["__TEXT_SOLDIER_TOWER"] .. hVar.tab_string["__TEXT_ITEM_TYPE_GIFTITEM"] --"防御塔礼包"
					end
					
					break
				end
			end
		end
		
		--如果里面包含橙装，那么替换成银盒子
		local bExistedOrangeEquip = false
		if (not bExistedRedEquip) and (not bExistedTacticDerbris) then
			--检测是否包含橙装
			for i = 1, totalCardNum, 1 do
				local rewardT = cardList[i]
				local rewardType = tonumber(rewardT[1]) --奖励类型
				local rewardId = tonumber(rewardT[2]) or 0 --奖励id
				if (rewardType == 3) then --3:道具
					local tabT = hVar.tab_item[rewardId] or {}
					if (tabT.itemLv == hVar.ITEM_QUALITY.RED) then --橙装
						bExistedOrangeEquip = true --找到了
						tmpModel = "icon/item/random_lv2.png"
						itemName = hVar.tab_string["__TEXT_OrangeEquip"] .. hVar.tab_string["__TEXT_ITEM_TYPE_GIFTITEM"] --"橙装礼包"
						itemWidth = 48 --控件宽度
						itemHeight = 48 --控件高度
						break
					end
				end
			end
		end
		
		--如果里面包含英雄将魂，那么替换成礼包
		local bExisteHeroDebris = false
		if (not bExistedRedEquip) and (not bExistedTacticDerbris) and (not bExistedOrangeEquip) then
			--检测是否包含橙装
			for i = 1, totalCardNum, 1 do
				local rewardT = cardList[i]
				local rewardType = tonumber(rewardT[1]) --奖励类型
				local rewardId = tonumber(rewardT[2]) or 0 --奖励id
				if (rewardType == 5) then --5:英雄将魂
					bExisteHeroDebris = true --找到了
					tmpModel = "UI:HERODEBRIRS_GIFTCARD"
					itemName = hVar.tab_string["__TEXT_ITEM_TYPE_SOULSTONE"] .. hVar.tab_string["__TEXT_ITEM_TYPE_GIFTITEM"] --"将魂礼包"
					itemWidth = 46 --控件宽度
					itemHeight = 46 --控件高度
					
					--检测是否包含高级英雄将魂
					local itemId = tonumber(rewardT[2]) --战术卡道具id
					local tabI = hVar.tab_item[itemId] or {}
					local heroID = tabI.heroID or 0
					local pvp_only = false
					for h = 1, #hVar.HERO_AVAILABLE_LIST, 1 do
						if (hVar.HERO_AVAILABLE_LIST[h].id == heroID) then --找到了
							pvp_only = hVar.HERO_AVAILABLE_LIST[h].pvp_only
							break
						end
					end
					if pvp_only then
						tmpModel = "UI:HERODEBRIRS_GIFTCARD_HIGH"
					end
					
					break
				end
			end
		end
		
	elseif (rewardType == 14) then --14:英雄经验卡
		if hVar.tab_unit[rewardID] then
			tmpModel = hVar.tab_unit[rewardID].icon --成就模型
		end
		if hVar.tab_stringU[rewardID] then
			itemName = hVar.tab_stringU[rewardID][1] .. hVar.tab_string["__Attr_Hint_Exp"] --英雄名称"经验"
		else
			itemName = "未知英雄" .. tostring(rewardID) .. hVar.tab_string["__Attr_Hint_Exp"] --"经验"
		end
		itemName = LuaGetObjectName(rewardID,1) .. hVar.tab_string["__Attr_Hint_Exp"]
		itemNum = rewardNum --将魂数量
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
		
		--绘制子控件：英雄经验
		sub_tmpModel = "ICON:HeroAttr" --英雄经验图标
		sub_pos_x = 10 --子控件位置x
		sub_pos_y = -10 --子控件位置y
		sub_pos_w = 26 --子控件宽度
		sub_pos_h = 26 --子控件高度
	elseif (rewardType == 15) then --15:直接开锦囊
		--tmpModel = "UI:SkillSlot" --道具模型
		local itemLv = hVar.tab_item[rewardID] and hVar.tab_item[rewardID].itemLv or 1
		tmpModel = hVar.ITEMLEVEL[itemLv].BORDERMODEL --抽奖类战术技能卡模型边框
		if hVar.tab_stringI[rewardID] then
			itemName = hVar.tab_stringI[rewardID][1] --道具名称
		else
			itemName = "未知道具" .. tostring(rewardID)
		end
		itemName = LuaGetObjectName(rewardID,2)
		itemNum = rewardNum --幸运神器锦囊道具数量
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
		
		--绘制子控件：道具图标
		if hVar.tab_item[rewardID] then
			sub_tmpModel = hVar.tab_item[rewardID].icon --道具模型
		end
		sub_pos_x = 0 --子控件位置x
		sub_pos_y = 0 --子控件位置y
		sub_pos_w = 38 --子控件宽度
		sub_pos_h = 38 --子控件高度
		
		--资源类型的道具，不需要边框
		if hVar.tab_item[rewardID] and (hVar.tab_item[rewardID].type == hVar.ITEM_TYPE.RESOURCES) then
			tmpModel = hVar.tab_item[rewardID].icon --道具模型
			sub_tmpModel = nil
		end
	elseif (rewardType == 16) then --16:铁
		tmpModel = "UI:ICON_main_frm_ResourceIron" --铁模型
		itemName = hVar.tab_string["ios_iron"] --铁
		itemNum = rewardID --积分数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 17) then --17:木材
		tmpModel = "UI:ICON_main_frm_ResourceWood" --木材模型
		itemName = hVar.tab_string["ios_wood"] --木材
		itemNum = rewardID --积分数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 18) then --18:粮食
		tmpModel = "UI:ICON_main_frm_ResourceFood" --粮食模型
		itemName = hVar.tab_string["ios_food"] --粮食
		itemNum = rewardID --积分数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 20) then --20:军团币
		tmpModel = "misc/legion/market_coin.png" --军团币模型
		itemName = hVar.tab_string["ios_groupcoin"] --军团币
		itemNum = rewardID --军团币数量
		itemWidth = 56 --控件宽度
		itemHeight = 56 --控件高度
	elseif (rewardType == 21) then --21:强化免费券
		tmpModel = "UI:QIANGHUA_FREE_TICKET" --强化免费券模型
		itemName = hVar.tab_string["__ITEM_PANEL__PAGE_QIANGHUA"] .. hVar.tab_string["ios_freeticket"] --强化免费券
		itemNum = rewardID --强化免费券数量
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
	elseif (rewardType == 22) then --22:宝物碎片
		if hVar.tab_item[rewardID] then
			tmpModel = hVar.tab_item[rewardID].icon --宝物碎片模型
		end
		if hVar.tab_stringI[rewardID] then
			--itemName = hVar.tab_stringI[rewardID][1] --宝物碎片名称 --language
			itemName = hVar.tab_stringI[rewardID][1] --宝物碎片名称 --language
		else
			itemName = "未知宝物碎片" .. tostring(rewardID)
		end
		itemName = LuaGetObjectName(rewardID,2)
		itemNum = rewardNum --宝物碎片数量
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
		
		--绘制子控件：宝物碎片
		sub_tmpModel = "UI:SoulStoneFlag" --宝物碎片模型
		sub_pos_x = 8 --子控件位置x
		sub_pos_y = -8 --子控件位置y
		sub_pos_w = 32 --子控件宽度
		sub_pos_h = 32 --子控件高度
	elseif (rewardType == 23) then --23:藏宝图碎片
		tmpModel = "UI:CANGBAOTU_NORMAL" --藏宝图模型
		itemName = hVar.tab_string["ios_cangbaotu_normal"] --藏宝图碎片名称
		itemNum = rewardID --藏宝图碎片数量
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
	elseif (rewardType == 24) then --24:高级藏宝图碎片
		tmpModel = "UI:CANGBAOTU_HIGH" --高级藏宝图模型
		itemName = hVar.tab_string["ios_cangbaotu_high"] --高级藏宝图碎片名称
		itemNum = rewardID --高级藏宝图碎片数量
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
	elseif (rewardType == 25) then --25:兵符
		tmpModel = "misc/task/tili.png" --兵符模型
		itemName = hVar.tab_string["__TEXT_TILI"] --兵符名称
		itemNum = rewardID --兵符数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 26) then --26:抽奖免费券
		tmpModel = "UI:CHOUJIANG_FREE_TICKET" --抽奖免费券模型
		itemName = hVar.tab_string["__FB_CHOUJIANGTICKET"] --抽奖免费券名称
		itemNum = rewardNum --抽奖免费券数量
		itemWidth = 42 --控件宽度
		itemHeight = 42 --控件高度
	elseif (rewardType == 100) then --100:任务之石
		tmpModel = "misc/task/task_stone.png" --任务之石模型
		itemName = hVar.tab_string["__TEXT_PAGE_TASKSTONE"] --任务之石名称
		itemNum = rewardID --任务之石数量
		itemWidth = 56 --控件宽度
		itemHeight = 56 --控件高度
	elseif (rewardType == 101) then --101:武器枪碎片
		if hVar.tab_item[rewardID] then
			tmpModel = hVar.tab_item[rewardID].icon --武器枪碎片模型
		end
		if hVar.tab_stringI[rewardID] then
			--itemName = hVar.tab_stringI[rewardID][1] --宝物碎片名称 --language
			itemName = hVar.tab_stringI[rewardID][1] --宝物碎片名称 --language
		else
			itemName = "未知武器枪碎片" .. tostring(rewardID)
		end
		itemName = ""--LuaGetObjectName(rewardID,2)..hVar.tab_string["__TEXT_CHIP"]
		itemNum = rewardNum --宝物碎片数量
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
		
		--绘制子控件：武器枪碎片
		sub_tmpModel = "UI:SoulStoneFlag" --武器枪碎片模型
		sub_pos_x = 10 --子控件位置x
		sub_pos_y = -6 --子控件位置y
		sub_pos_w = 24 --子控件宽度
		sub_pos_h = 24 --子控件高度
	elseif (rewardType == 103) then --103:宠物碎片
		if hVar.tab_item[rewardID] then
			tmpModel = hVar.tab_item[rewardID].icon --武器枪碎片模型
		end
		if hVar.tab_stringI[rewardID] then
			--itemName = hVar.tab_stringI[rewardID][1] --宝物碎片名称 --language
			itemName = hVar.tab_stringI[rewardID][1] --宝物碎片名称 --language
		else
			itemName = "未知宠物碎片" .. tostring(rewardID)
		end
		itemName = ""--LuaGetObjectName(rewardID,2)..hVar.tab_string["__TEXT_CHIP"]
		itemNum = rewardNum --宝物碎片数量
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
		
		--绘制子控件：宠物碎片
		sub_tmpModel = "UI:SoulStoneFlag" --宠物碎片模型
		sub_pos_x = 10 --子控件位置x
		sub_pos_y = -6 --子控件位置y
		sub_pos_w = 24 --子控件宽度
		sub_pos_h = 24 --子控件高度
	elseif (rewardType == 105) then --105:武器枪宝箱
		tmpModel = "icon/item/chest_1.png"
		itemName = hVar.tab_stringCHEST[1][1] --武器宝箱
		itemNum = rewardID --宝物碎片数量
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
	elseif (rewardType == 106) then --106:战术卡宝箱
		tmpModel = "icon/item/chest_2.png"
		itemName = hVar.tab_stringCHEST[2][1] --战术宝箱
		itemNum = rewardID --宝物碎片数量
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
	elseif (rewardType == 107) then --107:宠物宝箱
		tmpModel = "icon/item/chest_3.png"
		itemName = hVar.tab_stringCHEST[3][1] --基因宝箱
		itemNum = rewardID --宝物碎片数量
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
	elseif (rewardType == 108) then --108:装备宝箱
		tmpModel = "icon/item/chest_4.png"
		itemName = hVar.tab_stringCHEST[4][1] --装备宝箱
		itemNum = rewardID --宝物碎片数量
		itemWidth = 48 --控件宽度
		itemHeight = 48 --控件高度
	elseif (rewardType == 109) then --109:科学家宝箱
		--
	elseif (rewardType == 110) then --110:科学家成就1
		tmpModel = "icon/item/icon_garage_01.png"
		itemName = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT1"] --工程师皮肤
		itemNum = rewardID --宝物碎片数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 111) then --111:科学家成就2
		tmpModel = "icon/item/icon_garage_02.png"
		itemName = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT2"] --工程师皮肤
		itemNum = rewardID --宝物碎片数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 112) then --112:科学家成就3
		tmpModel = "icon/item/icon_garage_03.png"
		itemName = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT3"] --工程师皮肤
		itemNum = rewardID --宝物碎片数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 113) then --113:科学家成就4
		tmpModel = "icon/item/icon_garage_04.png"
		itemName = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT4"] --工程师皮肤
		itemNum = rewardID --宝物碎片数量
		itemWidth = 64 --控件宽度
		itemHeight = 64 --控件高度
	elseif (rewardType == 114) then --114:地鼠币
		tmpModel = "misc/coin2.png"
		itemName = hVar.tab_string["__TEXT_SCIENTIST_DISHU_COIN"] --地鼠币
		itemNum = rewardID --宝物碎片数量
		itemWidth = 58 --控件宽度
		itemHeight = 58 --控件高度
	elseif (rewardType == 115) then --115:垃圾堆成就1
		tmpModel = "icon/item/icon_remains_01.png"
		itemName = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT1"] --垃圾堆皮肤
		itemNum = rewardID --宝物碎片数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 116) then --116:垃圾堆成就2
		tmpModel = "icon/item/icon_remains_02.png"
		itemName = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT2"] --垃圾堆皮肤
		itemNum = rewardID --宝物碎片数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 117) then --117:垃圾堆成就3
		tmpModel = "icon/item/icon_remains_03.png"
		itemName = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT3"] --垃圾堆皮肤
		itemNum = rewardID --宝物碎片数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 118) then --118:垃圾堆成就4
		tmpModel = "icon/item/icon_remains_04.png"
		itemName = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT4"] --垃圾堆皮肤
		itemNum = rewardID --宝物碎片数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 119) then --119:垃圾堆成就5
		tmpModel = "icon/item/icon_remains_05.png"
		itemName = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT5"] --垃圾堆皮肤
		itemNum = rewardID --宝物碎片数量
		itemWidth = 52 --控件宽度
		itemHeight = 52 --控件高度
	elseif (rewardType == 120) then --120:天赋点
		tmpModel = "misc/chariotconfig/point.png"
		itemName = hVar.tab_string["__TEXT_TALENT_POINT"] --天赋点
		itemNum = rewardID --宝物碎片数量
		itemWidth = 56 --控件宽度
		itemHeight = 56 --控件高度
	elseif (rewardT[1] == "ap") then --"ap":成就点
		reward = nil
		tmpModel = "UI:ach_king"
		--itemName = "成就点" --language
		itemName = hVar.tab_string["APPont"] --language
		itemNum = rewardID
	end
	
	return tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h
end


--函数：显示各种类型的奖励的tip
hApi.ShowRewardTip = function(rewardT)
	if rewardT then --存在奖励i
		local rewardType = rewardT[1]
		
		--(1:积分 / 2:战术技能卡 / 3:道具 / 4:英雄 / 5:英雄将魂 / 6:战术技能卡碎片 / 7:游戏币 / 8:网络宝箱 / 9:抽奖类战术技能卡 / 10:神器 / 11:神器晶石)
		if (rewardType == 1) then --1:积分
			--显示积分介绍的tip
			--hApi.ShowJiFennTip()
		elseif (rewardType == 2) then --2:战术技能卡
			--显示战术技能卡tip
			local tacticId = rewardT[2] or 0
			local tacticNum = rewardT[3] or 0
			local tacticLv = rewardT[4] or 1
			hApi.ShowTacticCardTip(rewardType, tacticId, tacticLv)
		elseif (rewardType == 3) then --3:道具
			--[[
			--显示道具tip
			local itemtipX = 400 + (hVar.SCREEN.w - 1024) / 2 --适配其他分辨率
			local itemtipY = 718 + (hVar.SCREEN.h - 768) / 2 --适配其他分辨率
			--hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1,}}, nil, 1, itemtipX, itemtipY, 0)
			]]
			local itemId = tonumber(rewardT[2]) or 0
			local tabI = hVar.tab_item[itemId] or {}
			local icon = tabI.icon
			local itemType = tabI.type
			local itemLv = tabI.itemLv or hVar.ITEM_QUALITY.WHITE
			local NAMERGB = hVar.ITEMLEVEL[itemLv].NAMERGB
			local txt = tabI.txt
			
			--显示商品tip
			local title = hVar.tab_string[txt] or ("未知商品" .. itemId)
			if (txt == nil) then
				title = hVar.tab_stringI[itemId] and hVar.tab_stringI[itemId][1] or ("未知商品" .. itemId)
			end
			local titleColor = ccc3(NAMERGB[1], NAMERGB[2], NAMERGB[3])
			local _frm2 = hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
			local _GameCoinTipParent = _frm2.handle._n
			local _GameCoinTipChildUI = _frm2.childUI
			local _offX = hVar.SCREEN.w / 2
			local _offY = hVar.SCREEN.h / 2 + 220
			local reward = tabI.reward or {}
			local countH = 140
			for i = 1, #reward, 1 do
				local key,strExpress = unpack(reward[i])
				local lv = 1
				local quality = 1
				--print(id,strExpress,quality)
				local value = hApi.AnalyzeValueExpr(nil, nil, {["@lv"] = lv,["@quality"] = quality,}, strExpress, 0)
				local strText = hVar.tab_string[hVar.ItemRewardStr[key]]
				
				_GameCoinTipChildUI["lab_attr"..i] = hUI.label:new({
					parent = _GameCoinTipParent,
					x = _offX - 110,
					y = _offY - countH,
					size = 26,
					font = hVar.FONTC,
					align = "LC",
					text = strText,
				})
				
				local valuatext = ""
				if value > 0 then
					valuatext = "+ " .. value
				else
					valuatext = "- " .. math.abs(value)
				end
				if (hVar.ItemRewardStrMode[key] == 1) then
					valuatext = valuatext .. " %"
				end
				if (hVar.ItemRewardMillinSecondMode[key] == 1) then
					valuatext = valuatext / 1000
				end
				_GameCoinTipChildUI["lab_value"..i] = hUI.label:new({
					parent = _GameCoinTipParent,
					x = _offX + 30,
					y = _offY - countH,
					size = 26,
					font = hVar.FONTC,
					align = "LC",
					text = valuatext,
				})
				
				countH = countH + 32
			end
		elseif (rewardType == 4) then --4:英雄
			--显示英雄tip
			local herotipX = 400 + (hVar.SCREEN.w - 1024) / 2 --适配其他分辨率
			local herotipY = 600 + (hVar.SCREEN.h - 768) / 2 --适配其他分辨率
			hGlobal.event:event("LocalEvent_HeroCardInfo", rewardT[2])
		elseif (rewardType == 5) then --5:英雄将魂
			--显示英雄将魂tip
			local heroItemId = rewardT[2] or 0
			hApi.ShowHeroDerbiesTip(heroItemId)
		elseif (rewardType == 6) then --6:战术技能卡碎片
			--显示战术技能卡碎片tip
			local tacticId = tonumber(rewardT[2]) or 0
			local tacticNum = tonumber(rewardT[3]) or 0
			hApi.ShowTacticCardTip(rewardType, tacticId)
		elseif (rewardType == 7) then --7:游戏币(服务器处理，客户端只拼日志)
			--显示游戏币介绍的tip
			hApi.ShowGameCoinTip()
		elseif (rewardType == 8) then --8:网络宝箱(服务器处理，客户端只拼日志)
			--显示道具tip
			local itemtipX = 400 + (hVar.SCREEN.w - 1024) / 2 --适配其他分辨率
			local itemtipY = 718 + (hVar.SCREEN.h - 768) / 2 --适配其他分辨率
			hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1,}}, nil, 1, itemtipX, itemtipY, 0)
		elseif (rewardType == 9) then --9:抽奖类战术技能卡
			--显示道具tip
			local itemtipX = 400 + (hVar.SCREEN.w - 1024) / 2 --适配其他分辨率
			local itemtipY = 718 + (hVar.SCREEN.h - 768) / 2 --适配其他分辨率
			hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1,}}, nil, 1, itemtipX, itemtipY, 0)
		elseif (rewardType == 10) then --10:红装神器
			--[[
			--显示道具tip
			local itemtipX = 400 + (hVar.SCREEN.w - 1024) / 2 --适配其他分辨率
			local itemtipY = 718 + (hVar.SCREEN.h - 768) / 2 --适配其他分辨率
			local itemSlotNum = rewardT[3] or 0 --神器孔数量
			local itemQuality = tonumber(rewardT[4]) or 0 --品质
			if (itemSlotNum == 4) then --4孔神器 四孔
				hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1, {"unknwon", "unknwon", "unknwon", "unknwon",},nil,nil,nil,itemQuality,}}, nil, 1, itemtipX, itemtipY, 0)
			elseif (itemSlotNum == 3) then --3孔神器 三孔
				hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1, {"unknwon", "unknwon", "unknwon",},nil,nil,nil,itemQuality,}}, nil, 1, itemtipX, itemtipY, 0)
			elseif (itemSlotNum == 2) then --2孔神器 二孔
				hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1, {"unknwon", "unknwon",},nil,nil,nil,itemQuality,}}, nil, 1, itemtipX, itemtipY, 0)
			else
				hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1,nil,nil,nil,nil,itemQuality,}}, nil, 1, itemtipX, itemtipY, 0)
			end
			]]
			
			--显示道具tip（战车）
			local itemId = tonumber(rewardT[2]) or 0 --奖励ID
			local itemEntity = rewardT[3] or ""
			local entity = {}
			local tEntity = hApi.Split(itemEntity,"|")
			--print("itemEntity=", itemEntity, type(itemEntity))
			--30160|20110|1|atk3||0|1|11|12|21|22|31|32|41|42|51|52|61|62|71|72|81|82
			entity.dbid = tonumber(tEntity[1]) or 0
			entity.typeId = tonumber(tEntity[2]) or 0
			entity.slotnum = tonumber(tEntity[3]) or 0
			entity.attr = {}
			local idx = 3
			for i = 1, entity.slotnum do
				entity.attr[#entity.attr + 1] = tEntity[idx + i]
			end
			
			--如果是指定孔数的装备tip，以"unkonwn"填充孔数
			if (itemEntity == 1) then
				entity.slotnum = 1
				entity.attr = {"unknwon",}
			elseif (itemEntity == 2) then
				entity.slotnum = 2
				entity.attr = {"unknwon", "unknwon",}
			elseif (itemEntity == 3) then
				entity.slotnum = 3
				entity.attr = {"unknwon", "unknwon", "unknwon",}
			elseif (itemEntity == 4) then
				entity.slotnum = 4
				entity.attr = {"unknwon", "unknwon", "unknwon", "unknwon",}
			end
			
			idx = idx + entity.slotnum + 1
			
			entity.CUnique = tonumber(tEntity[idx+1]) or 0
			entity.quality = tonumber(tEntity[idx+2]) or 0
			entity.randIdx1 = tonumber(tEntity[idx+3]) or 0 --随机属性索引1
			entity.randVal1 = tonumber(tEntity[idx+4]) or 0 --随机属性值1
			entity.randIdx2 = tonumber(tEntity[idx+5]) or 0 --随机属性索引2
			entity.randVal2 = tonumber(tEntity[idx+6]) or 0 --随机属性值2
			entity.randIdx3 = tonumber(tEntity[idx+7]) or 0 --随机属性索引3
			entity.randVal3 = tonumber(tEntity[idx+8]) or 0 --随机属性值3
			entity.randIdx4 = tonumber(tEntity[idx+9]) or 0 --随机属性索引4
			entity.randVal4 = tonumber(tEntity[idx+10]) or 0 --随机属性值4
			entity.randIdx5 = tonumber(tEntity[idx+11]) or 0 --随机属性索引5
			entity.randVal5 = tonumber(tEntity[idx+12]) or 0 --随机属性值5
			entity.randSkillIdx1 = tonumber(tEntity[idx+13]) or 0 --随机技能索引1
			entity.randSkillLv1 = tonumber(tEntity[idx+14]) or 0 --随机技能等级1
			entity.randSkillIdx2 = tonumber(tEntity[idx+15]) or 0 --随机技能索引2
			entity.randSkillLv2 = tonumber(tEntity[idx+16]) or 0 --随机技能等级2
			entity.randSkillIdx3 = tonumber(tEntity[idx+17]) or 0 --随机技能索引3
			entity.randSkillLv3 = tonumber(tEntity[idx+18]) or 0 --随机技能等级3
			local item_uniqueID = 0
			local oEquip = {itemId,1,entity.attr,info or 0,"",item_uniqueID,entity.quality,1,{{hVar.ITEM_FROMWHAT_TYPE.NET,entity.dbid,entity.slotnum,0}},0,0,0,
				entity.randIdx1,entity.randVal1,entity.randIdx2,entity.randVal2,entity.randIdx3,entity.randVal3,entity.randIdx4,entity.randVal4,entity.randIdx5,entity.randVal5,
				entity.randSkillIdx1,entity.randSkillLv1,entity.randSkillIdx2,entity.randSkillLv2,entity.randSkillIdx3,entity.randSkillLv3,}
			hGlobal.event:event("localEvent_ShowItemTipFrm", oEquip)
		elseif (rewardType == 11) then --11:神器晶石
			--显示神器晶石介绍的tip
			hApi.ShowRedEquipDeribsTip()
		elseif (rewardType == 12) then --12:红装兑换券
			--显示红装兑换券介绍tip
			hApi.ShowFBExchangeTip()
		elseif (rewardType == 13) then --13:服务器将魂抽卡
			--显示将魂抽卡介绍tip
			hApi.ShowHeroDeribsDrawCardTip(rewardT[2], rewardT[3], rewardT[4])
		elseif (rewardType == 14) then --14:英雄经验
			--
		elseif (rewardType == 15) then --15:直接开锦囊
			--显示锦囊道具tip
			local itemtipX = 400 + (hVar.SCREEN.w - 1024) / 2 --适配其他分辨率
			local itemtipY = 718 + (hVar.SCREEN.h - 768) / 2 --适配其他分辨率
			hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1,}}, nil, 1, itemtipX, itemtipY, 0)
		elseif (rewardType == 16) then --16:铁
			--显示铁介绍的tip
			hApi.ShowGroupIronTip()
		elseif (rewardType == 17) then --17:木材
			--显示木材介绍的tip
			hApi.ShowGroupWoodTip()
		elseif (rewardType == 18) then --18:粮食
			--显示粮食介绍的tip
			hApi.ShowGroupFoodTip()
		elseif (rewardType == 20) then --20:军团币
			--显示军团币介绍的tip
			hApi.ShowGroupCoinTip()
		elseif (rewardType == 21) then --21:强化免费券
			--显示强化免费券介绍的tip
			hApi.ShowQiangHuaFreeTicketTip()
		elseif (rewardType == 22) then --22:宝物碎片
			--显示宝物碎片介绍的tip
			local treasureItemId = tonumber(rewardT[2]) or 0
			hApi.ShowTreasureDerbiesTip(treasureItemId)
		elseif (rewardType == 23) then --23:藏宝图碎片
			--显示藏宝图碎片介绍的tip
			hApi.ShowCangBaoTuTip()
		elseif (rewardType == 24) then --24:高级藏宝图碎片
			--显示高级藏宝图碎片介绍的tip
			hApi.ShowCangBaoTuHighTip()
		elseif (rewardType == 25) then --25:兵符
			--显示兵符介绍的tip（简版）
			hApi.ShowPvpCoinTip_Short()
		elseif (rewardType == 26) then --26:抽奖免费券
			--显示抽奖免费券介绍的tip
			hApi.ShowChouJiangFreeTicketTip()
		elseif (rewardType == 100) then --100:任务之石
			--显示任务之石介绍的tip
			hApi.ShowTaskStonTip()
		elseif (rewardType == 101) then --101:武器枪碎片
			--显示战术技能卡碎片tip
			local tacticId = tonumber(rewardT[2]) or 0
			local tacticNum = tonumber(rewardT[3]) or 0
			hApi.ShowTacticCardTip(rewardType, tacticId)
		elseif (rewardType == 103) then --103:宠物碎片
			--显示战术技能卡碎片tip
			local tacticId = tonumber(rewardT[2]) or 0
			local tacticNum = tonumber(rewardT[3]) or 0
			hApi.ShowTacticCardTip(rewardType, tacticId)
		elseif (rewardType == 105) then --103:武器枪宝箱
			local chestId = 1
			local title = hVar.tab_stringCHEST[chestId][1]
			local titleColor = ccc3(255, 196, 0)
			local icon = hVar.tab_chest[chestId].icon
			local iconW = hVar.tab_chest[chestId].width * 0.4
			local iconH = hVar.tab_chest[chestId].height * 0.4
			local content = hVar.tab_stringCHEST[chestId][2]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 106) then --106:战术卡宝箱
			local chestId = 2
			local title = hVar.tab_stringCHEST[chestId][1]
			local titleColor = ccc3(255, 196, 0)
			local icon = hVar.tab_chest[chestId].icon
			local iconW = hVar.tab_chest[chestId].width * 0.4
			local iconH = hVar.tab_chest[chestId].height * 0.4
			local content = hVar.tab_stringCHEST[chestId][2]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 107) then --107:宠物宝箱
			local chestId = 3
			local title = hVar.tab_stringCHEST[chestId][1]
			local titleColor = ccc3(255, 196, 0)
			local icon = hVar.tab_chest[chestId].icon
			local iconW = hVar.tab_chest[chestId].width * 0.4
			local iconH = hVar.tab_chest[chestId].height * 0.4
			local content = hVar.tab_stringCHEST[chestId][2]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 108) then --108:装备宝箱
			local chestId = 4
			local title = hVar.tab_stringCHEST[chestId][1]
			local titleColor = ccc3(255, 196, 0)
			local icon = hVar.tab_chest[chestId].icon
			local iconW = hVar.tab_chest[chestId].width * 0.4
			local iconH = hVar.tab_chest[chestId].height * 0.4
			local content = hVar.tab_stringCHEST[chestId][2]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 109) then --109:科学家宝箱
			--
		elseif (rewardType == 110) then --110:科学家成就1
			local title = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT1"] --工程师皮肤
			local titleColor = ccc3(255, 255, 0)
			local icon = "icon/item/icon_garage_01.png"
			local iconW = 72
			local iconH = 72
			local content = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT_INTRO1"]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 111) then --111:科学家成就2
			local title = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT2"] --工程师皮肤
			local titleColor = ccc3(255, 255, 0)
			local icon = "icon/item/icon_garage_02.png"
			local iconW = 72
			local iconH = 72
			local content = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT_INTRO2"]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 112) then --112:科学家成就3
			local title = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT3"] --工程师皮肤
			local titleColor = ccc3(255, 255, 0)
			local icon = "icon/item/icon_garage_03.png"
			local iconW = 72
			local iconH = 72
			local content = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT_INTRO3"]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 113) then --113:科学家成就4
			local title = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT4"] --工程师皮肤
			local titleColor = ccc3(255, 255, 0)
			local icon = "icon/item/icon_garage_04.png"
			local iconW = 86
			local iconH = 86
			local content = hVar.tab_string["__TEXT_SCIENTIST_ACHIEVEMENT_INTRO4"]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 114) then --114:地鼠币
			local title = hVar.tab_string["__TEXT_SCIENTIST_DISHU_COIN"] --地鼠币
			local titleColor = ccc3(255, 255, 0)
			local icon = "misc/coin2.png"
			local iconW = 80
			local iconH = 80
			local content = hVar.tab_string["__TEXT_SCIENTIST_DISHU_COIN_INTRODUCE"]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 115) then --115:垃圾堆成就1
			local title = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT1"] --垃圾堆皮肤
			local titleColor = ccc3(255, 255, 0)
			local icon = "icon/item/icon_remains_01.png"
			local iconW = 72
			local iconH = 72
			local content = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT_INTRO1"]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 116) then --116:垃圾堆成就2
			local title = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT2"] --垃圾堆皮肤
			local titleColor = ccc3(255, 255, 0)
			local icon = "icon/item/icon_remains_02.png"
			local iconW = 72
			local iconH = 72
			local content = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT_INTRO2"]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 117) then --117:垃圾堆成就3
			local title = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT3"] --垃圾堆皮肤
			local titleColor = ccc3(255, 255, 0)
			local icon = "icon/item/icon_remains_03.png"
			local iconW = 72
			local iconH = 72
			local content = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT_INTRO3"]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 118) then --118:垃圾堆成就4
			local title = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT4"] --垃圾堆皮肤
			local titleColor = ccc3(255, 255, 0)
			local icon = "icon/item/icon_remains_04.png"
			local iconW = 72
			local iconH = 72
			local content = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT_INTRO4"]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 119) then --119:垃圾堆成就5
			local title = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT5"] --垃圾堆皮肤
			local titleColor = ccc3(255, 255, 0)
			local icon = "icon/item/icon_remains_05.png"
			local iconW = 72
			local iconH = 72
			local content = hVar.tab_string["__TEXT_TANKDEADTH_ACHIEVEMENT_INTRO5"]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		elseif (rewardType == 120) then --120:天赋点
			local title = hVar.tab_string["__TEXT_TALENT_POINT"] --天赋点
			local titleColor = ccc3(255, 255, 0)
			local icon = "misc/chariotconfig/point.png"
			local iconW = 92
			local iconH = 92
			local content = hVar.tab_string["__TEXT_TALENT_POINT_INTRODUCE"]
			hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
		end
	end
end

--冒泡显示所有奖励
hApi.BubbleGiftAnim = function(reward, rewardLength, pos_x, pos_y)
	rewardLength = rewardLength or (#reward)
	
	--依次做运动
	for i = 1, rewardLength, 1 do
		local rewardT = reward[i]
		if rewardT then
			local rewardType = tonumber(rewardT[1]) or 0 --获取类型
			
			if (rewardType == "ap") or (rewardType > 0) then
				local tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h = hApi.GetRewardParams(rewardT)
				
				--父控件
				local _frmNode = hUI.button:new({
					parent = nil,
					--model = "misc/mask.png",
					model = -1,
					x = pos_x,
					y = pos_y,
					w = 45,
					h = 45,
					align = "MC",
					z = 10000,
				})
				_frmNode:setstate(-1) --一开始不显示
				local _parentNode = _frmNode.handle._n
				
				--选中框
				local px = 0
				local py = 0
				local offset = 0
				local yOffset = 0
				local WW = 32
				local HH = 32
				
				--奖励物品的图标
				_frmNode.childUI["imgIcon"] = hUI.button:new({
					parent = _parentNode,
					model = tmpModel,
					x = px + offset - 70,
					y = py + yOffset,
					w = WW,
					h = HH,
					align = "MC",
				})
				
				--绘制奖励图标的子控件
				if sub_tmpModel then
					_frmNode.childUI["imgIcon"].childUI["image"] = hUI.image:new({
						parent = _frmNode.childUI["imgIcon"].handle._n,
						model = sub_tmpModel,
						x = sub_pos_x * WW / itemWidth,
						y = sub_pos_y * HH / itemHeight,
						w = sub_pos_w * WW / itemWidth,
						h = sub_pos_h * HH / itemHeight,
					})
				end
				
				--奖励物品的名称
				_frmNode.childUI["labName"] = hUI.label:new({
					parent = _parentNode,
					size = 22,
					align = "LC",
					border = 1,
					x = px + offset - 45,
					y = py + yOffset,
					--font = hVar.FONTC,
					font = hVar.FONTC,
					width = 290,
					text = itemName,
				})
				_frmNode.childUI["labName"].handle.s:setColor(ccc3(196, 255, 196))
				
				--奖励物品的数量
				local intro = "+" .. itemNum
				if (itemNum < 0) then --负数
					intro = itemNum
				end
				_frmNode.childUI["labIntro"] = hUI.label:new({
					parent = _parentNode,
					size = 20,
					align = "LC",
					border = 1,
					x = px + offset - 45 + (#itemName) * 8,
					y = py + yOffset - 1,
					--font = hVar.FONTC,
					font = "numWhite",
					width = 290,
					text = intro,
				})
				_frmNode.childUI["labIntro"].handle.s:setColor(ccc3(255, 255, 0))
				if (itemNum < 0) then --负数
					_frmNode.childUI["labIntro"].handle.s:setColor(ccc3(255, 64, 64))
				end
				
				--做运动
				local waittime = 0.4 * (i - 1) --等待时间
				local moveTime = 0.5
				local fadeTime = 0.4
				--local sumTime = 0.4 * (rewardLength - 1) + waittime + moveTime + fadeTime
				local act1 = CCDelayTime:create(waittime)
				local act2 = CCCallFunc:create(function(ctrl)
					_frmNode:setstate(1) --显示
				end)
				local act3 = CCMoveBy:create(moveTime, ccp(0, 50))
				local act4 = CCDelayTime:create(fadeTime)
				local act5 = CCCallFunc:create(function(ctrl)
					_frmNode:del()
				end)
				local a = CCArray:create()
				a:addObject(act1)
				a:addObject(act2)
				a:addObject(act3)
				a:addObject(act4)
				a:addObject(act5)
				local sequence = CCSequence:create(a)
				_frmNode.handle._n:runAction(sequence)
			end
		end
	end
end

--[[
--创建击杀怪得金币的动画
hApi.ShowGoldBubble = function(oUnit, gold, bIsCirt)
	local hero_x, hero_y = hApi.chaGetPos(oUnit.handle) --我方小兵的坐标
	local hero_bx, hero_by, hero_bw, hero_bh = oUnit:getbox() --我方小兵的包围盒
	local tx = hero_x + (hero_bx + hero_bw / 2) --中心点x位置
	local ty = -hero_y + hero_bh --上部y
	--local screenX, screenY = hApi.world2view(tx, ty) --屏幕坐标
	
	if (bIsCirt) then --暴击
		--击杀得的金币图标
		local ctrl = hUI.button:new({
			parent = oUnit:getworld().handle.worldLayer,
			model = "UI:ach_weathy",
			x = tx,
			y = ty,
			z = 100000,
			scale = 1.0,
		})
		ctrl.handle.s:setOpacity(0)
		
		ctrl.childUI["image"] = hUI.image:new({
			parent = ctrl.handle._n,
			model = "UI:ach_weathy",
			x = -20,
			y = 10,
			scale = 0.5,
		})
		
		ctrl.childUI["label"] = hUI.label:new({
			parent = ctrl.handle._n,
			font = "numWhite",
			size = 15,
			align = "LC",
			text = "+" .. gold,
			x = 0,
			y = 10,
		})
		ctrl.childUI["label"].handle.s:setColor(ccc3(255, 255, 0))
		
		--播放动画
		local array = CCArray:create()
		local scale1 = CCEaseSineOut:create(CCScaleTo:create(0.2, 2.2))
		local scale2 = CCScaleTo:create(0.2, 1.1)
		local waitScale = CCDelayTime:create(0.4)
		array:addObject(scale1)
		array:addObject(scale2)
		array:addObject(waitScale)
		local sequecne = CCSequence:create(array) --同步1：变大又变小
		local moveby = CCEaseSineIn:create(CCMoveTo:create(0.8, ccp(tx, ty + 50))) --同步2:移动
		local spawn = CCSpawn:createWithTwoActions(sequecne, moveby) --同步
		
		local array = CCArray:create()
		local callback = CCCallFunc:create(function() --回调
			local finishCount = 0
			
			--图片暗淡
			local fade1 = CCFadeTo:create(0.6, 0)
			local call1 = CCCallFunc:create(function() --回调
				finishCount = finishCount + 1
				
				if (finishCount == 2) then
					ctrl:del()
				end
			end)
			local seq1 = CCSequence:createWithTwoActions(fade1, call1) --同步1
			ctrl.childUI["image"].handle.s:runAction(seq1) --action
			
			--文字暗淡
			local fade2 = CCFadeTo:create(0.6, 0)
			local call2 = CCCallFunc:create(function() --回调
				finishCount = finishCount + 1
				
				if (finishCount == 2) then
					ctrl:del()
				end
			end)
			local seq2 = CCSequence:createWithTwoActions(fade2, call2) --同步2
			ctrl.childUI["label"].handle.s:runAction(seq2) --action
		end)
		
		array:addObject(spawn)
		array:addObject(callback)
		ctrl.handle._n:runAction(CCSequence:create(array)) --action
		
		--播放音效
		hApi.PlaySound("pay_gold")
	else
		--击杀得的金币图标
		local ctrl = hUI.image:new({
			parent = oUnit:getworld().handle.worldLayer,
			model = "UI:ach_weathy",
			x = tx,
			y = ty,
			z = 100000,
			scale = 0.25,
		})
		
		--播放动画
		local array = CCArray:create()
		local scale1 = CCEaseSineOut:create(CCScaleTo:create(0.4, 0.4))
		local waitScale = CCDelayTime:create(0.2)
		local scale2 = CCScaleTo:create(0.1, 0.1)
		array:addObject(scale1)
		array:addObject(waitScale)
		array:addObject(scale2)
		local sequecne = CCSequence:create(array) --同步1：变大又变小
		local moveby = CCEaseSineOut:create(CCMoveTo:create(0.7, ccp(tx, ty + 15))) --同步2:移动
		local spawn1 = CCSpawn:createWithTwoActions(sequecne, moveby) --同步
		local fade = CCEaseSineIn:create(CCFadeTo:create(1.0, 0))
		local spawn2 = CCSpawn:createWithTwoActions(spawn1, fade) --同步
		
		local array = CCArray:create()
		local wait = CCDelayTime:create(0.02)
		
		local callback = CCCallFunc:create(function() --回调
			ctrl:del()
			---print("DDDDD")
		end)
		
		array:addObject(spawn2)
		array:addObject(wait)
		array:addObject(callback)
		ctrl.handle._n:runAction(CCSequence:create(array)) --action
	end
end
]]

--单次延时显示金币掉落的动画
local __ShowSingleBubble = function(oUnit, delayTime, scaleFrom, scaleTo, HPos, VPosU, VPosD)
	local hero_x, hero_y = hApi.chaGetPos(oUnit.handle) --我方小兵的坐标
	local hero_bx, hero_by, hero_bw, hero_bh = oUnit:getbox() --我方小兵的包围盒
	local tx = hero_x + (hero_bx + hero_bw / 2) --中心点x位置
	local ty = -hero_y + hero_bh --上部y
	--local screenX, screenY = hApi.world2view(tx, ty) --屏幕坐标
	
	--击杀得的金币图标
	local ctrl = hUI.image:new({
		parent = oUnit:getworld().handle.worldLayer,
		model = "UI:ach_weathy",
		x = tx,
		y = ty,
		z = 100000,
		scale = scaleFrom,
	})
	ctrl.handle.s:setVisible(false)
	
	--播放动画
	local randVal = hApi.random(0, 1)
	if (randVal == 0) then
		randVal = -1
	end
	local array = CCArray:create()
	--[[
	local scale1 = CCEaseSineOut:create(CCScaleTo:create(0.5, 0.5))
	local waitScale = CCDelayTime:create(0.2)
	local scale2 = CCScaleTo:create(0.1, 0.1)
	array:addObject(scale1)
	array:addObject(waitScale)
	array:addObject(scale2)
	local sequecne = CCSequence:create(array) --同步1：变大又变小
	local moveby = CCEaseSineOut:create(CCMoveTo:create(0.7, ccp(tx, ty + 50))) --同步2:移动
	local spawn1 = CCSpawn:createWithTwoActions(sequecne, moveby) --同步
	local fade = CCEaseSineIn:create(CCFadeTo:create(1.0, 0))
	local spawn2 = CCSpawn:createWithTwoActions(spawn1, fade) --同步
	]]
	local moveHor = CCMoveBy:create(1.5, ccp(HPos * randVal, 0)) --水平位移
	local moveVer1 = CCEaseSineOut:create(CCMoveBy:create(0.5, ccp(0, VPosU))) --垂直位移1
	local moveVer2 = CCEaseSineIn:create(CCMoveBy:create(1.0, ccp(0, -VPosD))) --垂直位移2
	local moveVer = CCSequence:createWithTwoActions(moveVer1, moveVer2)
	local spawn1 = CCSpawn:createWithTwoActions(moveHor, moveVer) --同步位移
	local scale2 = CCScaleTo:create(1.5, scaleTo) --变大
	local spawn2 = CCSpawn:createWithTwoActions(spawn1, scale2) --同步位移
	
	local array = CCArray:create()
	local wait = CCDelayTime:create(0.02)
	
	local callback = CCCallFunc:create(function() --回调
		ctrl:del()
	end)
	
	local delayBegin = CCDelayTime:create(delayTime)
	local callbackShow = CCCallFunc:create(function()
		ctrl.handle.s:setVisible(true)
		
		--播放音效
		hApi.PlaySound("pay_gold")
	end)
	array:addObject(delayBegin)
	array:addObject(callbackShow)
	array:addObject(spawn2)
	array:addObject(wait)
	array:addObject(callback)
	ctrl.handle._n:runAction(CCSequence:create(array)) --action
end

--创建击杀怪得金币的动画
hApi.ShowGoldBubble = function(oUnit, gold, bIsCirt)
	--显示动画
	if bIsCirt then
		local LOOP = 10 --数量
		for i = 1, LOOP, 1 do
			local delatTime = 0.8 * i / LOOP
			local HPos = hApi.random(30, 70) --x位移
			local VPosU = hApi.random(20, 50) --y位移1
			local VPosD = hApi.random(40, 70) --y位移2
			__ShowSingleBubble(oUnit, delatTime, 0.28, 0.4, HPos, VPosU, VPosD)
		end
		
		hApi.ShowDmgNumber(0, 0, oUnit, 0, 0, 0, 0, "+" .. gold, "numYellow", 1.6, 2200)
	else --未暴击
		--显示在角色的头顶
		local hero_x, hero_y = hApi.chaGetPos(oUnit.handle) --我方小兵的坐标
		local cx, cy, cw, ch = oUnit:getbox()
		local offsetX = hero_x + math.floor(cx + cw / 2)
		local offsetY = -hero_y + math.floor(cy + ch)
		local offsetY = -hero_y + math.floor(cy + ch)
		local ctrl = hUI.floatNumber:new(
		{
			--parent = oUnit:getworld().handle.worldLayer,
			unit = oUnit,
			font = "numWhite",
			text = "+" .. gold, --hp_restore_show
			size = 18,
			--x = offsetX,
			y = -cy,
			align = "MB",
			moveY = 15,
			lifetime = 900,
			fadeout = 500,
			jumpH = 2,
		})
		ctrl.handle.s:setColor(ccc3(0, 255, 255))
	end
end

--显示掉落大量金币的特效
hApi.ShowComboGoldBubble = function(oUnit, gold)
	local LOOP = 36 --数量
	for i = 1, LOOP, 1 do
		local delatTime = 2.0 * i / LOOP
		local HPos = hApi.random(40, 100) --x位移
		local VPosU = hApi.random(20, 60) --y位移1
		local VPosD = hApi.random(60, 100) --y位移2
		__ShowSingleBubble(oUnit, delatTime, 0.3, 0.5, HPos, VPosU, VPosD)
	end
	hApi.ShowDmgNumber(0, 0, oUnit, 0, 0, 0, 0, "+" .. gold, "numYellow", 2.0, 3000, 20)
end


--留一份缓存 为了充值礼包
local _tIapList = nil
--geyachao: 新的商店充值接口，获得充值列表
function xlLuaEvent_OnIapList(list)
	_tIapList = {}
	if list then
		for i=1,#list do
			_tIapList[#_tIapList + 1] = list[i]
			_tIapList[#_tIapList].custombuyindex = i
		end
	end
	--触发事件: 获得充值列表
	hGlobal.event:event("LocalEvent_OnIapList_Back", _tIapList)
end

--获取充值列表
function xlLuaEvent_GetIapList()
	return _tIapList
end

function hApi.xlSetPlayerInfo(index)
	local TargetPlatform = CCApplication:sharedApplication():getTargetPlatform()
	
	if g_tTargetPlatform.kTargetWindows ~= TargetPlatform then --app
		hApi.CreateInputBox(index)
	else --windows
		--xlSetPlayerInfo(index)
		hApi.CreateInputBox(index)
	end
end

--创建角色弹出起名字的界面
hApi.CreateInputBox = function(index)
	--[[
	if IputBoxFrm then
		IputBoxFrm:del()
	end
	
	local WIDTH = 400 --宽度
	local HEIGHT = 250 --高度
	IputBoxFrm = hUI.frame:new({
		parent = nil,
		border = 1, --显示frame边框
		background = "UI:Tactic_Background",
		x = hVar.SCREEN.w / 2 - WIDTH / 2,
		y = hVar.SCREEN.h / 2 + HEIGHT / 2,
		w = WIDTH,
		h = HEIGHT,
		dragable = 4,
		autoactive = 0,
	})
	
	--标题
	local OFFSETX = WIDTH / 2
	local OFFSETY = -HEIGHT / 2
	IputBoxFrm.childUI["TitleLbael"] = hUI.label:new({
		parent = IputBoxFrm.handle._n,
		x = OFFSETX,
		y = OFFSETY + 78,
		size = 26,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 500,
		--text = "欢迎来到策马守天关的世界", --language
		text = hVar.tab_string["welcome_cow1"], --language
	})
	
	--提示输入文字
	IputBoxFrm.childUI["NoteInputLbael"] = hUI.label:new({
		parent = IputBoxFrm.handle._n,
		x = OFFSETX,
		y = OFFSETY + 15,
		size = 26,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 500,
		--text = "为您的主公起个名字", --language
		text = hVar.tab_string["welcome_cow2"], --language
	})
	
	--关闭按钮
	if (index > 1) then
		IputBoxFrm.childUI["closeBtn"] = hUI.button:new({
			parent = IputBoxFrm.handle._n,
			dragbox = IputBoxFrm.childUI["dragBox"],
			--model = "UI:BTN_Close", --BTN:PANEL_CLOSE
			model = "BTN:PANEL_CLOSE",
			x = WIDTH,
			y = 0,
			scaleT = 0.95,
			code = function()
				IputBoxFrm:del()
				IputBoxFrm = nil
			end,
		})
	end
	
	--输入框
	local enterNameEditBox = nil
	local rgName = "" --输入的内容
	local editNameBoxTextEventHandle = function(strEventName, pSender)
		--local edit = tolua.cast(pSender, "CCEditBox") 
		
		if (strEventName == "began") then
			--
		elseif (strEventName == "changed") then --改变事件
			--
		elseif (strEventName == "ended") then
			rgName = enterNameEditBox:getText()
		elseif (strEventName == "return") then
			--
		end
		
		--print("editNameBoxTextEventHandle", strEventName, rgName)
		--xlLG("editbox", tostring(strEventName) .. ", rgName=" .. tostring(rgName) .. "\n")
	end
	
	enterNameEditBox = CCEditBox:create(CCSizeMake(290, 36), CCScale9Sprite:create("data/image/misc/tfback.png"))--"data/image/misc/win_back.png""data/image/misc/1xs.png"
	enterNameEditBox:setPosition(ccp(OFFSETX + 0, OFFSETY - 25))
	--enterNameEditBox:setFontName("Sketch Rockwell.ttf")
	enterNameEditBox:setFontSize(24)
	enterNameEditBox:setFontColor(ccc3(255, 255, 255))
	enterNameEditBox:setPlaceHolder("")--hVar.tab_string["enter_name_7_15"]
	enterNameEditBox:setPlaceholderFontColor(ccc3(255, 122, 16))
	enterNameEditBox:setMaxLength(128)
	enterNameEditBox:registerScriptEditBoxHandler(editNameBoxTextEventHandle)
	enterNameEditBox:setTouchPriority(0)
	enterNameEditBox:setReturnType(kKeyboardReturnTypeDone)
	IputBoxFrm.handle._n:addChild(enterNameEditBox)
	
	--确定按钮
	--背景图
	IputBoxFrm.childUI["okButton"] = hUI.button:new({
		parent = IputBoxFrm.handle._n,
		--model = "misc/button_back.png",
		x = OFFSETX,
		y = OFFSETY - 80,
		scale = 1.0,
		scaleT = 0.95,
		dragbox = IputBoxFrm.childUI["dragBox"],
		--label = "确定", --language
		label = hVar.tab_string["Exit_Ack"], --language
		font = hVar.FONTC,
		border = 1,
		code = function()
			--验证名字是否有效
			rgName = string.lower(rgName) --转小写
			local answer, errInfo = LuaCheckPlayerName(rgName)
			--print(rgName, answer)
			if (answer == hVar.STRING_TRIM_MODE.SUCCEED) then
				LuaSetPlayerList(index, rgName, "normal")
				Lua_UIShow_PlayerInfoFram(index)
				
				IputBoxFrm:del()
			else
				--error
				--errInfo = "同的名"
				hUI.floatNumber:new({
					x = hVar.SCREEN.w / 2 - 30,
					y = hVar.SCREEN.h / 2 - 40,
					align = "MC",
					text = "",
					lifetime = 1000,
					fadeout = -550,
					moveY = 32,
				}):addtext(errInfo, hVar.FONTC, 32, "MC", 32, 0)
			end
		end,
	})
	]]
	
	--触发事件，显示输入名字界面
	hGlobal.event:event("LocalEvent_new_mainmenu_frm", 1, true, index)
end


--战车
--角色改起名字的界面
hApi.CreateModifyInputBox_Diablo = function(index,model,oID,bClosebtn)
	--print("hApi.CreateModifyInputBox_Diablo")
	
	--删除可能存在的界面
	if IputBoxFrm then
		IputBoxFrm:del()
		IputBoxFrm = nil
	end
	
	--移除监听修改战车名字成功事件
	hGlobal.event:listen("localEvent_modify_tank_username", "_change_name_", nil)
	
	if type(xlGetScreenRotation) == "function" and type(xlRotateScreen) == "function" then
		--不可旋转
		local orientation, lock_flag = xlGetScreenRotation()
		xlRotateScreen(orientation,  1)               --设置屏幕朝向以及是否锁定
	end
	
	local iPhoneX_WIDTH = 0
	if (g_phone_mode == 4) then --iPhoneX
		iPhoneX_WIDTH = hVar.SCREEN.offx
	end
	
	local WIDTH = 540 --宽度
	local HEIGHT = 400 --高度
	
	local frameX = hVar.SCREEN.w - WIDTH - 6 - iPhoneX_WIDTH
	local dragable = 3
	--结算界面自动跳出
	if model == 2 then
		frameX = hVar.SCREEN.w / 2 - WIDTH / 2
		dragable = 4
	end
	
	--回调函数
	local callbackfunc = function()
		if (type(oID) == "number") then
			local oAction = hClass.action:find(oID)
			if oAction then --目标身上已有此buff
				--继续释放技能
				oAction.data.tick = 1
			end
		end
	end
	
	
	--检测是起名字还是改名
	local bIsSysName = false
	--名字为"游客XXXXXXXX"
	--设置新存档
	local userID = xlPlayer_GetUID()
	local guestPrefix = hVar.tab_string["guest"] --"游客"
	--if (g_lua_src == 1) then --内网源代码模式下，用英文名
	--	guestPrefix = "User"
	--end
	
	local rgNameSystem = guestPrefix
	if (userID > 0) then
		rgNameSystem = guestPrefix .. userID
	end
	
	--苹果
	--如果玩家有存档，并且玩家有名字了，可以取名字
	if (g_curPlayerName ~= nil) then
		--显示名
		local curMyName = ""
		local playerInfo = LuaGetPlayerByName(g_curPlayerName)
		if playerInfo and (playerInfo.showName) then
			curMyName = playerInfo.showName
		end
		if (curMyName == hVar.tab_string["guest"]) or (curMyName == "GUEST") or (curMyName == rgNameSystem) or (curMyName == "") then
			bIsSysName = true
		end
	end
	
	--[[
	--允许关闭
	if bClosebtn then
		bIsSysName = false
	end
	]]
	
	if bIsSysName and (not bClosebtn) then
		IputBoxFrm = hUI.frame:new({
			parent = nil,
			--border = 1, --显示frame边框
			--background = "misc/skillup/msgbox4.png",
			border = -1,
			background = -1,
			x = frameX,
			y = hVar.SCREEN.h / 2 + HEIGHT / 2,
			z = hZorder.TankSetName,
			w = WIDTH,
			h = HEIGHT,
			dragable = dragable,
			autoactive = 0,
			--closebtn = "misc/skillup/btn_close.png",
			--closebtnX = WIDTH - 46,
			--closebtnY = -46,
			--closebtnW = -1,
			--closebtnH = -1,
			--[[
			codeOnClose = function()
				print("codeOnClose")
				--if model == 2 then
					--hGlobal.event:event("LocalEvent_PlayTotalSettlement")
				--end
				
				--移除监听修改战车名字成功事件
				hGlobal.event:listen("localEvent_modify_tank_username", "_change_name_", nil)
				
				if type(callbackfunc) == "function" then
					callbackfunc()
				end
				
				if IputBoxFrm then
					IputBoxFrm:del()
					IputBoxFrm = nil
				end
				
				hApi.ChangeScreenMode()
			end
			]]
		})
	else
		IputBoxFrm = hUI.frame:new({
			parent = nil,
			--border = 1, --显示frame边框
			--background = "misc/skillup/msgbox4.png",
			border = -1,
			background = -1,
			x = frameX,
			y = hVar.SCREEN.h / 2 + HEIGHT / 2,
			z = hZorder.TankSetName,
			w = WIDTH,
			h = HEIGHT,
			dragable = dragable,
			autoactive = 0,
			closebtn = "misc/skillup/btn_close.png",
			closebtnX = WIDTH - 46,
			closebtnY = -46,
			closebtnW = -1,
			closebtnH = -1,
			
			codeOnClose = function()
				print("codeOnClose")
				--if model == 2 then
					--hGlobal.event:event("LocalEvent_PlayTotalSettlement")
				--end
				
				--移除监听修改战车名字成功事件
				hGlobal.event:listen("localEvent_modify_tank_username", "_change_name_", nil)
				
				if type(callbackfunc) == "function" then
					callbackfunc()
				end
				
				if IputBoxFrm then
					IputBoxFrm:del()
					IputBoxFrm = nil
				end
				
				hApi.ChangeScreenMode()
			end
		})
	end
	
	IputBoxFrm:show(1)
	IputBoxFrm:active()
	
	--背景图
	IputBoxFrm.childUI["imgBG"] = hUI.image:new({
		parent = IputBoxFrm.handle._n,
		model = "misc/skillup/msgbox4.png",
		x = WIDTH/2,
		y = -HEIGHT/2,
		w = WIDTH,
		h = HEIGHT,
		z = -1,
	})
	
	--标题
	local OFFSETX = WIDTH / 2
	local OFFSETY = -HEIGHT / 2 + 60
	
	--[[
	IputBoxFrm.childUI["TitleLbael"] = hUI.label:new({
		parent = IputBoxFrm.handle._n,
		x = OFFSETX,
		y = OFFSETY + 78,
		size = 26,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 500,
		--text = "欢迎来到策马守天关的世界", --language
		text = hVar.tab_string["welcome_cow1"], --language
	})
	]]
	
	--关闭按钮
	--IputBoxFrm.childUI["closeBtn"] = hUI.button:new({
		--parent = IputBoxFrm.handle._n,
		--dragbox = IputBoxFrm.childUI["dragBox"],
		----model = "UI:BTN_Close", --BTN:PANEL_CLOSE
		--model = "misc/skillup/btn_close.png", --"BTN:PANEL_CLOSE",
		--x = WIDTH - 50,
		--y = -50,
		--scaleT = 0.95,
		--code = function()
			----删除起名字界面
			--if IputBoxFrm then
				--IputBoxFrm:del()
				--IputBoxFrm = nil
			--end

			--if model == 2 then
				--hGlobal.event:event("LocalEvent_PlayTotalSettlement")
			--end
			
			----列表收回去
			----hGlobal.event:event("LocalEvent_afterShowPhone_PlayerCardFram", index)
		--end,
	--})
	
	--[[
	--输入框的底图
	IputBoxFrm.childUI["inputboxImg"] = hUI.image:new({
		parent = IputBoxFrm.handle._n,
		x = OFFSETX,
		y = OFFSETY - 15,
		w = 290,
		h = 36,
		model = "misc/tfback.png",
	})
	]]
	
	--输入框
	local enterNameEditBox = nil
	local rgName = "" --输入的内容
	local editNameBoxTextEventHandle = function(strEventName, pSender)
		--local edit = tolua.cast(pSender, "CCEditBox") 
		
		if (strEventName == "began") then
			--
		elseif (strEventName == "changed") then --改变事件
			--
		elseif (strEventName == "ended") then
			rgName = enterNameEditBox:getText()
		elseif (strEventName == "return") then
			--
		end
		
		--print("editNameBoxTextEventHandle", strEventName, rgName)
		--xlLG("editbox", tostring(strEventName) .. ", rgName=" .. tostring(rgName) .. "\n")
	end
	
	enterNameEditBox = CCEditBox:create(CCSizeMake(330, 48), CCScale9Sprite:create("data/image/misc/billboard/bg_ng_graywhite.png"))--"data/image/misc/win_back.png""data/image/misc/1xs.png"
	enterNameEditBox:setPosition(ccp(OFFSETX + 0, OFFSETY - 30))
	--enterNameEditBox:setFontName("Sketch Rockwell.ttf")
	enterNameEditBox:setFontSize(24)
	enterNameEditBox:setFontColor(ccc3(0, 0, 0))
	enterNameEditBox:setPlaceHolder("")--hVar.tab_string["enter_name_7_15"]
	enterNameEditBox:setPlaceholderFontColor(ccc3(192, 192, 192))
	enterNameEditBox:setMaxLength(128)
	enterNameEditBox:registerScriptEditBoxHandler(editNameBoxTextEventHandle)
	enterNameEditBox:setTouchPriority(0)
	enterNameEditBox:setReturnType(kKeyboardReturnTypeDone)
	IputBoxFrm.handle._n:addChild(enterNameEditBox)
	
	--[[
	--需要的游戏币文字前缀
	IputBoxFrm.childUI["RmbPrefix"] = hUI.label:new({
		parent = IputBoxFrm.handle._n,
		y = 28,
		size = 24,
		align = "LC",
		--border = 1,
		x = OFFSETX - 72,
		y = OFFSETY - 98,
		font = hVar.FONTC,
		width = 300,
		--text = "消耗", --language
		text = hVar.tab_string["__TEXT_CONSUME"], --language
		border = 1,
	})
	IputBoxFrm.childUI["RmbPrefix"].handle.s:setColor(ccc3(255, 236, 0))
	]]
	
	--系统名字改名，不要游戏币
	local requireRmb = 0
	if bIsSysName then
		--提示输入文字
		IputBoxFrm.childUI["NoteInputLbael"] = hUI.label:new({
			parent = IputBoxFrm.handle._n,
			x = OFFSETX,
			y = OFFSETY + 20,
			size = 26,
			align = "MC",
			border = 1,
			font = hVar.FONTC,
			width = 500,
			height = 28,
			--text = "修改您主公的名字", --language
			--text = hVar.tab_string["welcome_cow3"], --language
			text = hVar.tab_string["your_name"],
		})
	else
		requireRmb = 200
		
		--提示修改文字
		IputBoxFrm.childUI["NoteInputLbael"] = hUI.label:new({
			parent = IputBoxFrm.handle._n,
			x = OFFSETX,
			y = OFFSETY + 20,
			size = 26,
			align = "MC",
			border = 1,
			font = hVar.FONTC,
			width = 500,
			--text = "修改您主公的名字", --language
			--text = hVar.tab_string["welcome_cow3"], --language
			text = hVar.tab_string["new_name"],
		})
		
		if (requireRmb > 0) then
			--需要的游戏币图标
			IputBoxFrm.childUI["RmbIcon"] = hUI.image:new({
				parent = IputBoxFrm.handle._n,
				model = "misc/skillup/keshi.png",
				x = OFFSETX - 40,
				y = OFFSETY - 122,
				w = 36,
				h = 36,
			})
			
			--需要的游戏币值
			IputBoxFrm.childUI["RmbValue"] = hUI.label:new({
				parent = IputBoxFrm.handle._n,
				size = 22,
				align = "LC",
				--border = 1,
				x = OFFSETX - 14,
				y = OFFSETY - 122 - 1,
				font = "num",
				width = 500,
				text = requireRmb,
			})
			IputBoxFrm.childUI["RmbValue"].handle.s:setColor(ccc3(255, 236, 0))
		end
	end
	
	--确定按钮
	IputBoxFrm.childUI["okButton"] = hUI.button:new({
		parent = IputBoxFrm.handle._n,
		model = "misc/addition/cg.png",
		x = OFFSETX + 6,
		y = OFFSETY - 80 - 96,
		--w = 150,
		--h = 52,
		scaleT = 0.95,
		scale = 0.76,
		dragbox = IputBoxFrm.childUI["dragBox"],
		--label = "确定", --language
		--label = hVar.tab_string["Exit_Ack"], --language
		label = {text = hVar.tab_string["confirm"],size = 28, border = 1,font = hVar.FONTC, x = 0, y = 4,width = 200,height = 32, },
		border = 1,
		code = function()
			--检测是否联网
			if (g_cur_net_state == -1) then --未联网
				local strText = hVar.tab_string["__TEXT_Cant_UseDepletion11_Net"] --"修改名字需要联网"
				hUI.floatNumber:new({
					x = hVar.SCREEN.w / 2 - 113,
					y = hVar.SCREEN.h / 2,
					align = "MC",
					text = "",
					lifetime = 1000,
					fadeout = -550,
					moveY = 32,
				}):addtext(strText, hVar.FONTC, 40, "LC", 0, 0,nil,1)
				
				return
			end
			
			--检测氪石是否足够
			if (LuaGetPlayerRmb() < requireRmb) then
				
				hApi.NotEnoughResource("keshi")
				
				return
			end
			
			--[[
			rgName = "ttttt888" --测试 --test
			]]
			--geyachao: windows版，接收不到输入框的ended事件，只能在点击按钮的时候，取一下输入的文本
			local TargetPlatform = CCApplication:sharedApplication():getTargetPlatform()
			if (g_tTargetPlatform.kTargetWindows == TargetPlatform) then --windows版
				rgName = enterNameEditBox:getText()
			end
			
			--验证名字是否有效
			rgName = string.lower(rgName) --转小写
			local answer, errInfo = LuaCheckPlayerName(rgName)
			
			--print(rgName, answer, errInfo)
			
			if (answer == hVar.STRING_TRIM_MODE.SUCCEED) then
				--监听修改战车名字成功事件
				hGlobal.event:listen("localEvent_modify_tank_username", "_change_name_", function(result, info, name, gamecoin)
					--取消挡操作
					hUI.NetDisable(0)
					
					--更名结果（1成功 0失败）
					--更名信息 (成功:prizeid 失败:失败原因 -1钱不够 -2重名 -3未知)
					if (result == 1) then
						--[[
						--一些旧值
						local oldName = Save_playerList[index].name
						local currentScore = LuaGetPlayerScore()
						
						Save_playerList[index].name = rgName
						g_curPlayerName = rgName
						--Lua_UIShow_PlayerInfoFram(index)
						]]
						local currentScore = LuaGetPlayerScore()
						--修改显示名
						local playerInfo = LuaGetPlayerByName(g_curPlayerName)
						if playerInfo and (playerInfo.showName) then
							playerInfo.showName = rgName
						end
						
						--保存存档
						LuaSavePlayerData(g_localfilepath, g_curPlayerName, Save_PlayerData, Save_PlayerLog)
						LuaSavePlayerList()
						
						--[[
						--删除旧存档
						if hApi.FileExists(g_localfilepath .. oldName .. hVar.SAVE_DATA_PATH.PLAYER_DATA, "full") then
							xlDeleteFileWithFullPath(g_localfilepath .. oldName .. hVar.SAVE_DATA_PATH.PLAYER_DATA)
						end
						if hApi.FileExists(g_localfilepath .. oldName .. hVar.SAVE_DATA_PATH.PLAYER_LOG, "full") then
							xlDeleteFileWithFullPath(g_localfilepath .. oldName .. hVar.SAVE_DATA_PATH.PLAYER_LOG)
						end
						]]
						
						hApi.ChangeScreenMode()
						
						--移除监听修改战车名字成功事件
						hGlobal.event:listen("localEvent_modify_tank_username", "_change_name_", nil)
						
						--删除本界面
						if IputBoxFrm then
							IputBoxFrm:del()
							IputBoxFrm = nil
						end
						
						if type(callbackfunc) == "function" then
							callbackfunc()
						end
						--if model == 2 then
							--hGlobal.event:event("LocalEvent_PlayTotalSettlement")
						--end
						
						--[[
						--刷新本界面
						hGlobal.event:event("LocalEvent_PhoneShowPlayerCardFrm", g_curPlayerName)
						hGlobal.event:event("LocalEvent_afterShowPhone_PlayerCardFram", index)
						]]
						
						--keyChain_score
						--判断设备
						local TargetPlatform = CCApplication:sharedApplication():getTargetPlatform()
						--IOS
						if g_tTargetPlatform.kTargetWindows ~= TargetPlatform then
							xlSaveIntToKeyChain("xl_"..g_curPlayerName.."_playerScore", currentScore)
						--windows
						else
							CCUserDefault:sharedUserDefault():setIntegerForKey("xl_"..g_curPlayerName.."_playerScore",currentScore)
							CCUserDefault:sharedUserDefault():flush()
						end
						
						--[[
						--local strText = "您的主公已更名为：" .. rgName --language
						local strText = hVar.tab_string["__TEXT_ModifyNameSuccess"] .. rgName --language
						hGlobal.UI.MsgBox(strText, {
							font = hVar.FONTC,
							ok = function()
							end,
						})
						]]
						
						--更名完成需要加一句，更新服务器订单状态。只有参数info>0才需要调用
						--local order_id = info
						--SendCmdFunc["order_update_new"](order_id, 2, rgName)
						
						--扣除水晶
						--LuaAddPlayerScore(-gamecoin)
						
						--音效
						if (gamecoin > 0) then
							hApi.PlaySound("pay_gold")
						end
						
						--隐藏界面
						hGlobal.event:event("HidePlayerBestInfoFrame",0)
					else
						--(失败:失败原因 -1钱不够 -2重名 -3未知)
						local strText = nil
						if (info == -1) then
							--strText = "游戏币不足" --language
							strText = hVar.tab_string["ios_not_enough_game_coin"] --language
						elseif (info == -2) then
							--strText = "您输入的名字与已有玩家重名，请更换名字" --language
							strText = hVar.tab_string["ios_err_rename"] --language
						elseif (info == -3) then
							--strText = "未知错误" --language
							strText = hVar.tab_string["ios_err_unknow"] --language
						else
							strText = "rename_err:"..tostring(info)
						end
						
						hUI.floatNumber:new({
							x = hVar.SCREEN.w / 2 - 30,
							y = hVar.SCREEN.h / 2 - 40,
							align = "MC",
							text = "",
							lifetime = 1000,
							fadeout = -550,
							moveY = 32,
						}):addtext(strText, hVar.FONTC, 40, "LC", 0, 0,nil,1)
					end
				end)
				
				--挡操作
				hUI.NetDisable(30000)
				
				--发起改名请求
				--print("发起改名请求", rgName)
				SendCmdFunc["modify_tank_username"](rgName, requireRmb)
				--hGlobal.event:event("localEvent_change_name", 1, -3)
			else
				--error
				--errInfo = "同的名"
				local strText = errInfo
				hUI.floatNumber:new({
					x = hVar.SCREEN.w / 2 - 113,
					y = hVar.SCREEN.h / 2,
					align = "MC",
					text = "",
					lifetime = 1000,
					fadeout = -550,
					moveY = 32,
				}):addtext(strText, hVar.FONTC, 40, "LC", 0, 0,nil,1)
			end
		end,
	})
end

--创建失败后的小贴士界面
function hApi.CreateFailHintFrame(nIsShow, parent)
	local _frame = parent or hGlobal.UI.__GameOverPanel
	local _parent = _frame.handle._n
	local _childUI = _frame.childUI
	
	local w,h = hVar.SCREEN.w+10, hVar.SCREEN.h
	local x,y = hVar.SCREEN.w/2-w/2, hVar.SCREEN.h
	local nScreenY = 0							--根据机器类型（手机，平板）调正整体位置
	if 0 == g_phone_mode then
		nScreenY = -70
	end
	local nGameDescribeX, nGameDescribeY = w/2, nScreenY-79
	
	if _childUI["FailCtrlParent"] then
		_childUI["FailCtrlParent"]:del()
		_childUI["FailCtrlParent"] = nil
	end
	
	--如果是隐藏界面，到这里就可以结束了
	if (nIsShow == 0) then
		return
	end
	
	--随机出小贴士的排序
	local NUM = #g_fail_hint_info
	local introList = {} --提示列表
	local g_fail_hint_info_copy = {} --拷贝表
	for i = 1, NUM, 1 do
		g_fail_hint_info_copy[i] = g_fail_hint_info[i]
	end
	
	local num = NUM
	while (num > 0) do
		local randIdx = hApi.random(1, num)
		local text = g_fail_hint_info_copy[randIdx]
		table.remove(g_fail_hint_info_copy, randIdx)
		table.insert(introList, text)
		num = num - 1
	end
	
	--当前显示的索引值
	local currentShowIdx = 1
	
	--父控件
	_childUI["FailCtrlParent"] = hUI.button:new({ --作为button只是为了子控件坐标正常
		parent = _parent,
		model = "misc/mask.png",
		dragbox = _childUI["dragBox"],
		x = nGameDescribeX - 10,
		y = nGameDescribeY - 400,
		w = 800,
		h = 120,
		scaleT = 1.0,
		failcall = 1,
		
		--按下事件
		codeOnTouch = function(self, touchX, touchY, sus)
			--向右提示的箭头缩小
			_childUI["FailCtrlParent"].childUI["NextGuideImg"].handle._n:setScale(0.45)
			
			--文字缩小
			_childUI["FailCtrlParent"].childUI["FailIntroLabel"].handle._n:setScale(0.96)
			_childUI["FailCtrlParent"].childUI["FailIntroLabel"]:setXY(32, 6)
		end,
		
		--抬起事件
		code = function(self, touchX, touchY, sus)
			--向右提示的箭头正常
			_childUI["FailCtrlParent"].childUI["NextGuideImg"].handle._n:setScale(0.55)
			
			--文字正常
			_childUI["FailCtrlParent"].childUI["FailIntroLabel"].handle._n:setScale(1.0)
			_childUI["FailCtrlParent"].childUI["FailIntroLabel"]:setXY(7, 6)
			
			--点到了里面
			if (sus == 1) then
				--显示的索引加1
				currentShowIdx = currentShowIdx + 1
				if (currentShowIdx > NUM) then
					currentShowIdx = 1
				end
				
				--更新文字
				_childUI["FailCtrlParent"].childUI["FailIntroLabel"]:setText(introList[currentShowIdx])
				_childUI["FailCtrlParent"].childUI["Degree"]:setText(currentShowIdx .. "/" .. NUM)
				
				--不显示叹号
				_childUI["FailCtrlParent"].childUI["HintImg"].handle.s:setVisible(false)
			end
		end,
	})
	_childUI["FailCtrlParent"].handle.s:setOpacity(0) --只用于响应事件，不显示
	
	--[[
	--背景底板
	local enterNameEditBox = CCScale9Sprite:create("data/image/misc/tipMinBG.png")
	enterNameEditBox:setPosition(ccp(-90, 6))
	enterNameEditBox:setScaleX(1.5)
	enterNameEditBox:setScaleY(1.8)
	_childUI["FailCtrlParent"].handle._n:addChild(enterNameEditBox)
	]]
	
	--[[
	--刘备的肖像
	_childUI["FailCtrlParent"].childUI["SystemMgxBoxlab2"] = hUI.image:new({
		parent = _childUI["FailCtrlParent"].handle._n,
		model = "icon/portrait/hero_liubei.png",
		x = 80,
		y = 4,
		w = 128,
		h = 128,
	})
	]]
	
	--标题 "通关小贴士"
	_childUI["FailCtrlParent"].childUI["FailTitleLabel"] = hUI.label:new({
		parent =  _childUI["FailCtrlParent"].handle._n,
		x = 7,
		y = 44,
		size = 28,
		w = 128,
		font = hVar.FONTC,
		border = 1,
		width = 150,
		align = "MT",
		--text = "通关小贴士", --language
		text = hVar.tab_string["XiaoTieShi"], --language
	})
	_childUI["FailCtrlParent"].childUI["FailTitleLabel"].handle.s:setColor(ccc3(255, 255, 0))
	
	--小贴士提示的文字
	_childUI["FailCtrlParent"].childUI["FailIntroLabel"] = hUI.label:new({
		parent =  _childUI["FailCtrlParent"].handle._n,
		x = 7,
		y = 6,
		size = 24,
		w = 128,
		font = hVar.FONTC,
		border = 1,
		width = 1200,
		align = "MT",
		text = introList[currentShowIdx],
	})
	_childUI["FailCtrlParent"].childUI["FailIntroLabel"].handle.s:setColor(ccc3(224, 255, 224))
	
	--提示叹号图
	_childUI["FailCtrlParent"].childUI["HintImg"] = hUI.image:new({
		parent = _childUI["FailCtrlParent"].handle._n,
		model = "UI:TaskTanHao",
		x = 88,
		y = 36,
		scale = 0.48,
	})
	local act1 = CCMoveBy:create(0.2, ccp(0, 6))
	local act2 = CCMoveBy:create(0.2, ccp(0, -6))
	local act3 = CCMoveBy:create(0.2, ccp(0, 6))
	local act4 = CCMoveBy:create(0.2, ccp(0, -6))
	local act5 = CCDelayTime:create(0.6)
	local act6 = CCRotateBy:create(0.1, 10)
	local act7 = CCRotateBy:create(0.1 * 1, -10 * 2)
	local act8 = CCRotateBy:create(0.1 * 1, 10 * 2)
	local act9 = CCRotateBy:create(0.1, -10)
	local act10 = CCDelayTime:create(0.8)
	local a = CCArray:create()
	a:addObject(act1)
	a:addObject(act2)
	a:addObject(act3)
	a:addObject(act4)
	a:addObject(act5)
	a:addObject(act6)
	a:addObject(act7)
	a:addObject(act8)
	a:addObject(act9)
	a:addObject(act10)
	local sequence = CCSequence:create(a)
	_childUI["FailCtrlParent"].childUI["HintImg"].handle.s:runAction(CCRepeatForever:create(sequence))
	
	--当前的进度
	_childUI["FailCtrlParent"].childUI["Degree"] = hUI.label:new({
		parent =  _childUI["FailCtrlParent"].handle._n,
		x = 7,
		y = -43,
		size = 16,
		w = 128,
		font = "numWhite",
		border = 1,
		width = 200,
		align = "MC",
		text = currentShowIdx .. "/" .. NUM,
	})
	_childUI["FailCtrlParent"].childUI["Degree"].handle.s:setColor(ccc3(255, 255, 196))
	
	--提示下一条提示的箭头
	_childUI["FailCtrlParent"].childUI["NextGuideImg"] = hUI.image:new({
		parent = _childUI["FailCtrlParent"].handle._n,
		model = "UI:direction",
		x = 225,
		y = -40,
		scale = 0.55,
	})
	local act1 = CCMoveBy:create(0.2, ccp(6, 0))
	local act2 = CCMoveBy:create(0.2, ccp(-6, 0))
	local act3 = CCMoveBy:create(0.2, ccp(6, 0))
	local act4 = CCMoveBy:create(0.2, ccp(-6, 0))
	local act10 = CCDelayTime:create(0.8)
	local a = CCArray:create()
	a:addObject(act1)
	a:addObject(act2)
	a:addObject(act3)
	a:addObject(act4)
	a:addObject(act10)
	local sequence = CCSequence:create(a)
	_childUI["FailCtrlParent"].childUI["NextGuideImg"].handle.s:runAction(CCRepeatForever:create(sequence))
end


--角色改起名字的界面
hApi.CreateModifyInputBox = function(index)
	if IputBoxFrm then
		IputBoxFrm:del()
	end
	
	local WIDTH = 400 --宽度
	local HEIGHT = 250 --高度
	IputBoxFrm = hUI.frame:new({
		parent = nil,
		border = 1, --显示frame边框
		background = "UI:Tactic_Background",
		x = hVar.SCREEN.w / 2 - WIDTH / 2,
		y = hVar.SCREEN.h / 2 + HEIGHT / 2,
		z = 10000,
		w = WIDTH,
		h = HEIGHT,
		dragable = 4,
		autoactive = 0,
	})
	IputBoxFrm:show(1)
	IputBoxFrm:active()
	
	--[[
	--背景图
	IputBoxFrm.childUI["imgBG"] = hUI.image:new({
		parent = IputBoxFrm.handle._n,
		model = "misc/mask.png",
		x = 0,
		y = 0,
		w = 320,
		h = 140,
	})
	]]
	
	--标题
	local OFFSETX = WIDTH / 2
	local OFFSETY = -HEIGHT / 2 + 60
	
	--[[
	IputBoxFrm.childUI["TitleLbael"] = hUI.label:new({
		parent = IputBoxFrm.handle._n,
		x = OFFSETX,
		y = OFFSETY + 78,
		size = 26,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 500,
		--text = "欢迎来到策马守天关的世界", --language
		text = hVar.tab_string["welcome_cow1"], --language
	})
	]]
	
	--提示输入文字
	IputBoxFrm.childUI["NoteInputLbael"] = hUI.label:new({
		parent = IputBoxFrm.handle._n,
		x = OFFSETX,
		y = OFFSETY + 15,
		size = 26,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 500,
		--text = "修改您主公的名字", --language
		text = hVar.tab_string["welcome_cow3"], --language
	})
	
	--关闭按钮
	IputBoxFrm.childUI["closeBtn"] = hUI.button:new({
		parent = IputBoxFrm.handle._n,
		dragbox = IputBoxFrm.childUI["dragBox"],
		--model = "UI:BTN_Close", --BTN:PANEL_CLOSE
		model = "BTN:PANEL_CLOSE",
		x = WIDTH,
		y = 0,
		scaleT = 0.95,
		code = function()
			--删除本界面
			if IputBoxFrm then
				IputBoxFrm:del()
				IputBoxFrm = nil
			end
			
			--列表收回去
			--hGlobal.event:event("LocalEvent_afterShowPhone_PlayerCardFram", index)
		end,
	})
	
	--[[
	--输入框的底图
	IputBoxFrm.childUI["inputboxImg"] = hUI.image:new({
		parent = IputBoxFrm.handle._n,
		x = OFFSETX,
		y = OFFSETY - 15,
		w = 290,
		h = 36,
		model = "misc/tfback.png",
	})
	]]
	
	--输入框
	local enterNameEditBox = nil
	local rgName = "" --输入的内容
	local editNameBoxTextEventHandle = function(strEventName, pSender)
		--local edit = tolua.cast(pSender, "CCEditBox") 
		
		if (strEventName == "began") then
			--
		elseif (strEventName == "changed") then --改变事件
			--
		elseif (strEventName == "ended") then
			rgName = enterNameEditBox:getText()
		elseif (strEventName == "return") then
			--
		end
		
		--print("editNameBoxTextEventHandle", strEventName, rgName)
		--xlLG("editbox", tostring(strEventName) .. ", rgName=" .. tostring(rgName) .. "\n")
	end
	
	enterNameEditBox = CCEditBox:create(CCSizeMake(290, 36), CCScale9Sprite:create("data/image/misc/tfback.png"))--"data/image/misc/win_back.png""data/image/misc/1xs.png"
	enterNameEditBox:setPosition(ccp(OFFSETX + 0, OFFSETY - 25))
	--enterNameEditBox:setFontName("Sketch Rockwell.ttf")
	enterNameEditBox:setFontSize(24)
	enterNameEditBox:setFontColor(ccc3(255, 255, 255))
	enterNameEditBox:setPlaceHolder("")--hVar.tab_string["enter_name_7_15"]
	enterNameEditBox:setPlaceholderFontColor(ccc3(255, 122, 16))
	enterNameEditBox:setMaxLength(128)
	enterNameEditBox:registerScriptEditBoxHandler(editNameBoxTextEventHandle)
	enterNameEditBox:setTouchPriority(0)
	enterNameEditBox:setReturnType(kKeyboardReturnTypeDone)
	IputBoxFrm.handle._n:addChild(enterNameEditBox)
	
	--需要的游戏币文字前缀
	IputBoxFrm.childUI["RmbPrefix"] = hUI.label:new({
		parent = IputBoxFrm.handle._n,
		y = 28,
		size = 24,
		align = "LC",
		--border = 1,
		x = OFFSETX - 72,
		y = OFFSETY - 98,
		font = hVar.FONTC,
		width = 300,
		--text = "消耗", --language
		text = hVar.tab_string["__TEXT_CONSUME"], --language
		border = 1,
	})
	IputBoxFrm.childUI["RmbPrefix"].handle.s:setColor(ccc3(255, 236, 0))
	
	--需要的游戏币图标
	IputBoxFrm.childUI["RmbIcon"] = hUI.image:new({
		parent = IputBoxFrm.handle._n,
		model = "UI:game_coins",
		x = OFFSETX + 8,
		y = OFFSETY - 94,
		w = 36,
		h = 36,
	})
	
	--需要的游戏币值
	local requireRmb = 100
	IputBoxFrm.childUI["RmbValue"] = hUI.label:new({
		parent = IputBoxFrm.handle._n,
		size = 20,
		align = "LC",
		--border = 1,
		x = OFFSETX + 24,
		y = OFFSETY - 98,
		font = "numWhite",
		width = 300,
		text = requireRmb,
	})
	IputBoxFrm.childUI["RmbValue"].handle.s:setColor(ccc3(255, 236, 0))
	
	--确定按钮
	IputBoxFrm.childUI["okButton"] = hUI.button:new({
		parent = IputBoxFrm.handle._n,
		--model = "misc/button_back.png",
		x = OFFSETX,
		y = OFFSETY - 80 - 60,
		scale = 1.0,
		scaleT = 0.95,
		dragbox = IputBoxFrm.childUI["dragBox"],
		--label = "确定", --language
		label = hVar.tab_string["Exit_Ack"], --language
		font = hVar.FONTC,
		border = 1,
		code = function()
			--检测是否联网
			if (g_cur_net_state == -1) then --未联网
				hGlobal.UI.MsgBox(hVar.tab_string["__TEXT_Cant_UseDepletion11_Net"],{ --"修改名字需要联网"
					font = hVar.FONTC,
					ok = function()
						--
					end,
				})
				
				--删除本界面
				if IputBoxFrm then
					IputBoxFrm:del()
					IputBoxFrm = nil
				end
				
				return
			end
			
			--检测游戏币是否足够
			if (LuaGetPlayerRmb() < requireRmb) then
				--弹框
				--[[
				--local strText = "游戏币不足" --language
				local strText = hVar.tab_string["ios_not_enough_game_coin"] --language
				hGlobal.UI.MsgBox(strText, {
					font = hVar.FONTC,
					ok = function()
					end,
				})
				]]
				--弹出游戏币不足并提示是否购买的框
				hGlobal.event:event("LocalEvent_BuyItemfail", 1, 0)
				
				--删除本界面
				if IputBoxFrm then
					IputBoxFrm:del()
					IputBoxFrm = nil
				end
				
				return
			end
			
			--[[
			rgName = "ttttt888" --测试 --test
			]]
			--geyachao: windows版，接收不到输入框的ended事件，只能在点击按钮的时候，取一下输入的文本
			local TargetPlatform = CCApplication:sharedApplication():getTargetPlatform()
			if (g_tTargetPlatform.kTargetWindows == TargetPlatform) then --windows版
				rgName = enterNameEditBox:getText()
			end
			
			--验证名字是否有效
			rgName = string.lower(rgName) --转小写
			local answer, errInfo = LuaCheckPlayerName(rgName)
			
			--print(rgName, answer, errInfo)
			
			if (answer == hVar.STRING_TRIM_MODE.SUCCEED) then
				--监听修改名字成功事件
				hGlobal.event:listen("localEvent_change_name", "_change_name_", function(result, info)
					--取消挡操作
					hUI.NetDisable(0)
					
					--更名结果（1成功 0失败）
					--更名信息 (成功:prizeid 失败:失败原因 -1钱不够 -2重名 -3未知)
					if (result == 1) then
						--一些旧值
						local oldName = Save_playerList[index].name
						local currentScore = LuaGetPlayerScore()
						
						Save_playerList[index].name = rgName
						g_curPlayerName = rgName
						--Lua_UIShow_PlayerInfoFram(index)
						
						--保存存档
						LuaSavePlayerData(g_localfilepath, g_curPlayerName, Save_PlayerData, Save_PlayerLog)
						LuaSavePlayerList()
						
						--删除旧存档
						if hApi.FileExists(g_localfilepath .. oldName .. hVar.SAVE_DATA_PATH.PLAYER_DATA, "full") then
							xlDeleteFileWithFullPath(g_localfilepath .. oldName .. hVar.SAVE_DATA_PATH.PLAYER_DATA)
						end
						if hApi.FileExists(g_localfilepath .. oldName .. hVar.SAVE_DATA_PATH.PLAYER_LOG, "full") then
							xlDeleteFileWithFullPath(g_localfilepath .. oldName .. hVar.SAVE_DATA_PATH.PLAYER_LOG)
						end
						
						--删除本界面
						if IputBoxFrm then
							IputBoxFrm:del()
							IputBoxFrm = nil
						end
						
						--刷新本界面
						hGlobal.event:event("LocalEvent_PhoneShowPlayerCardFrm", g_curPlayerName)
						hGlobal.event:event("LocalEvent_afterShowPhone_PlayerCardFram", index)
						
						--keyChain_score
						--判断设备
						local TargetPlatform = CCApplication:sharedApplication():getTargetPlatform()
						--IOS
						if g_tTargetPlatform.kTargetWindows ~= TargetPlatform then
							xlSaveIntToKeyChain("xl_"..g_curPlayerName.."_playerScore", currentScore)
						--windows
						else
							CCUserDefault:sharedUserDefault():setIntegerForKey("xl_"..g_curPlayerName.."_playerScore",currentScore)
							CCUserDefault:sharedUserDefault():flush()
						end
						
						
						--local strText = "您的主公已更名为：" .. rgName --language
						local strText = hVar.tab_string["__TEXT_ModifyNameSuccess"] .. rgName --language
						hGlobal.UI.MsgBox(strText, {
							font = hVar.FONTC,
							ok = function()
							end,
						})
						
						--更名完成需要加一句，更新服务器订单状态。只有参数info>0才需要调用
						local order_id = info
						SendCmdFunc["order_update"](order_id, 2, rgName)
					else
						--(失败:失败原因 -1钱不够 -2重名 -3未知)
						local strText = nil
						if (info == -1) then
							--strText = "游戏币不足" --language
							strText = hVar.tab_string["ios_not_enough_game_coin"] --language
						elseif (info == -2) then
							--strText = "您输入的名字与已有玩家重名，请更换名字" --language
							strText = hVar.tab_string["ios_err_rename"] --language
						elseif (info == -3) then
							--strText = "未知错误" --language
							strText = hVar.tab_string["ios_err_unknow"] --language
						end
						
						hUI.floatNumber:new({
							x = hVar.SCREEN.w / 2 - 30,
							y = hVar.SCREEN.h / 2 - 40,
							align = "MC",
							text = "",
							lifetime = 1000,
							fadeout = -550,
							moveY = 32,
						}):addtext(strText, hVar.FONTC, 32, "MC", 32, 0)
					end
				end)
				
				--挡操作
				hUI.NetDisable(30000)
				
				--发起改名请求
				--print("发起改名请求", rgName)
				SendCmdFunc["change_name"](rgName)
				--hGlobal.event:event("localEvent_change_name", 1, -3)
			else
				--error
				--errInfo = "同的名"
				hUI.floatNumber:new({
					x = hVar.SCREEN.w / 2 - 30,
					y = hVar.SCREEN.h / 2 - 40,
					align = "MC",
					text = "",
					lifetime = 1000,
					fadeout = -550,
					moveY = 32,
				}):addtext(errInfo, hVar.FONTC, 40, "LC", 0, 0,nil,1)
			end
		end,
	})
end

--geyachao: 显示角色文字的冒字动画
--hApi.ShowLabelBubble = function(
--参数: strFlag:本次冒字的标识符（如果下次有相同标识符，不重复创建）
function hApi.ShowLabelBubble(oUnit, text, color, offsetX, offsetY, fontSize, showTime, modelTable, offsetZ, strFlag)
	--单位合法性判断
	if (oUnit == 0) or (oUnit == nil) then
		return
	end
	
	--全局标识符
	if (type(strFlag) == "string") then
		--不重复创建
		if oUnit.handle[strFlag] then
			return
		end
	end
	
	--单位是否活着
	--if (oUnit.data.IsDead == 1) then
	--	return
	--end
	
	--print("显示角色文字的冒字动画", oUnit.data.name, text)
	
	--显示在角色的头顶
	color = color or ccc3(255, 255, 255)
	offsetX = offsetX or 0
	offsetY = offsetY or 0
	offsetZ = offsetZ or 0
	if (g_phone_mode ~= 0) then --手机模式
		offsetY = offsetY * 1.2
	end
	fontSize = fontSize or 20 --字体大小
	showTime = showTime or 0 --单位（毫秒）
	local hero_x, hero_y = hApi.chaGetPos(oUnit.handle) --坐标
	local hero_bx, hero_by, hero_bw, hero_bh = oUnit:getbox() --包围盒
	local tx = hero_x + (hero_bx + hero_bw / 2) --中心点x位置
	local ty = hero_y + (hero_by + hero_bh) --上部y
	local display_x = tx + offsetX
	local display_y = -ty + hero_bh + 18 + offsetY
	if (oUnit.data.type == hVar.UNIT_TYPE.HERO) then
		display_y = display_y + 30
	end
	
	local fontAlign = "MC"
	local fontBorder = 1
	
	if modelTable and (modelTable.fontAlign) then
		fontAlign = modelTable.fontAlign
	end
	
	if modelTable and (modelTable.fontBorder) then
		fontBorder = modelTable.fontBorder
	end
	
	--父控件
	local ctrl = hUI.button:new({
		parent = oUnit:getworld().handle.worldLayer,
		x = display_x,
		y = display_y,
		z = 100000,
		align = "MC",
		w = 1,
		h = 1,
		model = "misc/masc.png",
	})
	ctrl.handle.s:setOpacity(0) --只用于挂载子控件，不显示
	
	--全局标识符
	if (type(strFlag) == "string") then
		oUnit.handle[strFlag] = ctrl
	end
	
	--文字
	if text and (text ~= "") then
		local fontLabel = hVar.FONTC
		local sizeLabel = fontSize
		if (tonumber(text) ~= nil) then
			fontLabel = "numWhite"
			sizeLabel = fontSize - 2
		end
		local label = hUI.label:new({
			parent = ctrl.handle._n,
			x = 0,
			y = 0,
			font = fontLabel,
			align = fontAlign,
			text = text,
			size = sizeLabel,
			border = fontBorder,
			--width = 500,
			height = math.max(fontSize, 32),
		})
		label.handle.s:setColor(color)
	end
	
	--显示图片
	if modelTable then
		local image = nil
		if (modelTable.c9sprite == true) or (modelTable.c9sprite == 1) then --九宫格模式
			image = hApi.CCScale9SpriteCreate("data/image/" .. modelTable.model, modelTable.x, modelTable.y, modelTable.w, modelTable.h, ctrl)
			if modelTable.z then
				ctrl.handle._n:reorderChild(image, modelTable.z)
			end
			if (modelTable.flipX == 1) then
				image:setFlipX(true)
			end
		else
			image = hUI.image:new({
				parent = ctrl.handle._n,
				x = modelTable.x,
				y = modelTable.y,
				z = modelTable.z,
				model = modelTable.model,
				w = modelTable.w,
				h = modelTable.h,
			})
			if (modelTable.flipX == 1) then
				image.handle.s:setFlipX(true)
			end
		end
	end
	
	--播放动画
	local array = CCArray:create()
	local scale1 = CCEaseSineOut:create(CCScaleTo:create(0.2, 1.0))
	local waitScale = CCDelayTime:create(0.1)
	--local scale2 = CCScaleTo:create(0.1, 1.0)
	array:addObject(scale1)
	array:addObject(waitScale)
	--array:addObject(scale2)
	local sequecne = CCSequence:create(array) --同步1：变大又变小
	local moveby = CCEaseSineOut:create(CCMoveBy:create(0.3, ccp(0, 25 + offsetZ))) --同步2:移动
	local spawn1 = CCSpawn:createWithTwoActions(sequecne, moveby) --同步
	--local fade = CCEaseSineIn:create(CCFadeTo:create(1.0, 0))
	--local spawn2 = CCSpawn:createWithTwoActions(spawn1, fade) --同步
	
	local array = CCArray:create()
	local wait = CCDelayTime:create(0.3 + showTime / 1000)
	
	local callback = CCCallFunc:create(function() --回调
		ctrl:del()
		---print("DDDDD")
		--全局标识符
		if (type(strFlag) == "string") then
			oUnit.handle[strFlag] = nil
		end
	end)
	
	array:addObject(spawn1) --spawn2
	array:addObject(wait)
	array:addObject(callback)
	ctrl.handle._n:runAction(CCSequence:create(array)) --action
end

--上传gamecenter分数
function hApi.xlGameCenter_reportScore(num, key)
	if xlGameCenter_reportScore and num > 0 and type(key) == "string" then
		xlGameCenter_reportScore(num, key)
	end
end

--显示通用简易tip
---@param num number 数量，会显示在icon下方
function hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content, num)
    -- dump({title, titleColor, icon, iconW, iconH, content, num})
	num = num or 0
	--print(rewardType, tacticId, tacticLv)
	
	--先清除上一次的游戏币说明面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--创建游戏币说明tip
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = hZorder.EquipTip,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除技能说明面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _GameCoinTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _GameCoinTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	--创建游戏币图片背景
	--[[
	_GameCoinTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _GameCoinTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 380,
	})
	_GameCoinTipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	--local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 250, 380, hGlobal.UI.GameCoinTipFrame)
	--img9:setOpacity(204)
	local img9 = hApi.CCScale9SpriteCreate("data/image/misc/chest/itemtip.png", _offX, _offY - 235, 288, 488, hGlobal.UI.GameCoinTipFrame)
	
	--创建游戏币图标
	_GameCoinTipChildUI["TacticIcon"] = hUI.image:new({
		parent = _GameCoinTipParent,
		model = icon,
		x = _offX - 76,
		y = _offY - 65,
		z = 1,
		w = iconW,
		h = iconH,
	})

	if num > 0 then
		_GameCoinTipChildUI["TacticNum"] = hUI.label:new({
			parent = _GameCoinTipParent,
			size = 20,
			x = _offX - 76,
			y = _offY - 105,
			align = "MC",
			font = "numWhite",
			text = "+" .. tostring(num),
			border = 1,
            z = 1
		})
	end
	
	--创建游戏币名称
	local titleLength = (#title)
	local titleOffsetX = 30
	local titleFontSize = 30
	if (titleLength >= 21) then --7个汉字
		titleOffsetX = 40
		titleFontSize = 24
	elseif (titleLength >= 18) then --6个汉字
		titleOffsetX = 40
		titleFontSize = 24
	elseif (titleLength >= 15) then --5个汉字
		titleOffsetX = 40
		titleFontSize = 28
	elseif (titleLength >= 12) then --4个汉字
		titleOffsetX = 34
		titleFontSize = 28
	elseif (titleLength <= 6) then --1~2个汉字
		titleOffsetX = 16
		titleFontSize = 30
	end
	_GameCoinTipChildUI["TacticName"] = hUI.label:new({
		parent = _GameCoinTipParent,
		size = titleFontSize,
		x = _offX + titleOffsetX,
		y = _offY - 60 - 8,
		width = 300,
		align = "MC",
		font = hVar.FONTC,
		text = title,
		border = 1,
	})
	_GameCoinTipChildUI["TacticName"].handle.s:setColor(titleColor)
	
	--游戏币描述
	_GameCoinTipChildUI["TacticIntro"] = hUI.label:new({
		parent = _GameCoinTipParent,
		size = 26,
		x = _offX - 110,
		y = _offY - 150,
		width = 230,
		align = "LT",
		font = hVar.FONTC,
		text = content,
		border = 1,
		RGB = {244, 244, 244,},
	})
	
	return hGlobal.UI.GameCoinTipFrame
end

--显示通用VIPtip
function hApi.ShowGeneralVIPTip(vipLv)
	--print(rewardType, tacticId, tacticLv)
	
	--先清除上一次的游戏币说明面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--创建游戏币说明tip
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = hZorder.EquipTip,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--[[
				--清除技能说明面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
				]]
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _GameCoinTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _GameCoinTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	if (hVar.SCREEN_MODE == hVar.SCREEN_MODE_DEFINE.HORIZONTAL) then --横屏模式
		_offY = hVar.SCREEN.h / 2 + 232
	end
	
	--创建游戏币图片背景（只响应事件，不显示）
	_GameCoinTipChildUI["ItemBG"] = hUI.button:new({
		parent = _GameCoinTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "misc/mask.png",
		dragbox = hGlobal.UI.GameCoinTipFrame.childUI["dragBox"],
		x = _offX,
		y = _offY - 220,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		code = function()
			--清除技能说明面板
			hGlobal.UI.GameCoinTipFrame:del()
			hGlobal.UI.GameCoinTipFrame = nil
		end,
	})
	_GameCoinTipChildUI["ItemBG"].handle.s:setOpacity(0) --战术卡tip背景图片透明度为204
	
	--创建游戏币图片背景（只响应事件，不显示）
	_GameCoinTipChildUI["ItemBG_1"] = hUI.button:new({
		parent = _GameCoinTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "misc/mask.png",
		dragbox = hGlobal.UI.GameCoinTipFrame.childUI["dragBox"],
		x = _offX,
		y = _offY - 235,
		w = 720,
		h = 720,
		code = function()
			--print("AAA")
		end,
	})
	_GameCoinTipChildUI["ItemBG_1"].handle.s:setOpacity(0) --战术卡tip背景图片透明度为204
	--local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 250, 380, hGlobal.UI.GameCoinTipFrame)
	--img9:setOpacity(204)
	local img9 = hApi.CCScale9SpriteCreate("data/image/misc/chest/itemtip.png", 0, 0, 720, 720, _GameCoinTipChildUI["ItemBG_1"])
	
	--[[
	--背景遮罩图
	_GameCoinTipChildUI["_blackpanel"] = hUI.image:new({
		parent = _GameCoinTipParent,
		model = "UI:zhezhao",
		x = _offX + 0,
		y = _offY - 10,
		w = hVar.SCREEN.w*2,
		h = hVar.SCREEN.h*2,
		z = -1,
	})
	_GameCoinTipChildUI["_blackpanel"].handle.s:setOpacity(160)
	]]
	
	local img9 = hApi.CCScale9SpriteCreate("data/image/misc/chariotconfig/itemgrid2.png", _offX, _offY - 234 - 70, 550, 490, hGlobal.UI.GameCoinTipFrame)
	
	local curVipLv = LuaGetPlayerVipLv()
	if curVipLv >= vipLv then
		--评论按钮
		_GameCoinTipChildUI["btn_comment"] = hUI.button:new({
			parent = _GameCoinTipParent,
			--model = "UI_frm:slot",
			--animation = "normal",
			model = "misc/addition/commentbtn.png",
			dragbox = hGlobal.UI.GameCoinTipFrame.childUI["dragBox"],
			x = _offX + 241,
			y = _offY + 56,
			code = function()
				--清除技能说明面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				hGlobal.event:event("LocalEvent_DoCommentProcess",{vipLv})
			end,
		})
	end

	--_GameCoinTipChildUI["TacticName"].handle.s:setColor(titleColor)
	--地图单位id
	local mapUnitId = hVar.Vip_Conifg.mapUnit[vipLv]
	local tabU = hVar.tab_unit[mapUnitId]
	local effect = tabU.effect
	local scale_intro = tabU.scale_intro
	local rmb = hVar.Vip_Conifg.condition.rmb[vipLv]
	local coin = hVar.Vip_Conifg.condition.coin[vipLv]
	
	--vip标题
	_GameCoinTipChildUI["TacticName"] = hUI.label:new({
		parent = _GameCoinTipParent,
		size = 36,
		x = _offX + 50,
		y = _offY + 50,
		width = 300,
		align = "MC",
		font = hVar.FONTC,
		text = hVar.tab_stringU[mapUnitId][1],
		border = 1,
		RGB = {255, 255, 0},
	})
	
	--vip条件
	_GameCoinTipChildUI["TacticIntroduce"] = hUI.label:new({
		parent = _GameCoinTipParent,
		size = 26,
		x = _offX + 60,
		y = _offY - 10,
		--width = 300,
		align = "MC",
		font = hVar.FONTC,
		text = string.format(hVar.tab_string["__TEXT_PurchaseMoneyGet"], rmb*10), --"累计充值%d元可获得"
		border = 1,
		RGB = {224, 224, 224},
	})
	
	_GameCoinTipChildUI["TacticEff"] = hUI.image:new({
		parent = _GameCoinTipParent,
		model = effect,
		x = _offX - 200,
		y = _offY + 30,
		scale = scale_intro,
	})
	
	local contentOffsetY = 0
	
	--依次绘制vip福利
	for i = 1, #hVar.VipInfo[vipLv], 1 do
		local str = hVar.VipInfo[vipLv][i]
		local strText = hVar.tab_string[str]
		--print(strText)
		
		--福利描述i
		_GameCoinTipChildUI["TacticIntro_" .. i] = hUI.label:new({
			parent = _GameCoinTipParent,
			size = 28,
			x = _offX - 200,
			y = _offY - 100 + contentOffsetY,
			--width = 230,
			align = "LC",
			font = hVar.FONTC,
			text = strText,
			border = 1,
			RGB = {244, 244, 244,},
		})
		
		local tSize = _GameCoinTipChildUI["TacticIntro_" .. i].handle.s:getContentSize()
		contentOffsetY = contentOffsetY - tSize.height - 16
		
		--福利图标
		local iconIdx = hVar.VipInfo.icon[vipLv][i]
		local icon = hVar.VipInfo.iconList[iconIdx]
		_GameCoinTipChildUI["TacticIcon_" .. i] = hUI.button:new({
			parent = _GameCoinTipParent,
			x = _offX - 230,
			y = _offY - 52 + contentOffsetY,
			model = "misc/mask.png",
			w = 46,
			h = 46,
			scaleT = 0.95,
			dragbox = hGlobal.UI.GameCoinTipFrame.childUI["dragBox"],
			code = function()
				print(i)
			end,
		})
		_GameCoinTipChildUI["TacticIcon_" .. i].handle.s:setOpacity(0) --只响应事件，不显示
		--图标
		_GameCoinTipChildUI["TacticIcon_" .. i].childUI["icon"] = hUI.image:new({
			parent = _GameCoinTipChildUI["TacticIcon_" .. i].handle._n,
			x = 0,
			y = 0,
			model = icon,
			w = 36,
			h = 36,
		})
	end
	
	return hGlobal.UI.GameCoinTipFrame
end

--显示战术技能卡的tip
--mergeTacticCardId: 合成后的战术卡id
function hApi.ShowTacticCardTip(rewardType, tacticId)
	--print(rewardType, tacticId, tacticLv, mergeTacticCardId)
	
	--先清除上一次的战术技能卡说明面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--创建战术卡说明tip
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = hZorder.EquipTip,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除技能说明面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _TacticTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _TacticTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	local tabI = hVar.tab_item[tacticId] or {} --道具表
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	--创建战术卡tip图片背景
	--[[
	_TacticTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _TacticTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 380,
	})
	_TacticTipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	local img9 = hApi.CCScale9SpriteCreate("data/image/misc/chest/itemtip.png", _offX, _offY - 235, 288, 488, hGlobal.UI.GameCoinTipFrame)
	--img9:setOpacity(204)
	
	--创建战术卡tip-技能图标
	_TacticTipChildUI["TacticIconType"] = hUI.image:new({
		parent = _TacticTipParent,
		model = tabI.icon,
		x = _offX - 80,
		y = _offY - 68,
		w = 80,
		h = 80,
	})
	
	--碎片显示碎片的图标
	_TacticTipChildUI["TacticDebrisIcon"] = hUI.image:new({
		parent = _TacticTipParent,
		model = "UI:SoulStoneFlag",
		x = _offX - 80 + 16,
		y = _offY - 68 - 16,
		w = 32,
		h = 32,
	})
	
	--创建战术卡tip-战术卡名称
	local tacticName = ""
	local tacticNameScale = 1.0
	if (rewardType == 6) then --战术卡碎片
		tacticName = hVar.tab_string["txt_tactics_card"]
	elseif (rewardType == 101) then --武器枪碎片
		tacticName = hVar.tab_string["txt_weapon"]
	elseif (rewardType == 103) then --宠物碎片
		tacticName = hVar.tab_string["txt_pet"]
	end
	--创建游戏币名称
	local titleLength = (#tacticName)
	local titleFontSize = 30
	local titleOffsetX = 26
	if (titleLength >= 21) then --7个汉字
		titleFontSize = 26
		titleOffsetX = 34
	elseif (titleLength >= 15) then --5个汉字
		titleFontSize = 28
		titleOffsetX = 30
	elseif (titleLength <= 6) then --1~2个汉字
		titleFontSize = 30
		titleOffsetX = 16
	end
	_TacticTipChildUI["TacticName"] = hUI.label:new({
		parent = _TacticTipParent,
		size = titleFontSize,
		x = _offX - 48 + titleOffsetX,
		y = _offY - 70 - 0,
		width = 300,
		align = "LC",
		font = hVar.FONTC,
		text = tacticName,
		border = 1,
	})
	
	--战术卡描述
	local tacticY = -150
	if (rewardType == 6) then --6:战术技能卡碎片
		tacticY = -190
	end
	local tacticDesc = ""
	if (rewardType == 6) then --战术卡碎片
		tacticDesc = hVar.tab_string["txt_tactics_card_introduce"]
	elseif (rewardType == 101) then --武器枪碎片
		tacticDesc = hVar.tab_string["txt_weapon_introduce"]
	elseif (rewardType == 103) then --宠物碎片
		tacticDesc = hVar.tab_string["txt_pet_introduce"]
	end
	_TacticTipChildUI["TacticIntro"] = hUI.label:new({
		parent = _TacticTipParent,
		size = 26,
		x = _offX - 110,
		y = _offY - 150,
		width = 230,
		align = "LT",
		font = hVar.FONTC,
		text = tacticDesc,
		border = 1,
		RGB = {244, 244, 244,},
	})
end

--显示PVP塔的tip
function hApi.ShowTowerCardTip_PVP(tacticId, tacticLv)
	--print(rewardType, tacticId, tacticLv)
	
	--先清除上一次的战术技能卡说明面板-PVP
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	local extraName = "" --碎片的话显示"碎片"2个字
	
	--创建战术卡说明tip-PVP
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = 100,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除技能说明面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _TacticTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _TacticTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	local tabT = hVar.tab_tactics[tacticId] or {} --战术技能卡表
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	--创建战术卡tip图片背景
	--[[
	_TacticTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _TacticTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 400,
	})
	_TacticTipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 250, 400, hGlobal.UI.GameCoinTipFrame)
	img9:setOpacity(204)
	
	--创建技能tip-图标
	_TacticTipChildUI["TacticIcon"] = hUI.image:new({
		parent = _TacticTipParent,
		model = tabT.icon,
		x = _offX - 80,
		y = _offY - 85,
		w = 64,
		h = 64,
	})
	
	--创建战术卡tip-战术卡名称
	local tacticName = hVar.tab_stringT[tacticId] and hVar.tab_stringT[tacticId][1] or ("未知战术卡" .. tacticId)
	local tacticNameScale = 1.0
	--print(#tacticName)
	if (#tacticName >= 12) then
		tacticNameScale = 0.8
	end
	_TacticTipChildUI["TacticName"] = hUI.label:new({
		parent = _TacticTipParent,
		size = 32,
		x = _offX - 43,
		y = _offY - 80 - 8,
		width = 300,
		align = "LC",
		font = hVar.FONTC,
		text = tacticName .. extraName,
		border = 1,
		scale = tacticNameScale, --缩放
	})
	
	--战术卡描述（PVP塔）
	local tacticDesc = hVar.tab_stringT[tacticId] and hVar.tab_stringT[tacticId][1 + tacticLv] or ("未知战术卡说明" .. tacticId)
	_TacticTipChildUI["TacticIntro"] = hUI.label:new({
		parent = _TacticTipParent,
		size = 26,
		x = _offX - 110,
		y = _offY - 135,
		width = 230,
		align = "LT",
		font = hVar.FONTC,
		text = tacticDesc,
		border = 1,
	})
	
	local towerUnitId = hVar.tab_tactics[tacticId].remouldUnlock[tacticLv][1] --对应的塔基的单位
	local basetowerId = hVar.tab_tactics[tacticId].remouldUnlock.baseTowerId --对应的塔基单位
	--print("basetowerId", basetowerId)
	local tUnitTab = hVar.tab_unit[towerUnitId] or {}
	local attr = tUnitTab.attr or {}
	local atkMin = attr.attack and attr.attack[4] or "?" --最小攻击力
	local atkMax = attr.attack and attr.attack[5] or "?" --最大攻击力
	local atkRange = attr.atk_radius or "?" --攻击范围
	local hp = attr.hp or "?" --血量
	local moveSpeed = attr.move_speed or "?" --移动速度
	local atkSpeed = (attr.atk_interval or 0) / 1000 --攻击速度
	local pDef = attr.def_physic --物理防御
	local mDef = attr.def_magic --法术防御
	local upgradeSkill = tUnitTab.td_upgrade and tUnitTab.td_upgrade.upgradeSkill or {} --技能升级列表
	
	local BOARD_WIDTH = _offX
	local BOARD_HEIGHT = _offY
	local DETAIL_OFFSET_X = -95
	local DETAIL_OFFSET_Y = -250
	local offsetX = BOARD_WIDTH  + DETAIL_OFFSET_X
	local offsetY = BOARD_HEIGHT + DETAIL_OFFSET_Y
	
	--攻击力图标
	local towerAtkIcon = nil --塔的攻击力图标
	
	if tUnitTab.tag and (tUnitTab.tag[hVar.UNIT_TAG_TYPE.TOWER.TAG_JIANTA]) then --箭塔系
		towerAtkIcon = "ui/battle_attack02.png"
	elseif tUnitTab.tag and (tUnitTab.tag[hVar.UNIT_TAG_TYPE.TOWER.TAG_FASHUTA]) then --法术塔系
		towerAtkIcon = "ui/battle_attack03.png"
	elseif tUnitTab.tag and (tUnitTab.tag[hVar.UNIT_TAG_TYPE.TOWER.TAG_PAOTA]) then --炮塔系
		towerAtkIcon = "ui/battle_move.png"
	else
		towerAtkIcon = "ICON:action_attack"
	end
	_TacticTipChildUI["towerAttrAtkIcon"] = hUI.image:new({
		parent = _TacticTipParent,
		model = towerAtkIcon,
		x = offsetX - 3,
		y = offsetY - 20,
		w = 26,
		h = 26,
		align = "MC",
	})
	
	--攻击力文字
	local atkValTotal = atkMin .. "-" .. atkMax
	local atkSize = 22
	if (#atkValTotal > 6) then --如果攻击力文字太长，缩小文字大小
		atkSize = 16
	elseif (#atkValTotal > 5) then --如果攻击力文字太长，缩小文字大小
		atkSize = 18
	end
	_TacticTipChildUI["towerAttrAtkValue"] = hUI.label:new({
		parent = _TacticTipParent,
		size = atkSize,
		align = "LC",
		--border = 1,
		x = offsetX + 20 - 3,
		y = offsetY - 20 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 210,
		text = atkValTotal,
	})
	
	--射程图标
	_TacticTipChildUI["towerAttrAtkRange"] = hUI.image:new({
		parent = _TacticTipParent,
		model = "ICON:MOVERANGE", --"UI:Attr_AtkRange",
		x = offsetX + 120 + 5,
		y = offsetY - 20,
		w = 26,
		h = 26,
		align = "MC",
	})
	
	--射程文字
	_TacticTipChildUI["towerAttrAtkRangeValue"] = hUI.label:new({
		parent = _TacticTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 20 + 120 + 5,
		y = offsetY - 20 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 210,
		text = atkRange,
	})
	
	--攻击速度图标
	_TacticTipChildUI["towerAttrAtkSpeed"] = hUI.image:new({
		parent = _TacticTipParent,
		model = "ICON:MOVESPEED", --"UI:Attr_CD",
		x = offsetX - 3,
		y = offsetY - 50,
		w = 26,
		h = 26,
		align = "MC",
	})
	
	--攻击速度文字
	_TacticTipChildUI["towerAttrAtkSpeedValue"] = hUI.label:new({
		parent = _TacticTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 20 - 3,
		y = offsetY - 50 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 210,
		--text = ("%d.%d"):format(math.floor(atkSpeed), math.floor((atkSpeed - math.floor(atkSpeed)) * 100)) --保留2位有效数字
		text = string.format("%.2f", atkSpeed), --保留2位有效数字
	})
	
	--[[
	--攻击速度符号文字
	_TacticTipChildUI["towerAttrAtkSpeedSign"] = hUI.label:new({
		parent = _TacticTipParent,
		size = 26,
		align = "LC",
		border = 1,
		x = offsetX + 40 + 38 - 3,
		y = offsetY - 50,
		font = hVar.DEFAULT_FONT,
		width = 210,
		text = "s",
	})
	--_TacticTipChildUI["towerAttrAtkSpeedSign"].handle.s:setColor(ccc3(255, 255, 0))
	]]
	
	--需要的金币图标
	_TacticTipChildUI["towerAttrGold"] = hUI.image:new({
		parent = _TacticTipParent,
		model = "UI:ICON_ResourceGold",
		x = offsetX + 120 + 5,
		y = offsetY - 50,
		w = 32,
		h = 32,
		align = "MC",
	})
	
	--计算需要消耗的金币
	local remouldCost = 0
	if (type(basetowerId) == "table") then
		basetowerId = basetowerId[2] --pvp填第2项
	end
	
	local td_upgrade = hVar.tab_unit[basetowerId].td_upgrade --zhenkira 2015.9.25 修改为角色身上的属性,并且使用kv形式存储表结构
	if td_upgrade and type(td_upgrade) == "table" then
		local remould = td_upgrade.remould
		if remould then
			local buildInfo = remould[towerUnitId]
			remouldCost = (buildInfo and buildInfo.cost or 0) + (buildInfo and buildInfo.costAdd or 0)
		end
	end
	
	--需要的金币文字
	_TacticTipChildUI["towerAttrGoldValue"] = hUI.label:new({
		parent = _TacticTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 20 + 120 + 5,
		y = offsetY - 50 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 210,
		text = remouldCost,
	})
	
	--塔的技能图标
	if upgradeSkill then
		local skillList = {} --实际的技能排序列表
		
		if upgradeSkill.order and type(upgradeSkill.order) == "table" then
			for i = 1, # upgradeSkill.order do
				local skillId =  upgradeSkill.order[i]
				
				if upgradeSkill[skillId] then
					table.insert(skillList, skillId) --添加塔的技能（有序）
				end
			end
		else
			for skillId, v in pairs(upgradeSkill) do
				if (skillId ~= "order") then
					table.insert(skillList, skillId) --添加塔的技能（乱序）
				end
			end
		end
		
		--依次绘制塔的技能图标
		for i = 1, #skillList, 1 do
			local skillId = skillList[i]
			local v = upgradeSkill[skillId]
			
			--技能图标
			_TacticTipChildUI["towerAttrSkill" .. i] = hUI.image:new({
				parent = _TacticTipParent,
				model = v.icon,
				x = offsetX - 45 + (48 + 6),
				y = offsetY - 40 - i * (48 + 4),
				w = 48,
				h = 48,
				align = "MC",
			})
			
			--技能名称
			local skillName = hVar.tab_stringS[skillId] and hVar.tab_stringS[skillId][1] or ("未知技能" .. skillId)
			_TacticTipChildUI["towerAttrSkillName" .. i] = hUI.label:new({
				parent = _TacticTipParent,
				size = 26,
				align = "LT",
				border = 1,
				x = offsetX - 43 + (48 + 6) + 28,
				y = offsetY - 46 - i * (48 + 2) + 28,
				font = hVar.FONTC,
				width = 210,
				text = skillName,
			})
			--_TacticTipChildUI["towerAttrSkillName" .. i].handle.s:setColor(ccc3(255, 255, 0))
			
			--技能描述
			v.maxLv = 1 --pvp技能只升级1次
			--local skillIntro = hVar.tab_stringS[skillId] and hVar.tab_stringS[skillId][2] or ("未知技能说明" .. skillId)
			--local skillIntro = "最高可升级" .. (v.maxLv or 1) .. "次" --language
			local skillIntro = hVar.tab_string["CanLvUpMax"] .. (v.maxLv or 1) .. hVar.tab_string["__TEXT_YouCanForgedCount1"] --language
			
			if (v.maxLv == 0) then
				--skillIntro = "未解锁升级该技能" --language
				skillIntro = hVar.tab_string["CanNotLvUp"] --language
			end
			_TacticTipChildUI["towerAttrSkillIntro" .. i] = hUI.label:new({
				parent = _TacticTipParent,
				size = 22,
				align = "LT",
				border = 1,
				x = offsetX - 43 + (48 + 6) + 28,
				y = offsetY - 54 - i * (48 + 2) + 10,
				font = hVar.FONTC,
				width = 170,
				text = skillIntro,
			})
			_TacticTipChildUI["towerAttrSkillIntro" .. i].handle.s:setColor(ccc3(0, 255, 0))
			if (v.maxLv == 0) then
				_TacticTipChildUI["towerAttrSkillIntro" .. i].handle.s:setColor(ccc3(255, 0, 0))
			end
		end
	end
end

--显示PVP兵种的tip
function hApi.ShowTacticCardTip_PVP(tacticId, tacticLv)
	--print(rewardType, tacticId, tacticLv)
	
	--先清除上一次的战术技能卡说明面板-PVP
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	local extraName = "" --碎片的话显示"碎片"2个字
	
	--创建战术卡说明tip-PVP
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = hZorder.EquipTip,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除技能说明面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _TacticTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _TacticTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	local tabT = hVar.tab_tactics[tacticId] or {} --战术技能卡表
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	--创建战术卡tip图片背景
	--[[
	_TacticTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _TacticTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 320,
	})
	_TacticTipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 250, 320, hGlobal.UI.GameCoinTipFrame)
	img9:setOpacity(204)
	
	--创建技能tip-技能背景图
	local qLv = math.min((tabT.quality or 1), 4) --图片最多只有4张
	_TacticTipChildUI["TacticIconBG"] = hUI.image:new({
		parent = _TacticTipParent,
		model = "UI:tactic_card_" .. qLv,
		x = _offX - 80,
		y = _offY - 132,
		w = 68,
		h = 85,
	})
	
	--创建战术卡tip-战术技能卡类型图标
	_TacticTipChildUI["TacticIcon"] = hUI.image:new({
		parent = _TacticTipParent,
		model = hApi.GetTacticsCardTypeIcon(tacticId, "model"),
		x = _offX - 81,
		y = _offY - 99,
		w = 20,
		h = 20,
	})
	
	--创建战术卡tip-技能图标
	_TacticTipChildUI["TacticIconType"] = hUI.image:new({
		parent = _TacticTipParent,
		model = tabT.icon,
		x = _offX - 80,
		y = _offY - 141,
		w = 50,
		h = 50,
	})
	
	--创建战术卡tip-战术卡名称
	local tacticName = hVar.tab_stringT[tacticId] and hVar.tab_stringT[tacticId][1] or ("未知战术卡" .. tacticId)
	local tacticNameScale = 1.0
	--print(#tacticName)
	if (#tacticName >= 12) then
		tacticNameScale = 0.8
	end
	_TacticTipChildUI["TacticName"] = hUI.label:new({
		parent = _TacticTipParent,
		size = 32,
		x = _offX - 38,
		y = _offY - 135,
		width = 300,
		align = "LC",
		font = hVar.FONTC,
		text = tacticName .. extraName,
		border = 1,
		scale = tacticNameScale, --缩放
	})
	
	--战术卡描述（PVP兵种）
	local tacticDesc = hVar.tab_stringT[tacticId] and hVar.tab_stringT[tacticId][1 + tacticLv] or ("未知战术卡说明" .. tacticId)
	_TacticTipChildUI["TacticIntro"] = hUI.label:new({
		parent = _TacticTipParent,
		size = 26,
		x = _offX - 110,
		y = _offY - 190,
		width = 230,
		align = "LT",
		font = hVar.FONTC,
		text = tacticDesc,
		border = 1,
	})
	
	local offsetX = _offX - 90
	local offsetY = _offY - 410
	
	--消耗的金币图标
	_TacticTipChildUI["tacticAttrGold"] = hUI.image:new({
		parent = _TacticTipParent,
		model = "UI:ICON_ResourceGold",
		x = offsetX,
		y = offsetY + 47 - 2,
		w = 32,
		h = 32,
	})
	
	--消耗的金币文字
	local tacticSkillId = hVar.tab_tactics[tacticId].castSkillUnlock.unlockSkillId[1]
	local targetId = hVar.tab_tactics[tacticId].castSkillUnlock.targetId[1]
	local goldCost = hVar.tab_unit[targetId].td_upgrade.castSkill[tacticSkillId].cost
	_TacticTipChildUI["tacticAttrGoldValue"] = hUI.label:new({
		parent = _TacticTipParent,
		size = 20,
		align = "LC",
		--border = 1,
		x = offsetX + 24,
		y = offsetY + 47 - 4, --num字体有4像素偏差
		font = "numWhite",
		width = 210,
		text = goldCost,
	})
	
	--兵符图标
	_TacticTipChildUI["tacticAttrPvpCoin"] = hUI.image:new({
		parent = _TacticTipParent,
		model = "UI:uitoken",
		x = offsetX + 130,
		y = offsetY + 47 - 2,
		scale = 0.85,
	})
	
	--兵符消耗值
	_TacticTipChildUI["tacticAttrPvpCoinValue"] = hUI.label:new({
		parent = _TacticTipParent,
		size = 20,
		align = "LC",
		--border = 1,
		x = offsetX + 130 + 20,
		y = offsetY + 47 - 4, --num字体有4像素偏差
		font = "numWhite",
		width = 210,
		text = "1",
	})
end

--显示任务之石的tip
function hApi.ShowTaskStonTip()
	local title = hVar.tab_string["__TEXT_PAGE_TASKSTONE"] --"任务之石"
	local titleColor = ccc3(255, 196, 0)
	local icon = "misc/task/task_stone.png"
	local iconW = 72
	local iconH = 72
	local content = hVar.tab_string["ios_taskstone_intro"]
	
	return hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
end

--显示游戏币介绍的tip
function hApi.ShowGameCoinTip()
	local title = hVar.tab_string["__TEXT_PAGE_PURCHASE"] --"氪石"
	local titleColor = ccc3(255, 196, 0)
	local icon = "misc/skillup/keshi.png"
	local iconW = 72
	local iconH = 72
	local content = hVar.tab_string["ios_gamecoin_intro"]
	
	return hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
end

--显示积分介绍的tip
function hApi.ShowJiFennTip()
	--print(rewardType, tacticId, tacticLv)
	
	--先清除上一次的积分说明面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--创建游戏币说明tip
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = 100009,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除技能说明面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _JiFenTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _jiFenTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	--创建游戏币图片背景
	--[[
	_jiFenTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _JiFenTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 380,
	})
	_jiFenTipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 250, 380, hGlobal.UI.GameCoinTipFrame)
	img9:setOpacity(204)
	
	--创建积分图标
	_jiFenTipChildUI["TacticIcon"] = hUI.image:new({
		parent = _JiFenTipParent,
		model = "misc/skillup/mu_coin_world.png",
		x = _offX - 80,
		y = _offY - 95,
		w = 58,
		h = 58,
	})
	
	--创建积分名称
	_jiFenTipChildUI["TacticName"] = hUI.label:new({
		parent = _JiFenTipParent,
		size = 32,
		x = _offX - 33,
		y = _offY - 90 - 8,
		width = 300,
		align = "LC",
		font = hVar.FONTC,
		--text = "积分", --language
		text = hVar.tab_string["ios_score"], --language
		border = 1,
		scale = tacticNameScale, --缩放
	})
	_jiFenTipChildUI["TacticName"].handle.s:setColor(ccc3(255, 196, 0))
	
	--游戏币描述
	_jiFenTipChildUI["TacticIntro"] = hUI.label:new({
		parent = _JiFenTipParent,
		size = 26,
		x = _offX - 110 + 4,
		y = _offY - 150,
		width = 230,
		align = "LT",
		font = hVar.FONTC,
		text = hVar.tab_string["ios_jifen_intro"],
		border = 1,
	})
end

--显示成就点介绍的tip
function hApi.ShowAPTip()
	--print(rewardType, tacticId, tacticLv)
	
	--先清除上一次的成就点说明面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--创建成就点说明tip
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = 100,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除成就点说明面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _APTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _ApTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	--创建成就点图片背景
	--[[
	_ApTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _APTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 380,
	})
	_ApTipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 250, 380, hGlobal.UI.GameCoinTipFrame)
	img9:setOpacity(204)
	
	--创建成就点图标
	_ApTipChildUI["TacticIcon"] = hUI.image:new({
		parent = _APTipParent,
		model = "UI:ach_king",
		x = _offX - 80,
		y = _offY - 95,
		w = 52,
		h = 52,
	})
	
	--创建成就点名称
	_ApTipChildUI["TacticName"] = hUI.label:new({
		parent = _APTipParent,
		size = 32,
		x = _offX - 33,
		y = _offY - 90 - 8,
		width = 300,
		align = "LC",
		font = hVar.FONTC,
		--text = "成就点", --language
		text = hVar.tab_string["APPont"], --language
		border = 1,
		scale = tacticNameScale, --缩放
	})
	_ApTipChildUI["TacticName"].handle.s:setColor(ccc3(255, 196, 0))
	
	--成就点描述
	_ApTipChildUI["TacticIntro"] = hUI.label:new({
		parent = _APTipParent,
		size = 26,
		x = _offX - 110 + 4,
		y = _offY - 150,
		width = 230,
		align = "LT",
		font = hVar.FONTC,
		text = hVar.tab_string["ios_AP_intro"],
		border = 1,
	})
end

--显示神器晶石介绍的tip
function hApi.ShowRedEquipDeribsTip()
	local title = hVar.tab_string["__SHENQI_CRTSTAL"] --"神器晶石"
	local titleColor = ccc3(255, 255, 0)
	local icon = "ICON:CHIP_BROKEN"
	local iconW = 76
	local iconH = 76
	local content = hVar.tab_string["__SHENQI_CRTSTAL_INTRODUCE"]
	
	return hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
end

--显示兵符介绍的tip（简版）
function hApi.ShowPvpCoinTip_Short()
	local title = hVar.tab_string["__TEXT_TILI"] --"体力"
	local titleColor = ccc3(255, 255, 0)
	local icon = "misc/task/tili.png" --兵符模型
	local iconW = 76
	local iconH = 76
	local content = hVar.tab_string["__TEXT_TILI_INTRODUCE"]
	
	return hApi.ShowGeneralMiniTip(title, titleColor, icon, iconW, iconH, content)
end

--显示英雄经验值介绍的tip
function hApi.ShowHeroExpTip()
	--print(rewardType, tacticId, tacticLv)
	
	--先清除上一次的英雄经验值说明面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--创建英雄经验值说明tip
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = 100,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除技能说明面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _HETipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _HETipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	--创建成就点图片背景
	--[[
	_HETipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _HETipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 380,
	})
	_HETipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 250, 380, hGlobal.UI.GameCoinTipFrame)
	img9:setOpacity(204)
	
	--创建英雄经验值图标
	_HETipChildUI["TacticIcon"] = hUI.image:new({
		parent = _HETipParent,
		model = "ICON:HeroAttr",
		x = _offX - 80,
		y = _offY - 95,
		w = 64,
		h = 64,
	})
	
	--创建英雄经验值名称
	_HETipChildUI["TacticName"] = hUI.label:new({
		parent = _HETipParent,
		size = 32,
		x = _offX - 33,
		y = _offY - 90 - 8,
		width = 300,
		align = "LC",
		font = hVar.FONTC,
		--text = "经验", --language
		text = hVar.tab_string["__Attr_Hint_Exp"], --language
		border = 1,
		scale = tacticNameScale, --缩放
	})
	_HETipChildUI["TacticName"].handle.s:setColor(ccc3(255, 196, 0))
	
	--英雄经验值描述
	_HETipChildUI["TacticIntro"] = hUI.label:new({
		parent = _HETipParent,
		size = 26,
		x = _offX - 110 + 4,
		y = _offY - 150,
		width = 230,
		align = "LT",
		font = hVar.FONTC,
		text = hVar.tab_string["ios_AP_heroexp"],
		border = 1,
	})
end

--显示怪物生命点介绍的tip
function hApi.ShowEnemyLifePointTip()
	--print(rewardType, tacticId, tacticLv)
	
	--先清除上一次的怪物生命点说明面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--创建怪物生命点说明tip
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = 100,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除怪物生命点说明面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _ELPTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _ELPTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	--创建怪物生命点图片背景
	--[[
	_ELPTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _ELPTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 380,
	})
	_ELPTipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 250, 380, hGlobal.UI.GameCoinTipFrame)
	img9:setOpacity(204)
	
	--创建怪物生命点图标
	_ELPTipChildUI["TacticIcon"] = hUI.image:new({
		parent = _ELPTipParent,
		model = "ui/Attr_Hp.png",
		x = _offX - 80,
		y = _offY - 95,
		w = 64,
		h = 64,
	})
	
	--创建怪物生命点名称
	_ELPTipChildUI["TacticName"] = hUI.label:new({
		parent = _ELPTipParent,
		size = 32 - 2, --文字太长
		x = _offX - 33,
		y = _offY - 90 - 8,
		width = 300,
		align = "LC",
		font = hVar.FONTC,
		--text = "怪物生命点", --language
		text = hVar.tab_string["__ATTR__EscapePunish"], --language
		border = 1,
		scale = tacticNameScale, --缩放
	})
	_ELPTipChildUI["TacticName"].handle.s:setColor(ccc3(255, 196, 0))
	
	--创建怪物生命点描述
	_ELPTipChildUI["TacticIntro"] = hUI.label:new({
		parent = _ELPTipParent,
		size = 26,
		x = _offX - 110 + 4,
		y = _offY - 150,
		width = 230,
		align = "LT",
		font = hVar.FONTC,
		text = hVar.tab_string["ios_AP_enemy_lifepoint"],
		border = 1,
	})
end

--显示怪物击杀得钱介绍的tip
function hApi.ShowEnemyKillGoldTip()
	--print(rewardType, tacticId, tacticLv)
	
	--先清除上一次的怪物击杀得钱说明面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--创建怪物击杀得钱说明tip
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = 100,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除怪物生命点说明面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _EKGTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _EKGTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	--创建怪物击杀得钱图片背景
	--[[
	_EKGTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _EKGTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 380,
	})
	_EKGTipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 250, 380, hGlobal.UI.GameCoinTipFrame)
	img9:setOpacity(204)
	
	--创建怪物击杀得钱图标
	_EKGTipChildUI["TacticIcon"] = hUI.image:new({
		parent = _EKGTipParent,
		model = "ui/res_money.png",
		x = _offX - 80,
		y = _offY - 95,
		w = 64,
		h = 64,
	})
	
	--创建怪物击杀得钱名称
	_EKGTipChildUI["TacticName"] = hUI.label:new({
		parent = _EKGTipParent,
		size = 32,
		x = _offX - 33,
		y = _offY - 90 - 8,
		width = 300,
		align = "LC",
		font = hVar.FONTC,
		--text = "怪物金币", --language
		text = hVar.tab_string["__ATTR__KillGold"], --language
		border = 1,
		scale = tacticNameScale, --缩放
	})
	_EKGTipChildUI["TacticName"].handle.s:setColor(ccc3(255, 196, 0))
	
	--创建怪物击杀得钱描述
	_EKGTipChildUI["TacticIntro"] = hUI.label:new({
		parent = _EKGTipParent,
		size = 26,
		x = _offX - 110 + 4,
		y = _offY - 150,
		width = 230,
		align = "LT",
		font = hVar.FONTC,
		text = hVar.tab_string["ios_AP_enemy_killgold"],
		border = 1,
	})
end

--查看技能说明tip
--单位: 毫秒
function hApi.ShowSkillTip(skillId, skillCD)
	local _frm = hGlobal.UI.Phone_MyHeroCardFrm_New
	local _frmNode = _frm.childUI["PageNode"]
	local _parentNode = _frmNode.handle._n
	
	--先清除上一次的技能说明面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--_frmNode.childUI["EnemySkill" .. skillIdx].childUI["selectbox"].handle.s:setVisible(true) --显示
	
	--创建技能说明面板
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = 100,
		show = 1,
		--dragable = 2,
		dragable = 3, --点击后消失
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--清除技能说明面板
				--hGlobal.UI.GameCoinTipFrame:del()
				--hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
				--隐藏技能选中框
				--_frmNode.childUI["EnemySkill" .. skillIdx].childUI["selectbox"].handle.s:setVisible(false) --隐藏
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _SkillParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _SkillChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	--创建技能tip图片背景
	--[[
	_SkillChildUI["ItemBG_1"] = hUI.image:new({
		parent = _SkillParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 320,
		h = 320,
	})
	_SkillChildUI["ItemBG_1"].handle.s:setOpacity(232) --技能背景图片透明度为232
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 320, 320, hGlobal.UI.GameCoinTipFrame)
	img9:setOpacity(204)
	
	--创建技能tip-技能图标
	--print(hVar.tab_skill[skillId].icon)
	_SkillChildUI["SkillIcon"] = hUI.image:new({
		parent = _SkillParent,
		model = hVar.tab_skill[skillId].icon,
		x = _offX - 110 + 4,
		y = _offY - 125,
		w = 64,
		h = 64,
	})
	
	--创建技能tip-技能名称
	_SkillChildUI["SkillName"] = hUI.label:new({
		parent = _SkillParent,
		size = 32,
		x = _offX - 60,
		y = _offY - 125 - 3,
		width = 300,
		align = "LC",
		font = hVar.FONTC,
		text = hVar.tab_stringS[skillId] and hVar.tab_stringS[skillId][1] or ("未知技能" .. skillId),
		border = 1,
	})
	_SkillChildUI["SkillName"].handle.s:setColor(ccc3(255, 255, 0))
	
	if (skillCD ~= nil) then
		--创建技能tip-技能冷却时间图标
		_SkillChildUI["SkillCDIcon"] = hUI.image:new({
			parent = _SkillParent,
			model = "ui/bimage_replay.png",
			x = _offX - 124,
			y = _offY - 185,
			w = 32,
			h = 32,
		})
		--技能冷却的时间
		_SkillChildUI["skillCDLabel"] = hUI.label:new({
			parent = _SkillParent,
			size = 20,
			align = "RT",
			font = "numWhite",
			--border = 1,
			x = _offX - 64,
			y = _offY - 174,
			width = 300,
			text = (skillCD / 1000),
		})
		_SkillChildUI["skillCDLabel"].handle.s:setColor(ccc3(168, 168, 168))
		
		--技能冷却"秒"
		_SkillChildUI["skillCDSecond"] = hUI.label:new({
			parent = _SkillParent,
			size = 26,
			align = "LT",
			font = hVar.FONTC,
			border = 1,
			x = _offX - 64,
			y = _offY - 174 - 1,
			width = 320,
			--text = "秒", --language
			text = hVar.tab_string["__Second"], --language
		})
		_SkillChildUI["skillCDSecond"].handle.s:setColor(ccc3(168, 168, 168))
	end
	
	local introDy = -218
	if (skillCD == nil) then
		introDy = -178
	end
	--技能说明
	_SkillChildUI["SkillIntro"] = hUI.label:new({
		parent = _SkillParent,
		size = 26,
		x = _offX - 144,
		y = _offY + introDy,
		width = 295,
		align = "LT",
		font = hVar.FONTC,
		text = hVar.tab_stringS[skillId] and hVar.tab_stringS[skillId][2] or ("未知技能说明" .. skillId),
		border = 1,
	})
end

--显示英雄属性的tip(简版)
function hApi.ShowHeroInfoTip_Short(typeId, lv, star, equipment, strPlayerName, bHideLv)
	--print(rewardType, tacticId, tacticLv)
	
	--先清除上一次的英雄属性说明面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--创建英雄属性说明tip
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = 100,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除英雄属性面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _HeroTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _HeroTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	local tabU = hVar.tab_unit[typeId] or {}
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 230
	
	--创建英雄属性图片背景
	--[[
	_HeroTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _HeroTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 380,
	})
	_HeroTipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 460, 370, hGlobal.UI.GameCoinTipFrame)
	img9:setOpacity(204)
	
	--创建英雄图标背景图
	_HeroTipChildUI["HeroIconBG"] = hUI.image:new({
		parent = _HeroTipParent,
		model = "UI:NewKuang",
		x = _offX - 160,
		y = _offY - 120,
		w = 78 + 10,
		h = 78 + 10,
	})
	
	--创建英雄图标
	_HeroTipChildUI["HeroIcon"] = hUI.image:new({
		parent = _HeroTipParent,
		model = tabU.icon,
		x = _offX - 160,
		y = _offY - 120,
		w = 78,
		h = 78,
	})
	
	--创建英雄名
	_HeroTipChildUI["HeroName"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 38,
		x = _offX - 160 + 130,
		y = _offY - 120 - 5,
		width = 300,
		align = "MC",
		font = hVar.FONTC,
		text = hVar.tab_stringU[typeId] and hVar.tab_stringU[typeId][1] or ("未知英雄" .. typeId),
		border = 1,
		scale = tacticNameScale, --缩放
	})
	_HeroTipChildUI["HeroName"].handle.s:setColor(ccc3(255, 196, 0))
	
	--创建玩家名
	if strPlayerName and (type(strPlayerName) == "string") then
		--创建英雄名
		_HeroTipChildUI["HeroPlayerName"] = hUI.label:new({
			parent = _HeroTipParent,
			size = 26,
			x = _offX - 160 + 290,
			y = _offY - 120 - 5 - 1,
			width = 300,
			align = "MC",
			font = hVar.FONTC,
			text = "( " .. strPlayerName .. " )",
			border = 1,
		})
		_HeroTipChildUI["HeroPlayerName"].handle.s:setColor(ccc3(128, 255, 128))
	end
	
	--创建英雄等级背景图(大图)
	_HeroTipChildUI["HeroLvBG"] = hUI.image:new({
		parent = _HeroTipParent,
		model = "ui/pvp/pvpselect.png",
		x = _offX - 160 + 40,
		y = _offY - 120 + 40,
		w = 40,
		h = 40,
	})
	if bHideLv then --隐藏等级
		_HeroTipChildUI["HeroLvBG"].handle._n:setVisible(false)
	end
	
	--创建英雄等级(大图)
	local fontSize = 26
	if lv and (lv >= 10) then --如果等级是2位数的，那么缩一下文字
		fontSize = 18
	end
	_HeroTipChildUI["HeroLv"] = hUI.label:new({
		parent = _HeroTipParent,
		x = _offX - 160 + 40,
		y = _offY - 120 + 40 - 1,
		text = lv,
		size = fontSize,
		font = "numWhite",
		align = "MC",
		width = 200,
	})
	if bHideLv then --隐藏等级
		_HeroTipChildUI["HeroLv"].handle._n:setVisible(false)
	end
	
	--英雄的星级
	for i = 1, star, 1 do
		_HeroTipChildUI["HeroStar" .. i] = hUI.image:new({
			parent = _HeroTipParent,
			model = "UI:STAR_YELLOW",
			x = _offX - 160 + 26 - (i - 1) * (26),
			y = _offY - 120 - 26,
			w = 26,
			h = 26,
		})
		if bHideLv then --隐藏等级
			_HeroTipChildUI["HeroStar" .. i].handle._n:setVisible(false)
		end
	end
	
	--依次绘制装备
	if equipment and (type(equipment) == "table") then
		--第3,4项可能颠倒了
		if (type(equipment[3]) == "table") and equipment[3][1] and hVar.tab_item[equipment[3][1]] and (hVar.tab_item[equipment[3][1]].type == hVar.ITEM_TYPE.MOUNT) then
			equipment = {equipment[1], equipment[2], equipment[4], equipment[3],}
		end
		if (type(equipment[4]) == "table") and equipment[4][1] and hVar.tab_item[equipment[4][1]] and (hVar.tab_item[equipment[4][1]].type == hVar.ITEM_TYPE.ORNAMENTS) then
			equipment = {equipment[1], equipment[2], equipment[4], equipment[3],}
		end
		
		for k = 1, #equipment, 1 do
			--装备表
			local itemId = 0 --道具id
			local item = equipment[k]
			
			if (type(item) == "table") then
				itemId = item[1] --道具id
			end
			
			--存在道具
			if hVar.tab_item[itemId] then
				--绘制道具背景图
				local itemLv = hVar.tab_item[itemId].itemLv or 1
				local itemtModel = hVar.ITEMLEVEL[itemLv].BORDERMODEL
				_HeroTipChildUI["HeroEquipBG" .. k] = hUI.image:new({
					parent = _HeroTipParent,
					model = itemtModel, --"UI:SkillSlot",
					x = _offX - 160 - 33 + (k - 1) * (22 + 0),
					y = _offY - 120 - 55,
					w = 22,
					h = 22,
				})
				
				--绘制道具图标
				_HeroTipChildUI["HeroEquip" .. k] = hUI.image:new({
					parent = _HeroTipParent,
					model = hVar.tab_item[itemId].icon,
					x = _offX - 160 - 33 + (k - 1) * (22 + 0),
					y = _offY - 120 - 55,
					w = 22 - 2,
					h = 22 - 2,
				})
			else
				--不存在道具，画个空板子
				_HeroTipChildUI["HeroEquipBG" .. k] = hUI.image:new({
					parent = _HeroTipParent,
					model = "misc/photo_frame.png",
					x = _offX - 160 - 33 + (k - 1) * (22 + 0),
					y = _offY - 120 - 55,
					w = 22,
					h = 22,
				})
			end
		end
	end
	
	local attr = hApi.GetUnitAttrs(typeId, lv, star, equipment) --计算出角色的最终属性
	local atkMin = math.floor(attr.atk_min) --最小攻击力
	local atkMax = math.floor(attr.atk_max) --最大攻击力
	local atkRange = attr.atk_radius --攻击范围
	local hp_max = attr.hp_max --血量
	local moveSpeed = attr.move_speed --移动速度
	local atkSpeed = attr.atk_interval / 1000 --攻击速度
	local pDef = math.floor(attr.def_physic) --物理防御
	local mDef = math.floor(attr.def_magic) --法术防御
	local critRate = attr.crit_rate --暴击几率
	local critValue = attr.crit_value --暴击倍数
	local atk_skill_id = hVar.tab_unit[typeId] and hVar.tab_unit[typeId].attr and hVar.tab_unit[typeId].attr.attack and hVar.tab_unit[typeId].attr.attack[1]
	
	local offsetX = _offX - 185
	local offsetY = _offY - 205
	if equipment and (type(equipment) == "table") then --有装备多空行
		offsetY = _offY - 225
	end
	
	--血量图标
	_HeroTipChildUI["heroAttrHp"] = hUI.image:new({
		parent = _HeroTipParent,
		model = "ui/hp_pec.png", --"UI:Attr_Hp",
		x = offsetX,
		y = offsetY - 48 * 0,
		w = 32,
		h = 32,
		align = "MC",
	})
	
	--血量文字
	local hpSize = 22
	if (hp_max > 5) then --如果血量太大，缩小文字大小
		hpSize = 22
	end
	_HeroTipChildUI["heroAttrHpValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = hpSize,
		align = "LC",
		--border = 1,
		x = offsetX + 25,
		y = offsetY - 48 * 0 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 210,
		text = hp_max,
	})
	
	--攻击力图标
	if (atkRange <= 150) then
		--近战攻击力图标
		_HeroTipChildUI["heroAttrAtkIcon"] = hUI.image:new({
			parent = _HeroTipParent,
			model = "ICON:action_attack", --"UI:Attr_Atk"
			x = offsetX + 220,
			y = offsetY - 48 * 0,
			w = 32,
			h = 32,
			align = "MC",
		})
	else
		--法术伤害
		--print(atk_skill_id)
		if hVar.tab_skill[atk_skill_id] and (hVar.tab_skill[atk_skill_id].DamageType == 2) then
			--远程法术攻击图标
			_HeroTipChildUI["heroAttrAtkIcon"] = hUI.image:new({
				parent = _HeroTipParent,
				model = "ICON:/battle_attack03",
				x = offsetX + 220,
				y = offsetY - 48 * 0,
				w = 32,
				h = 32,
				align = "MC",
			})
		else
			--远程物理攻击图标
			_HeroTipChildUI["heroAttrAtkIcon"] = hUI.image:new({
				parent = _HeroTipParent,
				model = "ui/battle_attack02.png",
				x = offsetX + 220,
				y = offsetY - 48 * 0,
				w = 32,
				h = 32,
				align = "MC",
			})
		end
	end
	
	--攻击力文字
	local atkValTotal = atkMin .. "-" .. atkMax
	--atkValTotal = "138-159" --test
	local atkSize = 22
	if (#atkValTotal > 6) then --如果攻击力文字太长，缩小文字大小
		atkSize = 22
	elseif (#atkValTotal > 5) then --如果攻击力文字太长，缩小文字大小
		atkSize = 22
	end
	_HeroTipChildUI["heroAttrAtkValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = atkSize,
		align = "LC",
		--border = 1,
		x = offsetX + 220 + 25,
		y = offsetY - 48 * 0 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 300,
		text = atkValTotal,
	})
	
	--物理防御图标
	_HeroTipChildUI["heroAttrPDef"] = hUI.image:new({
		parent = _HeroTipParent,
		model = "ICON:DETICON", --"UI:Attr_PDef",
		x = offsetX,
		y = offsetY - 48 * 1,
		w = 26,
		h = 26,
		align = "MC",
	})
	
	--物理防御文字
	_HeroTipChildUI["heroAttrPDefValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 25,
		y = offsetY - 48 * 1 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 300,
		text = pDef,
	})
	
	--法术防御图标
	_HeroTipChildUI["heroAttrMDef"] = hUI.image:new({
		parent = _HeroTipParent,
		model = "ICON:icon01_x1y1", --"UI:Attr_MDef",
		x = offsetX + 220,
		y = offsetY - 48 * 1,
		w = 32,
		h = 32,
		align = "MC",
	})
	
	--法术防御文字
	_HeroTipChildUI["heroAttrMDefValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 220 + 25,
		y = offsetY - 48 * 1 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 300,
		text = mDef,
	})
	
	--移动速度图标
	_HeroTipChildUI["heroAttrMoveSpeed"] = hUI.image:new({
		parent = _HeroTipParent,
		model = "ICON:Item_Horse01", --"UI:Attr_MoveSpeed",
		x = offsetX,
		y = offsetY - 48 * 2,
		w = 32,
		h = 32,
		align = "MC",
	})
	
	--移动速度文字
	_HeroTipChildUI["heroAttrMoveSpeedValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 25,
		y = offsetY - 48 * 2 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 300,
		text = moveSpeed,
	})
	
	--攻击速度图标
	_HeroTipChildUI["heroAttrAtkSpeed"] = hUI.image:new({
		parent = _HeroTipParent,
		model = "ICON:MOVESPEED", --"UI:Attr_CD",
		x = offsetX + 220,
		y = offsetY - 48 * 2,
		w = 32,
		h = 32,
		align = "MC",
	})
	
	--攻击速度文字
	_HeroTipChildUI["heroAttrAtkSpeedValue"] = hUI.label:new({
		parent = _HeroTipParent,
		y = 28,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 220 + 25,
		y = offsetY - 48 * 2 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 210,
		--text = ("%d.%d"):format(math.floor(atkSpeed), math.floor((atkSpeed - math.floor(atkSpeed)) * 100)) --保留2位有效数字
		text = string.format("%.2f", atkSpeed), --保留2位有效数字
	})
	
	--暴击几率图标
	_HeroTipChildUI["heroAttrCritRate"] = hUI.image:new({
		parent = _HeroTipParent,
		model = "UI:Attr_CritRate",
		x = offsetX,
		y = offsetY - 48 * 3,
		w = 32,
		h = 32,
		align = "MC",
	})
	
	--暴击几率文字
	_HeroTipChildUI["heroAttrCritRateValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 25,
		y = offsetY - 48 * 3 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 300,
		text = (critRate .. "%"),
	})
	
	--暴击倍数图标
	_HeroTipChildUI["heroAttrCritValue"] = hUI.image:new({
		parent = _HeroTipParent,
		model = "UI:Attr_CritValue",
		x = offsetX + 220,
		y = offsetY - 48 * 3,
		w = 32,
		h = 32,
		align = "MC",
	})
	
	--暴击倍数文字
	local strCV = string.format("%.1f", critValue) --保留1位有效数字
	_HeroTipChildUI["heroAttrCritValueValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 220 + 25,
		y = offsetY - 48 * 3 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 300,
		text = strCV,
	})
	
	--暴击倍数后缀文字
	local cvExraDx = 82
	if (#strCV >= 4) then
		cvExraDx = 98
	end
	_HeroTipChildUI["heroAttrCritValuePostfix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 26,
		align = "LC",
		border = 1,
		x = offsetX + 220 + cvExraDx,
		y = offsetY - 48 * 3 - 2,
		font = hVar.FONTC,
		width = 300,
		--text = "倍", --language
		text = hVar.tab_string["__Bei"], --language
	})
end

--显示英雄属性的tip
function hApi.ShowHeroInfoTip(typeId, lv, star, equipment, strPlayerName)
	--print(rewardType, tacticId, tacticLv)
	
	--先清除上一次的英雄属性说明面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--创建英雄属性说明tip
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = 100,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除英雄属性面板
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _HeroTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _HeroTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	local tabU = hVar.tab_unit[typeId] or {}
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220 + 10
	
	--创建英雄属性图片背景
	--[[
	_HeroTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _HeroTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 380,
	})
	_HeroTipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY - 235, 510, 520, hGlobal.UI.GameCoinTipFrame)
	img9:setOpacity(204)
	
	--创建英雄图标背景图
	_HeroTipChildUI["HeroIconBG"] = hUI.image:new({
		parent = _HeroTipParent,
		model = "UI:NewKuang",
		x = _offX - 185,
		y = _offY - 45,
		w = 78 + 10,
		h = 78 + 10,
	})
	
	--创建英雄图标
	_HeroTipChildUI["HeroIcon"] = hUI.image:new({
		parent = _HeroTipParent,
		model = tabU.icon,
		x = _offX - 185,
		y = _offY - 45,
		w = 78,
		h = 78,
	})
	
	--创建英雄名
	_HeroTipChildUI["HeroName"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 42,
		x = _offX - 180 + 120,
		y = _offY - 45 - 5,
		width = 300,
		align = "MC",
		font = hVar.FONTC,
		text = hVar.tab_stringU[typeId] and hVar.tab_stringU[typeId][1] or ("未知英雄" .. typeId),
		border = 1,
	})
	_HeroTipChildUI["HeroName"].handle.s:setColor(ccc3(255, 196, 0))
	
	--创建玩家名
	if strPlayerName and (type(strPlayerName) == "string") then
		--创建英雄名
		_HeroTipChildUI["HeroPlayerName"] = hUI.label:new({
			parent = _HeroTipParent,
			size = 28,
			x = _offX - 180 + 220,
			y = _offY - 45 - 5,
			width = 300,
			align = "LC",
			font = hVar.FONTC,
			text = "( " .. strPlayerName .. " )",
			border = 1,
		})
		_HeroTipChildUI["HeroPlayerName"].handle.s:setColor(ccc3(128, 255, 128))
	end
	
	--创建英雄等级背景图(大图)
	_HeroTipChildUI["HeroLvBG"] = hUI.image:new({
		parent = _HeroTipParent,
		model = "ui/pvp/pvpselect.png",
		x = _offX - 185 + 40,
		y = _offY - 45 + 40,
		w = 40,
		h = 40,
	})
	
	--创建英雄等级(大图)
	local fontSize = 26
	if lv and (lv >= 10) then --如果等级是2位数的，那么缩一下文字
		fontSize = 18
	end
	_HeroTipChildUI["HeroLv"] = hUI.label:new({
		parent = _HeroTipParent,
		x = _offX - 185 + 40,
		y = _offY - 45 + 40 - 1,
		text = lv,
		size = fontSize,
		font = "numWhite",
		align = "MC",
		width = 200,
	})
	
	--英雄的星级
	for i = 1, star, 1 do
		_HeroTipChildUI["HeroStar" .. i] = hUI.image:new({
			parent = _HeroTipParent,
			model = "UI:STAR_YELLOW",
			x = _offX - 185 + 25 - (i - 1) * (26),
			y = _offY - 45 - 26,
			w = 26,
			h = 26,
		})
	end
	
	--依次绘制装备
	if equipment and (type(equipment) == "table") then
		--第3,4项可能颠倒了
		if (type(equipment[3]) == "table") and equipment[3][1] and hVar.tab_item[equipment[3][1]] and (hVar.tab_item[equipment[3][1]].type == hVar.ITEM_TYPE.MOUNT) then
			equipment = {equipment[1], equipment[2], equipment[4], equipment[3],}
		end
		if (type(equipment[4]) == "table") and equipment[4][1] and hVar.tab_item[equipment[4][1]] and (hVar.tab_item[equipment[4][1]].type == hVar.ITEM_TYPE.ORNAMENTS) then
			equipment = {equipment[1], equipment[2], equipment[4], equipment[3],}
		end
		
		for k = 1, #equipment, 1 do
			--装备表
			local itemId = 0 --道具id
			local item = equipment[k]
			
			if (type(item) == "table") then
				itemId = item[1] --道具id
			end
			
			--存在道具
			if hVar.tab_item[itemId] then
				--绘制道具背景图
				local itemLv = hVar.tab_item[itemId].itemLv or 1
				local itemtModel = hVar.ITEMLEVEL[itemLv].BORDERMODEL
				_HeroTipChildUI["HeroEquipBG" .. k] = hUI.image:new({
					parent = _HeroTipParent,
					model = itemtModel, --"UI:SkillSlot",
					x = _offX - 185 - 33 + (k - 1) * (22 + 0),
					y = _offY - 45 - 55,
					w = 22,
					h = 22,
				})
				
				--绘制道具图标
				_HeroTipChildUI["HeroEquip" .. k] = hUI.image:new({
					parent = _HeroTipParent,
					model = hVar.tab_item[itemId].icon,
					x = _offX - 185 - 33 + (k - 1) * (22 + 0),
					y = _offY - 45 - 55,
					w = 22 - 2,
					h = 22 - 2,
				})
			else
				--不存在道具，画个空板子
				_HeroTipChildUI["HeroEquipBG" .. k] = hUI.image:new({
					parent = _HeroTipParent,
					model = "misc/photo_frame.png",
					x = _offX - 185 - 33 + (k - 1) * (22 + 0),
					y = _offY - 45 - 55,
					w = 22,
					h = 22,
				})
			end
		end
	end
	
	local attr = hApi.GetUnitAttrs(typeId, lv, star, equipment) --计算出角色的最终属性
	local atkMin = math.floor(attr.atk_min) --最小攻击力
	local atkMax = math.floor(attr.atk_max) --最大攻击力
	local atkRange = attr.atk_radius --射程
	local hp_max = attr.hp_max --血量
	local pDef = math.floor(attr.def_physic) --物理防御
	local mDef = math.floor(attr.def_magic) --法术防御
	local moveSpeed = attr.move_speed --移动速度
	local atkSpeed = attr.atk_interval / 1000 --攻击速度
	local dodgeRate = attr.dodge_rate --闪避几率
	local critRate = attr.crit_rate --暴击几率
	local critValue = attr.crit_value --暴击倍率
	local hpRestore = attr.hp_restore --回血速度
	local rebirthTime = attr.rebirth_time / 1000 --复活时间（秒）
	local suckBlood = attr.suck_blood_rate --吸血
	local activeSkillCDRate = attr.active_skill_cd_delta_rate --战术技能冷却
	local passiveSkillCDRate = attr.passive_skill_cd_delta_rate --被动技能冷却
	local atk_skill_id = hVar.tab_unit[typeId] and hVar.tab_unit[typeId].attr and hVar.tab_unit[typeId].attr.attack and hVar.tab_unit[typeId].attr.attack[1]
	
	local offsetX = _offX - 230
	local offsetY = _offY - 140
	
	--攻击力前缀
	_HeroTipChildUI["heroAttrAtkPrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 26,
		align = "LC",
		border = 1,
		x = offsetX,
		y = offsetY - 45 * 0,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_atk"], --"攻击"
	})
	_HeroTipChildUI["heroAttrAtkPrefix"].handle.s:setColor(ccc3(255, 255, 255))
	
	--攻击力文字
	local atkValTotal = atkMin .. "-" .. atkMax
	--atkValTotal = "138-159" --test
	local atkSize = 22
	if (#atkValTotal > 6) then --如果攻击力文字太长，缩小文字大小
		atkSize = 20
	elseif (#atkValTotal > 5) then --如果攻击力文字太长，缩小文字大小
		atkSize = 21
	end
	_HeroTipChildUI["heroAttrAtkValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = atkSize,
		align = "LC",
		--border = 1,
		x = offsetX + 110,
		y = offsetY - 45 * 0 - 2, --num字体有2像素偏差
		font = "numWhite",
		width = 210,
		text = atkValTotal,
	})
	_HeroTipChildUI["heroAttrAtkValue"].handle.s:setColor(ccc3(255, 255, 255))
	
	--射程前缀
	_HeroTipChildUI["heroAttrAtkRadiusPrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 26,
		align = "LC",
		border = 1,
		x = offsetX + 260,
		y = offsetY - 45 * 0,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Atk_Range"], --"射程"
	})
	_HeroTipChildUI["heroAttrAtkRadiusPrefix"].handle.s:setColor(ccc3(255, 255, 255))
	
	--射程值
	if (atkRange <= 90) then
		--射程值(近战)
		_HeroTipChildUI["heroAttrAtkRadiusValue"] = hUI.label:new({
			parent = _HeroTipParent,
			size = 26,
			align = "LC",
			border = 1,
			x = offsetX + 260 + 110,
			y = offsetY - 45 * 0,
			font = hVar.FONTC,
			width = 210,
			text = hVar.tab_string["__Attr_ATTACKMODE_28"], --"近战"
		})
		_HeroTipChildUI["heroAttrAtkRadiusValue"].handle.s:setColor(ccc3(255, 255, 255))
	else
		--射程值(远程)
		_HeroTipChildUI["heroAttrAtkRadiusValue"] = hUI.label:new({
			parent = _HeroTipParent,
			size = hpSize,
			align = "LC",
			--border = 1,
			x = offsetX + 260 + 110,
			y = offsetY - 45 * 0 - 1, --数字字体有1像素偏差
			font = "numWhite",
			width = 210,
			text = atkRange,
		})
		_HeroTipChildUI["heroAttrAtkRadiusValue"].handle.s:setColor(ccc3(255, 255, 255))
	end
	
	--血量前缀
	_HeroTipChildUI["heroAttrHpPrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 26,
		align = "LC",
		border = 1,
		x = offsetX,
		y = offsetY - 45 * 1,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__ATTR__hp_max"], --"生命值"
	})
	_HeroTipChildUI["heroAttrHpPrefix"].handle.s:setColor(ccc3(255, 255, 224))
	
	--血量文字
	local hpSize = 22
	if (hp_max > 5) then --如果血量太大，缩小文字大小
		hpSize = 22
	end
	_HeroTipChildUI["heroAttrHpValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = hpSize,
		align = "LC",
		--border = 1,
		x = offsetX + 110,
		y = offsetY - 45 * 1 - 1, --数字字体有1像素偏差
		font = "numWhite",
		width = 210,
		text = hp_max,
	})
	_HeroTipChildUI["heroAttrHpValue"].handle.s:setColor(ccc3(255, 255, 224))
	
	--物理防御前缀
	_HeroTipChildUI["heroAttrPDefPrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 24,
		align = "LC",
		border = 1,
		x = offsetX + 260,
		y = offsetY - 45 * 1,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_def_physic"], --"物防"
	})
	_HeroTipChildUI["heroAttrPDefPrefix"].handle.s:setColor(ccc3(255, 255, 224))
	
	--物理防御文字
	_HeroTipChildUI["heroAttrPDefValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 260 + 110,
		y = offsetY - 45 * 1 - 0, --数字字体有1像素偏差(小字体没有偏移)
		font = "numWhite",
		width = 210,
		text = pDef,
	})
	_HeroTipChildUI["heroAttrPDefValue"].handle.s:setColor(ccc3(255, 255, 224))
	
	--法术防御前缀
	_HeroTipChildUI["heroAttrMDefPrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 24,
		align = "LC",
		border = 1,
		x = offsetX,
		y = offsetY - 45 * 2,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_def_magic"], --"法防"
	})
	_HeroTipChildUI["heroAttrMDefPrefix"].handle.s:setColor(ccc3(255, 255, 255))
	
	--法术防御文字
	_HeroTipChildUI["heroAttrMDefValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 110,
		y = offsetY - 45 * 2 - 0, --数字字体有1像素偏差(小字体没有偏移)
		font = "numWhite",
		width = 210,
		text = mDef,
	})
	_HeroTipChildUI["heroAttrMDefValue"].handle.s:setColor(ccc3(255, 255, 255))
	
	--移动速度前缀
	_HeroTipChildUI["heroAttrMoveSpeedPrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 24,
		align = "LC",
		border = 1,
		x = offsetX + 260,
		y = offsetY - 45 * 2,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_move_speed"], --"移动速度"
	})
	_HeroTipChildUI["heroAttrMoveSpeedPrefix"].handle.s:setColor(ccc3(255, 255, 255))
	
	--移动速度文字
	_HeroTipChildUI["heroAttrMoveSpeedValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 260 + 110,
		y = offsetY - 45 * 2 - 0, --数字字体有1像素偏差(小字体没有偏移)
		font = "numWhite",
		width = 210,
		text = moveSpeed,
	})
	_HeroTipChildUI["heroAttrMoveSpeedValue"].handle.s:setColor(ccc3(255, 255, 255))
	
	--攻击速度图标
	_HeroTipChildUI["heroAttrAtkSpeedPrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 24,
		align = "LC",
		border = 1,
		x = offsetX,
		y = offsetY - 45 * 3,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_atk_speed"], --"攻击速度"
	})
	_HeroTipChildUI["heroAttrAtkSpeedPrefix"].handle.s:setColor(ccc3(255, 255, 224))
	
	--攻击速度文字
	_HeroTipChildUI["heroAttrAtkSpeedValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 110,
		y = offsetY - 45 * 3 - 0, --数字字体有1像素偏差(小字体没有偏移)
		font = "numWhite",
		width = 210,
		--text = ("%d.%d"):format(math.floor(atkSpeed), math.floor((atkSpeed - math.floor(atkSpeed)) * 100)) --保留2位有效数字
		text = string.format("%.2f", atkSpeed), --保留2位有效数字
	})
	_HeroTipChildUI["heroAttrAtkSpeedValue"].handle.s:setColor(ccc3(255, 255, 224))
	
	--闪避几率前缀
	_HeroTipChildUI["heroAttrDodgeRatePrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 24,
		align = "LC",
		border = 1,
		x = offsetX + 260,
		y = offsetY - 45 * 3,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_dodge_rate"], --"闪避几率"
	})
	_HeroTipChildUI["heroAttrDodgeRatePrefix"].handle.s:setColor(ccc3(255, 255, 224))
	
	--闪避几率文字
	_HeroTipChildUI["heroAttrDodgeRateValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 260 + 110,
		y = offsetY - 45 * 3 - 0, --数字字体有1像素偏差(小字体没有偏移)
		font = "numWhite",
		width = 210,
		text = dodgeRate .. "%",
	})
	_HeroTipChildUI["heroAttrDodgeRateValue"].handle.s:setColor(ccc3(255, 255, 224))
	
	--暴击几率前缀
	_HeroTipChildUI["heroAttrCritRatePrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 24,
		align = "LC",
		border = 1,
		x = offsetX,
		y = offsetY - 45 * 4,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_crit_rate"], --"暴击几率"
	})
	_HeroTipChildUI["heroAttrCritRatePrefix"].handle.s:setColor(ccc3(255, 255, 255))
	
	--暴击几率文字
	_HeroTipChildUI["heroAttrCritRateValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 110,
		y = offsetY - 45 * 4 - 0, --数字字体有1像素偏差(小字体没有偏移)
		font = "numWhite",
		width = 210,
		text = critRate .. "%",
	})
	_HeroTipChildUI["heroAttrCritRateValue"].handle.s:setColor(ccc3(255, 255, 255))
	
	--暴击倍数前缀
	_HeroTipChildUI["heroAttrCritValuePrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 24,
		align = "LC",
		border = 1,
		x = offsetX + 260,
		y = offsetY - 45 * 4,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_crit_value"], --"暴击倍数"
	})
	_HeroTipChildUI["heroAttrCritValuePrefix"].handle.s:setColor(ccc3(255, 255, 255))
	
	--暴击倍数文字
	_HeroTipChildUI["heroAttrCritValueValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 260 + 110,
		y = offsetY - 45 * 4 - 0, --数字字体有1像素偏差(小字体没有偏移)
		font = "numWhite",
		width = 210,
		text = string.format("%.1f", critValue), --保留1位有效数字,
	})
	_HeroTipChildUI["heroAttrCritValueValue"].handle.s:setColor(ccc3(255, 255, 255))
	
	--回血速度前缀
	_HeroTipChildUI["heroAttrCoverHpPrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 24,
		align = "LC",
		border = 1,
		x = offsetX,
		y = offsetY - 45 * 5,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_hp_restore"], --"回血速度"
	})
	_HeroTipChildUI["heroAttrCoverHpPrefix"].handle.s:setColor(ccc3(255, 255, 224))
	
	--回血速度文字
	_HeroTipChildUI["heroAttrrCoverHpValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 110,
		y = offsetY - 45 * 5 - 0, --数字字体有1像素偏差(小字体没有偏移)
		font = "numWhite",
		width = 210,
		text = hpRestore,
	})
	_HeroTipChildUI["heroAttrrCoverHpValue"].handle.s:setColor(ccc3(255, 255, 224))
	
	--复活时间前缀
	_HeroTipChildUI["heroAttrRebirthTimePrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 24,
		align = "LC",
		border = 1,
		x = offsetX + 260,
		y = offsetY - 45 * 5,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_rebirth_time"], --"复活时间"
	})
	_HeroTipChildUI["heroAttrRebirthTimePrefix"].handle.s:setColor(ccc3(255, 255, 224))
	
	--复活时间文字
	_HeroTipChildUI["heroAttrrRebirthTimeValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 260 + 110,
		y = offsetY - 45 * 5 - 0, --数字字体有1像素偏差(小字体没有偏移)
		font = "numWhite",
		width = 210,
		text = rebirthTime,
	})
	_HeroTipChildUI["heroAttrrRebirthTimeValue"].handle.s:setColor(ccc3(255, 255, 224))
	
	--复活时间后缀(秒)
	local rebirthTimePostfixDy = 42
	if (rebirthTime < 10) then
		rebirthTimePostfixDy = 24
	end
	_HeroTipChildUI["heroAttrRebirthTimePostfix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 26,
		align = "LC",
		border = 1,
		x = offsetX + 260 + 110 + rebirthTimePostfixDy,
		y = offsetY - 45 * 5,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Second"], --"秒"
	})
	_HeroTipChildUI["heroAttrRebirthTimePostfix"].handle.s:setColor(ccc3(255, 255, 224))
	
	--攻击吸血前缀
	_HeroTipChildUI["heroAttrSuckBloodPrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 24,
		align = "LC",
		border = 1,
		x = offsetX,
		y = offsetY - 45 * 6,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_suck_blood_rate"], --"攻击吸血"
	})
	_HeroTipChildUI["heroAttrSuckBloodPrefix"].handle.s:setColor(ccc3(255, 255, 255))
	
	--攻击吸血文字
	_HeroTipChildUI["heroAttrSuckBloodValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 110,
		y = offsetY - 45 * 6 - 1, --数字字体有1像素偏差
		font = "numWhite",
		width = 210,
		text = suckBlood .. "%",
	})
	_HeroTipChildUI["heroAttrSuckBloodValue"].handle.s:setColor(ccc3(255, 255, 255))
	
	--战术技能冷却前缀
	_HeroTipChildUI["heroAttrActiveCDPrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 20,
		align = "LC",
		border = 1,
		x = offsetX,
		y = offsetY - 45 * 7,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_active_skill_cd_delta_rate"], --"战术技能冷却"
	})
	_HeroTipChildUI["heroAttrActiveCDPrefix"].handle.s:setColor(ccc3(255, 255, 224))
	
	--战术技能冷却文字
	local activeSkillCDHead = ""
	if (activeSkillCDRate > 0) then
		activeSkillCDHead = "+"
	elseif (activeSkillCDRate == 0) then
		activeSkillCDHead = "-"
	end
	_HeroTipChildUI["heroAttrActiveCDValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 110 + 15,
		y = offsetY - 45 * 7 - 1, --数字字体有1像素偏差
		font = "numWhite",
		width = 210,
		text = (activeSkillCDHead .. activeSkillCDRate .. "%"),
	})
	_HeroTipChildUI["heroAttrActiveCDValue"].handle.s:setColor(ccc3(255, 255, 224))
	
	--被动技能冷却前缀
	_HeroTipChildUI["heroAttPassiveCDPrefix"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 20,
		align = "LC",
		border = 1,
		x = offsetX + 260,
		y = offsetY - 45 * 7,
		font = hVar.FONTC,
		width = 210,
		text = hVar.tab_string["__Attr_Hint_passive_skill_cd_delta_rate"], --"被动技能冷却"
	})
	_HeroTipChildUI["heroAttPassiveCDPrefix"].handle.s:setColor(ccc3(255, 255, 224))
	
	--被动技能冷却文字
	local passiveSkillCDHead = ""
	if (passiveSkillCDRate > 0) then
		passiveSkillCDHead = "+"
	elseif (passiveSkillCDRate == 0) then
		passiveSkillCDHead = "-"
	end
	_HeroTipChildUI["heroAttPassiveCDValue"] = hUI.label:new({
		parent = _HeroTipParent,
		size = 22,
		align = "LC",
		--border = 1,
		x = offsetX + 260 + 110 + 15,
		y = offsetY - 45 * 7 - 1, --数字字体有1像素偏差
		font = "numWhite",
		width = 210,
		text = (passiveSkillCDHead .. passiveSkillCDRate .. "%"),
	})
	_HeroTipChildUI["heroAttPassiveCDValue"].handle.s:setColor(ccc3(255, 255, 224))
end

--变换角色 参数 变换前单位, 变换后Id, 变换后阵营, 变换时特效, 变换时声音播放, 是否删除变换前单位（如果是在死亡事件中调用该接口，不能删除原角色）
function hApi.ChangeUnit(oUnit, toTypeId, toOwner, effectId, strSound, pathId, delCha)
	--print("hApi.ChangeUnit", oUnit.data.name, toTypeId, toOwner, effectId, strSound, pathId, delCha and delCha.data.name)
	
	--塔是否存在
	if (not oUnit) or (oUnit == 0) then
		return
	end
	
	--塔是否活着
	if (oUnit.data.IsDead == 1) then
		return
	end
	
	local w = oUnit:getworld()
	--local oPlayerMe = w:GetPlayerMe()
	local unitData = oUnit.data
	
	--unitData.facing
	local nu = w:addunit(toTypeId, toOwner,nil,nil, -45, unitData.worldX,unitData.worldY,nil,nil)
	
	if nu then
		
		if pathId then
			local dType = hVar.TD_DEPLOY_TYPE
			local formation = dType.ONE_SAME_DISTANCE
			--设置角色的路点
			nu:setRoadPoint(pathId, formation, 1)
		end
		
		--zhenkira 角色出生事件
		hGlobal.event:call("Event_UnitBorn", nu)
		
		if oUnit~=nil and delCha then
			--随机地图模式，检测本波发兵是否有此目标
			local regionId = w.data.randommapIdx
			if (regionId > 0) then
				local regionData = w.data.randommapInfo[regionId]
				if regionData then
					local roomgroupSendArmyList = regionData.roomgroupSendArmyList --房间组发兵表 --{[n] = {groupId = XXX, x = XXX, y = XXX, beginTick = XXX, currentWave = XXX, unitperWave = {[1] = {...}, [2] = {...}, ...}, ...}
					if roomgroupSendArmyList then
						for r = 1, #roomgroupSendArmyList, 1 do
							local tSendArmyList = roomgroupSendArmyList[r]
							local currentWave = tSendArmyList.currentWave --当前波次
							if (currentWave > 0) then
								local unitperWave = tSendArmyList.unitperWave --每波单位表
								local tPreWave = unitperWave[currentWave]
								if tPreWave then
									if (tPreWave.num > 0) then
										if tPreWave[oUnit] then --找到了
											tPreWave[oUnit] = nil
											tPreWave.num = tPreWave.num - 1
											print("随机组[" .. r .. "]的波次[" .. currentWave .. "]的单位 " .. oUnit.data.name .. " 迷惑，本组剩余" .. tPreWave.num)
											break
										end
									end
								end
							end
						end
					end
				end
			end
			
			--删除原角色
			oUnit:del()
		end
		
		--播放特效及音效
		if effectId and effectId > 0 then
			w:addeffect(effectId, 1, nil, unitData.worldX, unitData.worldY)
		end
		if strSound and type(strSound) == "string" then
			hApi.PlaySound(strSound)
		end
	end

	return nu
end

--战车变身
function hApi.TankChangeUnit(oUnit, toTypeId, livetime)
	--战车单位是否存在
	if (not oUnit) or (oUnit == 0) then
		return
	end
	
	--塔是否活着
	if (oUnit.data.IsDead == 1) then
		return
	end
	
	local world = oUnit:getworld()
	local unitData = oUnit.data
	local currentUnitId = unitData.id --原单位id
	local worldX, worldY = hApi.chaGetPos(oUnit.handle) --目标的位置
	local lv = oUnit.attr.lv
	local star = oUnit.attr.star
	local owner = oUnit:getowner():getpos()
	--local oPlayerMe = w:GetPlayerMe()
	local tabU = hVar.tab_unit[toTypeId]
	
	--替换模型
	local model = tabU.model
	local scale = tabU.scale
	oUnit.handle.__UnitModelName = model
	oUnit.data.scale = scale * 100
	oUnit:initmodel()
	
	--替换轮子
	local bind_wheel = tabU.bind_wheel
	if (oUnit.data.bind_wheel ~= 0) then
		oUnit.data.bind_wheel:del()
		oUnit.data.bind_wheel = 0
	end
	
	--替换轮子
	local bind_weapon = tabU.bind_weapon
	if (oUnit.data.bind_weapon ~= 0) then
		oUnit.data.bind_weapon:del()
		oUnit.data.bind_weapon = 0
	end
	
	--更新box
	oUnit.handle.__box = tabU.box
	
	--属性重算
	oUnit:__AttrRecheckBasic(tabU.attr)
	
	--属性替换
	oUnit.attr.attack[1] = tabU.attr.attack[1]
	oUnit.attr.attack[2] = tabU.attr.attack[2]
	oUnit.attr.attack[3] = tabU.attr.attack[3]
	oUnit.attr.attack[4] = tabU.attr.attack[4]
	oUnit.attr.attack[5] = tabU.attr.attack[5]
	oUnit.attr.atk_basic = math.min((oUnit.attr.attack[4] + oUnit.attr.attack[5]) / 2) --基础攻击力
	oUnit.attr.role_sex = tabU.role_sex or hVar.ROLE_SEX.MALE --性别
	oUnit.attr.bullet = tabU.bullet or 0 --子弹16方向偏移表
	oUnit.attr.bulletTank = tabU.bulletTank or 0 --子弹16方向偏移表
	oUnit.attr.bulletEffect = tabU.bulletEffect or 0 --子弹16方向偏移表
	
	--标记是召唤物
	oUnit.data.is_fenshen = 1
	
	--替换攻击技能
	local btni = world.data.tacticCardCtrls[hVar.NORMALATK_IDX]
	local weaponItemIdOld = btni.data.itemId --道具id
	local normalatkItemlId = tabU.normalatkItemlId
	--print("normalatkItemlId=", normalatkItemlId)
	hGlobal.event:event("Event_ResetSingleTactic", hVar.NORMALATK_IDX, 0, normalatkItemlId, 1, -1, hVar.MY_TANK_ID)
	--替换英雄存储的道具技能相关参数
	local oPlayer = world:GetPlayerMe()
	for j = 1, #oPlayer.heros, 1 do
		local oHero = oPlayer.heros[j]
		local itemSkillT = oHero.data.itemSkillT
		if (itemSkillT) then
			local k = hVar.NORMALATK_IDX - hVar.TANKSKILL_EMPTY
			
			local activeItemId = itemSkillT[k].activeItemId --主动技能的id
			local activeItemLv = itemSkillT[k].activeItemLv --主动技能的等级
			local activeItemNum = itemSkillT[k].activeItemNum --主动技能的使用次数
			local activeItemCD = itemSkillT[k].activeItemCD --主动技能的CD
			local activeItemLastCastTime = itemSkillT[k].activeItemLastCastTime --主动技能的上次释放的时间（单位:毫秒）
			
			--print(k, activeItemId, weaponItemIdOld)
			--print("找到了")
			itemSkillT[k].activeItemId = normalatkItemlId
			itemSkillT[k].activeItemCD = hVar.tab_item[normalatkItemlId].activeSkill.cd[activeItemLv]
		end
	end
	
	--替换扔手雷技能
	local btni = world.data.tacticCardCtrls[hVar.TANKSKILL_IDX]
	local weaponItemIdOld = btni.data.itemId --道具id
	local weaponItemId = tabU.skillItemlId
	--print("weaponItemId=", weaponItemId)
	hGlobal.event:event("Event_ResetSingleTactic", hVar.TANKSKILL_IDX, 0, weaponItemId, 1, -1, hVar.MY_TANK_ID)
	--替换英雄存储的道具技能相关参数
	local oPlayer = world:GetPlayerMe()
	for j = 1, #oPlayer.heros, 1 do
		local oHero = oPlayer.heros[j]
		local itemSkillT = oHero.data.itemSkillT
		if (itemSkillT) then
			local k = hVar.TANKSKILL_IDX - hVar.TANKSKILL_EMPTY
			
			local activeItemId = itemSkillT[k].activeItemId --主动技能的id
			local activeItemLv = itemSkillT[k].activeItemLv --主动技能的等级
			local activeItemNum = itemSkillT[k].activeItemNum --主动技能的使用次数
			local activeItemCD = itemSkillT[k].activeItemCD --主动技能的CD
			local activeItemLastCastTime = itemSkillT[k].activeItemLastCastTime --主动技能的上次释放的时间（单位:毫秒）
			
			--print(k, activeItemId, weaponItemIdOld)
			--print("找到了")
			itemSkillT[k].activeItemId = weaponItemId
			itemSkillT[k].activeItemCD = hVar.tab_item[weaponItemId].activeSkill.cd[activeItemLv]
		end
	end
	
	--tank: 是否有绑定的单位（坦克轮子）
	if bind_wheel then
		--local worldX, worldY = hApi.chaGetPos(oUnit.handle) --目标的位置
		local gridX, gridY = world:xy2grid(worldX, worldY)
		local facing = oUnit.data.facing
		local bind_wheel2 = world:addunit(bind_wheel, owner, gridX, gridY, facing, worldX, worldY, nil, nil, lv, star)
		oUnit.data.bind_wheel = bind_wheel2
		bind_wheel2.data.bind_wheel_owner = oUnit
	end
	
	--设置生存时间
	if (livetime) and (livetime > 0) then
		local currenttime = world:gametime()
		
		oUnit.data.livetimeBegin = currenttime --geyachao: 新加数据 生存时间开始值（毫秒）
		oUnit.data.livetime = livetime --新加数据 生存时间（毫秒）
		oUnit.data.livetimeMax = currenttime + livetime --geyachao: 新加数据 生存时间最大值（毫秒）
	end
end
--[[
local oPlayerMe = world:GetPlayerMe() --我的玩家对象
local oHero = oPlayerMe.heros[1]
local oUnit = oHero:getunit()
hApi.TankChangeUnit(oUnit, 6112, 30000)
]]








--打开同步日志文件
local SyncFile = nil
local SyncFileName = "log/sync_log.log"
local SyncFileT = {}
--hApi.SyncLogOpen = function()
function hApi.SyncLogOpen(fileName)
	if (hVar.IS_SYNC_LOG == 1) then
		if (not SyncFile) then
			--存储文件名
			if fileName then
				SyncFileName = fileName
			end
			
			--SyncFile = io.open(SyncFileName, "w+")
			SyncFile = true
			SyncFileT = {}
		end
	end
end

--输出同步日志
--hApi.SyncLog = function(msg)
function hApi.SyncLog(msg)
	if (hVar.IS_SYNC_LOG == 1) then
		local w = hGlobal.WORLD.LastWorldMap
		if w then
			if (not SyncFile) then
				hApi.SyncLogOpen()
			end
			local d = w.data
			local logiccount = d.__frameCount - d.__beginFrameCount
			local strLog = ("[%d]:%s\n"):format(logiccount, msg)
			SyncFileT[#SyncFileT + 1] = strLog
			--SyncFile:write("[" .. logiccount .. "]:" .. msg .. "\n")
			--SyncFile:flush()
		end
	end
end

--关闭同步日志文件
--hApi.SyncLogClose = function()
function hApi.SyncLogClose()
	--print("关闭同步日志文件")
	if (hVar.IS_SYNC_LOG == 1) then
		if SyncFile then
			--SyncFile:close()
			SyncFile = nil
			SyncFileName = "log/sync_log.log"
		end
	end
end

--获得同步日志
function hApi.SyncLogQuery()
	if (hVar.IS_SYNC_LOG == 1) then
		if SyncFile then
			return SyncFileName, SyncFileT
		end
	end
end

--打开非同步日志文件
local AsyncFile = nil
local AsyncFileName = "log/async_log.log"
--hApi.AsyncLogOpen = function()
function hApi.AsyncLogOpen(fileName)
	if (hVar.IS_ASYNC_LOG == 1) then
		if (not AsyncFile) then
			--存储文件名
			if fileName then
				AsyncFileName = fileName
			end
			
			AsyncFile = io.open(AsyncFileName, "w+")
		end
	end
end

--输出非同步日志
--hApi.AsyncLog = function(msg)
function hApi.AsyncLog(msg)
	if (hVar.IS_ASYNC_LOG == 1) then
		local w = hGlobal.WORLD.LastWorldMap
		if w then
			if (not AsyncFile) then
				hApi.AsyncLogOpen()
			end
			
			local d = w.data
			local logiccount = d.__frameCount - d.__beginFrameCount
			AsyncFile:write("[" .. logiccount .. "]:" .. msg .. "\n")
			AsyncFile:flush()
		end
	end
end

--关闭非同步日志文件
--hApi.AsyncLogClose = function()
function hApi.AsyncLogClose()
	if (hVar.IS_SYNC_LOG == 1) then
		if AsyncFile then
			AsyncFile:close()
			AsyncFile = nil
			AsyncFileName = "log/async_log.log"
		end
	end
end

--序列化 表->字符串
--hApi.serialize = function(obj)
function hApi.serialize(obj)
	local lua = ""  
	local t = type(obj)  
	if t == "number" then  
		lua = lua .. obj  
	elseif t == "boolean" then  
		lua = lua .. tostring(obj)  
	elseif t == "string" then  
		lua = lua .. string.format("%q", obj)  
	elseif t == "table" then  
		lua = lua .. "{\n"  
	for k, v in pairs(obj) do  
		lua = lua .. "[" .. hApi.serialize(k) .. "]=" .. hApi.serialize(v) .. ",\n"  
	end  
	local metatable = getmetatable(obj)  
		if metatable ~= nil and type(metatable.__index) == "table" then  
		for k, v in pairs(metatable.__index) do  
			lua = lua .. "[" .. hApi.serialize(k) .. "]=" .. hApi.serialize(v) .. ",\n"  
		end  
	end  
		lua = lua .. "}"  
	elseif t == "nil" then
		return nil  
	else
		error("can not serialize a " .. t .. " type.")  
	end 
	return lua
end

--显示系统弹框（大框）
hApi.ShowSysMsgBox = function(title, content, callback)
	--窗口
	local tipFrm = hUI.frame:new({
		x = hVar.SCREEN.w/2 - 580/2,
		y = hVar.SCREEN.h/2 + 430/2,
		z = hZorder.Msgbox,
		dragable = 2,
		w = 580,
		h = 430,
		titlebar = 0,
		show = 0,
		bgAlpha = 0,
		bgMode = "tile",
		border = 0,
		background = -1,
		autoactive = 0,
	})
	
	--背景图
	tipFrm.childUI["apartline_back"] = hUI.image:new({
		parent = tipFrm.handle._n,
		model = "misc/billboard/msgbox5.png",
		x = 580/2,
		y = -430/2,
		w = 580,
		h = 430,
	})
	
	--顶部分界线
	tipFrm.childUI["apartline_back"] = hUI.image:new({
		parent = tipFrm.handle._n,
		model = "misc/chest/line.png",
		x =  tipFrm.data.w/2,
		y = -84,
		w = tipFrm.data.w,
		h = 10,
	})
	
	--title
	tipFrm.childUI["title"] =  hUI.label:new({
		parent = tipFrm.handle._n,
		x = tipFrm.data.w/2,
		y = -40,
		--text = "系统公告",
		text = title,
		RGB = {0,255,0},
		size = 34,
		--width = tipFrm.data.w-64,
		width = tipFrm.data.w,
		font = hVar.FONTC,
		align = "MC",
		border = 1,
	})
	
	--提示文字title
	tipFrm.childUI["tipLab"] =  hUI.label:new({
		parent = tipFrm.handle._n,
		x = 30,
		y = -110,
		--text = "您的版本太老，已无法使用当前功能，请更新至最新版本! \n \n从 pp助手 等其它渠道下载游戏的,也请继续保持从这些渠道进行更新! \n \n \n          【 注意: 千万不要删除原有游戏 】",
		text = content,
		size = 26,
		width = tipFrm.data.w-60,
		font = hVar.FONTC,
		align = "LT",
		border = 1,
	})
	
	--确定按钮
	tipFrm.childUI["confirmBtn"] =  hUI.button:new({
		parent = tipFrm.handle._n,
		dragbox = tipFrm.childUI["dragBox"],
		model = "misc/task/ironbuf_button.png",
		x = tipFrm.data.w/2,
		y = -tipFrm.data.h + 80,
		scaleT = 0.95,
		code = function()
			tipFrm:show(0)
			
			if tipFrm then
				tipFrm:del()
			end
			
			if hUI and hUI.NetDisable and hUI.NetDisable(0) then
				hUI.NetDisable(0)
			end
			
			--回调函数
			if callback then
				callback()
			end
		end,
	})
	
	--显示窗口
	tipFrm:active()
	tipFrm:show(1)
	
	--返回值: 窗口, 按钮, 文本框
	return tipFrm, tipFrm.childUI["confirmBtn"], tipFrm.childUI["tipLab"]
end

--检测gameserver版本号是否为最新
hApi.CheckGameServerVersionControl = function()
	--检测版本号，是否为最新版本
	local local_srcVer = tostring(hVar.CURRENT_ITEM_VERSION) --1.0.070502
	local version_control = tostring(g_version_control) --1.0.070502-v018-018-app
	local vbpos = string.find(version_control, "-")
	if vbpos then
		version_control = string.sub(version_control, 1, vbpos - 1)
	end
	if (local_srcVer < version_control) then
		--弹系统框
		local msgTitle = hVar.tab_string["__TEXT_SystemNotice"]
		if (g_lua_src == 1) or (g_is_account_test == 1) or (g_is_account_test == 2) then --源代码模式、测试员、管理员，显示具体的版本号
			msgTitle = hVar.tab_string["__TEXT_SystemNotice"] .. " (" .. local_srcVer .. "|" .. version_control .. ")"
		end
		hApi.ShowSysMsgBox(msgTitle, hVar.tab_string["__TEXT_ScriptsTooOld"])
		
		return false
	else
		return true
	end
end

--弹框-竞技场通用弹框
hApi.ShowPvpMsgBoxFrm = function(strTitle, strContent, funCallback)
	--删除上一次的弹框对话框界面
	if hGlobal.UI.PhoneShowPvpMsgBoxFrm then
		hGlobal.UI.PhoneShowPvpMsgBoxFrm:del()
		hGlobal.UI.PhoneShowPvpMsgBoxFrm = nil
	end
	
	--创建竞技场通用对话框界面
	hGlobal.UI.PhoneShowPvpMsgBoxFrm = hUI.frame:new(
	{
		x = hVar.SCREEN.w / 2 - 450 / 2,
		y = hVar.SCREEN.h / 2 + 300 / 2, -- - 20,
		w = 450,
		h = 300,
		dragable = 4, --在外部点击会一直抖动
		show = 1,
		border = -1, --不显示frame边框
		background = -1, --不显示背景图
		--background = "UI:selectbg2",
		autoactive = 0,
		--全部事件
		codeOnDragEx = function(touchX, touchY, touchMode)
			--
		end,
	})
	
	local _frm = hGlobal.UI.PhoneShowPvpMsgBoxFrm
	local _parent = _frm.handle._n
	
	--背景图（九宫格）
	--创建9宫格贴图(create)
	hApi.CCScale9SpriteCreate("data/image/misc/selectbg2.png", _frm.data.w / 2, -_frm.data.h / 2, _frm.data.w + 30, _frm.data.h, _frm)
	--[[
	--local img9 = CCScale9Sprite:createWithSpriteFrameName("data/image/misc/selectbg2.png")
	local img9 = CCScale9Sprite:create("data/image/misc/selectbg2.png")
	img9:setPosition(ccp(_frm.data.w / 2, -_frm.data.h / 2))
	img9:setContentSize(CCSizeMake(_frm.data.w + 30, _frm.data.h))
	_parent:addChild(img9)
	]]
	
	--等待的标题
	_frm.childUI["labelTitle"] = hUI.label:new({
		parent = _parent,
		x = 225,
		y = -65,
		size = 42,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 300,
		text = strTitle,
	})
	
	--创建提示文字
	_frm.childUI["labelHintText"] = hUI.label:new({
		parent = _parent,
		x = 225,
		y = -145,
		size = 26,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 400,
		text = strContent,
	})
	_frm.childUI["labelHintText"].handle.s:setColor(ccc3(255, 224, 224))
	
	--挡操作的按钮
	_frm.childUI["btnCoverOp"] = hUI.button:new({
		x = 225 - 110,
		y = -235,
		dragbox = _frm.childUI["dragBox"],
		model = "misc/mask.png",
		w = 2000,
		h = 2000,
		scaleT = 1.0,
		code = function()
			--
		end,
	})
	_frm.childUI["btnCoverOp"].handle.s:setOpacity(0) --只用于控制，不显示
	
	--确定按钮
	_frm.childUI["btnOK"] = hUI.button:new({
		parent = _parent,
		x = 225 - 110 + 110,
		y = -235,
		dragbox = _frm.childUI["dragBox"],
		model = "misc/mask.png",
		w = 200,
		h = 80,
		scaleT = 0.95,
		code = function()
			--删除本界面
			if hGlobal.UI.PhoneShowPvpMsgBoxFrm then
				hGlobal.UI.PhoneShowPvpMsgBoxFrm:del()
				hGlobal.UI.PhoneShowPvpMsgBoxFrm = nil
			end
			
			--回调
			if funCallback then
				funCallback()
			end
		end,
	})
	_frm.childUI["btnOK"].handle.s:setOpacity(0) --只用于控制，不显示
	
	--确定背景图（九宫格）
	local img91 = CCScale9Sprite:createWithSpriteFrameName("data/image/ui/pvp/pvptimeoutbg2.png")
	img91:setPosition(ccp(0, 0))
	img91:setContentSize(CCSizeMake(190, 56))
	_frm.childUI["btnOK"].handle._n:addChild(img91)
	
	--确定的文字
	_frm.childUI["btnOK"].childUI["label"] = hUI.label:new({
		parent = _frm.childUI["btnOK"].handle._n,
		x = 0,
		y = -1, --文字有1像素的偏差
		size = 30,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 450,
		--text = "确定", --language
		text = hVar.tab_string["Exit_Ack"], --language
	})
end

--指定的地图是否可以进入
hApi.IsMapEnableEnter = function(mapName, mapDiff)
	--地图名为nil
	if (not mapName) then
		return 0
	end
	
	--地图信息
	local tMapInfo = hVar.MAP_INFO[mapName]
	
	--无效的地图名
	if (not tMapInfo) then
		return 0
	end
	
	--待解锁的地图名
	local unLockMapName = nil
	if tMapInfo.unLock then
		unLockMapName = tMapInfo.unLock[1]
	end
	
	--如果存在需要解锁的地图，检测地图是否通关
	if unLockMapName then
		local isFinish = LuaGetPlayerMapAchi(unLockMapName, hVar.ACHIEVEMENT_TYPE.LEVEL) or 0
		if (isFinish == 0) then
			return 0
		end
	end
	
	--print(unLockMapName, mapDiff)
	
	return 1
end

--创建/隐藏 玩家延时等待时间的界面
hApi.ShowDelayPlayerFrm = function(num, delayPlayer)
	--最大玩家数量
	local MAX_NUM = 2
	
	--如果数量为0，隐藏等待延时界面
	if (num == 0) then
		if hGlobal.UI.PhoneDelayPlayerFrm then
			hGlobal.UI.PhoneDelayPlayerFrm:del()
			hGlobal.UI.PhoneDelayPlayerFrm = nil
		end
	else
		--如果游戏已经结束，不显示等待界面
		local world = hGlobal.WORLD.LastWorldMap
		if world then
			local mapInfo = world.data.tdMapInfo
			if mapInfo then
				--游戏已结束
				if (mapInfo.mapState > hVar.MAP_TD_STATE.PAUSE) then
					--删除可能存在的等待界面面板
					if hGlobal.UI.PhoneDelayPlayerFrm then
						hGlobal.UI.PhoneDelayPlayerFrm:del()
						hGlobal.UI.PhoneDelayPlayerFrm = nil
					end
					
					return
				end
			end
		end
		
		--创建等待延时的界面
		if (not hGlobal.UI.PhoneDelayPlayerFrm) then
			--删除可能的响应时间过长框界面
			if hGlobal.UI.PhonePlayerNoHeartFrm then
				hGlobal.UI.PhonePlayerNoHeartFrm:del()
				hGlobal.UI.PhonePlayerNoHeartFrm = nil
			end
			
			--删除可能的投降界面
			if hGlobal.UI.PhonePlayerTouXiangFrm then
				hGlobal.UI.PhonePlayerTouXiangFrm:del()
				hGlobal.UI.PhonePlayerTouXiangFrm = nil
			end
			
			--首次创建等待延时的界面
			hGlobal.UI.PhoneDelayPlayerFrm = hUI.frame:new(
			{
				x = hVar.SCREEN.w / 2 - 450 / 2,
				y = hVar.SCREEN.h / 2 + 300 / 2, -- - 20,
				w = 450,
				h = 300,
				dragable = 2,
				show = 1,
				border = -1, --不显示frame边框
				background = -1, --不显示背景图
				--background = "UI:selectbg2",
				autoactive = 0,
				--全部事件
				codeOnDragEx = function(touchX, touchY, touchMode)
					--
				end,
			})
			
			local _frm = hGlobal.UI.PhoneDelayPlayerFrm
			local _parent = _frm.handle._n
			
			--背景图（九宫格）
			--local img9 = CCScale9Sprite:createWithSpriteFrameName("data/image/misc/selectbg2.png")
			local img9 = CCScale9Sprite:create("data/image/misc/selectbg2.png")
			img9:setPosition(ccp(450 / 2, -300 / 2))
			img9:setContentSize(CCSizeMake(450 + 30, 300 - 30))
			_parent:addChild(img9)
			
			--等待的标题
			_frm.childUI["labelTitle"] = hUI.label:new({
				parent = _parent,
				x = 225,
				y = -60,
				size = 32,
				align = "MC",
				border = 1,
				font = hVar.FONTC,
				width = 300,
				--text = "正在等待玩家...", --language
				text = hVar.tab_string["__TEXT_PVP_IsWaitingPlayer"], --language
			})
			
			--绘制全部的玩家
			local offsetX = 30
			local offsetY = -125
			local offsetEach = 55
			for i = 1, MAX_NUM, 1 do
				--创建文本玩家名
				_frm.childUI["labelPlayerName" .. i] = hUI.label:new({
					parent = _parent,
					x = offsetX,
					y = offsetY - (i - 1) * offsetEach,
					size = 26,
					align = "LC",
					border = 1,
					font = hVar.FONTC,
					width = 300,
					text = "------",
				})
				
				--创建文本玩家剩余等待时间前缀
				_frm.childUI["labelPlayerWaitTimePrefix" .. i] = hUI.label:new({
					parent = _parent,
					x = offsetX + 300,
					y = offsetY - (i - 1) * offsetEach,
					size = 26,
					align = "RC",
					border = 1,
					font = hVar.FONTC,
					width = 300,
					--text = "剩余等待", --language
					text = hVar.tab_string["__TEXT_PVP_LefeTime"], --language
				})
				
				--创建文本玩家剩余等待时间前缀
				_frm.childUI["labelPlayerWaitTime" .. i] = hUI.label:new({
					parent = _parent,
					x = offsetX + 360,
					y = offsetY - (i - 1) * offsetEach,
					size = 22,
					align = "RC",
					border = 1,
					font = "numWhite",
					width = 300,
					text = "--",
				})
				
				--创建文本玩家剩余等待时间后缀
				_frm.childUI["labelPlayerWaitTimePostfix" .. i] = hUI.label:new({
					parent = _parent,
					x = offsetX + 360,
					y = offsetY - (i - 1) * offsetEach,
					size = 26,
					align = "LC",
					border = 1,
					font = hVar.FONTC,
					width = 300,
					--text = "秒", --language
					text = hVar.tab_string["__Second"], --language
				})
			end
		end
		
		local _frm = hGlobal.UI.PhoneDelayPlayerFrm
		local _parent = _frm.handle._n
		_frm:active()
		
		--依次更新玩家名和剩余时间
		for i = 1, num, 1 do
			_frm.childUI["labelPlayerName" .. i].handle._n:setVisible(true)
			_frm.childUI["labelPlayerWaitTimePrefix" .. i].handle._n:setVisible(true)
			_frm.childUI["labelPlayerWaitTime" .. i].handle._n:setVisible(true)
			_frm.childUI["labelPlayerWaitTimePostfix" .. i].handle._n:setVisible(true)
			
			--更新
			--local playerName = "玩家" .. delayPlayer[i].dbId --language
			local playerName = hVar.tab_string["__TEXT_WanJia"] .. delayPlayer[i].dbId --language
			
			if world then
				local oPlayer = world:GetPlayerByDBID(delayPlayer[i].dbId)
				if oPlayer then
					playerName = oPlayer.data.name
				end
			end
			_frm.childUI["labelPlayerName" .. i]:setText(playerName)
			_frm.childUI["labelPlayerWaitTime" .. i]:setText(delayPlayer[i].kickCD)
		end
		for i = num + 1, MAX_NUM, 1 do
			_frm.childUI["labelPlayerName" .. i].handle._n:setVisible(false)
			_frm.childUI["labelPlayerWaitTimePrefix" .. i].handle._n:setVisible(false)
			_frm.childUI["labelPlayerWaitTime" .. i].handle._n:setVisible(false)
			_frm.childUI["labelPlayerWaitTimePostfix" .. i].handle._n:setVisible(false)
		end
		
		--如果总时间为0，那么延时隐藏该界面
		local maxSeconds = 0
		for i = 1, num, 1 do
			--print("delayPlayer", delayPlayer[i].dbId, delayPlayer[i].kickCD)
			maxSeconds = maxSeconds + (delayPlayer[i].kickCD or 0)
		end
		--print("更新玩家名和剩余时间", maxSeconds)
		if (maxSeconds == 0) then
			--[[
			--0.2秒后删除自身
			local delay = CCDelayTime:create(0.2)
			local actCall = CCCallFunc:create(function(ctrl)
				print("删除!")
				if hGlobal.UI.PhoneDelayPlayerFrm then
					hGlobal.UI.PhoneDelayPlayerFrm:del()
					hGlobal.UI.PhoneDelayPlayerFrm = nil
				end
			end)
			local actSeq = CCSequence:createWithTwoActions(delay, actCall)
			hGlobal.UI.PhoneDelayPlayerFrm.handle._n:runAction(actSeq)
			print("0.2秒后删除自身")
			]]
			
			--print("删除!")
			if hGlobal.UI.PhoneDelayPlayerFrm then
				hGlobal.UI.PhoneDelayPlayerFrm:del()
				hGlobal.UI.PhoneDelayPlayerFrm = nil
			end
		end
		
	end
end

--pvp创建玩家投降的对话框
hApi.ShowPlayerTouXiangFrm = function()
	--删除上一次的投降对话框界面
	if hGlobal.UI.PhonePlayerTouXiangFrm then
		hGlobal.UI.PhonePlayerTouXiangFrm:del()
		hGlobal.UI.PhonePlayerTouXiangFrm = nil
	end
	
	--创建投降对话框界面
	hGlobal.UI.PhonePlayerTouXiangFrm = hUI.frame:new(
	{
		x = hVar.SCREEN.w / 2 - 450 / 2,
		y = hVar.SCREEN.h / 2 + 300 / 2, -- - 20,
		w = 450,
		h = 300,
		dragable = 4, --在外部点击会一直抖动
		show = 1,
		border = -1, --不显示frame边框
		background = -1, --不显示背景图
		--background = "UI:selectbg2",
		autoactive = 0,
		--全部事件
		codeOnDragEx = function(touchX, touchY, touchMode)
			--
		end,
	})
	
	local _frm = hGlobal.UI.PhonePlayerTouXiangFrm
	local _parent = _frm.handle._n
	
	--背景图（九宫格）
	--[[
	--local img9 = CCScale9Sprite:createWithSpriteFrameName("data/image/misc/selectbg2.png")
	local img9 = CCScale9Sprite:create("data/image/misc/selectbg2.png")
	img9:setPosition(ccp(_frm.data.w / 2, -_frm.data.h / 2))
	img9:setContentSize(CCSizeMake(_frm.data.w + 30, _frm.data.h))
	_parent:addChild(img9)
	]]
	--创建9宫格贴图(create)
	hApi.CCScale9SpriteCreate("data/image/misc/selectbg2.png", _frm.data.w / 2, -_frm.data.h / 2, _frm.data.w + 30, _frm.data.h, _frm)
	
	--等待的标题
	_frm.childUI["labelTitle"] = hUI.label:new({
		parent = _parent,
		x = 225,
		y = -65,
		size = 42,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 300,
		text = "",
	})
	
	--创建提示文字
	_frm.childUI["labelHintText"] = hUI.label:new({
		parent = _parent,
		x = 225,
		y = -145,
		size = 26,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 400,
		text = "",
	})
	_frm.childUI["labelHintText"].handle.s:setColor(ccc3(255, 224, 224))
	
	--确定按钮
	_frm.childUI["btnOK"] = hUI.button:new({
		parent = _parent,
		x = 225 + 110 - 5,
		y = -235,
		dragbox = _frm.childUI["dragBox"],
		model = "misc/mask.png",
		w = 210,
		h = 80,
		scaleT = 0.95,
		code = function()
			--返回大厅
			--删除可能的投降对话框界面
			if hGlobal.UI.PhonePlayerTouXiangFrm then
				hGlobal.UI.PhonePlayerTouXiangFrm:del()
				hGlobal.UI.PhonePlayerTouXiangFrm = nil
			end
			
			--删除可能的pvp等待玩家的界面
			if hGlobal.UI.PhoneDelayPlayerFrm then
				hGlobal.UI.PhoneDelayPlayerFrm:del()
				hGlobal.UI.PhoneDelayPlayerFrm = nil
			end
			
			--删除可能的pvp结束界面
			if hGlobal.UI.__GameOverPanel_pvp then
				hGlobal.UI.__GameOverPanel_pvp:del()
				hGlobal.UI.__GameOverPanel_pvp = nil
			end
			
			--删除可能的响应时间过长框界面
			if hGlobal.UI.PhonePlayerNoHeartFrm then
				hGlobal.UI.PhonePlayerNoHeartFrm:del()
				hGlobal.UI.PhonePlayerNoHeartFrm = nil
			end
			
			--geyachao: 先存档
			--存档
			LuaSavePlayerData(g_localfilepath,g_curPlayerName,Save_PlayerData,Save_PlayerLog)
			
			--关闭同步日志文件
			hApi.SyncLogClose()
			--关闭非同步日志文件
			hApi.AsyncLogClose()
			
			--隐藏可能的选人界面
			if hGlobal.UI.PhoneSelectedHeroFrm2 then
				hGlobal.UI.PhoneSelectedHeroFrm2:show(0)
				hGlobal.UI.PhoneSelectedHeroFrmBG.handle.s:setVisible(false) --隐藏背景框挡板
				hApi.clearTimer("__SELECT_HERO_UPDATE__")
				hApi.clearTimer("__SELECT_TOWER_UPDATE__")
				hApi.clearTimer("__SELECT_TACTIC_UPDATE__")
			end
			
			--zhenkira 注释
			local world = hGlobal.WORLD.LastWorldMap
			if (world ~= nil) then
				--玩家主动离开游戏
				local sessionId = world.data.sessionId
				SendPvpCmdFunc["leave_game"](sessionId)
				
				--------------------------------------------------------
				--geyachao: pvp模式，为了防止玩家恶意刷游戏局
				--在投降或逃跑的时候，记录一下本局游戏对战的对手
				--找到对手
				local userId_Enemy = 0 --对手的uid
				local userName_Enemy = "" --对手的名字
				local forceMe = world:GetPlayerMe():getforce()
				for i = 1, 20, 1 do
					local player_i = world.data.PlayerList[i]
					if player_i then
						local force_i = player_i:getforce()
						if(force_i ~= forceMe) then
							if (player_i:gettype() == 1) then --0空 1玩家 2简单电脑 3中等电脑 4困难电脑 5大师电脑 6专家电脑
								userId_Enemy = player_i.data.dbid --找到了
								userName_Enemy = player_i.data.name
								break
							end
						end
					end
				end
				if (userId_Enemy > 0) then
					local session_dbId = world.data.session_dbId --本局的游戏局唯一id
					local userId = userId_Enemy --本局的对手id
					local userName = userName_Enemy --本局的对手名字
					local bUseEquip = world.data.bUseEquip --本局是否携带状态
					local pvpcoinCost = world:GetPlayerMe():getuserdata(1) or 0 --用户自定义数据[1] 本局消耗的兵符
					local gametime = math.floor(world:gametime() / 1000) --本局的游戏时长(秒)
					LuaAddPVPUserInfo(g_curPlayerName, session_dbId, userId, userName, bUseEquip, pvpcoinCost, gametime)
				end
				--------------------------------------------------------
				
				local mapname = world.data.map
				--if hApi.Is_RSYZ_Map(mapname) ~= -1 then
				--	print(".."..nil)
				--	Game_Zone_OnGameEvent(GZone_Event_TypeDef.Lua,{GZone_Event_TypeDef.BattleEnd_Fire,luaGetplayerDataID(),g_RSDYZ_BattleID})
				--end
				
				world:del()
				
				hGlobal.LocalPlayer:setfocusworld(nil)
				hApi.clearCurrentWorldScene()
				
				local tabM = hVar.MAP_INFO[mapname]
				local chapterId = 1
				if tabM then
					chapterId = tabM.chapter or 1
				end
				--hGlobal.event:event("LocalEvent_Phone_ShowPhone_SelecteMap", chapterId)
				--切换到新主界面事件
				hGlobal.event:event("LocalEvent_OpenPhoneMainMenu")
			end
		end,
	})
	_frm.childUI["btnOK"].handle.s:setOpacity(0) --只用于控制，不显示
	
	--确定背景图（九宫格）
	--[[
	local img91 = CCScale9Sprite:createWithSpriteFrameName("data/image/ui/pvp/pvptimeoutbg2.png")
	img91:setPosition(ccp(0, 0))
	img91:setContentSize(CCSizeMake(210, 56))
	_frm.childUI["btnOK"].handle._n:addChild(img91)
	]]
	--创建9宫格贴图(createWithSpriteFrameName)
	hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/pvp/pvptimeoutbg2.png", 0, 0, 210, 56, _frm.childUI["btnOK"])
	
	--确定的文字
	_frm.childUI["btnOK"].childUI["label"] = hUI.label:new({
		parent = _frm.childUI["btnOK"].handle._n,
		x = 0,
		y = -1, --文字有1像素的偏差
		size = 32,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 450,
		--text = "确定", --language
		text = hVar.tab_string["Exit_Ack"], --language
	})
	
	--取消按钮
	_frm.childUI["btnCancel"] = hUI.button:new({
		parent = _parent,
		x = 225 - 110,
		y = -235,
		dragbox = _frm.childUI["dragBox"],
		model = "misc/mask.png",
		w = 210,
		h = 80,
		scaleT = 0.95,
		code = function()
			--删除投降对话框界面
			if hGlobal.UI.PhonePlayerTouXiangFrm then
				hGlobal.UI.PhonePlayerTouXiangFrm:del()
				hGlobal.UI.PhonePlayerTouXiangFrm = nil
			end
		end,
	})
	_frm.childUI["btnCancel"].handle.s:setOpacity(0) --只用于控制，不显示
	
	--取消背景图（九宫格）
	--[[
	local img92 = CCScale9Sprite:createWithSpriteFrameName("data/image/ui/pvp/pvptimeoutbg1.png")
	--local img92 = CCScale9Sprite:create("data/image/misc/card_select_back.png")
	img92:setPosition(ccp(0, 0))
	img92:setContentSize(CCSizeMake(210, 56))
	_frm.childUI["btnCancel"].handle._n:addChild(img92)
	]]
	--创建9宫格贴图(createWithSpriteFrameName)
	hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/pvp/pvptimeoutbg1.png", 0, 0, 210, 56, _frm.childUI["btnCancel"])
	
	--取消的文字
	_frm.childUI["btnCancel"].childUI["label"] = hUI.label:new({
		parent = _frm.childUI["btnCancel"].handle._n,
		x = 0,
		y = -1, --文字有1像素的偏差
		size = 32,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 450,
		--text = "取消", --language
		text = hVar.tab_string["__TEXT_Cancel"], --language
	})
	
	--设置文字
	--检测时间是否满足有效局
	local bLongTime = true
	local world = hGlobal.WORLD.LastWorldMap
	if world then
		local gametime = world:gametime()
		local settime = 1000 * 60 * 3 --3分钟
		if (gametime < settime) then
			bLongTime = false --游戏时长不够
		end
	end
	
	--检测是否有电脑
	local bHaveComputer = false
	if (world.data.session_cfgId == 1) then --pvp配置id(1:娱乐房 / 4:匹配房)
		for i = 1, 20, 1 do
			local player = world.data.PlayerList[i]
			--如果玩家存在并且玩家是电脑
			if player and (player:gettype() >= 2) and (player:gettype() <= 6) then
				bHaveComputer = true --有电脑
			end
		end
	end
	
	--检测是否铜雀台
	local bMultiPve = false
	if (world.data.session_cfgId == 2) then --pvp配置id(2:铜雀台)
		bMultiPve = true
	end
	
	local strTitle = nil --标题
	local strCotnent = nil --正文
	if bHaveComputer then
		--strTitle = "是否离开游戏？" --language
		--strCotnent = "与电脑对战不计入您的战绩" --language
		strTitle = hVar.tab_string["__TEXT_SurrenderConfirm5"] --language
		strCotnent = hVar.tab_string["__TEXT_SurrenderConfirm6"] --language
	elseif bMultiPve then
		--strTitle = "是否离开游戏？" --language
		--strCotnent = "电脑将托管你的队伍继续战斗，通关后您不会获得奖励" --language
		strTitle = hVar.tab_string["__TEXT_SurrenderConfirm5"] --language
		strCotnent = hVar.tab_string["__TEXT_SurrenderConfirm7"] --language
	elseif bLongTime then
		--strTitle = "是否投降？" --language
		--strCotnent = "投降后本局游戏判定为失败" --language
		strTitle = hVar.tab_string["__TEXT_SurrenderConfirm3"] --language
		strCotnent = hVar.tab_string["__TEXT_SurrenderConfirm"] --language
	else
		--strTitle = "是否逃跑？" --language
		--strCotnent = "逃跑后本局游戏判定为无效，并扣除1点战功积分（如果您通过其它方式离开游戏，将受到更大惩罚）" --language
		strTitle = hVar.tab_string["__TEXT_SurrenderConfirm4"] --language
		strCotnent = hVar.tab_string["__TEXT_SurrenderConfirm2"] --language
	end
	
	_frm.childUI["labelTitle"]:setText(strTitle)
	_frm.childUI["labelHintText"]:setText(strCotnent)
end

--同步校验
hApi.CheckSum_Sync = function(bWriteToFile)
	--校验和
	local checkSum_RandomNum = 0 --种子
	local checkSum_UnitNum = 0 --单位数量
	local checkSum_Pos = 0 --单位坐标
	local checkSum_Attr = 0 --单位属性
	
	local world = hGlobal.WORLD.LastWorldMap
	if world then
		--file open
		local file = nil
		if bWriteToFile then
			file = io.open("log/kuaizhao.lua", "w+")
			file:write("local world =" .. "\n")
			file:write("{" .. "\n")
		end
		
		--种子
		local d = world.data
		local logiccount = d.__frameCount - d.__beginFrameCount
		checkSum_RandomNum = checkSum_RandomNum + d.randomSeed + d.randomcount + logiccount
		if bWriteToFile then
			file:write("\t" .. "randomSeed = " .. d.randomSeed .. ",\n")
			file:write("\t" .. "randomcount = " .. d.randomcount .. ",\n")
			file:write("\t" .. "logiccount = " .. logiccount .. ",\n")
		end
		
		if bWriteToFile then
			file:write("\t" .. "cha_list = " .. "\n")
			file:write("\t" .. "{" .. "\n")
		end
		
		--遍历所有单位
		world:enumunit(function(eu)
			local typeId = eu.data.id --类型id
			local a = eu.attr --属性表
			
			checkSum_UnitNum = checkSum_UnitNum + 1
			
			local lastAttackTime_adjust = a.lastAttackTime_adjust --TD角色上次攻击的时间修正值（因为timer精度有误差） --geyachao: 新加数据
			local lastAttackTime = a.lastAttackTime --TD角色上次攻击的时间 --geyachao: 新加数据
			checkSum_Attr = checkSum_Attr + lastAttackTime_adjust + lastAttackTime
			
			local lv = a.lv --zhenkira unit等级
			local star = a.star --zhenkira unit星级
			local pvp_lv = a.pvp_lv --pvp等级
			local pvp_exp = a.pvp_exp --pvp经验值
			checkSum_Attr = checkSum_Attr + lv + star + pvp_lv + pvp_exp
			
			--基础每级成长值
			local hp_lvup = a.hp_lvup --血量每级成长值
			local hp_restore_lvup = a.hp_restore_lvup --回血速度（每秒）每级成长值（支持小数）
			local move_speed_lvup = a.move_speed_lvup --移动速度每级成长值
			local atk_min_lvup = a.atk_min_lvup --最小攻击力每级成长值
			local atk_max_lvup = a.atk_max_lvup --最小攻击力每级成长值
			local atk_radius_lvup = a.atk_radius_lvup --攻击范围每级成长值
			local atk_interval_lvup = a.atk_interval_lvup --攻击间隔每级成长值
			local atk_speed_lvup = a.atk_speed_lvup --攻击速度（去百分号后的值）每级成长值
			local def_physic_lvup = a.def_physic_lvup --物防每级成长值
			local def_magic_lvup = a.def_magic_lvup --法防每级成长值
			local dodge_rate_lvup = a.dodge_rate_lvup --闪避几率（去百分号后的值）每级成长值
			local crit_value_lvup = a.crit_value_lvup --暴击倍数每级成长值（支持小数）
			local rebirth_time_lvup = a.rebirth_time_lvup --复活时间每级成长值（毫秒）
			local suck_blood_rate_lvup = a.suck_blood_rate_lvup --吸血率每级成长值（去百分号后的值）
			local active_skill_cd_delta_lvup = a.active_skill_cd_delta_lvup --主动技能冷却时间变化值每级成长值（毫秒）
			local passive_skill_cd_delta_lvup = a.passive_skill_cd_delta_lvup --被动技能冷却时间变化值每级成长值（毫秒）
			
			checkSum_Attr = checkSum_Attr + hp_lvup + hp_restore_lvup + move_speed_lvup + atk_min_lvup + atk_max_lvup + atk_radius_lvup
						+ atk_interval_lvup + atk_speed_lvup + def_physic_lvup + def_magic_lvup + dodge_rate_lvup + crit_value_lvup
						+ rebirth_time_lvup + suck_blood_rate_lvup + active_skill_cd_delta_lvup + passive_skill_cd_delta_lvup
			
			--pvp每级成长值
			local pvp_hp_lvup = a.pvp_hp_lvup --pvp血量每级成长值
			local pvp_hp_restore_lvup = a.pvp_hp_restore_lvup --pvp回血速度（每秒）每级成长值（支持小数）
			local pvp_move_speed_lvup = a.pvp_move_speed_lvup --pvp移动速度每级成长值
			local pvp_atk_min_lvup = a.pvp_atk_min_lvup --pvp最小攻击力每级成长值
			local pvp_atk_max_lvup = a.pvp_atk_max_lvup --pvp最小攻击力每级成长值
			local pvp_atk_radius_lvup = a.pvp_atk_radius_lvup --pvp攻击范围每级成长值
			local pvp_atk_interval_lvup = a.pvp_atk_interval_lvup --pvp攻击间隔每级成长值
			local pvp_atk_speed_lvup = a.pvp_atk_speed_lvup --pvp攻击速度（去百分号后的值）每级成长值
			local pvp_def_physic_lvup = a.pvp_def_physic_lvup --pvp物防每级成长值
			local pvp_def_magic_lvup = a.pvp_def_magic_lvup --pvp法防每级成长值
			local pvp_dodge_rate_lvup = a.pvp_dodge_rate_lvup --pvp闪避几率（去百分号后的值）每级成长值
			local pvp_crit_value_lvup = a.pvp_crit_value_lvup --pvp暴击倍数每级成长值（支持小数）
			local pvp_rebirth_time_lvup = a.pvp_rebirth_time_lvup --pvp复活时间每级成长值（毫秒）
			local pvp_suck_blood_rate_lvup = a.pvp_suck_blood_rate_lvup --pvp吸血率每级成长值（去百分号后的值）
			local pvp_active_skill_cd_delta_lvup = a.pvp_active_skill_cd_delta_lvup --pvp主动技能冷却时间变化值每级成长值（毫秒）
			local pvp_passive_skill_cd_delta_lvup = a.pvp_passive_skill_cd_delta_lvup --pvp被动技能冷却时间变化值每级成长值（毫秒）
			
			checkSum_Attr = checkSum_Attr + pvp_hp_lvup + pvp_hp_restore_lvup + pvp_move_speed_lvup + pvp_atk_min_lvup + pvp_atk_max_lvup
						+ pvp_atk_radius_lvup + pvp_atk_interval_lvup + pvp_atk_speed_lvup + pvp_def_physic_lvup + pvp_def_magic_lvup
						+ pvp_dodge_rate_lvup + pvp_crit_value_lvup + pvp_rebirth_time_lvup + pvp_suck_blood_rate_lvup
						+ pvp_active_skill_cd_delta_lvup + pvp_passive_skill_cd_delta_lvup
			
			--属性相关
			local hp_max_basic = a.hp_max_basic --基础血量
			local hp_max_item = a.hp_max_item --道具附加血量
			local hp_max_buff = a.hp_max_buff --buff附加血量
			local hp_max_aura = a.hp_max_aura --光环附加血量
			local hp_max_tactic = a.hp_max_tactic --战术技能卡附加血量
			checkSum_Attr = checkSum_Attr + hp_max_basic + hp_max_item + hp_max_buff + hp_max_aura + hp_max_tactic
			
			local hp = a.hp --当前血量
			checkSum_Attr = checkSum_Attr + hp
			
			local atk_basic = a.atk_basic --基础攻击力
			local atk_item = a.atk_item --道具附加攻击力
			local atk_buff = a.atk_buff --buff附加攻击力
			local atk_aura = a.atk_aura --光环附加攻击力
			local atk_tactic = a.atk_tactic --战术技能卡附加攻击力
			checkSum_Attr = checkSum_Attr + atk_basic + atk_item + atk_buff + atk_aura + atk_tactic
			
			local atk_interval_basic = a.atk_interval_basic --基础攻击间隔（毫秒）
			local atk_interval_item = a.atk_interval_item --道具附加攻击间隔（毫秒）
			local atk_interval_buff = a.atk_interval_buff --buff附加攻击间隔（毫秒）
			local atk_interval_aura = a.atk_interval_aura --光环附加攻击间隔（毫秒）
			local atk_interval_tactic = a.atk_interval_tactic --战术技能卡附加攻击间隔（毫秒）
			checkSum_Attr = checkSum_Attr + atk_interval_basic + atk_interval_item + atk_interval_buff + atk_interval_aura + atk_interval_tactic
			
			local atk_speed_basic = a.atk_speed_basic --基础攻击速度（去百分号后的值）
			local atk_speed_item = a.atk_speed_item --道具附加攻击速度（去百分号后的值）
			local atk_speed_buff = a.atk_speed_buff --buff附加攻击速度（去百分号后的值）
			local atk_speed_aura = a.atk_speed_aura --光环附加攻击速度（去百分号后的值）
			local atk_speed_tactic = a.atk_speed_tactic --战术技能卡附加攻击速度（去百分号后的值）
			checkSum_Attr = checkSum_Attr + atk_speed_basic + atk_speed_item + atk_speed_buff + atk_speed_aura + atk_speed_tactic
			
			local move_speed_basic = a.move_speed_basic --基础移动速
			local move_speed_item = a.move_speed_item --道具附加移动速度
			local move_speed_buff = a.move_speed_buff --buff附加移动速度
			local move_speed_aura = a.move_speed_aura --光环附加移动速度
			local move_speed_tactic = a.move_speed_tactic --战术技能卡附加移动速度
			checkSum_Attr = checkSum_Attr + move_speed_basic + move_speed_item + move_speed_buff + move_speed_aura + move_speed_tactic
			
			local atk_radius_basic = a.atk_radius_basic --基础攻击范围
			local atk_radius_item = a.atk_radius_item --道具附加攻击范围
			local atk_radius_buff = a.atk_radius_buff --buff附加攻击范围
			local atk_radius_aura = a.atk_radius_aura --光环附加攻击范围
			local atk_radius_tactic = a.atk_radius_tactic --战术技能卡附加攻击范围
			checkSum_Attr = checkSum_Attr + atk_radius_basic + atk_radius_item + atk_radius_buff + atk_radius_aura + atk_radius_tactic
			
			local atk_radius_min_basic = a.atk_radius_min_basic --基础攻击范围最小值
			local atk_radius_min_item = a.atk_radius_min_item --道具附加攻击范围最小值
			local atk_radius_min_buff = a.atk_radius_min_buff --buff附加攻击范围最小值
			local atk_radius_min_aura = a.atk_radius_min_aura --光环附加攻击范围最小值
			local atk_radius_min_tactic = a.atk_radius_min_tactic --战术技能卡附加攻击范围
			checkSum_Attr = checkSum_Attr + atk_radius_min_basic + atk_radius_min_item + atk_radius_min_buff + atk_radius_min_aura + atk_radius_min_tactic
			
			local def_physic_basic = a.def_physic_basic --基础物防
			local def_physic_item = a.def_physic_item --道具附加物防
			local def_physic_buff = a.def_physic_buff --buff附加物防
			local def_physic_aura = a.def_physic_aura --光环附加物防
			local def_physic_tactic = a.def_physic_tactic --战术技能卡附加物防
			checkSum_Attr = checkSum_Attr + def_physic_basic + def_physic_item + def_physic_buff + def_physic_aura + def_physic_tactic
			
			local def_magic_basic = a.def_magic_basic --基础法防
			local def_magic_item = a.def_magic_item --道具附加法防
			local def_magic_buff = a.def_magic_buff --buff附加法防
			local def_magic_aura = a.def_magic_aura --光环附加法防
			local def_magic_tactic = a.def_magic_tactic --战术技能卡附加法防
			checkSum_Attr = checkSum_Attr + def_magic_basic + def_magic_item + def_magic_buff + def_magic_aura + def_magic_tactic
			
			local dodge_rate_basic = a.dodge_rate_basic --基础闪避几率（去百分号后的值）
			local dodge_rate_item = a.dodge_rate_item --道具附加闪避几率（去百分号后的值）
			local dodge_rate_buff = a.dodge_rate_buff --buff附加闪避几率（去百分号后的值）
			local dodge_rate_aura = a.dodge_rate_aura --光环附加闪避几率（去百分号后的值）
			local dodge_rate_tactic = a.dodge_rate_tactic --战术技能卡附加闪避几率（去百分号后的值）
			checkSum_Attr = checkSum_Attr + dodge_rate_basic + dodge_rate_item + dodge_rate_buff + dodge_rate_aura + dodge_rate_tactic
			
			local crit_rate_basic = a.crit_rate_basic --基础暴击几率（去百分号后的值）
			local crit_rate_item = a.crit_rate_item --道具附加暴击几率（去百分号后的值）
			local crit_rate_buff = a.crit_rate_buff --buff附加暴击几率（去百分号后的值）
			local crit_rate_aura = a.crit_rate_aura --光环附加暴击几率（去百分号后的值）
			local crit_rate_tactic = a.crit_rate_tactic --战术技能卡附加暴击几率（去百分号后的值）
			checkSum_Attr = checkSum_Attr + crit_rate_basic + crit_rate_item + crit_rate_buff + crit_rate_aura + crit_rate_tactic
			
			local crit_value_basic = a.crit_value_basic --基础暴击倍数（支持小数）
			local crit_value_item = a.crit_value_item --道具附加暴击倍数（支持小数）
			local crit_value_buff = a.crit_value_buff --buff附加暴击倍数（支持小数）
			local crit_value_aura = a.crit_value_aura --光环附加暴击倍数（支持小数）
			local crit_value_tactic = a.crit_value_tactic --战术技能卡附加暴击倍数（支持小数）
			checkSum_Attr = checkSum_Attr + crit_value_basic + crit_value_item + crit_value_buff + crit_value_aura + crit_value_tactic
			
			local kill_gold_basic = a.kill_gold_basic --基础击杀获得的金币
			local kill_gold_item = a.kill_gold_item --道具附加击杀获得的金币
			local kill_gold_buff = a.kill_gold_buff --buff附加击杀获得的金币
			local kill_gold_aura = a.kill_gold_aura --光环附加击杀获得的金币
			local kill_gold_tactic = a.kill_gold_tactic --战术技能卡附加击杀获得的金币
			checkSum_Attr = checkSum_Attr + kill_gold_basic + kill_gold_item + kill_gold_buff + kill_gold_aura + kill_gold_tactic
			
			local escape_punish_basic = a.escape_punish_basic --基础逃怪惩罚
			local escape_punish_item = a.escape_punish_item --道具附加逃怪惩罚
			local escape_punish_buff = a.escape_punish_buff --buff附加逃怪惩罚
			local escape_punish_aura = a.escape_punish_aura --光环附加逃怪惩罚
			local escape_punish_tactic = a.escape_punish_tactic --战术技能卡附加逃怪惩罚
			checkSum_Attr = checkSum_Attr + escape_punish_basic + escape_punish_item + escape_punish_buff + escape_punish_aura + escape_punish_tactic
			
			local hp_restore_basic = a.hp_restore_basic --基础回血速度（每秒）（支持小数）
			local hp_restore_item = a.hp_restore_item --道具附加回血速度（每秒）（支持小数）
			local hp_restore_buff = a.hp_restore_buff --buff附加回血速度（每秒）（支持小数）
			local hp_restore_aura = a.hp_restore_aura --光环附加回血速度（每秒）（支持小数）
			local hp_restore_tactic = a.hp_restore_tactic --战术技能卡附加回血速度（每秒）（支持小数）
			checkSum_Attr = checkSum_Attr + hp_restore_basic + hp_restore_item + hp_restore_buff + hp_restore_aura + hp_restore_tactic
			
			local hp_restore_float_value = a.hp_restore_float_value --当前的回血小数值
			checkSum_Attr = checkSum_Attr + hp_restore_float_value
			
			local rebirth_time_basic = a.rebirth_time_basic --基础复活时间（毫秒）
			local rebirth_time_item = a.rebirth_time_item --道具附加复活时间（毫秒）
			local rebirth_time_buff = a.rebirth_time_buff --buff附加复活时间（毫秒）
			local rebirth_time_aura = a.rebirth_time_aura --光环附加复活时间（毫秒）
			local rebirth_time_tactic = a.rebirth_time_tactic ---战术技能卡附加复活时间（毫秒）
			checkSum_Attr = checkSum_Attr + rebirth_time_basic + rebirth_time_item + rebirth_time_buff + rebirth_time_aura + rebirth_time_tactic
			
			local suck_blood_rate_basic = a.suck_blood_rate_basic --基础吸血率（去百分号后的值）
			local suck_blood_rate_item = a.suck_blood_rate_item --道具吸血率（去百分号后的值）
			local suck_blood_rate_buff = a.suck_blood_rate_buff --buff吸血率（去百分号后的值）
			local suck_blood_rate_aura = a.suck_blood_rate_aura --光环吸血率（去百分号后的值）
			local suck_blood_rate_tactic = a.suck_blood_rate_tactic --战术技能卡吸血率（去百分号后的值）
			checkSum_Attr = checkSum_Attr + suck_blood_rate_basic + suck_blood_rate_item + suck_blood_rate_buff + suck_blood_rate_aura + suck_blood_rate_tactic
			
			local active_skill_cd_delta_basic = a.active_skill_cd_delta_basic --基础主动技能冷却时间变化值（毫秒）
			local active_skill_cd_delta_item = a.active_skill_cd_delta_item --道具主动技能冷却时间变化值（毫秒）
			local active_skill_cd_delta_buff = a.active_skill_cd_delta_buff --buff主动技能冷却时间变化值（毫秒）
			local active_skill_cd_delta_aura = a.active_skill_cd_delta_aura --光环主动技能冷却时间变化值（毫秒）
			local active_skill_cd_delta_tactic = a.active_skill_cd_delta_tactic --战术技能卡主动技能冷却时间变化值（毫秒）
			checkSum_Attr = checkSum_Attr + active_skill_cd_delta_basic + active_skill_cd_delta_item + active_skill_cd_delta_buff + active_skill_cd_delta_aura + active_skill_cd_delta_tactic
			
			local active_skill_cd_delta_rate_basic = a.active_skill_cd_delta_rate_basic --基础主动技能冷却时间变化比例值（去百分号后的值）
			local active_skill_cd_delta_rate_item = a.active_skill_cd_delta_rate_item --道具主动技能冷却时间变化比例值（去百分号后的值）
			local active_skill_cd_delta_rate_buff = a.active_skill_cd_delta_rate_buff --buff主动技能冷却时间变化比例值（去百分号后的值）
			local active_skill_cd_delta_rate_aura = a.active_skill_cd_delta_rate_aura --光环主动技能冷却时间变化比例值（去百分号后的值）
			local active_skill_cd_delta_rate_tactic = a.active_skill_cd_delta_rate_tactic --战术技能卡主动技能冷却时间变化比例值（去百分号后的值）
			checkSum_Attr = checkSum_Attr + active_skill_cd_delta_rate_basic + active_skill_cd_delta_rate_item + active_skill_cd_delta_rate_buff + active_skill_cd_delta_rate_aura + active_skill_cd_delta_rate_tactic
			
			local passive_skill_cd_delta_basic = a.passive_skill_cd_delta_basic --基础被动技能冷却时间变化值（毫秒）
			local passive_skill_cd_delta_item = a.passive_skill_cd_delta_item --道具被动技能冷却时间变化值（毫秒）
			local passive_skill_cd_delta_buff = a.passive_skill_cd_delta_buff --buff被动技能冷却时间变化值（毫秒）
			local passive_skill_cd_delta_aura = a.passive_skill_cd_delta_aura --光环被动技能冷却时间变化值（毫秒）
			local passive_skill_cd_delta_tactic = a.passive_skill_cd_delta_tactic --战术技能卡被动技能冷却时间变化值（毫秒）
			checkSum_Attr = checkSum_Attr + passive_skill_cd_delta_basic + passive_skill_cd_delta_item + passive_skill_cd_delta_buff + passive_skill_cd_delta_aura + passive_skill_cd_delta_tactic
			
			local passive_skill_cd_delta_rate_basic = a.passive_skill_cd_delta_rate_basic --基础被动技能冷却时间变化比例值（去百分号后的值）
			local passive_skill_cd_delta_rate_item = a.passive_skill_cd_delta_rate_item --道具被动技能冷却时间变化比例值（去百分号后的值）
			local passive_skill_cd_delta_rate_buff = a.passive_skill_cd_delta_rate_buff --buff被动技能冷却时间变化比例值（去百分号后的值）
			local passive_skill_cd_delta_rate_aura = a.passive_skill_cd_delta_rate_aura --光环被动技能冷却时间变化比例值（去百分号后的值）
			local passive_skill_cd_delta_rate_tactic = a.passive_skill_cd_delta_rate_tactic --战术技能卡被动技能冷却时间变化比例值（去百分号后的值）
			checkSum_Attr = checkSum_Attr + passive_skill_cd_delta_rate_basic + passive_skill_cd_delta_rate_item + passive_skill_cd_delta_rate_buff + passive_skill_cd_delta_rate_aura + passive_skill_cd_delta_rate_tactic
			
			local AI_attribute_basic = a.AI_attribute_basic --基础AI行为（0：被动怪 / 1:主动怪）
			local AI_attribute_item = a.AI_attribute_item --道具AI行为（0：被动怪 / 1:主动怪）
			local AI_attribute_buff = a.AI_attribute_buff --buffAI行为（0：被动怪 / 1:主动怪）
			local AI_attribute_aura = a.AI_attribute_aura --光环AI行为（0：被动怪 / 1:主动怪）
			local AI_attribute_tactic = a.AI_attribute_tactic --战术技能卡AI行为（0：被动怪 / 1:主动怪）
			checkSum_Attr = checkSum_Attr + AI_attribute_basic + AI_attribute_item + AI_attribute_buff + AI_attribute_aura + AI_attribute_tactic
			
			local rebirth_wudi_time_basic = a.rebirth_wudi_time_basic --基础复活后无敌时间（毫秒）
			local rebirth_wudi_time_item = a.rebirth_wudi_time_item --道具复活后无敌时间（毫秒）
			local rebirth_wudi_time_buff = a.rebirth_wudi_time_buff --buff复活后无敌时间（毫秒）
			local rebirth_wudi_time_aura = a.rebirth_wudi_time_aura --光环复活后无敌时间（毫秒）
			local rebirth_wudi_time_tactic = a.rebirth_wudi_time_tactic --战术技能卡复活后无敌时间（毫秒）
			checkSum_Attr = checkSum_Attr + rebirth_wudi_time_basic + rebirth_wudi_time_item + rebirth_wudi_time_buff + rebirth_wudi_time_aura + rebirth_wudi_time_tactic
			
			local basic_weapon_level_basic = a.basic_weapon_level_basic --基础武器等级
			local basic_weapon_level_item = a.basic_weapon_level_item --道具武器等级
			local basic_weapon_level_buff = a.basic_weapon_level_buff --buff武器等级
			local basic_weapon_level_aura = a.basic_weapon_level_aura --光环武器等级
			local basic_weapon_level_tactic = a.basic_weapon_level_tactic --战术技能卡武器等级
			checkSum_Attr = checkSum_Attr + basic_weapon_level_basic + basic_weapon_level_item + basic_weapon_level_buff + basic_weapon_level_aura + basic_weapon_level_tactic
			
			local basic_skill_level_basic = a.basic_skill_level_basic --基础武器等级
			local basic_skill_level_item = a.basic_skill_level_item --道具武器等级
			local basic_skill_level_buff = a.basic_skill_level_buff --buff武器等级
			local basic_skill_level_aura = a.basic_skill_level_aura --光环武器等级
			local basic_skill_level_tactic = a.basic_skill_level_tactic --战术技能卡武器等级
			checkSum_Attr = checkSum_Attr + basic_skill_level_basic + basic_skill_level_item + basic_skill_level_buff + basic_skill_level_aura + basic_skill_level_tactic
			
			local basic_skill_usecount_basic = a.basic_skill_usecount_basic --基础武器使用次数
			local basic_skill_usecount_item = a.basic_skill_usecount_item --道具武器使用次数
			local basic_skill_usecount_buff = a.basic_skill_usecount_buff --buff武器使用次数
			local basic_skill_usecount_aura = a.basic_skill_usecount_aura --光环武器使用次数
			local basic_skill_usecount_tactic = a.basic_skill_usecount_tactic --战术技能卡武器使用次数
			checkSum_Attr = checkSum_Attr + basic_skill_usecount_basic + basic_skill_usecount_item + basic_skill_usecount_buff + basic_skill_usecount_aura + basic_skill_usecount_tactic
			
			--坐标
			local ex, ey = hApi.chaGetPos(eu.handle)
			checkSum_Pos = checkSum_Pos + ex + ey
			
			if bWriteToFile then
				local name = eu.data.name
				file:write("\t\t" .. "--" .. name .. "\n")
				file:write("\t\t" .. "[" .. typeId .. "] = " .. "\n")
				file:write("\t\t" .. "{" .. "\n")
				
				--打出属性
				file:write("\t\t\t" .. "pos_x = " .. ex .. ",\n")
				file:write("\t\t\t" .. "pos_y = " .. ey .. ",\n")
				file:write("\t\t\t" .. "\n") --回车
				
				file:write("\t\t\t" .. "lv = " .. lv .. ",\n")
				file:write("\t\t\t" .. "star = " .. star .. ",\n")
				file:write("\t\t\t" .. "\n") --回车
				
				--每级成长值
				file:write("\t\t\t" .. "hp_lvup = " .. hp_lvup .. ",\n") --血量每级成长值
				file:write("\t\t\t" .. "hp_restore_lvup = " .. hp_restore_lvup .. ",\n") --回血速度（每秒）每级成长值（支持小数）
				file:write("\t\t\t" .. "move_speed_lvup = " .. move_speed_lvup .. ",\n") --移动速度每级成长值
				file:write("\t\t\t" .. "atk_min_lvup = " .. atk_min_lvup .. ",\n") --最小攻击力每级成长值
				file:write("\t\t\t" .. "atk_max_lvup = " .. atk_max_lvup .. ",\n") --最大攻击力每级成长值
				file:write("\t\t\t" .. "atk_radius_lvup = " .. atk_radius_lvup .. ",\n") --攻击范围每级成长值
				file:write("\t\t\t" .. "atk_interval_lvup = " .. atk_interval_lvup .. ",\n") --攻击间隔每级成长值
				file:write("\t\t\t" .. "atk_speed_lvup = " .. atk_speed_lvup .. ",\n") --攻击速度（去百分号后的值）每级成长值
				file:write("\t\t\t" .. "def_physic_lvup = " .. def_physic_lvup .. ",\n") --物防每级成长值
				file:write("\t\t\t" .. "def_magic_lvup = " .. def_magic_lvup .. ",\n") --法防每级成长值
				file:write("\t\t\t" .. "dodge_rate_lvup = " .. dodge_rate_lvup .. ",\n") --闪避几率（去百分号后的值）每级成长值
				file:write("\t\t\t" .. "crit_value_lvup = " .. crit_value_lvup .. ",\n") --暴击倍数每级成长值（支持小数）
				file:write("\t\t\t" .. "rebirth_time_lvup = " .. rebirth_time_lvup .. ",\n") --复活时间每级成长值（毫秒）
				file:write("\t\t\t" .. "suck_blood_rate_lvup = " .. suck_blood_rate_lvup .. ",\n") --吸血率每级成长值（去百分号后的值）
				file:write("\t\t\t" .. "rebirth_time_lvup = " .. rebirth_time_lvup .. ",\n") --复活时间每级成长值（毫秒）
				file:write("\t\t\t" .. "\n") --回车
				
				--属性相关
				file:write("\t\t\t" .. "hp_max_basic = " .. hp_max_basic .. ",\n") --基础血量
				file:write("\t\t\t" .. "hp_max_item = " .. hp_max_item .. ",\n") --道具附加血量
				file:write("\t\t\t" .. "hp_max_buff = " .. hp_max_buff .. ",\n") --buff附加血量
				file:write("\t\t\t" .. "hp_max_aura = " .. hp_max_aura .. ",\n") --光环附加血量
				file:write("\t\t\t" .. "hp_max_tactic = " .. hp_max_tactic .. ",\n") --战术技能卡附加血量
				
				file:write("\t\t\t" .. "hp = " .. hp .. ",\n") --当前血量
				
				file:write("\t\t\t" .. "atk_basic = " .. atk_basic .. ",\n") --基础攻击力
				file:write("\t\t\t" .. "atk_item = " .. atk_item .. ",\n") --道具附加攻击力
				file:write("\t\t\t" .. "atk_buff = " .. atk_buff .. ",\n") --buff附加攻击力
				file:write("\t\t\t" .. "atk_aura = " .. atk_aura .. ",\n") --光环附加攻击力
				file:write("\t\t\t" .. "atk_tactic = " .. atk_tactic .. ",\n") --战术技能卡附加攻击力
				
				file:write("\t\t\t" .. "atk_interval_basic = " .. atk_interval_basic .. ",\n") --基础攻击间隔（毫秒）
				file:write("\t\t\t" .. "atk_interval_item = " .. atk_interval_item .. ",\n") --道具附加攻击间隔（毫秒）
				file:write("\t\t\t" .. "atk_interval_buff = " .. atk_interval_buff .. ",\n") --buff附加攻击间隔（毫秒）
				file:write("\t\t\t" .. "atk_interval_aura = " .. atk_interval_aura .. ",\n") --光环附加攻击间隔（毫秒）
				file:write("\t\t\t" .. "atk_interval_tactic = " .. atk_interval_tactic .. ",\n") --战术技能卡附加攻击间隔（毫秒）
				
				file:write("\t\t\t" .. "atk_speed_basic = " .. atk_speed_basic .. ",\n") --基础攻击速度（去百分号后的值）
				file:write("\t\t\t" .. "atk_speed_item = " .. atk_speed_item .. ",\n") --道具附加攻击速度（去百分号后的值）
				file:write("\t\t\t" .. "atk_speed_buff = " .. atk_speed_buff .. ",\n") --buff附加攻击速度（去百分号后的值）
				file:write("\t\t\t" .. "atk_speed_aura = " .. atk_speed_aura .. ",\n") --光环附加攻击速度（去百分号后的值）
				file:write("\t\t\t" .. "atk_speed_tactic = " .. atk_speed_tactic .. ",\n") --战术技能卡附加攻击速度（去百分号后的值）
				
				file:write("\t\t\t" .. "move_speed_basic = " .. move_speed_basic .. ",\n") --基础移动速
				file:write("\t\t\t" .. "move_speed_item = " .. move_speed_item .. ",\n") --道具附加移动速度
				file:write("\t\t\t" .. "move_speed_buff = " .. move_speed_buff .. ",\n") --buff附加移动速度
				file:write("\t\t\t" .. "move_speed_aura = " .. move_speed_aura .. ",\n") --光环附加移动速度
				file:write("\t\t\t" .. "move_speed_tactic = " .. move_speed_tactic .. ",\n") --战术技能卡附加移动速度
				
				file:write("\t\t\t" .. "atk_radius_basic = " .. atk_radius_basic .. ",\n") --基础攻击范围
				file:write("\t\t\t" .. "atk_radius_item = " .. atk_radius_item .. ",\n") --道具附加攻击范围
				file:write("\t\t\t" .. "atk_radius_buff = " .. atk_radius_buff .. ",\n") --buff附加攻击范围
				file:write("\t\t\t" .. "atk_radius_aura = " .. atk_radius_aura .. ",\n") --光环附加攻击范围
				file:write("\t\t\t" .. "atk_radius_tactic = " .. atk_radius_tactic .. ",\n") --战术技能卡附加攻击范围
				
				file:write("\t\t\t" .. "atk_radius_min_basic = " .. atk_radius_min_basic .. ",\n") --基础攻击范围最小值
				file:write("\t\t\t" .. "atk_radius_min_item = " .. atk_radius_min_item .. ",\n") --道具附加攻击范围最小值
				file:write("\t\t\t" .. "atk_radius_min_buff = " .. atk_radius_min_buff .. ",\n") --buff附加攻击范围最小值
				file:write("\t\t\t" .. "atk_radius_min_aura = " .. atk_radius_min_aura .. ",\n") --光环附加攻击范围最小值
				file:write("\t\t\t" .. "atk_radius_min_tactic = " .. atk_radius_min_tactic .. ",\n") --战术技能卡附加攻击范围最小值
				
				file:write("\t\t\t" .. "def_physic_basic = " .. def_physic_basic .. ",\n") --基础物防
				file:write("\t\t\t" .. "def_physic_item = " .. def_physic_item .. ",\n") --道具附加物防
				file:write("\t\t\t" .. "def_physic_buff = " .. def_physic_buff .. ",\n") --buff附加物防
				file:write("\t\t\t" .. "def_physic_aura = " .. def_physic_aura .. ",\n") --光环附加物防
				file:write("\t\t\t" .. "def_physic_tactic = " .. def_physic_tactic .. ",\n") --战术技能卡附加物防
				
				file:write("\t\t\t" .. "def_magic_basic = " .. def_magic_basic .. ",\n") --基础法防
				file:write("\t\t\t" .. "def_magic_item = " .. def_magic_item .. ",\n") --道具附加法防
				file:write("\t\t\t" .. "def_magic_buff = " .. def_magic_buff .. ",\n") --buff附加法防
				file:write("\t\t\t" .. "def_magic_aura = " .. def_magic_aura .. ",\n") --光环附加法防
				file:write("\t\t\t" .. "def_magic_tactic = " .. def_magic_tactic .. ",\n") --战术技能卡附加法防
				
				file:write("\t\t\t" .. "dodge_rate_basic = " .. dodge_rate_basic .. ",\n") --基础闪避几率（去百分号后的值）
				file:write("\t\t\t" .. "dodge_rate_item = " .. dodge_rate_item .. ",\n") --道具附加闪避几率（去百分号后的值）
				file:write("\t\t\t" .. "dodge_rate_buff = " .. dodge_rate_buff .. ",\n") --buff附加闪避几率（去百分号后的值）
				file:write("\t\t\t" .. "dodge_rate_aura = " .. dodge_rate_aura .. ",\n") --光环附加闪避几率（去百分号后的值）
				file:write("\t\t\t" .. "dodge_rate_tactic = " .. dodge_rate_tactic .. ",\n") --战术技能卡附加闪避几率（去百分号后的值）
				
				file:write("\t\t\t" .. "crit_rate_basic = " .. crit_rate_basic .. ",\n") --基础暴击几率（去百分号后的值）
				file:write("\t\t\t" .. "crit_rate_item = " .. crit_rate_item .. ",\n") --道具附加暴击几率（去百分号后的值）
				file:write("\t\t\t" .. "crit_rate_buff = " .. crit_rate_buff .. ",\n") --buff附加暴击几率（去百分号后的值）
				file:write("\t\t\t" .. "crit_rate_aura = " .. crit_rate_aura .. ",\n") --光环附加暴击几率（去百分号后的值）
				file:write("\t\t\t" .. "crit_rate_tactic = " .. crit_rate_tactic .. ",\n") --战术技能卡附加暴击几率（去百分号后的值）
				
				file:write("\t\t\t" .. "crit_value_basic = " .. crit_value_basic .. ",\n") --基础暴击倍数（支持小数）
				file:write("\t\t\t" .. "crit_value_item = " .. crit_value_item .. ",\n") --道具附加暴击倍数（支持小数）
				file:write("\t\t\t" .. "crit_value_buff = " .. crit_value_buff .. ",\n") --buff附加暴击倍数（支持小数）
				file:write("\t\t\t" .. "crit_value_aura = " .. crit_value_aura .. ",\n") --光环附加暴击倍数（支持小数）
				file:write("\t\t\t" .. "crit_value_tactic = " .. crit_value_tactic .. ",\n") --战术技能卡附加暴击倍数（支持小数）
				
				file:write("\t\t\t" .. "kill_gold_basic = " .. kill_gold_basic .. ",\n") --基础击杀获得的金币
				file:write("\t\t\t" .. "kill_gold_item = " .. kill_gold_item .. ",\n") --道具附加击杀获得的金币
				file:write("\t\t\t" .. "kill_gold_buff = " .. kill_gold_buff .. ",\n") --buff附加击杀获得的金币
				file:write("\t\t\t" .. "kill_gold_aura = " .. kill_gold_aura .. ",\n") --光环附加击杀获得的金币
				file:write("\t\t\t" .. "kill_gold_tactic = " .. kill_gold_tactic .. ",\n") --战术技能卡附加击杀获得的金币
				
				file:write("\t\t\t" .. "escape_punish_basic = " .. escape_punish_basic .. ",\n") --基础逃怪惩罚
				file:write("\t\t\t" .. "escape_punish_item = " .. escape_punish_item .. ",\n") --道具附加逃怪惩罚
				file:write("\t\t\t" .. "escape_punish_buff = " .. escape_punish_buff .. ",\n") --buff附加逃怪惩罚
				file:write("\t\t\t" .. "escape_punish_aura = " .. escape_punish_aura .. ",\n") --光环附加逃怪惩罚
				file:write("\t\t\t" .. "escape_punish_tactic = " .. escape_punish_tactic .. ",\n") --战术技能卡附加逃怪惩罚
				
				file:write("\t\t\t" .. "hp_restore_basic = " .. hp_restore_basic .. ",\n") --基础回血速度（每秒）（支持小数）
				file:write("\t\t\t" .. "hp_restore_item = " .. hp_restore_item .. ",\n") --道具附加回血速度（每秒）（支持小数）
				file:write("\t\t\t" .. "hp_restore_buff = " .. hp_restore_buff .. ",\n") --buff附加回血速度（每秒）（支持小数）
				file:write("\t\t\t" .. "hp_restore_aura = " .. hp_restore_aura .. ",\n") --光环附加回血速度（每秒）（支持小数）
				file:write("\t\t\t" .. "hp_restore_tactic = " .. hp_restore_tactic .. ",\n") --战术技能卡附加回血速度（每秒）（支持小数）
				
				file:write("\t\t\t" .. "hp_restore_float_value = " .. hp_restore_float_value .. ",\n") --当前的回血小数值
				
				file:write("\t\t\t" .. "rebirth_time_basic = " .. rebirth_time_basic .. ",\n") --基础复活时间（毫秒）
				file:write("\t\t\t" .. "rebirth_time_item = " .. rebirth_time_item .. ",\n") --道具附加复活时间（毫秒）
				file:write("\t\t\t" .. "rebirth_time_buff = " .. rebirth_time_buff .. ",\n") --buff附加复活时间（毫秒）
				file:write("\t\t\t" .. "rebirth_time_aura = " .. rebirth_time_aura .. ",\n") --光环附加复活时间（毫秒）
				file:write("\t\t\t" .. "rebirth_time_tactic = " .. rebirth_time_tactic .. ",\n") --战术技能卡附加复活时间（毫秒）
				
				file:write("\t\t\t" .. "suck_blood_rate_basic = " .. suck_blood_rate_basic .. ",\n") --基础吸血率（去百分号后的值）
				file:write("\t\t\t" .. "suck_blood_rate_item = " .. suck_blood_rate_item .. ",\n") --道具吸血率（去百分号后的值）
				file:write("\t\t\t" .. "suck_blood_rate_buff = " .. suck_blood_rate_buff .. ",\n") --buff吸血率（去百分号后的值）
				file:write("\t\t\t" .. "suck_blood_rate_aura = " .. suck_blood_rate_aura .. ",\n") --光环吸血率（去百分号后的值）
				file:write("\t\t\t" .. "suck_blood_rate_tactic = " .. suck_blood_rate_tactic .. ",\n") --战术技能卡吸血率（去百分号后的值）
				
				file:write("\t\t\t" .. "active_skill_cd_delta_basic = " .. active_skill_cd_delta_basic .. ",\n") --基础主动技能冷却时间变化值（毫秒）
				file:write("\t\t\t" .. "active_skill_cd_delta_item = " .. active_skill_cd_delta_item .. ",\n") --道具主动技能冷却时间变化值（毫秒）
				file:write("\t\t\t" .. "active_skill_cd_delta_buff = " .. active_skill_cd_delta_buff .. ",\n") --buff主动技能冷却时间变化值（毫秒）
				file:write("\t\t\t" .. "active_skill_cd_delta_aura = " .. active_skill_cd_delta_aura .. ",\n") --光环主动技能冷却时间变化值（毫秒）
				file:write("\t\t\t" .. "active_skill_cd_delta_tactic = " .. active_skill_cd_delta_tactic .. ",\n") --战术技能卡主动技能冷却时间变化值（毫秒）
				
				file:write("\t\t\t" .. "active_skill_cd_delta_rate_basic = " .. active_skill_cd_delta_rate_basic .. ",\n") --基础主动技能冷却时间变化比例值（去百分号后的值）
				file:write("\t\t\t" .. "active_skill_cd_delta_rate_item = " .. active_skill_cd_delta_rate_item .. ",\n") --道具主动技能冷却时间变化比例值（去百分号后的值）
				file:write("\t\t\t" .. "active_skill_cd_delta_rate_buff = " .. active_skill_cd_delta_rate_buff .. ",\n") --buff主动技能冷却时间变化比例值（去百分号后的值）
				file:write("\t\t\t" .. "active_skill_cd_delta_rate_aura = " .. active_skill_cd_delta_rate_aura .. ",\n") --光环主动技能冷却时间变化比例值（去百分号后的值）
				file:write("\t\t\t" .. "active_skill_cd_delta_rate_tactic = " .. active_skill_cd_delta_rate_tactic .. ",\n") --战术技能卡主动技能冷却时间变化比例值（去百分号后的值）
				
				file:write("\t\t\t" .. "passive_skill_cd_delta_basic = " .. passive_skill_cd_delta_basic .. ",\n") --基础被动技能冷却时间变化值（毫秒）
				file:write("\t\t\t" .. "passive_skill_cd_delta_item = " .. passive_skill_cd_delta_item .. ",\n") --道具被动技能冷却时间变化值（毫秒）
				file:write("\t\t\t" .. "passive_skill_cd_delta_buff = " .. passive_skill_cd_delta_buff .. ",\n") --buff被动技能冷却时间变化值（毫秒）
				file:write("\t\t\t" .. "passive_skill_cd_delta_aura = " .. passive_skill_cd_delta_aura .. ",\n") --光环被动技能冷却时间变化值（毫秒）
				file:write("\t\t\t" .. "passive_skill_cd_delta_tactic = " .. passive_skill_cd_delta_tactic .. ",\n") --战术技能卡被动技能冷却时间变化值（毫秒）
				
				file:write("\t\t\t" .. "passive_skill_cd_delta_rate_basic = " .. passive_skill_cd_delta_rate_basic .. ",\n") --基础被动技能冷却时间变化比例值（去百分号后的值）
				file:write("\t\t\t" .. "passive_skill_cd_delta_rate_item = " .. passive_skill_cd_delta_rate_item .. ",\n") --道具被动技能冷却时间变化比例值（去百分号后的值）
				file:write("\t\t\t" .. "passive_skill_cd_delta_rate_buff = " .. passive_skill_cd_delta_rate_buff .. ",\n") --buff被动技能冷却时间变化比例值（去百分号后的值）
				file:write("\t\t\t" .. "passive_skill_cd_delta_rate_aura = " .. passive_skill_cd_delta_rate_aura .. ",\n") --光环被动技能冷却时间变化比例值（去百分号后的值）
				file:write("\t\t\t" .. "passive_skill_cd_delta_rate_tactic = " .. passive_skill_cd_delta_rate_tactic .. ",\n") --战术技能卡被动技能冷却时间变化比例值（去百分号后的值）
				
				file:write("\t\t\t" .. "AI_attribute_basic = " .. AI_attribute_basic .. ",\n") --基础AI行为（0：被动怪 / 1:主动怪）
				file:write("\t\t\t" .. "AI_attribute_item = " .. AI_attribute_item .. ",\n") --道具AI行为（0：被动怪 / 1:主动怪）
				file:write("\t\t\t" .. "AI_attribute_buff = " .. AI_attribute_buff .. ",\n") --buffAI行为（0：被动怪 / 1:主动怪）
				file:write("\t\t\t" .. "AI_attribute_aura = " .. AI_attribute_aura .. ",\n") --光环AI行为（0：被动怪 / 1:主动怪）
				file:write("\t\t\t" .. "AI_attribute_tactic = " .. AI_attribute_tactic .. ",\n") --战术技能卡AI行为（0：被动怪 / 1:主动怪）
				
				file:write("\t\t" .. "}," .. "\n")
				file:write("\t\t" .. "\n")
			end
		end)
		
		if bWriteToFile then
			file:write("\t" .. "}," .. "\n")
		end
		
		--file close
		if bWriteToFile then
			file:write("}" .. "\n")
			file:close()
		end
	end
	
	return checkSum_RandomNum, checkSum_UnitNum, checkSum_Pos, checkSum_Attr
end

--geyachao: 检测ui.plist图的spriteframe是否被释放，如果被释放就恢复
hApi.Restore_UI_PVP_PLIST = function()
	--检测 ui.plist的spriteframe是否存在
	local texture_ui = CCTextureCache:sharedTextureCache():textureForKey("data/image/ui.png")
	if texture_ui then
		local sprite_tanhao = CCSpriteFrameCache:sharedSpriteFrameCache():spriteFrameByName("data/image/ui/TaskTanHao.png")
		if (sprite_tanhao == nil) then
			xlLoadResourceFromPList("data/image/ui.plist")
			
			--[[
			--geyachao: 调试代码专用弹框
			--测试 --test
			local strText = "重新加载ui.plist！"
			hGlobal.UI.MsgBox(strText,{
				font = hVar.FONTC,
				ok = function()
				end,
			})
			]]
		end
	end
end

--添加游戏信息文本
local _game_info_text = "" --游戏信息文本
hApi.AppendGameInfo = function(text, bCovered)
	if text then
		if bCovered then
			_game_info_text = ("%s\n"):format(tostring(text))
		else
			_game_info_text = ("%s%s\n"):format(_game_info_text, tostring(text))
		end
	else
		if bCovered then
			_game_info_text = ""
		end
	end
end

--获得游戏信息文本
hApi.GetGameInfo = function()
	return _game_info_text
end

--刷新pvp我的英雄头像的装备可用状态
hApi.UpdateHeroEquipStateUI_PVP = function()
	local _frm = hGlobal.UI.HeroFrame
	local world = hGlobal.WORLD.LastWorldMap
	if world then
		if world and world.data.tdMapInfo and (world.data.tdMapInfo.mapMode == hVar.MAP_TD_TYPE.PVP) then --PVP模式
			--携带装备模式
			if world.data.bUseEquip then
				local oPlayerMe = world:GetPlayerMe()
				if oPlayerMe then
					local heros = oPlayerMe.heros
					if heros then
						for i = 1, #heros, 1 do
							local oHero = heros[i]
							if oHero then
								local pvp_level = oHero.attr.pvplv
								local equipment = oHero.data.equipment or {}
								
								for eq = 1, 4, 1 do
									local itemId = 0
									local equp = equipment[eq]
									if (type(equp) == "table") then
										itemId = equp[1]
									end
									
									--存在道具
									if hVar.tab_item[itemId] then
										local requireLv = hApi.GetItemRequire(itemId, "level") --需要的等级
										
										--是否解锁
										--print(oHero.data.name, hVar.tab_item[itemId].name, world.data.tdMapInfo.pveHeroMode, "pvp_level=" .. pvp_level)
										if (pvp_level >= requireLv) or (world.data.tdMapInfo.pveHeroMode == 1) then
											--存在道具背景
											if (oHero.heroUI["equipBG" .. eq]) then
												--显示
												--hApi.AddShader(oHero.heroUI["equipBG" .. eq].handle.s, "normal")
												oHero.heroUI["equipBG" .. eq].handle.s:setOpacity(255)
											end
											
											--存在道具
											if (oHero.heroUI["equip" .. eq]) then
												--显示
												--hApi.AddShader(oHero.heroUI["equip" .. eq].handle.s, "normal")
												oHero.heroUI["equip" .. eq].handle.s:setOpacity(255)
											end
											
											--存在禁用图标
											--存在道具
											--if (oHero.heroUI["equipBan" .. eq]) then
											--	--亮掉
											--	oHero.heroUI["equipBan" .. eq].handle.s:setVisible(false)
											--end
										else
											--存在道具背景
											if (oHero.heroUI["equipBG" .. eq]) then
												--显示
												--hApi.AddShader(oHero.heroUI["equipBG" .. eq].handle.s, "normal")
												oHero.heroUI["equipBG" .. eq].handle.s:setOpacity(64)
											end
											
											--存在道具
											if (oHero.heroUI["equip" .. eq]) then
												--灰掉
												--hApi.AddShader(oHero.heroUI["equip" .. eq].handle.s, "gray")
												oHero.heroUI["equip" .. eq].handle.s:setOpacity(64)
											end
											
											--存在禁用图标
											--存在道具
											--if (oHero.heroUI["equipBan" .. eq]) then
											--	--显示
											--	oHero.heroUI["equipBan" .. eq].handle.s:setVisible(true)
											--end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

--刷新pvp某个英雄的装备获得冒泡
hApi.UpdateHeroEquipBubble_PVP = function(oHero)
	--print("刷新pvp某个英雄的装备获得冒泡")
	local world = hGlobal.WORLD.LastWorldMap
	if world then
		if world and world.data.tdMapInfo and (world.data.tdMapInfo.mapMode == hVar.MAP_TD_TYPE.PVP) then --PVP模式
			--携带装备模式
			if world.data.bUseEquip then
				local oPlayerMe = world:GetPlayerMe()
				if oPlayerMe then
					if oHero then
						--print("UpdateHeroEquipBubble_PVP", oHero.data.name)
						if (oHero:getowner() == oPlayerMe) then --我的英雄
						--if true then
							local pvp_level = oHero.attr.pvplv
							local equipment = oHero.data.equipment or {}
							
							--本级可解锁的装备
							local tUnlockEq = {}
							
							for eq = 1, 4, 1 do
								local itemId = 0
								local equp = equipment[eq]
								if (type(equp) == "table") then
									itemId = equp[1]
								end
								
								--存在道具
								if hVar.tab_item[itemId] then
									local requireLv = hApi.GetItemRequire(itemId, "level") --需要的等级
									
									--是否解锁
									--$N @pveHeroMode %联网地图，是否直接使用pve英雄(0使用pvp英雄（局内可升级，装备局装备随局内升级解锁，技能随局内等级升级） 1使用pve英雄)
									--print(oHero.data.name, hVar.tab_item[itemId].name, world.data.tdMapInfo.pveHeroMode, "pvp_level=" .. pvp_level)
									if (pvp_level == requireLv) or ((world.data.tdMapInfo.pveHeroMode == 1) and (pvp_level == 1)) then
										table.insert(tUnlockEq, itemId)
									end
								end
							end
							
							--print("检测",  oHero.data.id)
							--存在有解锁的装备，冒泡动画
							if (#tUnlockEq > 0) then
								hApi.BubbleQueueTip(oHero:getowner(), oHero.data.id, tUnlockEq)
								--print("在有解锁的装备，冒泡动画", oHero.data.id)
							end
						end
					end
				end
			end
		end
	end
end

--单次冒泡英雄获得装备
local BubbleSingleTip = nil
BubbleSingleTip = function(oPlayer, heroId, itemIdList, callback, bScaleBigAtBeginning)
	local world = hGlobal.WORLD.LastWorldMap
	
	--不存在world，直接触发回调
	if (not world) then
		if callback then
			callback()
		end
		
		return
	end
	
	local WH = 48 --宽高
	local OFFSET = 40 --间距
	
	--hVar.SCREEN.w/2,hVar.SCREEN.h/2
	local button = hUI.button:new({
		parent = nil,
		model = "misc/mask.png",
		x = hVar.SCREEN.w/2,
		y = 200,
		z = 100,
		w = 1,
		h = 1,
	})
	button.handle.s:setOpacity(0) --不显示，只用于控制
	
	--如果当前游戏是第0帧，延时调用本函数
	local gametime = world:gametime()
	if (gametime == 0) then
		local delay = CCDelayTime:create(2.0)
		local actCall = CCCallFunc:create(function(ctrl)
			button:del()
			
			BubbleSingleTip(oPlayer, heroId, itemIdList, callback, bScaleBigAtBeginning)
		end)
		
		--创建动作数组
		local array = CCArray:create()
		array:addObject(delay)
		array:addObject(actCall)
		button.handle._n:runAction(CCSequence:create(array))
		
		return
	end
	
	--绘制英雄头像背景图
	button.childUI["HeroBG"] = hUI.image:new({
		parent = button.handle._n,
		model = "UI:slotSmall",
		animation = "lightSlim",
		x = -WH - OFFSET,
		y = 0,
		w = WH,
		h = WH,
	})
	
	--绘制英雄头像
	button.childUI["Hero"] = hUI.image:new({
		parent = button.handle._n,
		model = hVar.tab_unit[heroId] and hVar.tab_unit[heroId].icon,
		x = -WH - OFFSET,
		y = 0,
		w = WH - 6,
		h = WH - 6,
	})
	
	--绘制文字
	button.childUI["LabelText"] = hUI.label:new({
		parent = button.handle._n,
		x = 0,
		y = 0,
		font = hVar.FONTC,
		size = 26,
		align = "MC",
		width = 200,
		--text = "解锁装备", --language
		text = hVar.tab_string["__ITEM_PANEL__PAGE_CHONGZHU"] .. hVar.tab_string["GoodsKind1"], --language
		border = 1,
	})
	--非自己的玩家，显示红色文字
	if (world:GetPlayerMe() ~= oPlayer) then
		button.childUI["LabelText"].handle.s:setColor(ccc3(255, 0, 0))
	end
	
	--绘制全部道具
	for i = 1, #itemIdList, 1 do
		local itemId = itemIdList[i]
		if hVar.tab_item[itemId] then --存在道具
			--绘制装备品质等级颜色
			local itemLv = hVar.tab_item[itemId].itemLv or 1
			local itemtModel = hVar.ITEMLEVEL[itemLv].BORDERMODEL --边框
			
			--品质颜色图
			button.childUI["itemBG" .. i] = hUI.image:new({
				parent = button.handle._n,
				model = itemtModel, --"UI:SkillSlot",
				x = WH + OFFSET + (i - 1) * (WH + 5),
				y = 0,
				w = WH,
				h = WH,
			})
			
			--绘制道具图标
			button.childUI["itemIcon" .. i] = hUI.image:new({
				parent = button.handle._n,
				model = hVar.tab_item[itemId].icon,
				x = WH + OFFSET + (i - 1) * (WH + 5),
				y = 0,
				w = WH - 2,
				h = WH - 2,
			})
		else
			--不存在道具，画个空板子
			button.childUI["itemEmpty" .. i] = hUI.image:new({
				parent = button.handle._n,
				model = "misc/photo_frame.png",
				x = WH + OFFSET + (i - 1) * (WH + 5),
				y = 0,
				w = WH,
				h = WH,
			})
		end
	end
	
	--动画前，缩小
	if bScaleBigAtBeginning then
		button.handle._n:setScale(0.1)
		button:setXY(button.data.x, button.data.y - 50)
	end
	
	local scale = CCScaleTo:create(0.2, 1.0)
	local moveUp = CCMoveBy:create(0.2, ccp(0, 0))
	if bScaleBigAtBeginning then
		moveUp = CCMoveBy:create(0.2, ccp(0, 50))
	end
	local spawn1 = CCSpawn:createWithTwoActions(scale, moveUp)
	local delay1 = CCDelayTime:create(3.0)
	local move = CCMoveBy:create(0.4, ccp(0, -250))
	local delay2 = CCDelayTime:create(0.2)
	local actCall = CCCallFunc:create(function(ctrl)
		button:del()
		
		--触发回调
		if callback then
			callback()
		end
	end)
	
	--创建动作数组
	local array = CCArray:create()
	array:addObject(spawn1)
	array:addObject(delay1)
	array:addObject(move)
	array:addObject(delay2)
	array:addObject(actCall)
	button.handle._n:runAction(CCSequence:create(array))
	
	return button
end

local tBubbleQueue = {}

--队列冒泡英雄获得装备回调函数
local BubbleQueueTipCallback = nil
BubbleQueueTipCallback = function()
	--移除队首的项
	table.remove(tBubbleQueue, 1)
	
	--队列还有待冒泡的，继续动画
	if (#tBubbleQueue > 0) then
		local t = tBubbleQueue[1]
		BubbleSingleTip(t[1], t[2], t[3], BubbleQueueTipCallback, false)
		--print("继续播放")
	else
		--print("停止播放")
	end
end

--队列冒泡英雄获得装备
hApi.BubbleQueueTip = function(oPlayer, heroId, itemIdList)
	--不重复插入相同的数据
	for i = 1, #tBubbleQueue, 1 do
		local t = tBubbleQueue[i]
		if (t[1] == oPlayer) and (t[2] == heroId) then
			local sumi = 0
			for j = 1, #t[3], 1 do
				sumi = sumi + t[3][j]
			end
			
			local sum = 0
			for j = 1, #itemIdList, 1 do
				sum = sum + itemIdList[j]
			end
			
			--重复的道具
			if (sumi == sum) then
				return
			end
		end
	end
	
	--插入队列
	table.insert(tBubbleQueue, {oPlayer, heroId, itemIdList})
	
	--是第一项，播放动画
	if (#tBubbleQueue == 1) then
		BubbleSingleTip(oPlayer, heroId, itemIdList, BubbleQueueTipCallback, true)
		--print("开始播放")
	end
end

--显示pvp布局模式的界面
hApi.ShowPvpStyleFrm = function()
	--删除上一次的界面
	if hGlobal.UI.PhonePvpStyleFrm then
		hGlobal.UI.PhonePvpStyleFrm:del()
		hGlobal.UI.PhonePvpStyleFrm = nil
	end
	
	local pvpStyle = 1
	
	--选择某个式样
	local selectPvpStype = nil
	
	--选择式样1
	local onClickStyle1callback = function()
		selectPvpStype(1)
	end
	
	--选择式样2
	local onClickStyle2callback = function()
		selectPvpStype(2)
	end
	
	--创建pvp布局模式的界面
	hGlobal.UI.PhonePvpStyleFrm = hUI.frame:new(
	{
		x = hVar.SCREEN.w / 2 - 400 / 2,
		y = hVar.SCREEN.h / 2 + 400 / 2, -- - 20,
		w = 400,
		h = 400,
		dragable = 2,
		show = 1, --一开始不显示
		border = 1, --显示frame边框
		--background = "UI:Tactic_Background",
		autoactive = 0,
		--全部事件
		codeOnDragEx = function(touchX, touchY, touchMode)
			--
		end,
	})
	
	local _frm = hGlobal.UI.PhonePvpStyleFrm
	local _parent = _frm.handle._n
	
	--关闭按钮
	--btnClose
	_frm.childUI["closeBtnRight"] = hUI.button:new({
		parent = _parent,
		dragbox = _frm.childUI["dragBox"],
		--model = "UI:BTN_Close", --BTN:PANEL_CLOSE
		model = "BTN:PANEL_CLOSE",
		x = _frm.data.w + 5,
		y = 5,
		scaleT = 0.95,
		code = function()
			if hGlobal.UI.PhonePvpStyleFrm then
				hGlobal.UI.PhonePvpStyleFrm:del()
				hGlobal.UI.PhonePvpStyleFrm = nil
			end
		end,
	})
	
	--pvp布局样式标题
	_frm.childUI["labelTitle"] = hUI.label:new({
		parent = _parent,
		x = 200,
		y = -35,
		size = 32,
		align = "MC",
		border = 1,
		font = hVar.FONTC,
		width = 300,
		text = "界面布局", --language
		--text = hVar.tab_string["__TEXT_PVP_IsWaitingPlayer"], --language
	})
	
	--样式1：左上角和右上角（只用于挂载子控件，不显示）
	_frm.childUI["style1"] = hUI.button:new({
		parent = _parent,
		x = 200,
		y = -135,
		model = "misc/mask.png",
		w = 400,
		h = 150,
		dragbox = _frm.childUI["dragBox"],
		code = onClickStyle1callback,
	})
	_frm.childUI["style1"].handle.s:setOpacity(0) --只用于挂载子控件，不显示
	
	--样式1：背景图
	--[[
	_frm.childUI["style1"].childUI["bg"] = hUI.image:new({
		parent = _frm.childUI["style1"].handle._n,
		x = -35,
		y = 0,
		model = "UI:TacticBG",
		w = 300,
		h = 130,
	})
	_frm.childUI["style1"].childUI["bg"].handle.s:setOpacity(168)
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", -35, 0, 300, 130, _frm.childUI["style1"])
	img9:setOpacity(168)
	
	--样式1：刘备
	_frm.childUI["style1"].childUI["hero1"] = hUI.image:new({
		parent = _frm.childUI["style1"].handle._n,
		x = -155,
		y = 37,
		model = "icon/portrait/hero_liubei_s.png",
		w = 32,
		h = 32,
	})
	
	--样式1：曹操
	_frm.childUI["style1"].childUI["hero2"] = hUI.image:new({
		parent = _frm.childUI["style1"].handle._n,
		x = -155,
		y = -2,
		model = "icon/portrait/hero_caocao_s.png",
		w = 32,
		h = 32,
	})
	
	--样式1：刘备技能
	_frm.childUI["style1"].childUI["hero1_skill"] = hUI.image:new({
		parent = _frm.childUI["style1"].handle._n,
		x = 85,
		y = 37,
		model = "ICON:skill_icon_x2y1",
		w = 36,
		h = 36,
	})
	
	--样式1：曹操技能
	_frm.childUI["style1"].childUI["hero2_skill"] = hUI.image:new({
		parent = _frm.childUI["style1"].handle._n,
		x = 85,
		y = -4,
		model = "ICON:skill_icon_x4y6",
		w = 36,
		h = 36,
	})
	
	--样式1：9宫格图
	local imgLvUpBg911 = CCScale9Sprite:createWithSpriteFrameName("data/image/ui/image_frame.png")
	imgLvUpBg911:setPosition(ccp(0, 0))
	imgLvUpBg911:setContentSize(CCSizeMake(380, 140))
	_frm.childUI["style1"].handle._n:addChild(imgLvUpBg911)
	
	--样式1：选中框
	local imgLvUpBg912 = CCScale9Sprite:createWithSpriteFrameName("data/image/ui/TaskSelectBG.png")
	imgLvUpBg912:setPosition(ccp(-35, 0))
	imgLvUpBg912:setContentSize(CCSizeMake(308, 138))
	_frm.childUI["style1"].handle._n:addChild(imgLvUpBg912)
	
	--样式1：框框
	_frm.childUI["style1"].childUI["select_box"] = hUI.image:new({
		parent = _frm.childUI["style1"].handle._n,
		x = 152,
		y = 0,
		model = "UI:NewKuang",
		w = 32,
		h = 32,
	})
	
	--样式1：打勾
	_frm.childUI["style1"].childUI["check"] = hUI.image:new({
		parent = _frm.childUI["style1"].handle._n,
		x = 152,
		y = 0,
		model = "UI:finish",
		scale = 0.8,
	})
	
	--样式2：左下角和右下角（只用于挂载子控件，不显示）
	_frm.childUI["style2"] = hUI.button:new({
		parent = _parent,
		x = 200,
		y = -290,
		model = "misc/mask.png",
		w = 400,
		h = 150,
		dragbox = _frm.childUI["dragBox"],
		code = onClickStyle2callback,
	})
	_frm.childUI["style2"].handle.s:setOpacity(0) --只用于挂载子控件，不显示
	
	--样式2：背景图
	--[[
	_frm.childUI["style2"].childUI["bg"] = hUI.image:new({
		parent = _frm.childUI["style2"].handle._n,
		x = -35,
		y = 0,
		model = "UI:TacticBG",
		w = 300,
		h = 130,
	})
	_frm.childUI["style2"].childUI["bg"].handle.s:setOpacity(168)
	]]
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", -35, 0, 300, 130, _frm.childUI["style2"])
	img9:setOpacity(168)
	
	--样式2：刘备
	_frm.childUI["style2"].childUI["hero1"] = hUI.image:new({
		parent = _frm.childUI["style2"].handle._n,
		x = -163,
		y = -10,
		model = "icon/portrait/hero_liubei_s.png",
		w = 32,
		h = 32,
	})
	
	--样式2：曹操
	_frm.childUI["style2"].childUI["hero2"] = hUI.image:new({
		parent = _frm.childUI["style2"].handle._n,
		x = -130,
		y = -45,
		model = "icon/portrait/hero_caocao_s.png",
		w = 32,
		h = 32,
	})
	
	--样式2：刘备技能
	_frm.childUI["style2"].childUI["hero1_skill"] = hUI.image:new({
		parent = _frm.childUI["style2"].handle._n,
		x = 91,
		y = -10,
		model = "ICON:skill_icon_x2y1",
		w = 36,
		h = 36,
	})
	
	--样式2：曹操技能
	_frm.childUI["style2"].childUI["hero2_skill"] = hUI.image:new({
		parent = _frm.childUI["style2"].handle._n,
		x = 55,
		y = -45,
		model = "ICON:skill_icon_x4y6",
		w = 36,
		h = 36,
	})
	
	--样式2：9宫格图
	local imgLvUpBg921 = CCScale9Sprite:createWithSpriteFrameName("data/image/ui/image_frame.png")
	imgLvUpBg921:setPosition(ccp(0, 0))
	imgLvUpBg921:setContentSize(CCSizeMake(380, 140))
	_frm.childUI["style2"].handle._n:addChild(imgLvUpBg921)
	
	--样式2：选中框
	local imgLvUpBg922 = CCScale9Sprite:createWithSpriteFrameName("data/image/ui/TaskSelectBG.png")
	imgLvUpBg922:setPosition(ccp(-35, 0))
	imgLvUpBg922:setContentSize(CCSizeMake(308, 138))
	_frm.childUI["style2"].handle._n:addChild(imgLvUpBg922)
	
	--样式2：框框
	_frm.childUI["style2"].childUI["select_box"] = hUI.image:new({
		parent = _frm.childUI["style2"].handle._n,
		x = 152,
		y = 0,
		model = "UI:NewKuang",
		w = 32,
		h = 32,
	})
	
	--样式2：打勾
	_frm.childUI["style2"].childUI["check"] = hUI.image:new({
		parent = _frm.childUI["style2"].handle._n,
		x = 152,
		y = 0,
		model = "UI:finish",
		scale = 0.8,
	})
	
	--选择某个式样
	selectPvpStype = function(pvpStyle)
		--根据当前模式，显示/隐藏某些按钮
		if (pvpStyle == 1) then
			imgLvUpBg912:setVisible(true) --样式1：选中框
			_frm.childUI["style1"].childUI["check"].handle.s:setVisible(true) --样式1：打勾
			
			imgLvUpBg922:setVisible(false) --样式2：选中框
			_frm.childUI["style2"].childUI["check"].handle.s:setVisible(false) --样式2：打勾
		else
			imgLvUpBg912:setVisible(false) --样式1：选中框
			_frm.childUI["style1"].childUI["check"].handle.s:setVisible(false) --样式1：打勾
			
			imgLvUpBg922:setVisible(true) --样式2：选中框
			_frm.childUI["style2"].childUI["check"].handle.s:setVisible(true) --样式2：打勾
		end
	end
	
	--默认选择
	selectPvpStype(pvpStyle)
end

--不同步弹框（后台上传不同步日志）
hApi.MessageBoxAsync = function()
	--删除可能的投降对话框界面
	if hGlobal.UI.PhonePlayerTouXiangFrm then
		hGlobal.UI.PhonePlayerTouXiangFrm:del()
		hGlobal.UI.PhonePlayerTouXiangFrm = nil
	end
	
	--删除可能的pvp等待玩家的界面
	if hGlobal.UI.PhoneDelayPlayerFrm then
		hGlobal.UI.PhoneDelayPlayerFrm:del()
		hGlobal.UI.PhoneDelayPlayerFrm = nil
	end
	
	--删除可能的pvp结束界面
	if hGlobal.UI.__GameOverPanel_pvp then
		hGlobal.UI.__GameOverPanel_pvp:del()
		hGlobal.UI.__GameOverPanel_pvp = nil
	end
	
	--删除可能的响应时间过长框界面
	if hGlobal.UI.PhonePlayerNoHeartFrm then
		hGlobal.UI.PhonePlayerNoHeartFrm:del()
		hGlobal.UI.PhonePlayerNoHeartFrm = nil
	end
	
	--弹框，不同步
	local titleText = hVar.tab_string["__TEXT_Net_ERRO_3"] --language
	--local contentText = "不同步信息：\n\n" ..  hApi.GetGameInfo()
	local contentText = ""
	local contentTextStep1 = ""
	local contentTextStep2 = ""
	local contentTextStep3 = ""
	local contentTextStep4 = ""
	contentTextStep1 = "正在搜集不同步信息.."
	contentText = ("%s\n%s\n%s\n%s"):format(contentTextStep1, contentTextStep2, contentTextStep3, contentTextStep4)
	local tipFrm, confirmBtn, tipLab = hApi.ShowSysMsgBox(titleText, contentText, function()
		--删除可能的投降对话框界面
		if hGlobal.UI.PhonePlayerTouXiangFrm then
			hGlobal.UI.PhonePlayerTouXiangFrm:del()
			hGlobal.UI.PhonePlayerTouXiangFrm = nil
		end
		
		--删除可能的pvp等待玩家的界面
		if hGlobal.UI.PhoneDelayPlayerFrm then
			hGlobal.UI.PhoneDelayPlayerFrm:del()
			hGlobal.UI.PhoneDelayPlayerFrm = nil
		end
		
		--删除可能的pvp结束界面
		if hGlobal.UI.__GameOverPanel_pvp then
			hGlobal.UI.__GameOverPanel_pvp:del()
			hGlobal.UI.__GameOverPanel_pvp = nil
		end
		
		--删除可能的响应时间过长框界面
		if hGlobal.UI.PhonePlayerNoHeartFrm then
			hGlobal.UI.PhonePlayerNoHeartFrm:del()
			hGlobal.UI.PhonePlayerNoHeartFrm = nil
		end
		
		--返回大厅
		--geyachao: 先存档
		--存档
		LuaSavePlayerData(g_localfilepath,g_curPlayerName,Save_PlayerData,Save_PlayerLog)
		
		--关闭同步日志文件
		hApi.SyncLogClose()
		--关闭非同步日志文件
		hApi.AsyncLogClose()
		
		--隐藏可能的选人界面
		if hGlobal.UI.PhoneSelectedHeroFrm2 then
			hGlobal.UI.PhoneSelectedHeroFrm2:show(0)
			hGlobal.UI.PhoneSelectedHeroFrmBG.handle.s:setVisible(false) --隐藏背景框挡板
			hApi.clearTimer("__SELECT_HERO_UPDATE__")
			hApi.clearTimer("__SELECT_TOWER_UPDATE__")
			hApi.clearTimer("__SELECT_TACTIC_UPDATE__")
		end
		
		
		--todo zhenkira 这里以后要读取当前地图所在章节进行切换
		
		--zhenkira 注释
		--if g_vs_number > 4 and g_lua_src == 1 then
		--	local mapname = hGlobal.WORLD.LastWorldMap.data.map
		--	if hApi.Is_WDLD_Map(mapname) ~= -1 then
		--		Game_Zone_OnGameEvent(GZone_Event_TypeDef.Leave,luaGetplayerDataID())
		--	end
		--end
		
		--if hGlobal.WORLD.LastTown~=nil then
		--	hGlobal.WORLD.LastTown:del()
		--end
		
		--zhenkira 注释
		if (hGlobal.WORLD.LastWorldMap ~= nil) then
			local mapname = hGlobal.WORLD.LastWorldMap.data.map
			--if hApi.Is_RSYZ_Map(mapname) ~= -1 then
			--	print(".."..nil)
			--	Game_Zone_OnGameEvent(GZone_Event_TypeDef.Lua,{GZone_Event_TypeDef.BattleEnd_Fire,luaGetplayerDataID(),g_RSDYZ_BattleID})
			--end
			
			hGlobal.WORLD.LastWorldMap:del()
			
			local tabM = hVar.MAP_INFO[mapname]
			local chapterId = 1
			if tabM then
				chapterId = tabM.chapter or 1
			end
			
			hGlobal.LocalPlayer:setfocusworld(nil)
			hApi.clearCurrentWorldScene()
			
			--hGlobal.event:event("LocalEvent_Phone_ShowPhone_SelecteMap", chapterId)
			--切换到新主界面事件
			hGlobal.event:event("LocalEvent_OpenPhoneMainMenu")
		end
		
		--zhenkira 注释
		--hGlobal.event:event("LocalEvent_OpenPhoneMainMenu")
		--zhenkira 新增
		--hGlobal.event:event("LocalEvent_Phone_ShowPhone_SelecteMap", chapterId)
		--hGlobal.event:event("LocalEvent_Phone_ShowReturnContinue",1)
		--hApi.setViewNodeFocus(hVar.SCREEN.w/2,hVar.SCREEN.h/2)
	end)
	
	--一开始禁用按钮
	confirmBtn:setstate(0)
	
	--将同步日志输出到文件里
	local strLong = ""
	local SyncFileName, SyncFileT = hApi.SyncLogQuery()
	local SyncFile = io.open(SyncFileName, "w+")
	for i = 1, #SyncFileT, 1 do
		--strLong = ("%s%s"):format(strLong, SyncFileT[i])
		SyncFile:write(SyncFileT[i])
	end
	SyncFile:close()
	
	local file = io.open(SyncFileName, "r")
	strLong = file:read("*all")
	file:close()
	os.remove(SyncFileName)
	
	--同步日志输到文件完成
	contentTextStep1 = "不同步信息搜集完成！"
	contentTextStep2 = "正在分析不同步信息.."
	contentText = ("%s\n%s\n%s\n%s"):format(contentTextStep1, contentTextStep2, contentTextStep3, contentTextStep4)
	tipLab:setText(contentText)
	
	--压缩文件
	local filePath = g_localfilepath .. "sync_log_compressed.log"
	xlSaveGameData(filePath, strLong)
	
	--压缩文件完成
	--128k截断，拼接字符串
	local file = io.open(filePath, "rb")
	local buff = file:read("*all")
	file:close()
	
	--byte转char begin
	local filePath_Byte = g_localfilepath .. "sync_log_compressed_byte.log"
	local file = io.open(filePath_Byte, "w+")
	for i = 1, #buff, 1 do
		local substr = string.sub(buff, i, i)
		file:write(string.byte(substr))
		file:write(",")
	end
	file:close()
	--再打开本文件
	local file = io.open(filePath_Byte, "r")
	local buff = file:read("*all")
	file:close()
	--byte转char end
	
	local buff_len = #buff
	local SIZE_ONE_PACKET = 1024 * 60 --128
	local PACKET_NUM = math.ceil(buff_len / SIZE_ONE_PACKET) --包的数量
	local t = {}
	local pivot = 1
	
	while true do
		if (pivot >= buff_len) then
			break
		end
		
		local beginIdx = pivot
		local endIdx = pivot + SIZE_ONE_PACKET - 1
		if (endIdx > buff_len) then
			endIdx = buff_len
		end
		
		local substr = string.sub(buff, beginIdx, endIdx)
		
		t[#t + 1] = substr
		pivot = endIdx + 1
	end
	
	--截断完成
	--contentTextStep1 = "不同步信息搜集完成！"
	contentTextStep2 = "不同步信息分析完成！"
	contentTextStep3 = "正在上传不同步信息... (" .. "0" .. "/" ..  PACKET_NUM .. ")"
	contentText = ("%s\n%s\n%s\n%s"):format(contentTextStep1, contentTextStep2, contentTextStep3, contentTextStep4)
	tipLab:setText(contentText)
	
	--开始上传
	local currentSendIdx = 0 --发送idx
	local SendHostSyncLog = nil
	SendHostSyncLog = function(result, dbId, rId, session_dbId, packageNum)
		--print("SendHostSyncLog", result, dbId, rId, session_dbId, packageNum)
		--先移除监听
		hGlobal.event:listen("LocalEvent_Pvp_SyncLog", "__Pvp_SyncLog", nil)
		
		local world = hGlobal.WORLD.LastWorldMap
		if (result == 1) and world and (world.data.session_dbId == session_dbId) and (packageNum == currentSendIdx) then
			--print("发送索引加1", PACKET_NUM)
			--发送索引加1
			currentSendIdx = currentSendIdx + 1
			
			if (currentSendIdx <= PACKET_NUM) then
				--contentTextStep1 = "不同步信息搜集完成！"
				--contentTextStep2 = "不同步信息分析完成！"
				contentTextStep3 = "正在上传不同步信息... (" .. currentSendIdx .. "/" ..  PACKET_NUM .. ")"
				contentText = ("%s\n%s\n%s\n%s"):format(contentTextStep1, contentTextStep2, contentTextStep3, contentTextStep4)
				tipLab:setText(contentText)
				
				--添加监听事件
				hGlobal.event:listen("LocalEvent_Pvp_SyncLog", "__Pvp_SyncLog", SendHostSyncLog)
				
				--上传不同步日志(游戏局, 当前第几个包, 包总长度, 包内容)
				local session_dbId = session_dbId --游戏局Id
				local packageTotalNum = PACKET_NUM --包的总数量
				local packageNum = currentSendIdx --当前包的编号
				local packageContent = t[currentSendIdx] --当前包的内容
				--print("SendPvpCmdFunc[uplade_outsync_log]", session_dbId, packageTotalNum, packageNum, #packageContent)
				--print(packageContent)
				SendPvpCmdFunc["uplade_outsync_log"](session_dbId, packageTotalNum, packageNum, packageContent)
			else
				--contentTextStep1 = "不同步信息搜集完成！"
				--contentTextStep2 = "不同步信息分析完成！"
				contentTextStep3 = "不同步信息上传完成！"
				contentText = ("%s\n%s\n%s\n%s"):format(contentTextStep1, contentTextStep2, contentTextStep3, contentTextStep4)
				tipLab:setText(contentText)
				
				--允许按钮
				confirmBtn:setstate(1)
			end
		end
	end
	
	--开始发送第1个包
	local world = hGlobal.WORLD.LastWorldMap
	local session_dbId = world.data.session_dbId
	SendHostSyncLog(1, nil, nil, session_dbId, currentSendIdx)
end

--动画打开宝箱播放（类似皇室战争的动画效果）
hApi.PlayChestOpenAnimation = function(chestItemId, reward)
	--处理合并宝箱相同的道具
	local rewardEx = {}
	
	--奖励类型(1:积分 / 2:战术技能卡 / 3:道具 / 4:英雄 / 5:英雄将魂 / 6:战术技能卡碎片 / 7:游戏币 / 8:网络宝箱 / 9:抽奖类战术技能卡 / 10:神器 / 11:神器晶石)
	for i = 1, #reward, 1 do
		local rewardT = reward[i]
		
		--返回值: tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h
		local rewardT = reward[i]
		local rewardType = tonumber(rewardT[1]) --奖励类型
		local rewardId = tonumber(rewardT[2]) --奖励id
		local tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h = hApi.GetRewardParams(rewardT)
		--检测是否存在
		local bExisted = false --是否存在
		local bFindIdx = 0 --找到的索引
		for j = 1, #rewardEx, 1 do
			if (rewardEx[j].rewardType == rewardType) and (rewardEx[j].tmpModel == tmpModel) and (rewardEx[j].itemName == itemName) then --奖励类型、模型、名称都一样
				bExisted = true --找到了
				bFindIdx = j
				break
			end
		end
		
		if bExisted then
			rewardEx[bFindIdx].itemNum = rewardEx[bFindIdx].itemNum + itemNum
		else
			table.insert(rewardEx,
			{
				rewardType = rewardType,
				rewardId = rewardId,
				tmpModel = tmpModel,
				itemName = itemName,
				itemNum = itemNum,
				itemWidth = itemWidth,
				itemHeight = itemHeight,
				sub_tmpModel = sub_tmpModel,
				sub_pos_x = sub_pos_x,
				sub_pos_y = sub_pos_y,
				sub_pos_w = sub_pos_w,
				sub_pos_h = sub_pos_h,
			})
		end
	end
	
	--合并后的奖励总长度
	local g_MAX_LENGTH = #rewardEx
	
	--缓存当前的碎片数量
	local tmp_myPvP_BaseInfo = {}
	tmp_myPvP_BaseInfo.heroInfo = {} --英雄将魂碎片
	tmp_myPvP_BaseInfo.tacticInfo = {} --兵符碎片
	if g_myPvP_BaseInfo.heroInfo then
		for k, v in pairs(g_myPvP_BaseInfo.heroInfo) do
			tmp_myPvP_BaseInfo.heroInfo[k] = v
		end
	end
	if g_myPvP_BaseInfo.tacticInfo then
		for k, v in pairs(g_myPvP_BaseInfo.tacticInfo) do
			tmp_myPvP_BaseInfo.tacticInfo[k] = v
		end
	end
	
	--清除上一次的全屏挡操作的控件
	if hGlobal.UI.CoverFrame then
		hGlobal.UI.CoverFrame:del()
		hGlobal.UI.CoverFrame = nil
	end
	
	--点击屏幕执行的函数
	local OnClickChest = nil
	
	--动画打开奖励的索引
	local m_currLength = 1
	
	--大底板
	hGlobal.UI.CoverFrame = hUI.frame:new({
		x = 0,
		y = 0,
		z = 100000,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		--z = -1,
		show = 1,
		--dragable = 3, --3:点击后消失
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = -1, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--print("点击事件（有可能在控件外部点击）")
				OnClickChest()
			end
		end,
	})
	hGlobal.UI.CoverFrame:active()
	
	local _Parent = hGlobal.UI.CoverFrame.handle._n
	local _ChildUI = hGlobal.UI.CoverFrame.childUI
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2
	
	--tip图片背景
	_ChildUI["ItemBG_1"] = hUI.button:new({
		parent = _Parent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY,
		w = hVar.SCREEN.w + 200,
		h = hVar.SCREEN.h + 200,
	})
	_ChildUI["ItemBG_1"].handle.s:setOpacity(0) --只挂载子控件，不显示
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", 0, 0, hVar.SCREEN.w + 200, hVar.SCREEN.h + 200, _ChildUI["ItemBG_1"])
	img9:setOpacity(192)
	
	--宝箱底图
	_ChildUI["ItemBG_ChestIconBG"] = hUI.image:new({
		parent = _Parent,
		model = "ui/explosive.png",
		x = _offX + 10,
		y = _offY - 30,
		scale = 1.5,
	})
	
	--宝箱图标
	_ChildUI["ItemBG_ChestIcon"] = hUI.button:new({ --作为button是为了挂载子控件
		parent = _Parent,
		model = hVar.tab_item[chestItemId] and hVar.tab_item[chestItemId].icon,
		x = _offX,
		y = _offY,
		scale = 1.0,
	})
	
	--创建闪光特效
	_ChildUI["ItemBG_ChestIcon"].childUI["Light"] = hUI.image:new({
		parent = _ChildUI["ItemBG_ChestIcon"].handle._n,
		model = "MODEL_EFFECT:break_down",
		x = 0,
		y = 20,
		scale = 1.0,
	})
	
	--文字1
	_ChildUI["ItemBG_Label"] = hUI.label:new({
		parent = _Parent,
		x = _offX,
		y = _offY - 150,
		size = 32,
		font = hVar.FONTC,
		align = "MC",
		width = 500,
		border = 1,
		text = "点击继续", --language
		--text = hVar.tab_string["__TEXT_NetConnecting"], --language
	})
	
	--文字2
	_ChildUI["ItemBG_LabelContinue"] = hUI.label:new({
		parent = _Parent,
		x = _offX,
		y = _offY - 60,
		size = 32,
		font = hVar.FONTC,
		align = "MC",
		width = 500,
		border = 1,
		text = "点击继续", --language
		--text = hVar.tab_string["__TEXT_NetConnecting"], --language
	})
	_ChildUI["ItemBG_LabelContinue"].handle._n:setVisible(false) --一开始不显示
	
	--文字3
	_ChildUI["ItemBG_LabelEnd"] = hUI.label:new({
		parent = _Parent,
		x = _offX,
		y = _offY - 60,
		size = 32,
		font = hVar.FONTC,
		align = "MC",
		width = 500,
		border = 1,
		text = "点击完成", --language
		--text = hVar.tab_string["__TEXT_NetConnecting"], --language
	})
	_ChildUI["ItemBG_LabelEnd"].handle._n:setVisible(false) --一开始不显示
	
	--文字4
	_ChildUI["ItemBG_LabelExit"] = hUI.label:new({
		parent = _Parent,
		x = _offX,
		y = _offY - 60,
		size = 32,
		font = hVar.FONTC,
		align = "MC",
		width = 500,
		border = 1,
		text = "点击退出", --language
		--text = hVar.tab_string["__TEXT_NetConnecting"], --language
	})
	_ChildUI["ItemBG_LabelExit"].handle.s:setColor(ccc3(168, 168, 168))
	_ChildUI["ItemBG_LabelExit"].handle._n:setVisible(false) --一开始不显示
	
	--创建闪光特效
	_ChildUI["ItemBG_Light"] = hUI.image:new({
		parent = _Parent,
		model = "MODEL_EFFECT:break_down",
		x = _offX,
		y = _offY - 125,
		scale = 1.3,
	})
	_ChildUI["ItemBG_Light"].handle._n:setVisible(false) --一开始不显示
	
	--宝箱动画
	local SHAKE_DELTA = 20 --震动位移
	local SHAKE_TIME = 0.3 --震动时间
	local act1 = CCMoveBy:create(SHAKE_TIME, ccp(0, SHAKE_DELTA))
	local act2 = CCMoveBy:create(SHAKE_TIME, ccp(0, -SHAKE_DELTA))
	local act12 = CCSequence:createWithTwoActions(act1, act2)
	local act3 = CCScaleTo:create(SHAKE_TIME, 1.6)
	local act4 = CCScaleTo:create(SHAKE_TIME, 1.5)
	local act34 = CCSequence:createWithTwoActions(act3, act4)
	local act1234 = CCSpawn:createWithTwoActions(act12, act34)
	local act5 = CCDelayTime:create(0.1)
	local a = CCArray:create()
	a:addObject(act1234)
	a:addObject(act5)
	local sequence = CCSequence:create(a)
	_ChildUI["ItemBG_ChestIcon"].handle._n:runAction(CCRepeatForever:create(sequence))
	
	--文字动画
	local SHAKE_DELTA = -24 --震动位移
	local SHAKE_TIME = 0.6 --震动时间
	local act1 = CCMoveBy:create(SHAKE_TIME, ccp(SHAKE_DELTA, 0))
	local act2 = CCMoveBy:create(SHAKE_TIME, ccp(-SHAKE_DELTA, 0))
	local act12 = CCSequence:createWithTwoActions(act1, act2)
	local act3 = CCScaleTo:create(SHAKE_TIME, 1.1)
	local act4 = CCScaleTo:create(SHAKE_TIME, 1.0)
	local act34 = CCSequence:createWithTwoActions(act3, act4)
	local act1234 = CCSpawn:createWithTwoActions(act12, act34)
	local act5 = CCDelayTime:create(0.1)
	local a = CCArray:create()
	a:addObject(act1234)
	a:addObject(act5)
	local sequence = CCSequence:create(a)
	_ChildUI["ItemBG_Label"].handle._n:runAction(CCRepeatForever:create(sequence))
	
	--文字动画2
	local SHAKE_DELTA = -24 --震动位移
	local SHAKE_TIME = 0.6 --震动时间
	local act1 = CCMoveBy:create(SHAKE_TIME, ccp(SHAKE_DELTA, 0))
	local act2 = CCMoveBy:create(SHAKE_TIME, ccp(-SHAKE_DELTA, 0))
	local act12 = CCSequence:createWithTwoActions(act1, act2)
	local act3 = CCScaleTo:create(SHAKE_TIME, 1.1)
	local act4 = CCScaleTo:create(SHAKE_TIME, 1.0)
	local act34 = CCSequence:createWithTwoActions(act3, act4)
	local act1234 = CCSpawn:createWithTwoActions(act12, act34)
	local act5 = CCDelayTime:create(0.1)
	local a = CCArray:create()
	a:addObject(act1234)
	a:addObject(act5)
	local sequence = CCSequence:create(a)
	_ChildUI["ItemBG_LabelContinue"].handle._n:runAction(CCRepeatForever:create(sequence))
	
	--文字动画3
	local SHAKE_DELTA = -24 --震动位移
	local SHAKE_TIME = 0.6 --震动时间
	local act1 = CCMoveBy:create(SHAKE_TIME, ccp(SHAKE_DELTA, 0))
	local act2 = CCMoveBy:create(SHAKE_TIME, ccp(-SHAKE_DELTA, 0))
	local act12 = CCSequence:createWithTwoActions(act1, act2)
	local act3 = CCScaleTo:create(SHAKE_TIME, 1.1)
	local act4 = CCScaleTo:create(SHAKE_TIME, 1.0)
	local act34 = CCSequence:createWithTwoActions(act3, act4)
	local act1234 = CCSpawn:createWithTwoActions(act12, act34)
	local act5 = CCDelayTime:create(0.1)
	local a = CCArray:create()
	a:addObject(act1234)
	a:addObject(act5)
	local sequence = CCSequence:create(a)
	_ChildUI["ItemBG_LabelEnd"].handle.s:setColor(ccc3(168, 168, 168))
	_ChildUI["ItemBG_LabelEnd"].handle._n:runAction(CCRepeatForever:create(sequence))
	
	--文字动画4
	local SHAKE_DELTA = -24 --震动位移
	local SHAKE_TIME = 0.6 --震动时间
	local act1 = CCMoveBy:create(SHAKE_TIME, ccp(SHAKE_DELTA, 0))
	local act2 = CCMoveBy:create(SHAKE_TIME, ccp(-SHAKE_DELTA, 0))
	local act12 = CCSequence:createWithTwoActions(act1, act2)
	local act3 = CCScaleTo:create(SHAKE_TIME, 1.1)
	local act4 = CCScaleTo:create(SHAKE_TIME, 1.0)
	local act34 = CCSequence:createWithTwoActions(act3, act4)
	local act1234 = CCSpawn:createWithTwoActions(act12, act34)
	local act5 = CCDelayTime:create(0.1)
	local a = CCArray:create()
	a:addObject(act1234)
	a:addObject(act5)
	local sequence = CCSequence:create(a)
	_ChildUI["ItemBG_LabelExit"].handle._n:runAction(CCRepeatForever:create(sequence))
	
	local m_chest_state = 0 --开宝箱状态(0:初始化 / 1:等待点击开启 / 2:等待播放结束动画 / 3:等待退出 / 10:动画中禁止操作)
	
	--点击屏幕执行的函数
	OnClickChest = function()
		if (m_chest_state == 0) then --0:初始化
			--print("初始化")
			
			--标记状态为动画中禁止操作
			m_chest_state = 10
			
			--停止动作
			_ChildUI["ItemBG_ChestIcon"].childUI["Light"].handle.s:setVisible(false)
			_ChildUI["ItemBG_ChestIcon"].handle._n:stopAllActions()
			_ChildUI["ItemBG_Label"].handle._n:stopAllActions()
			
			--宝箱动画
			local SHAKE_DELTA = -150 --位移
			local SHAKE_TIME = 0.3 --位移时间
			local act1 = CCMoveTo:create(SHAKE_TIME, ccp(_ChildUI["ItemBG_ChestIcon"].data.x, _ChildUI["ItemBG_ChestIcon"].data.y + SHAKE_DELTA))
			local act2 = CCScaleTo:create(SHAKE_TIME, 1.2)
			local act12 = CCSpawn:createWithTwoActions(act1, act2)
			local act3 = CCCallFunc:create(function()
				--标记开宝箱动画状态为等待点击开启
				m_chest_state = 1
				
				--执行一次
				OnClickChest()
			end)
			local a = CCArray:create()
			a:addObject(act12)
			a:addObject(act3)
			local sequence = CCSequence:create(a)
			_ChildUI["ItemBG_ChestIcon"].handle._n:runAction(sequence)
			
			--宝箱背景图动画
			local act1 = CCMoveTo:create(SHAKE_TIME, ccp(_ChildUI["ItemBG_ChestIconBG"].data.x, _ChildUI["ItemBG_ChestIconBG"].data.y + SHAKE_DELTA))
			local act2 = CCScaleTo:create(SHAKE_TIME, 1.2)
			local act12 = CCSpawn:createWithTwoActions(act1, act2)
			local a = CCArray:create()
			a:addObject(act12)
			local sequence = CCSequence:create(a)
			_ChildUI["ItemBG_ChestIconBG"].handle._n:runAction(sequence)
			
			--文字动画
			local FADE_TIME = SHAKE_TIME / 2 --淡入时间
			local act1 = CCMoveBy:create(FADE_TIME, ccp(0, SHAKE_DELTA / 2))
			local act2 = CCFadeOut:create(FADE_TIME)
			local act12 = CCSpawn:createWithTwoActions(act1, act2)
			local act3 = CCCallFunc:create(function()
				_ChildUI["ItemBG_Label"].handle._n:setVisible(false)
			end)
			local a = CCArray:create()
			a:addObject(act12)
			a:addObject(act3)
			local sequence = CCSequence:create(a)
			_ChildUI["ItemBG_Label"].handle.s:runAction(sequence)
		elseif (m_chest_state == 1) then --1:等待点击开启
			--print("等待点击开启" .. m_currLength)
			
			--标记状态为动画中禁止操作
			m_chest_state = 10
			
			--先隐藏（清除）上一次的控件
			_ChildUI["ItemBG_LabelContinue"].handle._n:setVisible(false) --提示继续的文字2
			hApi.safeRemoveT(_ChildUI, "ItemBG_CardBack")
			hApi.safeRemoveT(_ChildUI, "ItemBG_Card")
			hApi.safeRemoveT(_ChildUI, "ItemBG_Card_Light")
			
			--显示闪光特效
			_ChildUI["ItemBG_Light"].handle._n:setVisible(true)
			
			--闪光特效动画一会后消失
			local WAIT_TIME = 0.25
			local act1 = CCScaleTo:create(WAIT_TIME / 2, 1.8)
			local act2 = CCMoveBy:create(WAIT_TIME / 2, ccp(0, 1))
			local act12 = CCSpawn:createWithTwoActions(act1, act2)
			local act3 = CCScaleTo:create(WAIT_TIME / 2, 1.3)
			local act4 = CCMoveBy:create(WAIT_TIME / 2, ccp(0, -1))
			local act34 = CCSpawn:createWithTwoActions(act3, act4)
			local act5 = CCCallFunc:create(function()
				--隐藏闪光特效
				--_ChildUI["ItemBG_Light"].handle._n:setVisible(false)
			end)
			local a = CCArray:create()
			a:addObject(act12)
			a:addObject(act34)
			a:addObject(act4)
			local sequence = CCSequence:create(a)
			_ChildUI["ItemBG_Light"].handle._n:runAction(sequence)
			
			--创建得到的道具背面（按钮）
			_ChildUI["ItemBG_CardBack"] = hUI.button:new({ --作为按钮是为了挂载子控件
				parent = _Parent,
				model = "UI:cardbg1",
				x = _offX,
				y = _offY - 130,
				scale = 0.1,
			})
			_ChildUI["ItemBG_CardBack"].handle.s:setVisible(false) --一开始不显示
			
			--创建得到的背面闪光特效
			_ChildUI["ItemBG_CardBack"].childUI["light"] = hUI.image:new({
				parent = _ChildUI["ItemBG_CardBack"].handle._n,
				model = "MODEL_EFFECT:break_down",
				x = 0,
				y = 0,
				scale = 3.0,
			})
			_ChildUI["ItemBG_CardBack"].childUI["light"].handle._n:setVisible(false) --一开始不显示
			
			--创建神器的闪光背景
			_ChildUI["ItemBG_Card_Light"] = hUI.image:new({
				parent = _Parent,
				model = "MODEL_EFFECT:break_down",
				x = _offX,
				y = _offY - 130 + 200,
				scale = 3.1,
			})
			_ChildUI["ItemBG_Card_Light"].handle._n:setVisible(false) --一开始不显示
			
			--创建得到的道具正面（按钮）
			_ChildUI["ItemBG_Card"] = hUI.button:new({ --作为button是为了挂载自子控件
				parent = _Parent,
				model = "misc/mask.png",
				x = _offX,
				y = _offY - 130 + 200,
				w = 120,
				h = 160,
			})
			_ChildUI["ItemBG_Card"].handle.s:setOpacity(0) --只挂载子控件，不显示
			
			--背景图
			_ChildUI["ItemBG_Card"].childUI["cardbg"] = hUI.image:new({
				parent = _ChildUI["ItemBG_Card"].handle._n,
				model = "UI:pvpprivatesb1",
				x = 0,
				y = 0,
				w = 116,
				h = 144,
			})
			_ChildUI["ItemBG_Card"]:setstate(-1) --一开始不显示
			
			--道具图标
			--返回值: tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h
			local rewardTex = rewardEx[m_currLength]
			local tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h =
				--rewardTex.rewardType,
				rewardTex.tmpModel,
				rewardTex.itemName,
				rewardTex.itemNum,
				rewardTex.itemWidth,
				rewardTex.itemHeight,
				rewardTex.sub_tmpModel,
				rewardTex.sub_pos_x,
				rewardTex.sub_pos_y,
				rewardTex.sub_pos_w,
				rewardTex.sub_pos_h
			local rewardType = rewardTex.rewardType --奖励类型
			local rewardId = rewardTex.rewardId --奖励id
			local xoffset = 0
			local yOffset = 20
			local WW = 84
			local HH = 84
			
			--奖励物品的图标
			_ChildUI["ItemBG_Card"].childUI["imgIcon"] = hUI.button:new({
				parent = _ChildUI["ItemBG_Card"].handle._n,
				model = tmpModel,
				x = xoffset,
				y = yOffset,
				w = WW, --WW * itemWidth / 42,
				h = HH, --HH * itemHeight / 42,
				align = "MC",
			})
			
			--绘制奖励图标的子控件
			if sub_tmpModel then
				--奖励类型(1:积分 / 2:战术技能卡 / 3:道具 / 4:英雄 / 5:英雄将魂 / 6:战术技能卡碎片 / 7:游戏币 / 8:网络宝箱 / 9:抽奖类战术技能卡 / 10:神器 / 11:神器晶石)
				if (rewardType == 5) or (rewardType == 6) then --5:英雄将魂 / 6:战术技能卡碎片
					_ChildUI["ItemBG_Card"].childUI["imgIcon"].childUI["image"] = hUI.image:new({
						parent = _ChildUI["ItemBG_Card"].childUI["imgIcon"].handle._n,
						model = sub_tmpModel,
						x = sub_pos_x * WW / itemWidth + 0.7 * 6, --碎片小一点，王总说太大了挡住英雄
						y = sub_pos_y * HH / itemHeight - 0.7 * 10, --碎片小一点，王总说太大了挡住英雄
						w = sub_pos_w * WW / itemWidth * 0.7, --碎片小一点，王总说太大了挡住英雄
						h = sub_pos_h * HH / itemHeight * 0.7, --碎片小一点，王总说太大了挡住英雄
					})
				else
					--神器有个道具图标烧火的特效
					if (rewardType == 10) then --10:神器
						_ChildUI["ItemBG_Card"].childUI["imgIcon"].childUI["fire"] = hUI.image:new({
							parent = _ChildUI["ItemBG_Card"].childUI["imgIcon"].handle._n,
							--model = "MODEL_EFFECT:Fire02",
							model = -1,
							x = sub_pos_x * WW / itemWidth,
							y = sub_pos_y * HH / itemHeight,
							scale = 1.0,
						})
						_ChildUI["ItemBG_Card"].childUI["imgIcon"].childUI["fire"].handle.s:setOpacity(128)
					end
					
					_ChildUI["ItemBG_Card"].childUI["imgIcon"].childUI["image"] = hUI.image:new({
						parent = _ChildUI["ItemBG_Card"].childUI["imgIcon"].handle._n,
						model = sub_tmpModel,
						x = sub_pos_x * WW / itemWidth,
						y = sub_pos_y * HH / itemHeight,
						w = sub_pos_w * WW / itemWidth,
						h = sub_pos_h * HH / itemHeight,
					})
					
					--神器有个道具图标闪烁的动画
					if (rewardType == 10) then --10:神器
						local Scale0 = sub_pos_w * WW / itemWidth / 64
						local towAction = CCSequence:createWithTwoActions(CCScaleTo:create(0.6, Scale0 - 0.015), CCScaleTo:create(0.6, Scale0 + 0.06))
						local forever = CCRepeatForever:create(tolua.cast(towAction, "CCActionInterval"))
						_ChildUI["ItemBG_Card"].childUI["imgIcon"].childUI["image"].handle.s:runAction(forever)
					end
				end
			end
			
			--奖励物品的名称
			local fontLength = #itemName
			local fontSize = 28
			if (fontLength >= 18) then
				fontSize = 17
			elseif (fontLength >= 15) then
				fontSize = 22
			elseif (fontLength >= 12) then
				fontSize = 26
			end
			_ChildUI["ItemBG_Card"].childUI["labName"] = hUI.label:new({
				parent = _ChildUI["ItemBG_Card"].handle._n,
				size = fontSize,
				align = "MC",
				border = 1,
				x = xoffset,
				y = yOffset - 64,
				--font = hVar.FONTC,
				font = hVar.FONTC,
				width = 290,
				text = itemName,
			})
			--_ChildUI["ItemBG_Card"].childUI["labName"].handle.s:setColor(ccc3(196, 255, 196))
			if (rewardType == 3) or (rewardType == 10) then --3:道具 / 10:神器
				local itemLv = hVar.tab_item[rewardId].itemLv or 1
				local NAMERGB = hVar.ITEMLEVEL[itemLv].NAMERGB
				_ChildUI["ItemBG_Card"].childUI["labName"].handle.s:setColor(ccc3(NAMERGB[1], NAMERGB[2], NAMERGB[3]))
			end
			
			--奖励物品的数量
			local intro = "+" .. itemNum
			_ChildUI["ItemBG_Card"].childUI["labIntro"] = hUI.label:new({
				parent = _ChildUI["ItemBG_Card"].handle._n,
				size = 26,
				align = "RC",
				border = 1,
				x = xoffset + 43,
				y = yOffset - 28,
				--font = hVar.FONTC,
				font = "numWhite",
				width = 300,
				text = intro,
			})
			_ChildUI["ItemBG_Card"].childUI["labIntro"].handle._n:setVisible(false) --一开始不显示
			--_ChildUI["ItemBG_Card"].childUI["labIntro"].handle.s:setColor(ccc3(255, 255, 0))
			
			--道具背面往上做运动
			local MOVE_TIME = 0.25
			local MOVE_DELTA = 200
			local ROT_TIME = 0.15
			local act1 = CCDelayTime:create(WAIT_TIME / 10)
			local act2 = CCCallFunc:create(function()
				_ChildUI["ItemBG_CardBack"].handle.s:setVisible(true) --显示道具背面
			end)
			local act3 = CCMoveBy:create(MOVE_TIME, ccp(0, MOVE_DELTA))
			local act4 = CCScaleTo:create(MOVE_TIME, 0.8)
			local act34 = CCEaseSineOut:create(CCSpawn:createWithTwoActions(act3, act4))
			local act5 = CCCallFunc:create(function()
				--_ChildUI["ItemBG_CardBack"].childUI["light"].handle._n:setVisible(true) --显示
			end)
			local act6 = CCDelayTime:create(0.1)
			local act7 = CCCallFunc:create(function()
				--_ChildUI["ItemBG_CardBack"].childUI["light"].handle._n:setVisible(false) --不显示
			end)
			local act8 = CCEaseSineIn:create(CCOrbitCamera:create(ROT_TIME, 1, 0, 0 ,90, 0, 0)) --参数: t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX
			local act9 = CCCallFunc:create(function()
				--隐藏道具背面
				_ChildUI["ItemBG_CardBack"].handle.s:setVisible(false)
				
				--显示道具正面
				_ChildUI["ItemBG_Card"]:setstate(1)
				
				--播放音效
				if (rewardType == 10) then --10:神器
					hApi.PlaySound("zhongjiang")
				else
					hApi.PlaySound("eff_pickup")
				end
				
				local act10 = CCEaseSineOut:create(CCOrbitCamera:create(ROT_TIME, -1, 0, 90, 90, 0, 0)) --参数: t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX
				local act11 = CCCallFunc:create(function()
					--hApi.PlaySound("dealcard")
					
					--显示数量
					_ChildUI["ItemBG_Card"].childUI["labIntro"].handle._n:setVisible(true)
				end)
				
				--数字跳动动画
				local actN = {}
				local actTimeSum = 0.6
				
				--奖励类型(1:积分 / 2:战术技能卡 / 3:道具 / 4:英雄 / 5:英雄将魂 / 6:战术技能卡碎片 / 7:游戏币 / 8:网络宝箱 / 9:抽奖类战术技能卡 / 10:神器 / 11:神器晶石)
				if (rewardType == 1) then --1:积分
					--当前积分值
					local jifenNow = LuaGetPlayerScore() - itemNum --取的值，是已经加过游戏币后的值
					
					--actN1:创建积分
					local actN1 = CCCallFunc:create(function()
						--积分图标
						_ChildUI["ItemBG_Card"].childUI["action_JiFen"] = hUI.button:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							model = tmpModel,
							x = xoffset + 330,
							y = yOffset - 20,
							w = 48,
							h = 48,
							align = "MC",
						})
						
						--当前积分的数量
						_ChildUI["ItemBG_Card"].childUI["action_JiFenLabel"] = hUI.label:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							size = 30,
							align = "RC",
							border = 1,
							x = xoffset + 300,
							y = yOffset - 20 - 3, --数字字体有3像素的偏差
							font = "numWhite",
							width = 290,
							text = jifenNow,
						})
					end)
					local actN2 = CCDelayTime:create(0.1)
					table.insert(actN, actN1)
					table.insert(actN, actN2)
					
					local t = actTimeSum / itemNum
					local jifenShow = jifenNow
					for j = 1, itemNum, 1 do
						local actN3 = CCCallFunc:create(function()
							--当前积分的数量
							jifenShow = jifenShow + 1
							_ChildUI["ItemBG_Card"].childUI["action_JiFenLabel"]:setText(jifenShow)
						end)
						local actN4 = CCDelayTime:create(t)
						local towAction = CCSequence:createWithTwoActions(actN3, actN4)
					
						table.insert(actN, towAction)
					end
				elseif (rewardType == 5) then --5:英雄将魂碎片
					--当前此英雄将魂的碎片数量
					local heroId = hVar.tab_item[rewardId].heroID --英雄id
					local heroDebris = tmp_myPvP_BaseInfo.heroInfo[heroId] and tmp_myPvP_BaseInfo.heroInfo[heroId].soulstone or 0
					local tHeroCard = hApi.GetHeroCardById(heroId)
					local star = 1 --当前等级
					if tHeroCard then
						star = tHeroCard.attr.star
					end
					local maxStarLv = hVar.HERO_STAR_INFO.maxStarLv --最高星级
					local costSoulStone = 0 --升到下一星需要的碎片数量
					if (star < maxStarLv) then
						costSoulStone = hVar.HERO_STAR_INFO[heroId][star].costSoulStone
					else
						costSoulStone = hVar.HERO_STAR_INFO[heroId][maxStarLv].costSoulStone
					end
					--print("tHeroCard=" .. tostring(tHeroCard), "heroId=" .. heroId, "star=" .. star, "costSoulStone=" .. costSoulStone, "heroDebris=" .. heroDebris)
					
					--actN1:创建进度条
					local actN1 = CCCallFunc:create(function()
						--进度条
						local ACHIEVEMENT_WIDTH = 230
						_ChildUI["ItemBG_Card"].childUI["action_ProgressBar"] = hUI.valbar:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							align = "LC",
							model = "UI:SoulStoneBar1",
							x = xoffset + 130,
							y = yOffset - 20,
							back = {model = "UI:SoulStoneBarBg1", x = -5, y = 0, w = ACHIEVEMENT_WIDTH - 17, h = 30 + 6},
							w = ACHIEVEMENT_WIDTH - 25,
							h = 30,
							v = heroDebris,
							max = costSoulStone,
						})
						--_ChildUI["ItemBG_Card"].childUI["action_ProgressBar"].handle.s:setColor(ccc3(255, 0, 0))
						
						--进度条底图
						local ACHIEVEMENT_WIDTH = 230
						_ChildUI["ItemBG_Card"].childUI["action_ProgressBarBG"] = hUI.valbar:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							align = "LC",
							model = "misc/jdt1.png",
							x = xoffset + 130,
							y = yOffset - 20,
							--back = {model = "UI:SoulStoneBarBg1", x = -5, y = 0, w = ACHIEVEMENT_WIDTH - 17, h = 30 + 6},
							w = ACHIEVEMENT_WIDTH - 25,
							h = 30,
							v = heroDebris,
							max = costSoulStone,
						})
						
						--当前碎片的数量
						local showNumText = (heroDebris .. "/" .. costSoulStone)
						local scaleText = 1.0
						local showTextLength = #showNumText
						if (showTextLength > 11) then --如果长度大于11，只能缩小文字(12~...个字)
							scaleText = 0.56
						elseif (showTextLength > 9) then --如果长度大于9，只能缩小文字(10~11个字)
							scaleText = 0.64
						elseif (showTextLength > 7) then --如果长度大于7，只能缩小文字(8~9个字)
							scaleText = 0.8
						else --可以显示下
							scaleText = 1.0
						end
						_ChildUI["ItemBG_Card"].childUI["action_ProgressLabel"] = hUI.label:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							size = 26,
							align = "MC",
							border = 1,
							x = xoffset + 230,
							y = yOffset - 20 - 1, --数字字体有1像素的偏差
							font = "numWhite",
							width = 290,
							text = showNumText,
							scale = scaleText,
						})
						
						--可升级的提示箭头
						_ChildUI["ItemBG_Card"].childUI["action_ProgressjianTou"] = hUI.image:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							model = "ICON:image_jiantouV",
							x = xoffset + 105,
							y = yOffset - 20 + 1,
							w = 36,
							h = 36,
						})
						_ChildUI["ItemBG_Card"].childUI["action_ProgressjianTou"].handle.s:setVisible(false)
					end)
					local actN2 = CCDelayTime:create(0.1)
					table.insert(actN, actN1)
					table.insert(actN, actN2)
					
					local t = actTimeSum / itemNum
					local heroDebrisTmp = heroDebris
					for j = 1, itemNum, 1 do
						local actN3 = CCCallFunc:create(function()
							--当前碎片的数量+1
							heroDebrisTmp = heroDebrisTmp + 1
							_ChildUI["ItemBG_Card"].childUI["action_ProgressBar"]:setV(heroDebrisTmp, costSoulStone)
							
							local showNumText = (heroDebrisTmp .. "/" .. costSoulStone)
							local scaleText = 1.0
							local showTextLength = #showNumText
							if (showTextLength > 11) then --如果长度大于11，只能缩小文字(12~...个字)
								scaleText = 0.56
							elseif (showTextLength > 9) then --如果长度大于9，只能缩小文字(10~11个字)
								scaleText = 0.64
							elseif (showTextLength > 7) then --如果长度大于7，只能缩小文字(8~9个字)
								scaleText = 0.8
							else --可以显示下
								scaleText = 1.0
							end
							_ChildUI["ItemBG_Card"].childUI["action_ProgressLabel"]:setText(showNumText)
							_ChildUI["ItemBG_Card"].childUI["action_ProgressLabel"].handle.s:setScale(scaleText)
							
							--是否可升级
							--如果将魂数量足够、未到顶星、已获得英雄，那么提示可升级
							if (heroDebrisTmp >= costSoulStone) and (star < maxStarLv)  and (tHeroCard) then 
								_ChildUI["ItemBG_Card"].childUI["action_ProgressjianTou"].handle.s:setVisible(true)
							else
								_ChildUI["ItemBG_Card"].childUI["action_ProgressjianTou"].handle.s:setVisible(false)
							end
						end)
						local actN4 = CCDelayTime:create(t)
						local towAction = CCSequence:createWithTwoActions(actN3, actN4)
					
						table.insert(actN, towAction)
					end
				elseif (rewardType == 6) then --6:战术技能卡碎片
					--当前此战术技能卡的碎片数量
					local tacticId = hVar.tab_item[rewardId].tacticID --战术卡id
					local tacticDebris = tmp_myPvP_BaseInfo.tacticInfo[tacticId] and tmp_myPvP_BaseInfo.tacticInfo[tacticId].debris or 0
					local tacticLv = tmp_myPvP_BaseInfo.tacticInfo[tacticId] and tmp_myPvP_BaseInfo.tacticInfo[tacticId].lv or 0
					local armLvupInfo = hVar.tab_tactics[tacticId].armLvupInfo or {}
					local requireDebris = armLvupInfo[tacticLv] and armLvupInfo[tacticLv].material[1].num or 500 --升到下一级需要的碎片
					local maxLv = hVar.TACTIC_LVUP_INFO.maxArmyLv or 1 --兵种最大等级
					
					--actN1:创建进度条
					local actN1 = CCCallFunc:create(function()
						--进度条
						local ACHIEVEMENT_WIDTH = 230
						_ChildUI["ItemBG_Card"].childUI["action_ProgressBar"] = hUI.valbar:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							align = "LC",
							model = "UI:SoulStoneBar1",
							x = xoffset + 130,
							y = yOffset - 20,
							back = {model = "UI:SoulStoneBarBg1", x = -5, y = 0, w = ACHIEVEMENT_WIDTH - 17, h = 30 + 6},
							w = ACHIEVEMENT_WIDTH - 25,
							h = 30,
							v = tacticDebris,
							max = requireDebris,
						})
						--_ChildUI["ItemBG_Card"].childUI["action_ProgressBar"].handle.s:setColor(ccc3(255, 0, 0))
						
						--进度条底图
						local ACHIEVEMENT_WIDTH = 230
						_ChildUI["ItemBG_Card"].childUI["action_ProgressBarBG"] = hUI.valbar:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							align = "LC",
							model = "misc/jdt1.png",
							x = xoffset + 130,
							y = yOffset - 20,
							--back = {model = "UI:SoulStoneBarBg1", x = -5, y = 0, w = ACHIEVEMENT_WIDTH - 17, h = 30 + 6},
							w = ACHIEVEMENT_WIDTH - 25,
							h = 30,
							v = tacticDebris,
							max = requireDebris,
						})
						
						--当前碎片的数量
						local showNumText = (tacticDebris .. "/" .. requireDebris)
						local scaleText = 1.0
						local showTextLength = #showNumText
						if (showTextLength > 11) then --如果长度大于11，只能缩小文字(12~...个字)
							scaleText = 0.56
						elseif (showTextLength > 9) then --如果长度大于9，只能缩小文字(10~11个字)
							scaleText = 0.64
						elseif (showTextLength > 7) then --如果长度大于7，只能缩小文字(8~9个字)
							scaleText = 0.8
						else --可以显示下
							scaleText = 1.0
						end
						_ChildUI["ItemBG_Card"].childUI["action_ProgressLabel"] = hUI.label:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							size = 26,
							align = "MC",
							border = 1,
							x = xoffset + 230,
							y = yOffset - 20 - 1, --数字字体有1像素的偏差
							font = "numWhite",
							width = 290,
							text = showNumText,
							scale = scaleText,
						})
						
						--可升级的提示箭头
						_ChildUI["ItemBG_Card"].childUI["action_ProgressjianTou"] = hUI.image:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							model = "ICON:image_jiantouV",
							x = xoffset + 105,
							y = yOffset - 20 + 1,
							w = 36,
							h = 36,
						})
						_ChildUI["ItemBG_Card"].childUI["action_ProgressjianTou"].handle.s:setVisible(false)
					end)
					local actN2 = CCDelayTime:create(0.1)
					table.insert(actN, actN1)
					table.insert(actN, actN2)
					
					local t = actTimeSum / itemNum
					local tacticDebrisTmp = tacticDebris
					for j = 1, itemNum, 1 do
						local actN3 = CCCallFunc:create(function()
							--当前碎片的数量
							tacticDebrisTmp = tacticDebrisTmp + 1
							_ChildUI["ItemBG_Card"].childUI["action_ProgressBar"]:setV(tacticDebrisTmp, requireDebris)
							
							local showNumText = (tacticDebrisTmp .. "/" .. requireDebris)
							local scaleText = 1.0
							local showTextLength = #showNumText
							if (showTextLength > 11) then --如果长度大于11，只能缩小文字(12~...个字)
								scaleText = 0.56
							elseif (showTextLength > 9) then --如果长度大于9，只能缩小文字(10~11个字)
								scaleText = 0.64
							elseif (showTextLength > 7) then --如果长度大于7，只能缩小文字(8~9个字)
								scaleText = 0.8
							else --可以显示下
								scaleText = 1.0
							end
							_ChildUI["ItemBG_Card"].childUI["action_ProgressLabel"]:setText(showNumText)
							_ChildUI["ItemBG_Card"].childUI["action_ProgressLabel"].handle.s:setScale(scaleText)
							
							--是否可升级
							--如果碎片数量足够，未到顶级，那么提示可升级
							if (tacticDebrisTmp >= requireDebris) and (tacticLv < maxLv) then
								_ChildUI["ItemBG_Card"].childUI["action_ProgressjianTou"].handle.s:setVisible(true)
							else
								_ChildUI["ItemBG_Card"].childUI["action_ProgressjianTou"].handle.s:setVisible(false)
							end
						end)
						local actN4 = CCDelayTime:create(t)
						local towAction = CCSequence:createWithTwoActions(actN3, actN4)
					
						table.insert(actN, towAction)
					end
				elseif (rewardType == 7) then --7:游戏币
					--当前游戏币值
					local gamecoinNow = LuaGetPlayerRmb() - itemNum --取的值，是已经加过游戏币后的值
					
					--actN1:创建游戏币
					local actN1 = CCCallFunc:create(function()
						--积分图标
						_ChildUI["ItemBG_Card"].childUI["action_Rmb"] = hUI.button:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							model = tmpModel,
							x = xoffset + 330,
							y = yOffset - 20,
							w = 64,
							h = 64,
							align = "MC",
						})
						
						--当前游戏币的数量
						_ChildUI["ItemBG_Card"].childUI["action_RmbLabel"] = hUI.label:new({
							parent = _ChildUI["ItemBG_Card"].handle._n,
							size = 30,
							align = "RC",
							border = 1,
							x = xoffset + 300,
							y = yOffset - 20 - 3, --数字字体有3像素的偏差
							font = "numWhite",
							width = 290,
							text = gamecoinNow,
						})
					end)
					local actN2 = CCDelayTime:create(0.1)
					table.insert(actN, actN1)
					table.insert(actN, actN2)
					
					local t = actTimeSum / itemNum
					local gamecoinShow = gamecoinNow
					for j = 1, itemNum, 1 do
						local actN3 = CCCallFunc:create(function()
							--当前游戏币的数量
							gamecoinShow = gamecoinShow + 1
							_ChildUI["ItemBG_Card"].childUI["action_RmbLabel"]:setText(gamecoinShow)
						end)
						local actN4 = CCDelayTime:create(t)
						local towAction = CCSequence:createWithTwoActions(actN3, actN4)
					
						table.insert(actN, towAction)
					end
				elseif (rewardType == 10) then --10:神器
					--换卡牌背景图
					_ChildUI["ItemBG_Card"].childUI["cardbg"]:setmodel("UI:pvpprivatesb4", nil, nil, _ChildUI["ItemBG_Card"].childUI["cardbg"].data.w, _ChildUI["ItemBG_Card"].childUI["cardbg"].data.h)
					
					--放大特效
					local scale1 = CCScaleTo:create(0.1, 2.0)
					local scale2 = CCScaleTo:create(0.1, 1.0)
					local delay3 = CCDelayTime:create(0.5)
					local done4 = CCCallFunc:create(function()
						--标记状态为点击继续
						if (m_currLength <= g_MAX_LENGTH) then
							m_chest_state = 1
						else --结束
							
							m_chest_state = 2
						end
					end)
					table.insert(actN, scale1)
					table.insert(actN, scale2)
					table.insert(actN, delay3)
					table.insert(actN, done4)
				elseif (rewardType == 11) then --11:神器晶石
				end
				
				local act12 = CCDelayTime:create(0.05)
				local act13 = CCCallFunc:create(function()
					--索引加1
					m_currLength = m_currLength + 1
					
					--标记状态为点击继续
					if (m_currLength <= g_MAX_LENGTH) then
						--显示提示继续的文字2
						_ChildUI["ItemBG_LabelContinue"].handle._n:setVisible(true)
						_ChildUI["ItemBG_LabelEnd"].handle._n:setVisible(false)
						
						--显示闪光特效
						_ChildUI["ItemBG_Light"].handle._n:setVisible(true)
						
						if (rewardType == 10) then --10:神器
							--神器显示金边
							_ChildUI["ItemBG_Card_Light"].handle._n:setVisible(true)
						end
						
						m_chest_state = 1
						
						--神器强制要看动画
						if (rewardType == 10) then --10:神器
							--标记状态为动画中禁止操作
							m_chest_state = 10
						end
					else --结束
						--显示提示继续的文字2
						_ChildUI["ItemBG_LabelContinue"].handle._n:setVisible(false)
						_ChildUI["ItemBG_LabelEnd"].handle._n:setVisible(true)
						
						--隐藏闪光特效
						_ChildUI["ItemBG_Light"].handle._n:setVisible(false)
						
						m_chest_state = 2
					end
				end)
				local a = CCArray:create()
				a:addObject(act10)
				a:addObject(act11)
				a:addObject(act12)
				a:addObject(act13)
				for k = 1, #actN, 1 do
					a:addObject(actN[k])
				end
				local sequence = CCSequence:create(a)
				_ChildUI["ItemBG_Card"].handle._n:runAction(sequence)
			end)
			local a = CCArray:create()
			a:addObject(act1)
			a:addObject(act2)
			a:addObject(act34)
			a:addObject(act5)
			a:addObject(act6)
			a:addObject(act7)
			a:addObject(act8)
			a:addObject(act9)
			local sequence = CCSequence:create(a)
			_ChildUI["ItemBG_CardBack"].handle.s:runAction(sequence)
		elseif (m_chest_state == 2) then --2:等待播放结束动画
			--print("等待播放结束动画")
			
			--标记状态为动画中禁止操作
			m_chest_state = 10
			
			--先隐藏（清除）上一次的控件
			_ChildUI["ItemBG_LabelEnd"].handle._n:setVisible(false) --提示结束的文字3
			hApi.safeRemoveT(_ChildUI, "ItemBG_CardBack")
			hApi.safeRemoveT(_ChildUI, "ItemBG_Card")
			hApi.safeRemoveT(_ChildUI, "ItemBG_Card_Light")
			
			--绘制所有的奖励
			--绘制奖励底板（9宫格）
			local deltaX = 0
			local deltaY = 80
			local img9 = CCScale9Sprite:create("data/image/misc/card_select_back.png")
			img9:setPosition(ccp(_offX + deltaX, _offY + deltaY))
			img9:setContentSize(CCSizeMake(950, 150))
			_Parent:addChild(img9)
			
			--每个奖励
			for i = 1, g_MAX_LENGTH, 1 do
				local rewardTex = rewardEx[i]
				local rewardId = rewardTex.rewardId
				local rewardType = rewardTex.rewardType
				
				--道具图标
				--返回值: tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h
				local tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h =
					--rewardTex.rewardType,
					rewardTex.tmpModel,
					rewardTex.itemName,
					rewardTex.itemNum,
					rewardTex.itemWidth,
					rewardTex.itemHeight,
					rewardTex.sub_tmpModel,
					rewardTex.sub_pos_x,
					rewardTex.sub_pos_y,
					rewardTex.sub_pos_w,
					rewardTex.sub_pos_h
				local xoffset = 0
				local yOffset = 20
				local WW = 72
				local HH = 72
				if ((g_MAX_LENGTH % 2) == 1) then --奇数
					xoffset = (g_MAX_LENGTH - 1) / 2 * (WW + 50) - (WW + 50) / 2
				else --偶数
					xoffset = (g_MAX_LENGTH - 2) / 2 * (WW + 50)
				end
				
				--[[
				--创建神器的闪光背景
				if (rewardType == 10) then --10:神器
					_ChildUI["ItemBG_Card_Light" .. i] = hUI.image:new({
						parent = _Parent,
						model = "MODEL_EFFECT:break_down",
						x = _offX + deltaX - xoffset - 60 + (i - 1) * (WW + 50),
						y = _offY + deltaY,
						scale = 2.6,
					})
				end
				]]
				
				--创建得到的道具正面
				local pvpprivatesModel = "UI:pvpprivatesb1"
				if (rewardType == 10) then --10:神器
					pvpprivatesModel = "UI:pvpprivatesb4"
				end
				_ChildUI["ItemBG_Card_View" .. i] = hUI.button:new({ --作为button是为了挂载自子控件
					parent = _Parent,
					model = pvpprivatesModel,
					x = _offX + deltaX - xoffset - 60 + (i - 1) * (WW + 50),
					y = _offY + deltaY,
					scale = 0.65,
				})
				
				--奖励物品的图标
				_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"] = hUI.button:new({
					parent = _ChildUI["ItemBG_Card_View" .. i].handle._n,
					model = tmpModel,
					x = 0,
					y = 15,
					w = WW,
					h = HH,
					align = "MC",
				})
				
				--绘制奖励图标的子控件
				if sub_tmpModel then
					--奖励类型(1:积分 / 2:战术技能卡 / 3:道具 / 4:英雄 / 5:英雄将魂 / 6:战术技能卡碎片 / 7:游戏币 / 8:网络宝箱 / 9:抽奖类战术技能卡 / 10:神器 / 11:神器晶石)
					if (rewardType == 5) or (rewardType == 6) then --5:英雄将魂 / 6:战术技能卡碎片
						_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["image"] = hUI.image:new({
							parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
							model = sub_tmpModel,
							x = sub_pos_x * WW / itemWidth + 0.6 * 8, --碎片小一点，王总说太大了挡住英雄
							y = sub_pos_y * HH / itemHeight - 0.6 * 12, --碎片小一点，王总说太大了挡住英雄
							w = sub_pos_w * WW / itemWidth * 0.6, --碎片小一点，王总说太大了挡住英雄
							h = sub_pos_h * HH / itemHeight * 0.6, --碎片小一点，王总说太大了挡住英雄
						})
					else
						--神器有个道具图标烧火的特效
						if (rewardType == 10) then --10:神器
							_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["fire"] = hUI.image:new({
								parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
								--model = "MODEL_EFFECT:Fire02",
								model = -1,
								x = sub_pos_x * WW / itemWidth,
								y = sub_pos_y * HH / itemHeight,
								scale = 0.9,
							})
							_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["fire"].handle.s:setOpacity(128)
						end
						
						_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["image"] = hUI.image:new({
							parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
							model = sub_tmpModel,
							x = sub_pos_x * WW / itemWidth,
							y = sub_pos_y * HH / itemHeight,
							w = sub_pos_w * WW / itemWidth,
							h = sub_pos_h * HH / itemHeight,
						})
						
						--神器有个道具图标闪烁的动画
						if (rewardType == 10) then --10:神器
							local Scale0 = sub_pos_w * WW / itemWidth / 64
							local towAction = CCSequence:createWithTwoActions(CCScaleTo:create(0.6, Scale0 - 0.013), CCScaleTo:create(0.6, Scale0 + 0.04))
							local forever = CCRepeatForever:create(tolua.cast(towAction, "CCActionInterval"))
							_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["image"].handle.s:runAction(forever)
						end
					end
				end
				
				--奖励物品的名称
				local fontLength = #itemName
				local fontSize = 24
				if (fontLength >= 18) then
					fontSize = 16
				elseif (fontLength >= 15) then
					fontSize = 18
				elseif (fontLength >= 12) then
					fontSize = 22
				end
				_ChildUI["ItemBG_Card_View" .. i].childUI["labName"] = hUI.label:new({
					parent = _ChildUI["ItemBG_Card_View" .. i].handle._n,
					size = fontSize,
					align = "MC",
					border = 1,
					x = 0,
					y = yOffset - 58,
					--font = hVar.FONTC,
					font = hVar.FONTC,
					width = 290,
					text = itemName,
				})
				--_ChildUI["ItemBG_Card_View" .. i].childUI["labName"].handle.s:setColor(ccc3(196, 255, 196))
				if (rewardType == 3) or (rewardType == 10) then --3:道具 / 10:神器
					local itemLv = hVar.tab_item[rewardId].itemLv or 1
					local NAMERGB = hVar.ITEMLEVEL[itemLv].NAMERGB
					_ChildUI["ItemBG_Card_View" .. i].childUI["labName"].handle.s:setColor(ccc3(NAMERGB[1], NAMERGB[2], NAMERGB[3]))
				end
				
				--奖励物品的数量
				local intro = "+" .. itemNum
				_ChildUI["ItemBG_Card_View" .. i].childUI["labIntro"] = hUI.label:new({
					parent = _ChildUI["ItemBG_Card_View" .. i].handle._n,
					size = 18,
					align = "RC",
					border = 1,
					x = 35,
					y = yOffset - 30,
					--font = hVar.FONTC,
					font = "numWhite",
					width = 300,
					text = intro,
				})
				--_ChildUI["ItemBG_Card_View" .. i].childUI["labIntro"].handle.s:setColor(ccc3(255, 255, 0))
			end
			
			--每个奖励的动画
			local finishCount = 0
			for i = 1, g_MAX_LENGTH, 1 do
				--local act1 = CCDelayTime:create(0.01 + (i - 1) * 0.06)
				local act1 = CCDelayTime:create(0.01)
				local act2 = CCScaleTo:create(0.08, 1.3)
				local act3 = CCScaleTo:create(0.08, 1.0)
				local act6 = CCCallFunc:create(function()
					finishCount = finishCount + 1
					
					--全部动画完成
					if (finishCount == g_MAX_LENGTH) then
						local act7 = CCDelayTime:create(0.1)
						local act8 = CCCallFunc:create(function()
							--显示点击退出的文字4
							_ChildUI["ItemBG_LabelExit"].handle._n:setVisible(true)
							
							--标记开宝箱动画状态为等待点击退出
							m_chest_state = 3
						end)
						local towAction = CCSequence:createWithTwoActions(act7, act8)
						hGlobal.UI.CoverFrame.handle._n:runAction(towAction)
					end
				end)
				local a = CCArray:create()
				a:addObject(act1)
				a:addObject(act2)
				a:addObject(act3)
				a:addObject(act6)
				local sequence = CCSequence:create(a)
				_ChildUI["ItemBG_Card_View" .. i].handle._n:runAction(sequence)
			end
		elseif (m_chest_state == 3) then --3:等待退出
			--print("等待退出")
			
			--标记状态为动画中禁止操作
			m_chest_state = 10
			
			--删除本界面
			if hGlobal.UI.CoverFrame then
				hGlobal.UI.CoverFrame:del()
				hGlobal.UI.CoverFrame = nil
			end
		elseif (m_chest_state == 10) then --10:动画中禁止操作
			--print("动画中禁止操作")
		end
	end
	
	--播放箱子音效
	--hApi.PlaySound("magic11")
end



--序列化 表->字符串(无回车符)
local serialize_noline_short = nil
serialize_noline_short = function(obj)
	local lua = ""
	local t = type(obj)
	if (t == "number") then
		lua = lua .. tostring(obj)
	elseif (t == "boolean") then
		lua = lua .. tostring(obj)
	elseif (t == "string") then
		lua = lua .. string.format("%q", obj)
	elseif (t == "table") then
		--检测是否为纯数组表
		local bNumber = true
		local nMin = 9999
		local nMax = -9999
		local nCount = 0
		for k, v in pairs(obj) do  
			if (type(k) ~= "number") then
				bNumber = false --不是数组表
				break
			else
				nCount = nCount + 1
				
				if (k < nMin) then
					nMin = k
				end
				
				if (k > nMax) then
					nMax = k
				end
			end
		end
		if bNumber and (nMin == 1) and (nMax == nCount) then
			lua = lua .. "{"
			for i = 1, nCount, 1 do
				lua = lua .. serialize_noline_short(obj[i]) .. ","
			end
			lua = lua .. "}"
		else
			lua = lua .. "{"
			for k, v in pairs(obj) do
				lua = lua .. "[" .. serialize_noline_short(k) .. "]=" .. serialize_noline_short(v) .. ","
			end
			lua = lua .. "}"
		end
	elseif (t == "function") then
		lua = lua .. "\"" .. tostring(obj) .. "\""
	elseif (t == "nil") then
		return nil
	else
		error("can not serialize_noline_short a " .. tostring(t) .. " type.")
	end 
	
	return lua
end

--序列化 表->字符串(精简数组表)
--hApi.serialize_table = function(obj)
function hApi.serialize_table(obj)
	local lua = ""
	local t = type(obj)  
	
	if (t == "number") then
		lua = lua .. obj
	elseif (t == "boolean") then
		lua = lua .. tostring(obj)
	elseif (t == "string") then
		lua = lua .. string.format("%q", obj)
	elseif (t == "table") then
		lua = lua .. "{\n"
		
		--检测是否为纯数组表
		local bNumber = true
		local nMin = 9999
		local nMax = -9999
		local nCount = 0
		for k, v in pairs(obj) do  
			if (type(k) ~= "number") then
				bNumber = false --不是数组表
				break
			else
				nCount = nCount + 1
				
				if (k < nMin) then
					nMin = k
				end
				
				if (k > nMax) then
					nMax = k
				end
			end
		end
		if bNumber and (nMin == 1) and (nMax == nCount) then
			for i = 1, nCount, 1 do
				lua = lua .. serialize_noline_short(obj[i]) .. ",\n"
			end
		else
			for k, v in pairs(obj) do
				lua = lua .. "[" .. serialize_noline_short(k) .. "]=" .. serialize_noline_short(v) .. ",\n"
			end
		end
		
		lua = lua .. "}"
	elseif (t == "function") then
		lua = lua .. "\"" .. tostring(obj) .. "\""
	end
	
	return lua
end



--动画打开宝箱奖励播放（类似葫芦娃的动画效果）
hApi.PlayChestRewardAnimation = function(chestItemId, reward, funCallBack)
	--无效的格式
	if (type(reward) ~= "table") then
		return
	end
	
	--处理合并宝箱相同的道具
	local rewardEx = {}
	
	--奖励类型(1:积分 / 2:战术技能卡 / 3:道具 / 4:英雄 / 5:英雄将魂 / 6:战术技能卡碎片 / 7:游戏币 / 8:网络宝箱 / 9:抽奖类战术技能卡 / 10:神器 / 11:神器晶石 / 12:红装兑换券 / 13:服务器抽卡 / 14:英雄经验卡 / 15:直接开锦囊 / 16:铁 / 17:木材 / 18:粮食 / 20:军团币 / 21:强化免费券 / 22:宝物碎片)
	for i = 1, #reward, 1 do
		local rewardT = reward[i]
		
		--返回值: tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h
		local rewardT = reward[i]
		local rewardType = tonumber(rewardT[1]) or 0 --奖励类型
		local rewardId = tonumber(rewardT[2]) or 0 --奖励id
		
		if (rewardType > 0) then
			local tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h = hApi.GetRewardParams(rewardT)
			--检测是否存在
			local bExisted = false --是否存在
			local bFindIdx = 0 --找到的索引
			--[[
			--geyachao: 保留原始的奖励数量，不合并了
			for j = 1, #rewardEx, 1 do
				if (rewardEx[j].rewardType == rewardType) and (rewardEx[j].tmpModel == tmpModel) and (rewardEx[j].itemName == itemName) then --奖励类型、模型、名称都一样
					bExisted = true --找到了
					bFindIdx = j
					break
				end
			end
			]]
			
			if bExisted then
				rewardEx[bFindIdx].itemNum = rewardEx[bFindIdx].itemNum + itemNum
			else
				table.insert(rewardEx,
				{
					rewardType = rewardType,
					rewardId = rewardId,
					tmpModel = tmpModel,
					itemName = itemName,
					itemNum = itemNum,
					itemWidth = itemWidth,
					itemHeight = itemHeight,
					sub_tmpModel = sub_tmpModel,
					sub_pos_x = sub_pos_x,
					sub_pos_y = sub_pos_y,
					sub_pos_w = sub_pos_w,
					sub_pos_h = sub_pos_h,
					slotAttr = rewardT[3] or "", --神器孔属性
					param4 = rewardT[4], --第4个参数
				})
			end
		end
	end
	
	--合并后的奖励总长度
	local g_MAX_LENGTH = #rewardEx
	
	--没有有效的奖励
	if (g_MAX_LENGTH == 0) then
		return
	end
	
	--缓存当前的碎片数量
	local tmp_myPvP_BaseInfo = {}
	tmp_myPvP_BaseInfo.heroInfo = {} --英雄将魂碎片
	tmp_myPvP_BaseInfo.tacticInfo = {} --兵符碎片
	if g_myPvP_BaseInfo.heroInfo then
		for k, v in pairs(g_myPvP_BaseInfo.heroInfo) do
			tmp_myPvP_BaseInfo.heroInfo[k] = v
		end
	end
	if g_myPvP_BaseInfo.tacticInfo then
		for k, v in pairs(g_myPvP_BaseInfo.tacticInfo) do
			tmp_myPvP_BaseInfo.tacticInfo[k] = v
		end
	end
	
	--在弹出此界面时，如果邮箱界面是打开状态，那儿隐藏左侧的公告栏
	if hGlobal.UI.PhoneWebViewNews then
		if (hGlobal.UI.PhoneWebViewNews.data.show == 1) then
			if (type(xlShowWebView) == "function") and (type(Lua_xlShowWebView) == "function") then
				Lua_xlShowWebView(0)
			end
		end
	end
	
	--清除上一次的全屏挡操作的控件
	if hGlobal.UI.CoverFrame then
		hGlobal.UI.CoverFrame:del()
		hGlobal.UI.CoverFrame = nil
	end
	
	--删除timer
	hApi.clearTimer("__TD__PLAY_CHEST_REWARD_TIME__")
	hApi.clearTimer("__TD__PLAY_CHEST_REWARD_UPDATE__")
	
	--iPhoneX黑边宽
	local iPhoneX_WIDTH = 0
	if (g_phone_mode == 4) then --iPhoneX
		iPhoneX_WIDTH = 80
	end
	
	--竖屏模式
	if (hVar.SCREEN_MODE == hVar.SCREEN_MODE_DEFINE.VERTICAL) then
		iPhoneX_WIDTH = 0
	end
	
	--点击屏幕执行的函数
	local OnClickChest = hApi.DoNothing --点击屏幕事件
	local getUpDownOffset = hApi.DoNothing --获得第一个控件和最后一个控件距离最上面边界线和最下面边界线的距离
	local OnClickChestReward = hApi.DoNothing --选中某个奖励
	local refresh_dlcmapinfo_UI_loop = hApi.DoNothing --刷新DLC地图面板界面的滚动
	
	local MAX_SPEED = 50 --最大速度
	local DLCMAPINFO_WIDTH = hVar.EquipWH --DLC地图包宽度
	local DLCMAPINFO_HEIGHT = hVar.EquipWH --DLC地图包高度
	local DLCMAPINFO_OFFSETY = 80 --DLC地图包y间距
	
	--动画打开奖励的索引
	local m_currLength = 1
	
	--可变参数
	local current_DLCMap_max_num = g_MAX_LENGTH --最大的DLC地图包数量
	
	--控制参数
	local click_pos_x_dlcmapinfo = 0 --开始按下的坐标x
	local click_pos_y_dlcmapinfo = 0 --开始按下的坐标y
	local last_click_pos_y_dlcmapinfo = 0 --上一次按下的坐标x
	local last_click_pos_y_dlcmapinfo = 0 --上一次按下的坐标y
	local draggle_speed_y_dlcmapinfo = 0 --当前滑动的速度x
	local selected_dlcmapinfoEx_idx = 0 --选中的DLC地图面板ex索引
	local click_scroll_dlcmapinfo = false --是否在滑动DLC地图面板中
	local b_need_auto_fixing_dlcmapinfo = false --是否需要自动修正
	local friction_dlcmapinfo = 0 --阻力
	
	--定义每个分辨率下，一行能摆下的卡片总数量
	local CARD_X_NUM_MAX = 7
	if (g_phone_mode == 1) then --iPhone4
		--
	elseif (g_phone_mode == 2) then --iPhone5
		--
	elseif (g_phone_mode == 3) then --iPhone6, iPhone7, iPhone8
		CARD_X_NUM_MAX = 7
	elseif (g_phone_mode == 4) then --iPhoneX
		CARD_X_NUM_MAX = 7
	elseif (g_phone_mode == 5) then --安卓宽屏
		CARD_X_NUM_MAX = 7
	elseif (g_phone_mode == 6) then --平板宽屏
		CARD_X_NUM_MAX = 7
	end
	
	--竖屏模式
	if (hVar.SCREEN_MODE == hVar.SCREEN_MODE_DEFINE.VERTICAL) then
		CARD_X_NUM_MAX = 4
	end
	
	--定义一页最多列数
	local CARD_Y_NUM_MAX = 2
	
	--播放箱子音效
	--hApi.PlaySound("magic11")
	local m_chest_state = 0 --开宝箱状态(0:初始化 / 1:宝箱打开动画 / 2:宝箱打开动画完成 / 3:宝箱出奖励动画 / 4:宝箱出奖励动画中 / 5:宝箱出奖励动画完成)
	local m_play_speed = 1.0 --播放速率
	local PLAY_SPEED_MAX = 4.0 --最大速率
	
	--动画开始，禁止自动旋转
	--锁定视角及屏幕
	--print("锁定视角及屏幕")
	if type(xlGetScreenRotation) == "function" and type(xlRotateScreen) == "function" then
		--不可旋转
		local orientation, lock_flag = xlGetScreenRotation()
		--if lock_flag == 0 then
			xlRotateScreen(orientation,  1)               --设置屏幕朝向以及是否锁定
		--end
	end
	
	--大底板
	hGlobal.UI.CoverFrame = hUI.frame:new({
		x = 0,
		y = 0,
		z = hZorder.ChestReward,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		--z = -1,
		show = 1,
		--dragable = 3, --3:点击后消失
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = -1, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--print("点击事件（有可能在控件外部点击）")
				
				--检测是否点在滑动控件里
				--注意: 这里在需要滑动时才会接管事件，不满一页时点击后还是会消失
				if (current_DLCMap_max_num > (CARD_X_NUM_MAX * CARD_Y_NUM_MAX)) then
					local ctrlI = hGlobal.UI.CoverFrame.childUI["ItemEventNode"]
					if ctrlI then
						local bcx = ctrlI.data.x --中心点x坐标
						local bcy = ctrlI.data.y --中心点y坐标
						local bcw, bch = ctrlI.data.w, ctrlI.data.h
						local blx, bly = 0 + bcx - bcw / 2, 0  + bcy- bch / 2 --最左上侧坐标
						local brx, bry = blx + bcw, bly + bch --最右下角坐标
						--print(i, lx, rx, ly, ry, touchX, touchY)
						if (screenX >= blx) and (screenX <= brx) and (screenY >= bly) and (screenY <= bry) then
							--print("点在滑动控件里")
							return
						end
					end
				end
				
				--模拟点击
				OnClickChest(nil, screenX, screenY)
			end
		end,
	})
	hGlobal.UI.CoverFrame:active()
	
	local _frm = hGlobal.UI.CoverFrame
	local _Parent = _frm.handle._n
	local _ChildUI = _frm.childUI
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2
	
	--左侧裁剪区域
	local clipY = _offY+190+75
	local clipW = hVar.SCREEN.w
	local clipH = hVar.SCREEN.h - 220
	if (g_phone_mode == 1) then --iPhone4
		--
	elseif (g_phone_mode == 2) then --iPhone5
		--
	elseif (g_phone_mode == 3) then --iPhone6, iPhone7, iPhone8
		clipY = _offY+190+50
	elseif (g_phone_mode == 4) then --iPhoneX
		clipY = _offY+190+50
	elseif (g_phone_mode == 5) then --安卓宽屏
		clipY = _offY+190+50
	elseif (g_phone_mode == 6) then --平板宽屏
		clipY = _offY+190+75
	end
	if (hVar.SCREEN_MODE == hVar.SCREEN_MODE_DEFINE.VERTICAL) then --竖屏模式
		if (g_phone_mode == 1) then --iPhone4
			--
		elseif (g_phone_mode == 2) then --iPhone5
			--
		elseif (g_phone_mode == 3) then --iPhone6, iPhone7, iPhone8
			clipY = _offY+190+50+52+10
		elseif (g_phone_mode == 4) then --iPhoneX
			clipY = _offY+190+50+52+10+140
		elseif (g_phone_mode == 5) then --安卓宽屏
			clipY = _offY+190+50+52
		elseif (g_phone_mode == 6) then --平板宽屏
			clipY = _offY+190+75+52
		end
		
		clipH = hVar.SCREEN.h - 640 --640
	end
	
	local _BTC_PageClippingRect = {0, clipY, clipW, clipH, 0} -- {x, y, w, h, show}
	local _BTC_pClipNode_chest = nil
	--超过一页才需要创建滑动控件
	if (current_DLCMap_max_num > (CARD_X_NUM_MAX * CARD_Y_NUM_MAX)) then
		_BTC_pClipNode_chest = hApi.CreateClippingNode(_frm, _BTC_PageClippingRect, 98, _BTC_PageClippingRect[5], "_BTC_pClipNode_chest")
	end
	
	--显示所有的clipNode
	hApi.EnableClipByName(_frm, "_BTC_pClipNode_chest", 1)
	
	--tip图片背景
	_ChildUI["ItemBG_1"] = hUI.button:new({
		parent = _Parent,
		--model = "UI_frm:slot",
		--animation = "normal",
		--model = "UI:TacticBG",
		model = -1,
		x = _offX,
		y = _offY,
		z = -10,
		w = 1,
		h = 1,
	})
	--_ChildUI["ItemBG_1"].handle.s:setOpacity(0) --只挂载子控件，不显示
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", 0, 0, hVar.SCREEN.w, hVar.SCREEN.h, _ChildUI["ItemBG_1"])
	--local img9 = hApi.CCScale9SpriteCreate("data/image/ui/TacticBG.png", 0, 0, hVar.SCREEN.w, hVar.SCREEN.h, _ChildUI["ItemBG_1"])
	img9:setOpacity(204)
	
	--绘制奖励底板（9宫格）
	local deltaX = 0
	local deltaY = 0
	local deltaH = 190
	--竖屏模式
	if (hVar.SCREEN_MODE == hVar.SCREEN_MODE_DEFINE.VERTICAL) then
		deltaH = 590
	end
	
	local img91 = CCScale9Sprite:create("data/image/misc/chest/bg_9s_2.png")
	--local img9 = CCScale9Sprite:createWithSpriteFrameName("data/image/ui/pvp/pvptimeoutbg2.png")
	if img91 then
		img91:setPosition(ccp(_offX + deltaX, _offY + deltaY))
		--img91:setCapInsets(CCRectMake(10, 5, 490, 115))
		img91:setContentSize(CCSizeMake(hVar.SCREEN.w - 40 - iPhoneX_WIDTH * 2, hVar.SCREEN.h - deltaH))
		--img91:setColor(ccc3(255, 255, 0))
		img91:setOpacity(168)
		_Parent:addChild(img91)
	end
	
	--竖屏模式
	local congratulationY = 95
	if (hVar.SCREEN_MODE == hVar.SCREEN_MODE_DEFINE.VERTICAL) then
		congratulationY = 295
	end
	
	--恭喜您获得的左底纹
	_ChildUI["ItemBG_GreetingBGLeft"] = hUI.image:new({
		parent = _Parent,
		model = "misc/lightline.png",
		x = _offX - 116,
		y = hVar.SCREEN.h - congratulationY - 1,
		w = 292,
		h = 6,
	})
	_ChildUI["ItemBG_GreetingBGLeft"].handle._n:setVisible(false) --一开始不显示
	
	--恭喜您获得的左底纹
	_ChildUI["ItemBG_GreetingBGRight"] = hUI.image:new({
		parent = _Parent,
		model = "misc/lightline.png",
		x = _offX + 116,
		y = hVar.SCREEN.h - congratulationY - 1,
		w = 292,
		h = 6,
	})
	_ChildUI["ItemBG_GreetingBGRight"].handle._n:setVisible(false) --一开始不显示
	
	--恭喜您获得的转动图
	_ChildUI["ItemBG_GreetingImgRot"] = hUI.image:new({
		parent = _Parent,
		model = "misc/chest/Sprite_Shine.png",
		x = _offX,
		y = hVar.SCREEN.h - congratulationY,
		w = 139,
		h = 136,
	})
	local rot = CCRotateBy:create(3.0, 360)
	_ChildUI["ItemBG_GreetingImgRot"].handle.s:runAction(CCRepeatForever:create(rot))
	_ChildUI["ItemBG_GreetingImgRot"].handle._n:setOpacity(0) --一开始不显示
	
	--恭喜您获得的图片文字
	_ChildUI["ItemBG_GreetingImg"] = hUI.image:new({
		parent = _Parent,
		model = "misc/chest/Sprite_Text.png",
		x = _offX,
		y = hVar.SCREEN.h - congratulationY - 2,
		w = 436,
		h = 90,
	})
	_ChildUI["ItemBG_GreetingImg"].handle._n:setOpacity(0) --一开始不显示
	
	--宝箱的父控件
	_ChildUI["ItemBG_ChestNode"] = hUI.button:new({ --作为按钮是为了挂载子控件
		parent = _Parent,
		model = "misc/mask.png",
		x = _offX - 10,
		y = _offY - 30,
		w = 1,
		h = 1,
	})
	_ChildUI["ItemBG_ChestNode"].handle.s:setOpacity(0) --只挂载子控件，不显示
	
	--[[
	--宝箱的父控件一开始抖动
	local rot1 = CCEaseSineOut:create(CCRotateBy:create(0.1, -10))
	local rot2 = CCEaseSineOut:create(CCRotateBy:create(0.1, 10))
	local delay1 = CCDelayTime:create(0.01)
	local a = CCArray:create()
	a:addObject(rot1)
	a:addObject(rot2)
	a:addObject(delay1)
	local sequence = CCSequence:create(a)
	_ChildUI["ItemBG_ChestNode"].handle._n:runAction(CCRepeatForever:create(sequence))
	]]
	
	--播放音效
	--hApi.PlaySound("turntable_start")
	
	local chestScale = 0.64
	--[[
	--宝箱底图1
	local chestScale = 0.64
	_ChildUI["ItemBG_ChestNode"].childUI["box1"] = hUI.image:new({
		parent = _ChildUI["ItemBG_ChestNode"].handle._n,
		model = "misc/chest/Effect_bx1.png",
		x = 0,
		y = 0,
		w = 119 * chestScale,
		h = 94 * chestScale,
	})
	
	--宝箱底图2
	_ChildUI["ItemBG_ChestNode"].childUI["box2"] = hUI.image:new({
		parent = _ChildUI["ItemBG_ChestNode"].handle._n,
		model = "misc/chest/Effect_bx2.png",
		x = 0 * chestScale,
		y = 40 * chestScale,
		w = 123 * chestScale,
		h = 80 * chestScale,
	})
	]]
	
	--宝箱底图3
	_ChildUI["ItemBG_ChestNode"].childUI["box3"] = hUI.image:new({
		parent = _ChildUI["ItemBG_ChestNode"].handle._n,
		model = "MODEL_EFFECT:OpenChest",
		x = 0 * chestScale + 12,
		y = 50 * chestScale + 2,
		scale = 1.0,
		w = 324,
		h = 308,
	})
	local delay1 = CCDelayTime:create(0.9)
	local callback1 = CCCallFunc:create(function()
		_ChildUI["ItemBG_ChestNode"].childUI["box3"].handle._n:setVisible(false)
	end)
	local a = CCArray:create()
	a:addObject(delay1)
	a:addObject(callback1)
	local sequence = CCSequence:create(a)
	_ChildUI["ItemBG_ChestNode"].childUI["box3"].handle._n:runAction(sequence)
	--_ChildUI["ItemBG_ChestNode"].childUI["box3"].handle._n:setOpacity(0) --一开始隐藏
	
	--[[
	--宝箱底纹闪光特效
	_ChildUI["ItemBG_ChestNode"].childUI["boxlight"] = hUI.image:new({
		parent = _ChildUI["ItemBG_ChestNode"].handle._n,
		model = "MODEL_EFFECT:break_down",
		x = 0 * chestScale,
		y = 20 * chestScale,
		z = -1,
		scale = 2.3,
	})
	]]
	
	--[[
	--宝箱打开后闪光特效
	_ChildUI["ItemBG_ChestNode"].childUI["light"] = hUI.image:new({
		parent = _ChildUI["ItemBG_ChestNode"].handle._n,
		model = "misc/chest/Sprite_Light_Green.png",
		x = 5 * chestScale,
		y = 35 * chestScale,
		w = 192 * chestScale,
		h = 192 * chestScale,
	})
	_ChildUI["ItemBG_ChestNode"].childUI["light"].handle._n:setOpacity(0) --一开始隐藏
	local rot = CCRotateBy:create(1.0, 360)
	_ChildUI["ItemBG_ChestNode"].childUI["light"].handle.s:runAction(CCRepeatForever:create(rot))
	]]
	
	--文字
	_ChildUI["ItemBG_Label"] = hUI.label:new({
		parent = _Parent,
		x = _offX,
		y = 60,
		size = 20,
		font = hVar.FONTC,
		align = "MC",
		width = 500,
		border = 0,
		--text = "点击屏幕加速", --language
		text = hVar.tab_string["__TEXT_Page_AcreenSpeedUp"], --language
	})
	--文字动画
	local act1 = CCEaseSineIn:create(CCFadeTo:create(1.0, 0))
	local act2 = CCEaseSineIn:create(CCFadeTo:create(1.0, 255))
	local act12 = CCSequence:createWithTwoActions(act1, act2)
	_ChildUI["ItemBG_Label"].handle.s:runAction(CCRepeatForever:create(act12))
	
	--滑动响应区域
	_ChildUI["ItemEventNode"] = hUI.button:new({
		parent = _Parent,
		model = "misc/mask.png",
		x = _offX + deltaX,
		y = _offY + deltaY,
		w = hVar.SCREEN.w - 40 - iPhoneX_WIDTH * 2,
		h = hVar.SCREEN.h - 190,
		dragbox = _frm.childUI["dragBox"],
		failcall = 1,
		
		--按下事件
		codeOnTouch = function(self, touchX, touchY, sus)
			--开箱子动画未结束前，不能滑动
			if (m_chest_state < 5) then
				return
			end
			
			--超过一页才需要检测滑动
			if (current_DLCMap_max_num <= (CARD_X_NUM_MAX * CARD_Y_NUM_MAX)) then
				return
			end
			
			--print("codeOnTouch", touchX, touchY, sus)
			click_pos_x_dlcmapinfo = touchX --开始按下的坐标x
			click_pos_y_dlcmapinfo = touchY --开始按下的坐标y
			last_click_pos_y_dlcmapinfo = touchX --上一次按下的坐标x
			last_click_pos_y_dlcmapinfo = touchY --上一次按下的坐标y
			draggle_speed_y_dlcmapinfo = 0 --当前速度为0
			selected_dlcmapinfoEx_idx = 0 --选中的DLC地图面板ex索引
			click_scroll_dlcmapinfo = true --是否滑动DLC地图面板
			b_need_auto_fixing_dlcmapinfo = false --不需要自动修正位置
			friction_dlcmapinfo = 0 --无阻力
			
			--检测是否滑动到了最顶部或最底部
			local delta1_ly = 0 --第一个DLC地图面板最上侧的y坐标
			local deltNa_ry = 0 --最后一个DLC地图面板最下侧的y坐标
			delta1_ly, deltNa_ry = getUpDownOffset()
			--print(delta1_ly, deltNa_ry)
			--delta1_ly +:在下底线之上 /-:在下底线之下
			--deltNa_ry +:在下底线之上 /-:在下底线之下
			
			--print("click_scroll_dlcmapinfo=", click_scroll_dlcmapinfo)
			
			--不满一页
			--上面对其上顶线，下面在在下底线之上
			if (delta1_ly == 0) and (deltNa_ry >= 0) then
				click_scroll_dlcmapinfo = false --不需要滑动DLC地图面板
			end
		end,
		
		--滑动事件
		codeOnDrag = function(self, touchX, touchY, sus)
			--开箱子动画未结束前，不能滑动
			if (m_chest_state < 5) then
				return
			end
			
			--超过一页才需要检测滑动
			if (current_DLCMap_max_num <= (CARD_X_NUM_MAX * CARD_Y_NUM_MAX)) then
				return
			end
			
			--print("codeOnDrag", touchX, touchY, sus)
			local deltaY = touchY - last_click_pos_y_dlcmapinfo --与开始按下的位置的偏移值x
			
			--处理移动速度y
			draggle_speed_y_dlcmapinfo = touchY - last_click_pos_y_dlcmapinfo
			
			if (draggle_speed_y_dlcmapinfo > MAX_SPEED) then
				draggle_speed_y_dlcmapinfo = MAX_SPEED
			end
			if (draggle_speed_y_dlcmapinfo < -MAX_SPEED) then
				draggle_speed_y_dlcmapinfo = -MAX_SPEED
			end
			
			--检测是否滑动到了最顶部或最底部
			local delta1_ly = 0 --第一个DLC地图面板最上侧的y坐标
			local deltNa_ry = 0 --最后一个DLC地图面板最下侧的y坐标
			delta1_ly, deltNa_ry = getUpDownOffset()
			--print(delta1_ly, deltNa_ry)
			--delta1_ly +:在下底线之上 /-:在下底线之下
			--deltNa_ry +:在下底线之上 /-:在下底线之下
			--第一个DLC地图面板的坐标不能跑到最上侧的下边去
			if ((delta1_ly + deltaY) <= 0) then --防止走过
				deltaY = -delta1_ly
				delta1_ly = 0
				
				--没有惯性
				draggle_speed_y_dlcmapinfo = 0
				
				--_frmNode.childUI["DLCMapInfoPageUp"].handle.s:setVisible(false) --上分翻页提示
			else
				--if click_scroll_dlcmapinfo then
				--	_frmNode.childUI["DLCMapInfoPageUp"].handle.s:setVisible(true) --上分翻页提示
				--end
			end
			
			--最后一个DLC地图面板的坐标不能跑到最下侧的上边去
			--print(deltNa_ry, deltaY)
			if ((deltNa_ry + deltaY) >= 0) then --防止走过
				deltaY = -deltNa_ry
				deltNa_ry = 0
				
				--没有惯性
				draggle_speed_y_dlcmapinfo = 0
				
				--已到底部，标记下拉到底部（为true时有新消息自动滚到最下端）
				--current_in_scroll_down = true
				--_frmNode.childUI["DLCMapInfoPageDown"].handle.s:setVisible(false) --下分翻页提示
			else
				--if click_scroll_dlcmapinfo then
				--	_frmNode.childUI["DLCMapInfoPageDown"].handle.s:setVisible(true) --下分翻页提
				--end
			end
			
			--print("click_scroll_dlcmapinfo=", click_scroll_dlcmapinfo)
			--在滑动过程中才会处理滑动
			if click_scroll_dlcmapinfo then
				--local deltaY = touchY - last_click_pos_y_dlcmapinfo --与开始按下的位置的偏移值x
				for i = 1, current_DLCMap_max_num, 1 do
					local ctrli = _ChildUI["ItemBG_Card_View" .. i]
					ctrli.handle._n:setPosition(ctrli.data.x, ctrli.data.y + deltaY)
					ctrli.data.x = ctrli.data.x
					ctrli.data.y = ctrli.data.y + deltaY
				end
			end
			
			--存储本次的位置
			last_click_pos_y_dlcmapinfo = touchX
			last_click_pos_y_dlcmapinfo = touchY
		end,
		
		--抬起事件
		code = function(self, touchX, touchY, sus)
			--开箱子动画未结束前，不能滑动
			--按照模拟点击屏幕处理
			if (m_chest_state < 5) then
				--模拟点击
				OnClickChest(nil, touchX, touchY)
				
				return
			end
			
			--超过一页才需要检测滑动
			if (current_DLCMap_max_num <= (CARD_X_NUM_MAX * CARD_Y_NUM_MAX)) then
				return
			end
			
			--print("code", touchX, touchY, sus)
			--如果之前在滑动中，那么标记需要自动修正位置
			if click_scroll_dlcmapinfo then
				--if (touchX ~= click_pos_x_dlcmapinfo) or (touchY ~= click_pos_y_dlcmapinfo) then --不是点击事件
					b_need_auto_fixing_dlcmapinfo = true
					friction_dlcmapinfo = 0
				--end
			end
			
			--是否选中某个DLC地图面板查看区域内查看tip
			local selectTipIdx = 0
			for i = 1, current_DLCMap_max_num, 1 do
				local ctrli = _ChildUI["ItemBG_Card_View" .. i]
				local cx = ctrli.data.x --中心点x坐标
				local cy = ctrli.data.y --中心点y坐标
				local cw, ch = ctrli.data.w, ctrli.data.h
				local lx, ly = cx - cw / 2, cy - ch / 2 --最左上侧坐标
				local rx, ry = lx + cw, ly + ch --最右下角坐标
				--print(i, lx, rx, ly, ry, touchX, touchY)
				if (touchX >= lx) and (touchX <= rx) and (touchY >= ly) and (touchY <= ry) then
					selectTipIdx = i
					
					break
					--print("点击到了哪个DLC地图面板tip的框内" .. i)
				end
			end
			
			if (click_scroll_dlcmapinfo) and (math.abs(touchY - click_pos_y_dlcmapinfo) > 48) then
				selectTipIdx = 0
			end
			
			if (selectTipIdx > 0) then
				--显示tip
				--print("选中", selectTipIdx)
				OnClickChestReward(selectTipIdx)
			end
			
			--标记不用滑动
			click_scroll_dlcmapinfo = false
		end,
	})
	_ChildUI["ItemEventNode"].handle.s:setOpacity(0) --只响应事件，不显示
	
	--依次创建每个奖励
	for i = 1, current_DLCMap_max_num, 1 do
		local rewardTex = rewardEx[i]
		local rewardId = rewardTex.rewardId
		local rewardType = rewardTex.rewardType
		
		--道具图标
		--返回值: tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h
		local tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h =
			--rewardTex.rewardType,
			rewardTex.tmpModel,
			rewardTex.itemName,
			rewardTex.itemNum,
			rewardTex.itemWidth,
			rewardTex.itemHeight,
			rewardTex.sub_tmpModel,
			rewardTex.sub_pos_x,
			rewardTex.sub_pos_y,
			rewardTex.sub_pos_w,
			rewardTex.sub_pos_h
		local xoffset = 0
		local yOffset = 20
		local WW = DLCMAPINFO_WIDTH
		local HH = DLCMAPINFO_HEIGHT
		
		--计算列数
		local CARD_Y_NUM = math.ceil(g_MAX_LENGTH / CARD_X_NUM_MAX)
		if (CARD_Y_NUM > CARD_Y_NUM_MAX) then
			CARD_Y_NUM = CARD_Y_NUM_MAX
		end
		
		local card_x_num = g_MAX_LENGTH
		if (card_x_num > CARD_X_NUM_MAX) then
			card_x_num = CARD_X_NUM_MAX
		end
		if ((card_x_num % 2) == 1) then --奇数
			xoffset = (card_x_num - 1) / 2 * (WW + 50) - (WW + 50) / 2
		else --偶数
			xoffset = (card_x_num - 2) / 2 * (WW + 50)
		end
		
		if ((CARD_Y_NUM % 2) == 1) then --奇数
			yoffset = 10 - (CARD_Y_NUM - 1) / 2 * (HH + DLCMAPINFO_OFFSETY)
		else --偶数
			yoffset = 10 - (CARD_Y_NUM - 2) / 2 * (HH + DLCMAPINFO_OFFSETY) - (HH + DLCMAPINFO_OFFSETY) / 2
		end
		
		local xn = (i % CARD_X_NUM_MAX)
		if (xn == 0) then
			xn = CARD_X_NUM_MAX
		end
		local yn = math.ceil(i / CARD_X_NUM_MAX)
		--print(xn, yn)
		
		--[[
		--创建神器的闪光背景
		if (rewardType == 10) then --10:神器
			_ChildUI["ItemBG_Card_Light" .. i] = hUI.image:new({
				parent = _Parent,
				model = "MODEL_EFFECT:break_down",
				x = _offX + deltaX - xoffset - 60 + (i - 1) * (WW + 50),
				y = _offY + deltaY,
				scale = 2.6,
			})
		end
		]]
		
		--创建得到的道具正面
		local pvpprivatesModel = "misc/tempbag/square.png"
		if (rewardType == 10) then --10:神器
			--pvpprivatesModel = "UI:pvpprivatesb4"
		end
		_ChildUI["ItemBG_Card_View" .. i] = hUI.button:new({ --作为button是为了挂载自子控件
			parent = _BTC_pClipNode_chest or _Parent, --_Parent,
			model = pvpprivatesModel,
			x = _offX + deltaX - xoffset - 60 + (xn - 1) * (WW + 50),
			y = _offY + deltaY - yoffset - (yn - 1) * (HH + DLCMAPINFO_OFFSETY),
			w = 120,
			h = 144,
		})
		_ChildUI["ItemBG_Card_View" .. i].handle.s:setOpacity(0) --王总说不显示底纹了
		_ChildUI["ItemBG_Card_View" .. i].handle._n:setVisible(false) --一开始不显示
		
		--奖励物品的图标
		_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"] = hUI.button:new({
			parent = _ChildUI["ItemBG_Card_View" .. i].handle._n,
			model = tmpModel,
			x = 0,
			y = 15,
			w = WW,
			h = HH,
			align = "MC",
		})
		
		--特殊处理：王总说装备不显示底图了
		if (rewardType == 10) then --10:红装
			_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle.s:setOpacity(0)
		end
		
		--特殊处理：枪变大些
		if (rewardType == 101) then --101:武器枪碎片
			_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle.s:setScale(1)
		end
		
		--绘制奖励图标的子控件
		if sub_tmpModel then
			--奖励类型(1:积分 / 2:战术技能卡 / 3:道具 / 4:英雄 / 5:英雄将魂 / 6:战术技能卡碎片 / 7:游戏币 / 8:网络宝箱 / 9:抽奖类战术技能卡 / 10:神器 / 11:神器晶石 / 12:红装兑换券 / 13:服务器抽卡 / 14:英雄经验卡 / 15:直接开锦囊 / 16:铁 / 17:木材 / 18:粮食 / 20:军团币 / 21:强化免费券 / 22:宝物碎片 / 23:藏宝图碎片 / 24:高级藏宝图碎片 / 25:兵符 / 26:抽奖免费券)
			if (rewardType == 5) or (rewardType == 6) or (rewardType == 101) or (rewardType == 103) then --5:英雄将魂 / 6:战术技能卡碎片 / 101:武器枪碎片 / 103:宠物碎片
				_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["image"] = hUI.image:new({
					parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
					model = sub_tmpModel,
					x = sub_pos_x * WW / itemWidth + 0.6 * 8, --碎片小一点，王总说太大了挡住英雄
					y = sub_pos_y * HH / itemHeight - 0.6 * 12, --碎片小一点，王总说太大了挡住英雄
					w = sub_pos_w * WW / itemWidth * 0.6, --碎片小一点，王总说太大了挡住英雄
					h = sub_pos_h * HH / itemHeight * 0.6, --碎片小一点，王总说太大了挡住英雄
				})
			else
				--神器有个道具图标烧火的特效
				if (rewardType == 10) then --10:神器
					--[[
					_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["fire"] = hUI.image:new({
						parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
						model = "MODEL_EFFECT:Fire02",
						x = sub_pos_x * WW / itemWidth,
						y = sub_pos_y * HH / itemHeight,
						scale = 0.9,
					})
					_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["fire"].handle.s:setOpacity(128)
					]]
				end
				
				_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["image"] = hUI.image:new({
					parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
					model = sub_tmpModel,
					x = sub_pos_x * WW / itemWidth,
					y = sub_pos_y * HH / itemHeight,
					w = sub_pos_w * WW / itemWidth,
					h = sub_pos_h * HH / itemHeight,
				})
				
				--神器有个道具图标闪烁的动画
				if (rewardType == 10) then --10:神器
					local Scale0 = sub_pos_w * WW / itemWidth / 72
					local towAction = CCSequence:createWithTwoActions(CCScaleTo:create(0.6, Scale0 - 0.013), CCScaleTo:create(0.6, Scale0 + 0.04))
					local forever = CCRepeatForever:create(tolua.cast(towAction, "CCActionInterval"))
					_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["image"].handle.s:runAction(forever)
				end
				
				--神器显示孔数量
				if (rewardType == 10) then --10:神器
					local slotAttr = rewardTex.slotAttr
					local itemEntity = slotAttr
					--print(tAttr[1], tAttr[2], tAttr[3], tAttr[4])
					local entity = {}
					local tEntity = hApi.Split(itemEntity,"|")
					
					--28922|20205|0||0|2|11|12|21|22|31|32|41|42|51|52|61|62|71|72|81|82:0
					entity.dbid = tonumber(tEntity[1]) or 0
					entity.typeId = tonumber(tEntity[2]) or 0
					entity.slotnum = tonumber(tEntity[3]) or 0
					entity.attr = {}
					local idx = 3
					for i = 1, entity.slotnum do
						entity.attr[#entity.attr + 1] = tEntity[idx + i]
					end
					
					idx = idx + entity.slotnum + 1
					
					entity.CUnique = tonumber(tEntity[idx+1]) or 0
					entity.quality = tonumber(tEntity[idx+2]) or 0
					entity.randIdx1 = tonumber(tEntity[idx+3]) or 0 --随机属性索引1
					entity.randVal1 = tonumber(tEntity[idx+4]) or 0 --随机属性值1
					entity.randIdx2 = tonumber(tEntity[idx+5]) or 0 --随机属性索引2
					entity.randVal2 = tonumber(tEntity[idx+6]) or 0 --随机属性值2
					entity.randIdx3 = tonumber(tEntity[idx+7]) or 0 --随机属性索引3
					entity.randVal3 = tonumber(tEntity[idx+8]) or 0 --随机属性值3
					entity.randIdx4 = tonumber(tEntity[idx+9]) or 0 --随机属性索引4
					entity.randVal4 = tonumber(tEntity[idx+10]) or 0 --随机属性值4
					entity.randIdx5 = tonumber(tEntity[idx+11]) or 0 --随机属性索引5
					entity.randVal5 = tonumber(tEntity[idx+12]) or 0 --随机属性值5
					entity.randSkillIdx1 = tonumber(tEntity[idx+13]) or 0 --随机技能索引1
					entity.randSkillLv1 = tonumber(tEntity[idx+14]) or 0 --随机技能等级1
					entity.randSkillIdx2 = tonumber(tEntity[idx+15]) or 0 --随机技能索引2
					entity.randSkillLv2 = tonumber(tEntity[idx+16]) or 0 --随机技能等级2
					entity.randSkillIdx3 = tonumber(tEntity[idx+17]) or 0 --随机技能索引3
					entity.randSkillLv3 = tonumber(tEntity[idx+18]) or 0 --随机技能等级3
					
					--[[
					--测试 --test
					slotNum = 3
					]]
					
					local SlotPosList = 
					{
						{{0, 31},}, --1孔
						{{-7, 31}, {7, 31},}, --2孔
						{{-14, 31}, {0, 31}, {14, 31},}, --3孔
						{{-21, 31}, {-7, 31}, {7, 31}, {21, 31},}, --4孔
					}
					for s = 1, entity.slotnum, 1 do
						local attr_s = entity.attr[s] --孔的属性（字符串）
						print("attr=", attr_s)
						local attrVal = hVar.ITEM_ATTR_VAL[attr_s] --对应的孔的属性表
						local chipModel = hVar.ITEM_ATTR_CHIP_IMG_DEF[attrVal.quality]
						
						local deltaX = SlotPosList[entity.slotnum][s][1]
						local deltaY = SlotPosList[entity.slotnum][s][2]
						_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["slot" .. s] = hUI.image:new({
							parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
							model = chipModel, --"MODEL_EFFECT:diamond",
							x = sub_pos_x * WW / itemWidth + deltaX *  (WW / itemWidth),
							y = sub_pos_y * HH / itemHeight + deltaY * (HH / itemHeight),
							w = 22,
							h = 22,
						})
						_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["slot" .. s].handle._n:setVisible(false) --一开始不显示孔
					end
				end
				
				--[[
				--神器显示品质
				if (rewardType == 10) then --10:神器
					--品质前缀
					_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["qualityPrefix"] = hUI.label:new({
						parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
						x = 14,
						y = 68,
						width = 300,
						text = hVar.tab_string["__TEXT_Quality"], --"品质"
						border = 1,
						RGB = {255, 255, 0,},
						font = hVar.FONTC,
						align = "RC",
						size = 26,
					})
					
					--品质
					local quality = tonumber(rewardTex.param4) or 0
					_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["quality"] = hUI.label:new({
						parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
						x = 14 + 10,
						y = 68,
						width = 300,
						text = quality,
						border = 1,
						RGB = {255, 255, 0,},
						font = hVar.FONTC,
						align = "LC",
						size = 26,
					})
				end
				]]
			end
		end
		
		--奖励物品的名称
		local fontLength = #itemName
		local fontSize = 24
		if (fontLength >= 18) then
			fontSize = 22
		end
		_ChildUI["ItemBG_Card_View" .. i].childUI["labName"] = hUI.label:new({
			parent = _ChildUI["ItemBG_Card_View" .. i].handle._n,
			size = fontSize,
			align = "MC",
			border = 1,
			x = 0,
			y = -48,
			--font = hVar.FONTC,
			font = hVar.FONTC,
			width = 290,
			text = itemName,
		})
		--_ChildUI["ItemBG_Card_View" .. i].childUI["labName"].handle.s:setColor(ccc3(196, 255, 196))
		if (rewardType == 3) or (rewardType == 10) then --3:道具 / 10:神器
			local itemLv = hVar.tab_item[rewardId].itemLv or 1
			local NAMERGB = hVar.ITEMLEVEL[itemLv].NAMERGB
			_ChildUI["ItemBG_Card_View" .. i].childUI["labName"].handle.s:setColor(ccc3(NAMERGB[1], NAMERGB[2], NAMERGB[3]))
		end
		
		--奖励物品的数量
		local intro = "+" .. itemNum
		local fontNumLength = #intro
		local fontNum = "numWhite"
		local fontNumSize = 20
		if (fontNumLength == 5) then
			fontNumSize = 17
		elseif (fontNumLength == 6) then
			fontNum = hVar.FONTC
			fontNumSize = 20
		elseif (fontNumLength >= 7) then
			fontNum = hVar.FONTC
			fontNumSize = 18
		end
		_ChildUI["ItemBG_Card_View" .. i].childUI["labIntro"] = hUI.label:new({
			parent = _ChildUI["ItemBG_Card_View" .. i].handle._n,
			size = fontNumSize,
			align = "RC",
			border = 1,
			x = 35,
			y = -10,
			--font = hVar.FONTC,
			font = fontNum,
			width = 300,
			text = intro,
		})
		--_ChildUI["ItemBG_Card_View" .. i].childUI["labIntro"].handle.s:setColor(ccc3(255, 255, 0))
		
		--如果是碎片数量，数量是1，2，5，10等特定是数字，碎片数量换成图片形式
		if (rewardType == 3) or (rewardType == 10) then --道具不显示数量了
			hApi.safeRemoveT(_ChildUI["ItemBG_Card_View" .. i].childUI, "labIntro")
		end
		if (rewardType == 6) or (rewardType == 101) or (rewardType == 103) or (rewardType == 105) or (rewardType == 106) or (rewardType == 107) or (rewardType == 108) then
			if (itemNum == 1) then --碎片*1
				hApi.safeRemoveT(_ChildUI["ItemBG_Card_View" .. i].childUI, "labIntro")
				hApi.safeRemoveT(_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI, "image")
				
				--碎片*1的单独图标
				_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["image"] = hUI.image:new({
					parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
					model = "ICON:debris_1",
					x = 0,
					y = -30,
					scale = 1.0,
				})
			elseif (itemNum == 2) then --碎片*2
				hApi.safeRemoveT(_ChildUI["ItemBG_Card_View" .. i].childUI, "labIntro")
				hApi.safeRemoveT(_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI, "image")
				
				--碎片*2的单独图标
				_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["image"] = hUI.image:new({
					parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
					model = "ICON:debris_2",
					x = 0,
					y = -30,
					scale = 1.0,
				})
			elseif (itemNum == 5) then --碎片*5
				hApi.safeRemoveT(_ChildUI["ItemBG_Card_View" .. i].childUI, "labIntro")
				hApi.safeRemoveT(_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI, "image")
				
				--碎片*5的单独图标
				_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["image"] = hUI.image:new({
					parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
					model = "ICON:debris_5",
					x = 0,
					y = -30,
					scale = 1.0,
				})
			elseif (itemNum == 10) then --碎片*10
				hApi.safeRemoveT(_ChildUI["ItemBG_Card_View" .. i].childUI, "labIntro")
				hApi.safeRemoveT(_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI, "image")
				
				--碎片*10的单独图标
				_ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].childUI["image"] = hUI.image:new({
					parent = _ChildUI["ItemBG_Card_View" .. i].childUI["imgIcon"].handle._n,
					model = "ICON:debris_10",
					x = 0,
					y = -30,
					scale = 1.0,
				})
			end
		end
	end
	
	--点击屏幕执行的函数
	OnClickChest = function(bAuto, screenX, screenY)
		--print("OnClickChest", m_chest_state)
		
		if (m_chest_state == 0) then --0:初始化
			--标记状态为宝箱打开动画
			m_chest_state = 1
			
			--如果不是自动进入，加速动画，并隐藏文字
			if (not bAuto) then
				--加速
				m_play_speed = m_play_speed + 1.0 --播放速率
				
				--不超过最大速率
				if (m_play_speed > PLAY_SPEED_MAX) then
					m_play_speed = PLAY_SPEED_MAX
				end
				
				--不用提示点击屏幕加速了
				_ChildUI["ItemBG_Label"]:setText("")
			end
			
			--停止动画
			hGlobal.UI.CoverFrame.handle._n:stopAllActions()
			_ChildUI["ItemBG_ChestNode"].handle._n:stopAllActions()
			
			--宝箱子控件位置纠正
			_ChildUI["ItemBG_ChestNode"].handle._n:setRotation(0)
			
			--_ChildUI["ItemBG_ChestNode"].childUI["box3"]:setmodel("MODEL_EFFECT:OpenChest", nil, nil, 324, 308)
			
			--宝箱弹跳动画
			local acttime = 0.1 / m_play_speed
			--宝箱的父控件一开始抖动
			local delay1 = CCDelayTime:create(acttime)
			local callback1 = CCCallFunc:create(function()
				--恭喜获得的图片文字淡入
				local acttime = 0.4 / m_play_speed
				local fadein = CCEaseSineIn:create(CCFadeIn:create(acttime))
				_ChildUI["ItemBG_GreetingImg"].handle._n:runAction(fadein)
				
				--恭喜获得的左底纹飞入
				local lx = _ChildUI["ItemBG_GreetingBGLeft"].data.x
				local ly = _ChildUI["ItemBG_GreetingBGLeft"].data.y
				local lw = _ChildUI["ItemBG_GreetingBGLeft"].data.w
				local lh = _ChildUI["ItemBG_GreetingBGLeft"].data.h
				_ChildUI["ItemBG_GreetingBGLeft"].handle._n:setVisible(true)
				_ChildUI["ItemBG_GreetingBGLeft"]:setXY(lx - hVar.SCREEN.w - lw, ly)
				local moveright = CCEaseSineOut:create(CCMoveTo:create(acttime, ccp(lx, ly)))
				_ChildUI["ItemBG_GreetingBGLeft"].handle._n:runAction(moveright)
				
				--恭喜获得的右底纹飞入
				local rx = _ChildUI["ItemBG_GreetingBGRight"].data.x
				local ry = _ChildUI["ItemBG_GreetingBGRight"].data.y
				local rw = _ChildUI["ItemBG_GreetingBGRight"].data.w
				local rh = _ChildUI["ItemBG_GreetingBGRight"].data.h
				_ChildUI["ItemBG_GreetingBGRight"].handle._n:setVisible(true)
				_ChildUI["ItemBG_GreetingBGRight"]:setXY(rx + hVar.SCREEN.w + rw, ry)
				local moveleft = CCEaseSineOut:create(CCMoveTo:create(acttime, ccp(rx, ry)))
				_ChildUI["ItemBG_GreetingBGRight"].handle._n:runAction(moveleft)
				
				--宝箱打开盖子淡出
				--_ChildUI["ItemBG_ChestNode"].childUI["box3"].handle._n:setVisible(false)
				
				--宝箱打开闪光特效淡出
				--local fadeout = CCEaseSineIn:create(CCFadeOut:create(acttime))
				--_ChildUI["ItemBG_ChestNode"].childUI["light"].handle._n:runAction(fadeout)
				
				--标记状态为宝箱打开动画完成
				m_chest_state = 2
				
				--继续
				local bAuto = true --自动进入
				OnClickChest(bAuto, 0, 0)
			end)
			local a = CCArray:create()
			a:addObject(delay1)
			a:addObject(callback1)
			local sequence = CCSequence:create(a)
			_ChildUI["ItemBG_ChestNode"].handle._n:runAction(sequence)
			
			--宝箱背景闪光特效淡出
			--local fadeout = CCEaseSineIn:create(CCFadeOut:create(acttime))
			--_ChildUI["ItemBG_ChestNode"].childUI["boxlight"].handle._n:runAction(fadeout)
			
			--宝箱打开闪光特效淡入
			--local fadein = CCEaseSineIn:create(CCFadeIn:create(acttime))
			--_ChildUI["ItemBG_ChestNode"].childUI["light"].handle._n:runAction(fadein)
			
			--播放音效
			hApi.PlaySound("open_chest")
		elseif (m_chest_state == 1) then --1:宝箱打开动画
			--等待动画完成，不处理
		elseif (m_chest_state == 2) then --2:宝箱打开动画完成
			--标记状态为宝箱出奖励动画
			m_chest_state = 3
			
			--停止动画
			_ChildUI["ItemBG_ChestNode"].handle._n:stopAllActions()
			
			--每个奖励做动画
			local finishCount = 0
			hApi.addTimerForever("__TD__PLAY_CHEST_REWARD_TIME__", hVar.TIMER_MODE.GAMETIME, 10, function(currentTime, deltaTime)
				--只处理当前状态为宝箱出奖励动画
				if (m_chest_state == 3) then
					--标记状态为宝箱出奖励动画中
					m_chest_state = 4
					
					--道具飞到固定位置
					local idx = finishCount + 1
					local rewardTex = rewardEx[idx]
					local rewardId = rewardTex.rewardId
					local rewardType = rewardTex.rewardType
					
					--xn,yn
					local xn = (idx % CARD_X_NUM_MAX)
					if (xn == 0) then
						xn = CARD_X_NUM_MAX
					end
					local yn = math.ceil(idx / CARD_X_NUM_MAX)
					--print(xn, yn)
					
					--如果超过一页，那么在本行第一个道具开始飞入时，检测此行是否已经超过屏幕外，超出屏幕需要全体控件往上移动
					if (current_DLCMap_max_num > (CARD_X_NUM_MAX * CARD_Y_NUM_MAX)) then
						if (xn == 1) then
							if (yn > CARD_Y_NUM_MAX) then
								for i = 1, current_DLCMap_max_num, 1 do
									local cardi = _ChildUI["ItemBG_Card_View" .. i]
									if cardi then
										local fromX = cardi.data.x
										local fromY = cardi.data.y
										local toX = fromX
										local toY = fromY + (DLCMAPINFO_HEIGHT + DLCMAPINFO_OFFSETY)
										
										cardi.data.x = toX
										cardi.data.y = toY
										
										--本次做动画的直接设置坐标，其他卡牌动画完成
										--cardi:setXY(toX, toY)
										if (idx ~= i) then
											local MOVE_TIME = 0.25 / m_play_speed / 2 --时间减半
											local act3 = CCMoveTo:create(MOVE_TIME, ccp(toX, toY))
											--local sequence = CCSequence:create(act3)
											cardi.handle._n:runAction(act3)
										end
									end
								end
							end
						end
					end
					
					local WAIT_TIME = 0.01 --+ (MOVE_TIME + CALL_TIME) * (idx)
					local MOVE_TIME = 0.25 / m_play_speed
					--local CALL_TIME = 0.1 / m_play_speed
					--local MOVE_DELTA = 200
					--local ROT_TIME = 0.15
					
					local cardi = _ChildUI["ItemBG_Card_View" .. idx]
					local fromX = _ChildUI["ItemBG_ChestNode"].data.x
					local fromY = _ChildUI["ItemBG_ChestNode"].data.y
					local toX = cardi.data.x
					local toY = cardi.data.y
					
					--先设置卡牌在屏幕中央
					cardi:setXY(fromX, fromY)
					cardi.handle._n:setVisible(true)
					cardi.handle._n:setScale(0.01)
					
					local act1 = CCDelayTime:create(WAIT_TIME)
					local act2 = CCCallFunc:create(function()
						--播放音效
						if (rewardType == 10) then --10:神器
							--红装才播放特别音效
							local itemLv = hVar.tab_item[rewardId].itemLv or 1
							if (itemLv == hVar.ITEM_QUALITY.ORANGE) then --红装
								hApi.PlaySound("zhongjiang")
							else
								hApi.PlaySound("eff_pickup")
							end
						else
							hApi.PlaySound("eff_pickup")
						end
						
						--设置逻辑坐标
						cardi.data.x = toX
						cardi.data.y = toY
					end)
					local act3 = CCMoveTo:create(MOVE_TIME, ccp(toX, toY))
					local act4 = CCScaleTo:create(MOVE_TIME, 1.0)
					local act34 = CCEaseSineOut:create(CCSpawn:createWithTwoActions(act3, act4))
					--local act5 = nil --神器还有个等待播孔的动画
					local act6 = CCCallFunc:create(function()
						finishCount = finishCount + 1
						
						--全部动画完成
						if (finishCount == g_MAX_LENGTH) then
							local act7 = CCDelayTime:create(0.2)
							local act8 = CCCallFunc:create(function()
								--显示点击退出的文字4
								_ChildUI["ItemBG_Label"]:setText(hVar.tab_string["__TEXT_CLICK_SCREEN_CLOSE"]) --"点击屏幕关闭"
								
								--恭喜获得的转动图片淡入
								local acttime = 0.2 / m_play_speed
								local fadein = CCEaseSineOut:create(CCFadeTo:create(acttime, 64))
								_ChildUI["ItemBG_GreetingImgRot"].handle._n:runAction(fadein)
								
								--删除timer
								hApi.clearTimer("__TD__PLAY_CHEST_REWARD_TIME__")
								
								--创建timer，刷新DLC地图面板滚动
								hApi.addTimerForever("__TD__PLAY_CHEST_REWARD_UPDATE__", hVar.TIMER_MODE.GAMETIME, 30, refresh_dlcmapinfo_UI_loop)
								
								--标记开宝箱动画状态为宝箱出奖励动画完成
								m_chest_state = 5
							end)
							local towAction = CCSequence:createWithTwoActions(act7, act8)
							hGlobal.UI.CoverFrame.handle._n:runAction(towAction)
							
							if (type(funCallBack) == "function") then
								xpcall(funCallBack, hGlobal.__TRACKBACK__)
							end
						else
							--继续动画
							--标记开宝箱动画状态为宝箱出奖励动画
							m_chest_state = 3
						end
					end)
					
					local a = CCArray:create()
					a:addObject(act1)
					a:addObject(act2)
					a:addObject(act34)
					
					--神器有个孔的闪光动画
					if (rewardType == 10) then --10:红装神器
						local itemLv = hVar.tab_item[rewardId].itemLv or 1
						if (itemLv == hVar.ITEM_QUALITY.ORANGE) then --红装
							local slotAttr = rewardTex.slotAttr
							local tAttr = hApi.Split(slotAttr, "|")
							--print(tAttr[1], tAttr[2], tAttr[3], tAttr[4])
							local slotNum = tonumber(tAttr[3]) or 0 --孔数量
							
							--每个孔做动画
							local wait_prep_time = 0.1 / m_play_speed
							local scale_time = 0.2 / m_play_speed
							local wait_post_time = 0.1 / m_play_speed
							for s = 1, slotNum, 1 do
								--孔控件
								local slot_s = _ChildUI["ItemBG_Card_View" .. idx].childUI["imgIcon"].childUI["slot" .. s]
								
								local wt = (s - 1) * (wait_prep_time + scale_time + wait_post_time) + (WAIT_TIME + MOVE_TIME + MOVE_TIME)
								local actS1 = CCDelayTime:create(wt)
								local callS2 = CCCallFunc:create(function()
									slot_s.handle._n:setVisible(true)
								end)
								local scaleS3 = CCScaleTo:create(scale_time / 2, 64/32)
								local scaleS4 = CCScaleTo:create(scale_time / 2, 22/32)
								local actS5 = CCDelayTime:create(wait_post_time)
								
								local aS = CCArray:create()
								aS:addObject(actS1)
								aS:addObject(callS2)
								aS:addObject(scaleS3)
								aS:addObject(scaleS4)
								
								local sequenceS = CCSequence:create(aS)
								slot_s.handle._n:runAction(sequenceS)
							end
							
							local REDEDIP_TIME = slotNum * (wait_prep_time + scale_time + wait_post_time) + (WAIT_TIME + MOVE_TIME + MOVE_TIME)
							local act5 = CCDelayTime:create(REDEDIP_TIME)
							a:addObject(act5)
						else
							--直接显示孔
							for s = 1, 4, 1 do
								if (_ChildUI["ItemBG_Card_View" .. idx].childUI["imgIcon"].childUI["slot" .. s] ~= nil) then
									_ChildUI["ItemBG_Card_View" .. idx].childUI["imgIcon"].childUI["slot" .. s].handle._n:setVisible(true)
									_ChildUI["ItemBG_Card_View" .. idx].childUI["imgIcon"].childUI["slot" .. s].handle._n:setScale(22/32)
								end
							end
						end
					end
					
					a:addObject(act6)
					local sequence = CCSequence:create(a)
					_ChildUI["ItemBG_Card_View" .. idx].handle._n:stopAllActions() --先停掉之前全部动画
					_ChildUI["ItemBG_Card_View" .. idx].handle._n:runAction(sequence)
				end
			end)
		elseif (m_chest_state == 3) then --3:宝箱出奖励动画
			--等待动画完成，不处理
		elseif (m_chest_state == 4) then --4:宝箱出奖励动画中
			--等待动画完成，不处理
			--如果不是自动进入，加速动画，并隐藏文字
			if (not bAuto) then
				--加速
				m_play_speed = m_play_speed + 1.0 --播放速率
				
				--不超过最大速率
				if (m_play_speed > PLAY_SPEED_MAX) then
					m_play_speed = PLAY_SPEED_MAX
				end
				
				--不用提示点击屏幕加速了
				_ChildUI["ItemBG_Label"]:setText("")
			end
		elseif (m_chest_state == 5) then --5:宝箱出奖励动画完成
			--检测是否点到了卡牌区域
			for i = 1, current_DLCMap_max_num, 1 do
				local cardi = _ChildUI["ItemBG_Card_View" .. i]
				if cardi then
					local cx = cardi.data.x + hGlobal.UI.CoverFrame.data.x
					local cy = cardi.data.y + hGlobal.UI.CoverFrame.data.y
					local w = cardi.data.w
					local h = cardi.data.h
					local left = cx - w / 2
					local right = cx + w / 2
					local top = cy - h / 2
					local bottom = cy + h / 2
					--检测是否点击到了开始按钮
					--print(screenX, screenY)
					--print(left, right, top, bottom)
					if (screenX >= left) and (screenX <= right) and (screenY >= top) and (screenY <= bottom) then
						--print("点到了" .. i)
						OnClickChestReward(i)
						
						return
					end
				end
			end
			
			--检测是否点到了按钮区域
			local cardi = _ChildUI["btnReDraw"]
			if cardi then
				local cx = cardi.data.x + hGlobal.UI.CoverFrame.data.x
				local cy = cardi.data.y + hGlobal.UI.CoverFrame.data.y
				local w = cardi.data.w
				local h = cardi.data.h
				local left = cx - w / 2
				local right = cx + w / 2
				local top = cy - h / 2
				local bottom = cy + h / 2
				--检测是否点击到了再抽一次按钮
				--print(screenX, screenY)
				--print(left, right, top, bottom)
				if (screenX >= left) and (screenX <= right) and (screenY >= top) and (screenY <= bottom) then
					--print("点到了再抽一次按钮")
					
					return
				end
			end
			
			--检测是否点在滑动控件里
			--注意: 这里在需要滑动时才会接管事件，不满一页时点击后还是会消失
			if (current_DLCMap_max_num > (CARD_X_NUM_MAX * CARD_Y_NUM_MAX)) then
				local ctrlI = hGlobal.UI.CoverFrame.childUI["ItemEventNode"]
				if ctrlI then
					local bcx = ctrlI.data.x --中心点x坐标
					local bcy = ctrlI.data.y --中心点y坐标
					local bcw, bch = ctrlI.data.w, ctrlI.data.h
					local blx, bly = 0 + bcx - bcw / 2, 0  + bcy- bch / 2 --最左上侧坐标
					local brx, bry = blx + bcw, bly + bch --最右下角坐标
					--print(i, lx, rx, ly, ry, touchX, touchY)
					if (screenX >= blx) and (screenX <= brx) and (screenY >= bly) and (screenY <= bry) then
						--print("点在滑动控件里")
						return
					end
				end
			end
			
			--已结束
			m_chest_state = 6
			
			--隐藏所有的clipNode
			hApi.EnableClipByName(_frm, "_BTC_pClipNode_chest", 0)
			
			--在关闭此界面时，如果邮箱界面是打开状态，那儿显示左侧的公告栏
			if hGlobal.UI.PhoneWebViewNews then
				if (hGlobal.UI.PhoneWebViewNews.data.show == 1) then
					if (type(xlShowWebView) == "function") and (type(Lua_xlShowWebView) == "function") then
						Lua_xlShowWebView(1)
					end
				end
			end
			
			--删除本界面
			if hGlobal.UI.CoverFrame then
				hGlobal.UI.CoverFrame:del()
				hGlobal.UI.CoverFrame = nil
			end
			
			--删除timer
			hApi.clearTimer("__TD__PLAY_CHEST_REWARD_TIME__")
			hApi.clearTimer("__TD__PLAY_CHEST_REWARD_UPDATE__")
			
			--横竖屏解锁锁定
			hApi.ChangeScreenMode()
		end
	end
	
	--函数：获得第一个控件和最后一个控件距离最上面边界线和最下面边界线的距离
	getUpDownOffset = function()
		--第一个DLC地图面板的数据
		local DLCMapInfoBtn1 = _ChildUI["ItemBG_Card_View1"]
		local btn1_cx, btn1_cy = 0, 0 --第一个DLC地图面板中心点位置
		local btn1_ly = 0 --第一个DLC地图面板最上侧的x坐标
		local delta1_ly = 0 --第一个DLC地图面板距离上侧边界的距离
		if DLCMapInfoBtn1 then
			btn1_cx, btn1_cy = DLCMapInfoBtn1.data.x, DLCMapInfoBtn1.data.y --第一个DLC地图面板中心点位置
			btn1_ly = btn1_cy + DLCMAPINFO_HEIGHT / 2 --第一个DLC地图面板最上侧的x坐标
			
			delta1_ly = btn1_ly - 562
			if (g_phone_mode == 1) then --iPhone4
				--
			elseif (g_phone_mode == 2) then --iPhone5
				--
			elseif (g_phone_mode == 3) then --iPhone6, iPhone7, iPhone8
				delta1_ly = btn1_ly - 538
			elseif (g_phone_mode == 4) then --iPhoneX
				delta1_ly = btn1_ly - 538
			elseif (g_phone_mode == 5) then --安卓宽屏
				delta1_ly = btn1_ly - 538
			elseif (g_phone_mode == 6) then --平板宽屏
				delta1_ly = btn1_ly - 562
			end
			
			if (hVar.SCREEN_MODE == hVar.SCREEN_MODE_DEFINE.VERTICAL) then --竖屏模式
				delta1_ly = delta1_ly - 280
				
				if (g_phone_mode == 1) then --iPhone4
					--
				elseif (g_phone_mode == 2) then --iPhone5
					--
				elseif (g_phone_mode == 3) then --iPhone6, iPhone7, iPhone8
					--
				elseif (g_phone_mode == 4) then --iPhoneX
					delta1_ly = delta1_ly - 280 + 140
				elseif (g_phone_mode == 5) then --安卓宽屏
					--
				elseif (g_phone_mode == 6) then --平板宽屏
					--
				end
			end
		end
		
		--最后一个DLC地图面板的数据
		local DLCMapInfoBtnN = _ChildUI["ItemBG_Card_View" .. current_DLCMap_max_num]
		local btnN_cx, btnN_cy = 0, 0 --最后一个DLC地图面板中心点位置
		local btnN_ry = 0 --最后一个DLC地图面板最下侧的x坐标
		local deltNa_ry = 0 --最后一个DLC地图面板距离下侧边界的距离
		if DLCMapInfoBtnN then
			btnN_cx, btnN_cy = DLCMapInfoBtnN.data.x, DLCMapInfoBtnN.data.y --最后一个DLC地图面板中心点位置
			btnN_ry = btnN_cy - DLCMAPINFO_HEIGHT / 2 --最后一个DLC地图面板最下侧的x坐标
			
			deltNa_ry = btnN_ry - 186 - 52 --最后一个DLC地图面板距离下侧边界的距离
			if (g_phone_mode == 1) then --iPhone4
				--
			elseif (g_phone_mode == 2) then --iPhone5
				--
			elseif (g_phone_mode == 3) then --iPhone6, iPhone7, iPhone8
				deltNa_ry = btnN_ry - 162 - 52
			elseif (g_phone_mode == 4) then --iPhoneX
				deltNa_ry = btnN_ry - 162 - 52
			elseif (g_phone_mode == 5) then --安卓宽屏
				deltNa_ry = btnN_ry - 162 - 52
			elseif (g_phone_mode == 6) then --平板宽屏
				deltNa_ry = btnN_ry - 186 - 52
			end
			
			if (hVar.SCREEN_MODE == hVar.SCREEN_MODE_DEFINE.VERTICAL) then --竖屏模式
				deltNa_ry = deltNa_ry - 280
				
				if (g_phone_mode == 1) then --iPhone4
					--
				elseif (g_phone_mode == 2) then --iPhone5
					--
				elseif (g_phone_mode == 3) then --iPhone6, iPhone7, iPhone8
					--
				elseif (g_phone_mode == 4) then --iPhoneX
					deltNa_ry = deltNa_ry - 280 + 140
				elseif (g_phone_mode == 5) then --安卓宽屏
					--
				elseif (g_phone_mode == 6) then --平板宽屏
					--
				end
			end
		end
		
		--print("delta1_ly, deltNa_ry", delta1_ly, deltNa_ry)
		
		return delta1_ly, deltNa_ry
	end
	
	--函数：选中某个奖励
	OnClickChestReward = function(selectIdx)
		local rewardTex = rewardEx[selectIdx]
		if rewardTex then --存在奖励i
			local rewardType = rewardTex.rewardType
			local rewardT = {rewardType, rewardTex.rewardId, rewardTex.itemNum, rewardTex.param4,}
			
			--神器显示原来的参数
			if (rewardType == 10) then
				rewardT = {rewardType, rewardTex.rewardId, rewardTex.slotAttr, rewardTex.param4,}
			end
			
			--显示各种类型的奖励的tip
			hApi.ShowRewardTip(rewardT)
		end
	end
	
	--默认宝箱0.5秒后会自动进入下个状态，如果点击屏幕会加速动画，直接进入下个状态
	local act1 = CCDelayTime:create(0.01)
	local act2 = CCCallFunc:create(function()
		--继续
		local bAuto = true --自动进入
		OnClickChest(bAuto, 0, 0)
	end)
	local towAction = CCSequence:createWithTwoActions(act1, act2)
	hGlobal.UI.CoverFrame.handle._n:runAction(towAction)
	
	--函数：刷新DLC地图面板界面的滚动
	refresh_dlcmapinfo_UI_loop = function()
		--如果当前在动画中，不用处理
		--if (ANIM_IN_ACTION == 1) then
		--	return
		--end
		
		--超过一页才需要检测滑动
		if (current_DLCMap_max_num <= (CARD_X_NUM_MAX * CARD_Y_NUM_MAX)) then
			return
		end
		
		local SPEED = 50 --速度
		--print(b_need_auto_fixing_dlcmapinfo)
		
		if b_need_auto_fixing_dlcmapinfo then
			---第一个DLC地图面板的数据
			local DLCMapInfoBtn1 = _ChildUI["ItemBG_Card_View1"]
			if DLCMapInfoBtn1 then
				--检测是否滑动到了最顶部或最底部
				local delta1_ly = 0 --第一个DLC地图面板最上侧的y坐标
				local deltNa_ry = 0 --最后一个DLC地图面板最下侧的y坐标
				delta1_ly, deltNa_ry = getUpDownOffset()
				--print(delta1_ly, deltNa_ry)
				--delta1_ly +:在下底线之上 /-:在下底线之下
				--deltNa_ry +:在下底线之上 /-:在下底线之下
				
				--print("delta1_ly=" .. delta1_ly, ", deltNa_ry=" .. deltNa_ry)
				
				--如果第一个DLC地图面板的头像跑到下边，那么优先将第一个DLC地图面板头像贴边
				if (delta1_ly < 0) then
					--print("优先将第一个DLC地图面板头像贴边")
					--需要修正
					--不会选中DLC地图面板
					selected_dlcmapinfoEx_idx = 0 --选中的DLC地图面板索引
					
					--没有惯性
					draggle_speed_y_dlcmapinfo = 0
					
					local speed = SPEED
					if ((delta1_ly + speed) > 0) then --防止走过
						speed = -delta1_ly
						delta1_ly = 0
					end
					
					--每个按钮向上侧做运动
					for i = 1, current_DLCMap_max_num, 1 do
						local ctrli = _ChildUI["ItemBG_Card_View" .. i]
					--if (ctrli.data.selected == 0) then --只处理未选中的DLC地图面板卡牌
						local pos_x, pos_y = ctrli.data.x, ctrli.data.y
						
						--本地运动到达的坐标
						local to_x, to_y = pos_x, pos_y + speed
						
						--设置新坐标
						ctrli.data.x = to_x
						ctrli.data.y = to_y
						ctrli.handle._n:setPosition(to_x, to_y)
					--end
					end
					
					--[[
					--上滑动翻页不显示，下滑动翻页显示
					_frmNode.childUI["DLCMapInfoPageUp"].handle.s:setVisible(false) --上翻页提示
					--hApi.AddShader(_frmNode.childUI["DLCMapInfoListLineHUp"].handle.s, "gray") --上横线到顶了，灰掉
					_frmNode.childUI["DLCMapInfoPageDown"].handle.s:setVisible(true) --下翻页提示
					--hApi.AddShader(_frmNode.childUI["DLCMapInfoListLineHDown"].handle.s, "normal") --下横线需要翻页，正常
					]]
				elseif (delta1_ly ~= 0) and (deltNa_ry > 0) then --第一个头像没有贴上侧，并且最后一个头像没有贴下侧，那么再将最后一个DLC地图面板头像贴边
					--print("将最后一个DLC地图面板头像贴边")
					--需要修正
					--不会选中DLC地图面板
					selected_dlcmapinfoEx_idx = 0 --选中的DLC地图面板索引
					
					--没有惯性
					draggle_speed_y_dlcmapinfo = 0
					
					local speed = SPEED
					if ((deltNa_ry - speed) < 0) then --防止走过
						speed = deltNa_ry
						deltNa_ry = 0
					end
					
					--每个按钮向下侧做运动
					for i = 1, current_DLCMap_max_num, 1 do
						local ctrli = _ChildUI["ItemBG_Card_View" .. i]
					--if (ctrli.data.selected == 0) then --只处理未选中的DLC地图面板卡牌
						local pos_x, pos_y = ctrli.data.x, ctrli.data.y
						
						--本地运动到达的坐标
						local to_x, to_y = pos_x, pos_y - speed
						
						--设置新坐标
						ctrli.data.x = to_x
						ctrli.data.y = to_y
						ctrli.handle._n:setPosition(to_x, to_y)
					--end
					end
					
					--[[
					--上滑动翻页显示，下滑动翻页不显示
					_frmNode.childUI["DLCMapInfoPageUp"].handle.s:setVisible(true) --上分翻页提示
					--hApi.AddShader(_frmNode.childUI["DLCMapInfoListLineHUp"].handle.s, "normal") --上横线需要翻页，正常
					_frmNode.childUI["DLCMapInfoPageDown"].handle.s:setVisible(false) --下分翻页不提示
					--hApi.AddShader(_frmNode.childUI["DLCMapInfoListLineHDown"].handle.s, "gray") --下横线到顶了，灰掉
					]]
				elseif (draggle_speed_y_dlcmapinfo ~= 0) then --沿着当前的速度方向有惯性地运动一会
					--print("沿着当前的速度方向有惯性地运动一会", draggle_speed_y_dlcmapinfo)
					--不会选中DLC地图面板
					selected_dlcmapinfoEx_idx = 0 --选中的DLC地图面板索引
					--print("    ->   draggle_speed_y_dlcmapinfo=", draggle_speed_y_dlcmapinfo)
					
					if (draggle_speed_y_dlcmapinfo > 0) then --朝上运动
						local speed = (draggle_speed_y_dlcmapinfo) * 1.0 --系数
						friction_dlcmapinfo = friction_dlcmapinfo - 0.5
						draggle_speed_y_dlcmapinfo = draggle_speed_y_dlcmapinfo + friction_dlcmapinfo --衰减（正）
						
						if (draggle_speed_y_dlcmapinfo < 0) then
							draggle_speed_y_dlcmapinfo = 0
						end
						
						--最后一个DLC地图面板的坐标不能跑到最下侧的上边去
						if ((deltNa_ry + speed) > 0) then --防止走过
							speed = -deltNa_ry
							deltNa_ry = 0
							
							--没有惯性
							draggle_speed_y_dlcmapinfo = 0
						end
						
						--每个按钮向上侧做运动
						for i = 1, current_DLCMap_max_num, 1 do
							local ctrli = _ChildUI["ItemBG_Card_View" .. i]
						--if (ctrli.data.selected == 0) then --只处理未选中的DLC地图面板卡牌
							local pos_x, pos_y = ctrli.data.x, ctrli.data.y
							
							--本地运动到达的坐标
							local to_x, to_y = pos_x, pos_y + speed
							
							--设置新坐标
							ctrli.data.x = to_x
							ctrli.data.y = to_y
							ctrli.handle._n:setPosition(to_x, to_y)
						--end
						end
					elseif (draggle_speed_y_dlcmapinfo < 0) then --朝下运动
						local speed = (draggle_speed_y_dlcmapinfo) * 1.0 --系数
						friction_dlcmapinfo = friction_dlcmapinfo + 0.5
						draggle_speed_y_dlcmapinfo = draggle_speed_y_dlcmapinfo + friction_dlcmapinfo --衰减（负）
						
						if (draggle_speed_y_dlcmapinfo > 0) then
							draggle_speed_y_dlcmapinfo = 0
						end
						
						--第一个DLC地图面板的坐标不能跑到最上侧的下边去
						if ((delta1_ly + speed) < 0) then --防止走过
							speed = -delta1_ly
							delta1_ly = 0
							
							--没有惯性
							draggle_speed_y_dlcmapinfo = 0
						end
						
						--每个按钮向下侧做运动
						for i = 1, current_DLCMap_max_num, 1 do
							local ctrli = _ChildUI["ItemBG_Card_View" .. i]
						--if (ctrli.data.selected == 0) then --只处理未选中的DLC地图面板卡牌
							local pos_x, pos_y = ctrli.data.x, ctrli.data.y
							
							--本地运动到达的坐标
							local to_x, to_y = pos_x, pos_y + speed
							
							--设置新坐标
							ctrli.data.x = to_x
							ctrli.data.y = to_y
							ctrli.handle._n:setPosition(to_x, to_y)
						--end
						end
					end
					
					--[[
					--上滑动翻页显示，下滑动翻页显示
					if (delta1_ly == 0) then
						_frmNode.childUI["DLCMapInfoPageUp"].handle.s:setVisible(false) --上分翻页提示
						--hApi.AddShader(_frmNode.childUI["DLCMapInfoListLineHUp"].handle.s, "gray") --上横线到顶了，灰掉
					else
						_frmNode.childUI["DLCMapInfoPageUp"].handle.s:setVisible(true) --上分翻页提示
						--hApi.AddShader(_frmNode.childUI["DLCMapInfoListLineHUp"].handle.s, "normal") --上横线需要翻页，正常
					end
					if (deltNa_ry == 0) then
						_frmNode.childUI["DLCMapInfoPageDown"].handle.s:setVisible(false) --下分翻页提示
						--hApi.AddShader(_frmNode.childUI["DLCMapInfoListLineHDown"].handle.s, "gray") --下横线到顶了，灰掉
					else
						_frmNode.childUI["DLCMapInfoPageDown"].handle.s:setVisible(true) --下分翻页提示
						--hApi.AddShader(_frmNode.childUI["DLCMapInfoListLineHDown"].handle.s, "normal") --下横线需要翻页，正常
					end
					]]
				else --停止运动
					b_need_auto_fixing_dlcmapinfo = false
					friction_dlcmapinfo = 0
				end
			end
		end
	end
	
	--[[
	--连接pvp服务器，获取碎片、将魂
	if (Pvp_Server:GetState() ~= 1) then --未连接
		Pvp_Server:Connect()
	elseif (not hGlobal.LocalPlayer:getonline()) then --不重复登陆
		Pvp_Server:UserLogin()
	end
	]]
end


--获得本地的时区(GMT)
--北京时间(GMT+8)
hApi.get_timezone = function()
	local now = os.time()
	local deltaseconds = os.difftime(now, os.time(os.date("!*t", now)))
	local zone = deltaseconds / 3600
	
	--geyachao: 一个奇怪的现象，美国时间(-8)和北京时间(+8)相差只有15个小时
	if (zone < 0) then
		zone = zone + 1
	end
	
	return zone
end

local emojiList = {}
--绘制表情图
hApi.ShowEmoji = function(nForce, emojiIdx)
	--print(nForce, emojiIdx)
	local world = hGlobal.WORLD.LastWorldMap
	
	--不存在world，直接返回
	if (not world) then
		return
	end
	
	local MAX_EMOJI_NUM = 10 --最多显示10个表情
	local length = #emojiList --长度
	
	if (length > MAX_EMOJI_NUM) then
		return
	end
	
	local OFFSET_X = 64 --间距x
	local OFFSET_X_EXTRA = hVar.SCREEN.w / 2 --额外间距x（动画）
	local OFFSET_Y = 128 --间距y
	local sign = (nForce == 1) and (-1) or (1) --符号
	--hVar.SCREEN.w/2,hVar.SCREEN.h/2
	local strModel = "PVP:emoji_00" .. emojiIdx
	
	--找到一个合适的索引
	local index = 1
	local indexHaves = {}
	for i = 1, #emojiList, 1 do
		local idx = emojiList[i].index
		indexHaves[idx] = true
	end
	for i = 1, MAX_EMOJI_NUM, 1 do
		if (not indexHaves[i]) then
			index = i
			break
		end
	end
	
	local button = hUI.button:new({
		parent = nil,
		model = "misc/mask.png",
		x = hVar.SCREEN.w/2 + sign * OFFSET_X + sign * OFFSET_X_EXTRA,
		--y = hVar.SCREEN.h - index * OFFSET_Y,
		y = hVar.SCREEN.h/2 - (index - 1) * OFFSET_Y + OFFSET_Y / 2,
		z = 100,
		w = 128,
		h = 128,
	})
	button.handle.s:setOpacity(0) --不显示，只用于控制
	
	--绘制表情图
	--根据阵营，判断显示在哪一侧
	button.childUI["EmojiBG"] = hUI.image:new({
		parent = button.handle._n,
		model = strModel,
		x = 0,
		y = 0,
		scale = 1.0,
	})
	button.childUI["EmojiBG"].handle.s:setOpacity(64)
	
	--插入到队列的末尾
	table.insert(emojiList, {side = nForce, ctrl = button, index = index,})
	
	--动画
	local move1 = CCEaseSineOut:create(CCMoveBy:create(0.5, ccp(-sign * OFFSET_X_EXTRA, 0))) --由快至慢
	local actCall1 = CCCallFunc:create(function(ctrl)
		--local delay21 = CCDelayTime:create(0.1)
		--local scaleBig2 = CCEaseSineOut:create(CCScaleTo:create(0.1, 1.5))
		--local scaleSmall2 = CCEaseSineIn:create(CCScaleTo:create(0.1, 1.0))
		local delay22 = CCDelayTime:create(4.0)
		local fade2 = CCFadeOut:create(1.0)
		local actCall2 = CCCallFunc:create(function(ctrl)
			button:del()
			
			--移除表
			for i = 1, #emojiList, 1 do
				if (emojiList[i].ctrl == button) then
					table.remove(emojiList, i)
					break
				end
			end
		end)
		
		--创建动作数组
		local array = CCArray:create()
		--array:addObject(delay21)
		--array:addObject(scaleBig2)
		--array:addObject(scaleSmall2)
		array:addObject(delay22)
		array:addObject(fade2)
		array:addObject(actCall2)
		button.childUI["EmojiBG"].handle.s:runAction(CCSequence:create(array))
	end)
	
	--创建动作数组
	local array = CCArray:create()
	array:addObject(move1)
	array:addObject(actCall1)
	button.handle._n:runAction(CCSequence:create(array))
	
	--图片动画
	local delay3 = CCDelayTime:create(0.2)
	local fade3 = CCFadeTo:create(0.2, 255)
	--创建动作数组
	local array = CCArray:create()
	array:addObject(delay3)
	array:addObject(fade3)
	button.childUI["EmojiBG"].handle.s:runAction(CCSequence:create(array))
end

--创建9宫格贴图(create)
hApi.CCScale9SpriteCreate = function(filePath, pos_x, pos_y, width, height, parent,z)
	local img9 = CCScale9Sprite:create(filePath)
	if (img9 == nil) then
		img9 = CCScale9Sprite:create("data/image/misc/mask.png")
	end
	img9:setPosition(ccp(pos_x, pos_y))
	img9:setContentSize(CCSizeMake(width, height))
	parent.handle._n:addChild(img9,z or 0)
	
	return img9
end

--创建9宫格贴图(createWithSpriteFrameName)
hApi.CCScale9SpriteCreateWithSpriteFrameName = function(filePath, pos_x, pos_y, width, height, parent)
	local img9 = CCScale9Sprite:createWithSpriteFrameName(filePath)
	if (img9 == nil) then
		img9 = CCScale9Sprite:create("data/image/misc/mask.png")
	end
	img9:setPosition(ccp(pos_x, pos_y))
	img9:setContentSize(CCSizeMake(width, height))
	parent.handle._n:addChild(img9)
	
	return img9
end

--创建通用的tip提示框
hApi.ShowGeneralTip = function(strModel, strTitle, strIntrodice, offsetX, offsetY, colorTitle)
	--先清除上一次的通用tip面板
	if hGlobal.UI.PvpGeneralTipInfoFrame then
		hGlobal.UI.PvpGeneralTipInfoFrame:del()
		hGlobal.UI.PvpGeneralTipInfoFrame = nil
	end
	
	--创建通用tip面板
	hGlobal.UI.PvpGeneralTipInfoFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = hZorder.EquipTip,
		show = 1,
		dragable = 3, --3:点击后消失
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--print("点击事件（有可能在控件外部点击）")
			end
		end,
	})
	hGlobal.UI.PvpGeneralTipInfoFrame:active()
	
	local _GeneralTipParent = hGlobal.UI.PvpGeneralTipInfoFrame.handle._n
	local _GeneralTipChildUI = hGlobal.UI.PvpGeneralTipInfoFrame.childUI
	local BOARD_WIDTH = 960 --面板的宽度
	local BOARD_HEIGHT = 640 --面板的高度
	local BOARD_POS_X = hVar.SCREEN.w / 2 - BOARD_WIDTH / 2 --面板的x位置（最左侧）
	local BOARD_POS_Y = hVar.SCREEN.h / 2 + BOARD_HEIGHT / 2 --面板的y位置（最顶侧）
	local _offX = BOARD_POS_X + 530 + offsetX
	local _offY = BOARD_POS_Y - 365 + offsetY
	
	--黑色底图
	--[[
	_GeneralTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _GeneralTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 40,
		w = 320,
		h = 360,
	})
	_GeneralTipChildUI["ItemBG_1"].handle.s:setOpacity(192) --技能背景图片透明度为192
	]]
	local img9 = hApi.CCScale9SpriteCreate("data/image/misc/gopherboom/bar.png", _offX, _offY - 40, 320, 360, hGlobal.UI.PvpGeneralTipInfoFrame)
	--img9:setOpacity(192)
	
	--tip-图标（通用tip提示框）
	if strModel then
		_GeneralTipChildUI["Item_Icon"] = hUI.image:new({
			parent = _GeneralTipParent,
			model = strModel,
			x = _offX - 110,
			y = _offY + 95,
			w = 64,
			h = 64,
		})
	end
	
	--tip-标题
	_GeneralTipChildUI["ActivityName"] = hUI.label:new({
		parent = _GeneralTipParent,
		size = 36,
		x = _offX - 60,
		y = _offY + 95 - 5,
		width = 500,
		align = "LC",
		font = hVar.FONTC,
		text = strTitle,
		border = 1,
	})
	_GeneralTipChildUI["ActivityName"].handle.s:setColor(colorTitle)
	
	--tip-介绍
	_GeneralTipChildUI["ActivityHint"] = hUI.label:new({
		parent = _GeneralTipParent,
		size = 26,
		x = _offX - 145,
		y = _offY + 55,
		width = 300,
		align = "LT",
		font = hVar.FONTC,
		text = strIntrodice,
		border = 1,
	})
	_GeneralTipChildUI["ActivityHint"].handle.s:setColor(ccc3(255, 255, 255))
end

--创建/隐藏 本地玩家响应时间过长的框
hApi.ShowPlayerNoHeartFrm = function(nShow)
	--本次为隐藏操作
	if (not nShow) or (nShow == 0) then
		--删除上一次的响应时间过长框界面
		if hGlobal.UI.PhonePlayerNoHeartFrm then
			hGlobal.UI.PhonePlayerNoHeartFrm:del()
			hGlobal.UI.PhonePlayerNoHeartFrm = nil
			
			--[[
			local world = hGlobal.WORLD.LastWorldMap
			if world then
				local mapInfo = world.data.tdMapInfo
				if (mapInfo.mapState == hVar.MAP_TD_STATE.PAUSE)  then
					--恢复
					world:pause(0)
					mapInfo.mapState = mapInfo.mapLastState
					mapInfo.mapLastState = hVar.MAP_TD_STATE.IDLE
				end
			end
			]]
		end
	
		return
	end
	
	--不在游戏中
	local world = hGlobal.WORLD.LastWorldMap
	if (not world) then
		--删除上一次的响应时间过长框界面
		if hGlobal.UI.PhonePlayerNoHeartFrm then
			hGlobal.UI.PhonePlayerNoHeartFrm:del()
			hGlobal.UI.PhonePlayerNoHeartFrm = nil
		end
		
		return
	end
	
	--创建本地玩家响应时间过长的框界面
	if (not hGlobal.UI.PhonePlayerNoHeartFrm) then
		--删除可能的投降界面
		if hGlobal.UI.PhonePlayerTouXiangFrm then
			hGlobal.UI.PhonePlayerTouXiangFrm:del()
			hGlobal.UI.PhonePlayerTouXiangFrm = nil
		end
		
		hGlobal.UI.PhonePlayerNoHeartFrm = hUI.frame:new(
		{
			x = hVar.SCREEN.w / 2 - 450 / 2,
			y = hVar.SCREEN.h / 2 + 300 / 2, -- - 20,
			z = 100,
			w = 450,
			h = 300,
			dragable = 4, --在外部点击会一直抖动
			show = 1,
			border = -1, --不显示frame边框
			background = -1, --不显示背景图
			--background = "UI:selectbg2",
			autoactive = 0,
			--全部事件
			codeOnDragEx = function(touchX, touchY, touchMode)
				--
			end,
		})
		
		local _frm = hGlobal.UI.PhonePlayerNoHeartFrm
		local _parent = _frm.handle._n
		
		--背景图（九宫格）
		--创建9宫格贴图(create)
		hApi.CCScale9SpriteCreate("data/image/misc/selectbg2.png", _frm.data.w / 2, -_frm.data.h / 2, _frm.data.w + 30, _frm.data.h, _frm)
		--[[
		local img9 = CCScale9Sprite:create("data/image/misc/selectbg2.png")
		img9:setPosition(ccp(_frm.data.w / 2, -_frm.data.h / 2))
		img9:setContentSize(CCSizeMake(_frm.data.w + 30, _frm.data.h))
		_parent:addChild(img9)
		]]
		
		--等待的标题
		_frm.childUI["labelTitle"] = hUI.label:new({
			parent = _parent,
			x = 225,
			y = -65,
			size = 42,
			align = "MC",
			border = 1,
			font = hVar.FONTC,
			width = 300,
			text = "",
		})
		
		--创建提示文字
		_frm.childUI["labelHintText"] = hUI.label:new({
			parent = _parent,
			x = 225,
			y = -145,
			size = 26,
			align = "MC",
			border = 1,
			font = hVar.FONTC,
			width = 400,
			text = "",
		})
		_frm.childUI["labelHintText"].handle.s:setColor(ccc3(255, 224, 224))
		
		--挡操作的按钮
		_frm.childUI["btnCoverOp"] = hUI.button:new({
			x = 225 - 110 - 20,
			y = -235,
			dragbox = _frm.childUI["dragBox"],
			model = "misc/mask.png",
			w = 3000,
			h = 3000,
			scaleT = 1.0,
			code = function()
				--
			end,
		})
		_frm.childUI["btnCoverOp"].handle.s:setOpacity(0) --只用于控制，不显示
		
		--重新连接按钮
		_frm.childUI["btnOK"] = hUI.button:new({
			parent = _parent,
			x = 225 + 110 - 20,
			y = -235,
			dragbox = _frm.childUI["dragBox"],
			model = "misc/mask.png",
			w = 210,
			h = 80,
			scaleT = 0.95,
			code = function()
				--print("点击重新连接按钮", tostring(_frm.childUI["btnOK"]))
				_frm.childUI["btnCoverOp"].handle.s:stopAllActions()
				
				--5秒后禁用按钮
				local act1 = CCDelayTime:create(6.0)
				local act2 = CCCallFunc:create(function(ctrl)
					--禁挡操作按钮
					--print("禁挡操作按钮")
					_frm.childUI["btnBan"]:setstate(-1)
					
					--冒字
					--local strText = "连接超时，请稍后再试" --language
					local strText = hVar.tab_string["__TEXT_WattingPlease"] --language
					hUI.floatNumber:new({
						x = hVar.SCREEN.w / 2,
						y = hVar.SCREEN.h / 2,
						align = "MC",
						text = "",
						lifetime = 1000,
						fadeout = -550,
						moveY = 32,
					}):addtext(strText, hVar.FONTC, 40, "MC", 0, 0)
				end)
				local towAction = CCSequence:createWithTwoActions(act1, act2)
				
				--显示挡操作的按钮
				--print("显示挡操作的按钮")
				_frm.childUI["btnBan"]:setstate(1)
				_frm.childUI["btnCoverOp"].handle.s:runAction(towAction)
				
				--先断开pvp连接
				Pvp_Server:Close()
				
				--添加事件监听：收到连接结果回调
				--print("添加事件监听：收到连接结果回调", "LocalEvent_Pvp_NetEvent")
				hGlobal.event:listen("LocalEvent_Pvp_NetEvent", "__Pvp_NetEvent_World__", function(net_state)
					--在游戏中
					local world = hGlobal.WORLD.LastWorldMap
					if (world ~= nil) then
						if (net_state == 1) then
							--移除监听
							--print("移除监听：收到连接结果回调", "LocalEvent_Pvp_NetEvent, net_state=", net_state)
							hGlobal.event:listen("LocalEvent_Pvp_NetEvent", "__Pvp_NetEvent_World__", nil)
							
							--重新登入
							Pvp_Server.UserReLogin()
						elseif (net_state == 0) or (net_state == -2) then
							--失败
							--继续发起连接
							Pvp_Server:Connect()
						else
							--移除监听
							--print("移除监听：收到连接结果回调", "LocalEvent_Pvp_NetEvent, net_state=", net_state)
							hGlobal.event:listen("LocalEvent_Pvp_NetEvent", "__Pvp_NetEvent_World__", nil)
						end
					else
						--移除监听
						--print("移除监听：收到连接结果回调", "LocalEvent_Pvp_NetEvent, net_state=", net_state)
						hGlobal.event:listen("LocalEvent_Pvp_NetEvent", "__Pvp_NetEvent_World__", nil)
					end
				end)
				
				--log
				local world = hGlobal.WORLD.LastWorldMap
				if (world ~= nil) then
					--geyachao: 同步日志: 重练（只有一边有log）
					if (hVar.IS_SYNC_LOG == 1) then
						local msg = "[ignore]UserReLogin: sessionId=" .. world.data.sessionId .. ",cTurn=" .. world.data.cTurn .. ",cTick=" .. world:gametick() .. ",uid=" .. tostring(xlPlayer_GetUID())
						hApi.SyncLog(msg)
						--print("执行", msg)
					end
				end
				
				--连接
				Pvp_Server:Connect()
			end,
		})
		_frm.childUI["btnOK"].handle.s:setOpacity(0) --只用于控制，不显示
		
		--重新连接背景图（九宫格）
		--创建9宫格贴图(createWithSpriteFrameName)
		hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/pvp/pvptimeoutbg2.png", 0, 0, 210, 56, _frm.childUI["btnOK"])
		--[[
		local img91 = CCScale9Sprite:createWithSpriteFrameName("data/image/ui/pvp/pvptimeoutbg2.png")
		img91:setPosition(ccp(0, 0))
		img91:setContentSize(CCSizeMake(210, 56))
		_frm.childUI["btnOK"].handle._n:addChild(img91)
		]]
		
		--重新连接的文字
		_frm.childUI["btnOK"].childUI["label"] = hUI.label:new({
			parent = _frm.childUI["btnOK"].handle._n,
			x = 0,
			y = -1, --文字有1像素的偏差
			size = 32,
			align = "MC",
			border = 1,
			font = hVar.FONTC,
			width = 450,
			--text = "重新连接", --language
			text = hVar.tab_string["RSDYZ_RECONNECT"], --language
		})
		
		--挡住重新连接的按钮
		_frm.childUI["btnOK_Disable"] = hUI.button:new({
			parent = _parent,
			x = 225 + 110 - 20,
			y = -235,
			dragbox = _frm.childUI["dragBox"],
			model = "UI:lvUpCostBg",
			w = 210,
			h = 80,
			scaleT = 1.0,
			code = function()
				--
			end,
		})
		
		--离开游戏按钮
		_frm.childUI["btnCancel"] = hUI.button:new({
			parent = _parent,
			x = 225 - 110 - 10,
			y = -235,
			dragbox = _frm.childUI["dragBox"],
			model = "misc/mask.png",
			w = 210 - 40,
			h = 80,
			scaleT = 0.95,
			code = function()
				--玩家主动离开游戏
				local world = hGlobal.WORLD.LastWorldMap
				if world then
					local sessionId = world.data.sessionId
					SendPvpCmdFunc["leave_game"](sessionId)
				end
				
				--断开pvp连接
				Pvp_Server:Close()
				
				--返回大厅
				--删除可能的投降对话框界面
				if hGlobal.UI.PhonePlayerTouXiangFrm then
					hGlobal.UI.PhonePlayerTouXiangFrm:del()
					hGlobal.UI.PhonePlayerTouXiangFrm = nil
				end
				
				--删除可能的pvp等待玩家的界面
				if hGlobal.UI.PhoneDelayPlayerFrm then
					hGlobal.UI.PhoneDelayPlayerFrm:del()
					hGlobal.UI.PhoneDelayPlayerFrm = nil
				end
				
				--删除可能的pvp结束界面
				if hGlobal.UI.__GameOverPanel_pvp then
					hGlobal.UI.__GameOverPanel_pvp:del()
					hGlobal.UI.__GameOverPanel_pvp = nil
				end
				
				--删除可能的响应时间过长框界面
				if hGlobal.UI.PhonePlayerNoHeartFrm then
					hGlobal.UI.PhonePlayerNoHeartFrm:del()
					hGlobal.UI.PhonePlayerNoHeartFrm = nil
				end
				
				--geyachao: 先存档
				--存档
				LuaSavePlayerData(g_localfilepath,g_curPlayerName,Save_PlayerData,Save_PlayerLog)
				
				--关闭同步日志文件
				hApi.SyncLogClose()
				--关闭非同步日志文件
				hApi.AsyncLogClose()
				
				--隐藏可能的选人界面
				if hGlobal.UI.PhoneSelectedHeroFrm2 then
					hGlobal.UI.PhoneSelectedHeroFrm2:show(0)
					hGlobal.UI.PhoneSelectedHeroFrmBG.handle.s:setVisible(false) --隐藏背景框挡板
					hApi.clearTimer("__SELECT_HERO_UPDATE__")
					hApi.clearTimer("__SELECT_TOWER_UPDATE__")
					hApi.clearTimer("__SELECT_TACTIC_UPDATE__")
				end
				
				--zhenkira 注释
				local world = hGlobal.WORLD.LastWorldMap
				if (world ~= nil) then
					--玩家主动离开游戏
					local sessionId = world.data.sessionId
					SendPvpCmdFunc["leave_game"](sessionId)
					
					--------------------------------------------------------
					--geyachao: pvp模式，为了防止玩家恶意刷游戏局
					--在投降或逃跑的时候，记录一下本局游戏对战的对手
					--找到对手
					local userId_Enemy = 0 --对手的uid
					local userName_Enemy = "" --对手的名字
					local forceMe = world:GetPlayerMe():getforce()
					for i = 1, 20, 1 do
						local player_i = world.data.PlayerList[i]
						if player_i then
							local force_i = player_i:getforce()
							if(force_i ~= forceMe) then
								if (player_i:gettype() == 1) then --0空 1玩家 2简单电脑 3中等电脑 4困难电脑 5大师电脑 6专家电脑
									userId_Enemy = player_i.data.dbid --找到了
									userName_Enemy = player_i.data.name
									break
								end
							end
						end
					end
					if (userId_Enemy > 0) then
						local session_dbId = world.data.session_dbId --本局的游戏局唯一id
						local userId = userId_Enemy --本局的对手id
						local userName = userName_Enemy --本局的对手名字
						local bUseEquip = world.data.bUseEquip --本局是否携带状态
						local pvpcoinCost = world:GetPlayerMe():getuserdata(1) or 0 --用户自定义数据[1] 本局消耗的兵符
						local gametime = math.floor(world:gametime() / 1000) --本局的游戏时长(秒)
						LuaAddPVPUserInfo(g_curPlayerName, session_dbId, userId, userName, bUseEquip, pvpcoinCost, gametime)
					end
					--------------------------------------------------------
					
					local mapname = world.data.map
					--if hApi.Is_RSYZ_Map(mapname) ~= -1 then
					--	print(".."..nil)
					--	Game_Zone_OnGameEvent(GZone_Event_TypeDef.Lua,{GZone_Event_TypeDef.BattleEnd_Fire,luaGetplayerDataID(),g_RSDYZ_BattleID})
					--end
					
					world:del()
					
					hGlobal.LocalPlayer:setfocusworld(nil)
					hApi.clearCurrentWorldScene()
					
					local tabM = hVar.MAP_INFO[mapname]
					local chapterId = 1
					if tabM then
						chapterId = tabM.chapter or 1
					end
					--hGlobal.event:event("LocalEvent_Phone_ShowPhone_SelecteMap", chapterId)
					--切换到新主界面事件
					hGlobal.event:event("LocalEvent_OpenPhoneMainMenu")
				end
			end,
		})
		_frm.childUI["btnCancel"].handle.s:setOpacity(0) --只用于控制，不显示
		
		--离开游戏背景图（九宫格）
		--创建9宫格贴图(createWithSpriteFrameName)
		hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/pvp/pvptimeoutbg1.png", 0, 0, 210 - 40, 56 - 10, _frm.childUI["btnCancel"])
		--[[
		local img92 = CCScale9Sprite:createWithSpriteFrameName("data/image/ui/pvp/pvptimeoutbg1.png")
		--local img92 = CCScale9Sprite:create("data/image/misc/card_select_back.png")
		img92:setPosition(ccp(0, 0))
		img92:setContentSize(CCSizeMake(210, 56))
		_frm.childUI["btnCancel"].handle._n:addChild(img92)
		]]
		
		--离开游戏的文字
		_frm.childUI["btnCancel"].childUI["label"] = hUI.label:new({
			parent = _frm.childUI["btnCancel"].handle._n,
			x = 0,
			y = -1, --文字有1像素的偏差
			size = 32 - 2,
			align = "MC",
			border = 1,
			font = hVar.FONTC,
			width = 450,
			--text = "离开", --language
			text = hVar.tab_string["__TEXT_PVP_Leave"], --language
		})
		
		--创建挡重练、离开按钮操作的按钮
		--print("创建挡操作的按钮")
		_frm.childUI["btnBan"] = hUI.button:new({
			parent = _parent,
			x = 225 - 110 - 20,
			y = -235,
			dragbox = _frm.childUI["dragBox"],
			model = "misc/mask.png",
			w = 3000,
			h = 3000,
			scaleT = 1.0,
			code = function()
				--
			end,
		})
		_frm.childUI["btnBan"].handle.s:setOpacity(0) --只用于控制，不显示
		--灰色图1
		_frm.childUI["btnBan"].childUI["image1"] = hUI.image:new({
			parent = _frm.childUI["btnBan"].handle._n,
			x = 0,
			y = 0,
			w = 210,
			h = 56,
			model = "UI:lvUpCostBg",
		})
		--灰色图2
		_frm.childUI["btnBan"].childUI["image2"] = hUI.image:new({
			parent = _frm.childUI["btnBan"].handle._n,
			x = 220,
			y = 0,
			w = 210,
			h = 56,
			model = "UI:lvUpCostBg",
		})
		--菊花图
		_frm.childUI["btnBan"].childUI["image3"] = hUI.image:new({
			parent = _frm.childUI["btnBan"].handle._n,
			x = 220,
			y = 0,
			w = 64,
			h = 64,
			model = "MODEL_EFFECT:waiting",
		})
		
		--一开始不显示禁操作的按钮
		--print("一开始不显示禁操作的按钮")
		_frm.childUI["btnBan"]:setstate(-1)
	end
	
	--修改文字
	local _frm = hGlobal.UI.PhonePlayerNoHeartFrm
	local _parent = _frm.handle._n
	
	local strTitle = "本地网络无响应"
	local leftwaittime = world.data.leftHeartTime --心跳包剩余等待时间（毫秒）
	local strCotnent = nil
	if (leftwaittime <= 0) then
		strCotnent = "您的网络长时间没有响应，已被踢出游戏。"
		
		--挡操作重练按钮
		_frm.childUI["btnOK_Disable"]:setstate(1)
	else
		local showTime = math.floor(leftwaittime / 1000 + 0.5) --四舍五入
		strCotnent = "您的网络长时间没有响应，" .. showTime .. " 秒内未连上将被踢出游戏。"
		
		--不挡操作重练按钮
		_frm.childUI["btnOK_Disable"]:setstate(-1)
	end
	
	_frm.childUI["labelTitle"]:setText(strTitle)
	_frm.childUI["labelHintText"]:setText(strCotnent)
end


--显示关卡掉落道具列表的面板
hApi.ShowMapDropItemListPanel = function(mapName)
	--先清除上一次的tip
	if hGlobal.UI.MapDropInfoFrame then
		hGlobal.UI.MapDropInfoFrame:del()
		hGlobal.UI.MapDropInfoFrame = nil
	end
	
	--创建关卡掉落道具列表的面板
	hGlobal.UI.MapDropInfoFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		--z = -1,
		show = 1,
		--dragable = 2,
		dragable = 2, --3:点击后消失
		--buttononly = 1,
		autoactive = 0,
		background = "UI:PANEL_INFO_MINI",
		--failcall = 1, --出按钮区域抬起也会响应事件
		border = 0,
		--background = -1, --不显示背景图
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--清除技能说明面板
				--hGlobal.UI.ItemMergeInfoFrame:del()
				--hGlobal.UI.ItemMergeInfoFrame = nil
				--print("点击事件（有可能在控件外部点击）")
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
			end
		end,
	})
	hGlobal.UI.MapDropInfoFrame:active()
	local _RankTipParent = hGlobal.UI.MapDropInfoFrame.handle._n
	local _BanDiffTipChildUI = hGlobal.UI.MapDropInfoFrame.childUI
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2
	
	--创建tip图片背景
	_BanDiffTipChildUI["ItemBG_1"] = hUI.button:new({
		parent = _RankTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "misc/mask.png",
		x = _offX,
		y = _offY,
		w = 960 - 10,
		h = 640 - 10,
	})
	_BanDiffTipChildUI["ItemBG_1"].handle.s:setOpacity(0) --只挂载子控件，不显示
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", 0, 0, 960 - 10, 640 - 10, _BanDiffTipChildUI["ItemBG_1"])
	img9:setOpacity(204)
	
	--关闭按钮
	_BanDiffTipChildUI["closeBtn"] = hUI.button:new({
		parent = hGlobal.UI.MapDropInfoFrame,
		dragbox = _RankTipParent["dragBox"],
		model = "BTN:PANEL_CLOSE",
		x = _offX + 435,
		y = _offY + 275,
		scaleT = 0.95,
		code = function()
			--清除面板
			if hGlobal.UI.MapDropInfoFrame then
				hGlobal.UI.MapDropInfoFrame:del()
				hGlobal.UI.MapDropInfoFrame = nil
			end
		end,
	})
	
	--创建tip-标题
	local strMapName = hVar.tab_stringM[mapName][1]
	_BanDiffTipChildUI["BanDiffBoardName"] = hUI.label:new({
		parent = _RankTipParent,
		size = 36,
		x = _offX,
		y = _offY + 273,
		width = 800,
		align = "MC",
		font = hVar.FONTC,
		text = strMapName .. " - " .. "挑战掉落",
		border = 1,
	})
	_BanDiffTipChildUI["BanDiffBoardName"].handle.s:setColor(ccc3(255, 255, 255))
	
	--绘制奖池的所有道具
	local _createPoolUI = function(tPool, offsetX, offsetY)
		local ROW = 16 --一行显示16个
		local WIDTH = 59
		local scaleModel = 1.1
		if (#tPool > 23) then
			ROW = 30
			WIDTH = 39
			scaleModel = 0.8
		elseif (#tPool > 20) then
			ROW = 23
			WIDTH = 40
			scaleModel = 0.85
		elseif (#tPool > 16) then
			ROW = 20
			WIDTH = 47
			scaleModel = 1.0
		end
		
		for n = 1, #tPool, 1 do
			--获得奖励的UI相关参数
			local rewardT = tPool[n]
			local tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h = hApi.GetRewardParams(rewardT)
			--print(tmpModel, itemName, itemNum, itemWidth, itemHeight, sub_tmpModel, sub_pos_x, sub_pos_y, sub_pos_w, sub_pos_h)
			local yn = math.floor(n / ROW)
			local xn = n - yn * ROW
			if (xn == 0) then
				xn = ROW
				yn = yn - 1
			end
			
			--绘制奖励控件图标
			_BanDiffTipChildUI["baseReward" .. n] = hUI.button:new({ --作为button是为了子控件坐标正常
				parent = _RankTipParent,
				model = tmpModel,
				x = _offX + offsetX + (xn - 1) * (WIDTH) - 442,
				y = _offY + offsetY - (yn - 1) * (WIDTH + 15),
				w = itemWidth * scaleModel,
				h = itemHeight * scaleModel,
			})
			
			--绘制奖励控件图标的子控件
			if sub_tmpModel then
				_BanDiffTipChildUI["baseReward" .. n].childUI["subIcon"] = hUI.image:new({
					parent = _BanDiffTipChildUI["baseReward" .. n].handle._n,
					model = sub_tmpModel,
					x = sub_pos_x * scaleModel,
					y = sub_pos_y * scaleModel,
					w = sub_pos_w * scaleModel,
					h = sub_pos_h * scaleModel,
				})
			end
			
			--绘制奖励的数量
			local scaleSize = 16
			_BanDiffTipChildUI["baseReward" .. n].childUI["subNum"] = hUI.label:new({
				parent = _BanDiffTipChildUI["baseReward" .. n].handle._n,
				x = 0,
				y = -(WIDTH / 2) - 5, --数字字体有1像素偏差
				size = scaleSize,
				font = "numWhite",
				align = "MC",
				width = 300,
				border = 1,
				text = "+" .. itemNum,
			})
			if paintColor then
				_BanDiffTipChildUI["baseReward" .. n].childUI["subNum"].handle.s:setColor(paintColor)
			end
			
			--绘制按钮响应事件
			_BanDiffTipChildUI["baseBtn" .. n] = hUI.button:new({
				parent = hGlobal.UI.MapDropInfoFrame,
				dragbox = _RankTipParent["dragBox"],
				model = "misc/mask.png",
				x = _offX + offsetX + (xn - 1) * (WIDTH) - 442,
				y = _offY + offsetY - (yn - 1) * (WIDTH + 15),
				w = itemWidth * scaleModel + 4 * scaleModel,
				h = itemHeight * scaleModel + 30,
				scaleT = 0.95,
				code = function()
					local rewardType = rewardT[1]
					
					--(1:积分 / 2:战术技能卡 / 3:道具 / 4:英雄 / 5:英雄将魂 / 6:战术技能卡碎片 / 7:游戏币 / 8:网络宝箱 / 9:抽奖类战术技能卡 / 10:神器 / 11:神器晶石)
					if (rewardType == 1) then --1:积分
						--显示积分介绍的tip
						hApi.ShowJiFennTip()
					elseif (rewardType == 2) then --2:战术技能卡
						--显示战术技能卡tip
						local tacticId = rewardT[2] or 0
						local tacticNum = rewardT[3] or 0
						local tacticLv = rewardT[4] or 1
						hApi.ShowTacticCardTip(rewardType, tacticId, tacticLv)
					elseif (rewardType == 3) then --3:道具
						--显示道具tip
						local itemtipX = 400 + (hVar.SCREEN.w - 1024) / 2 --适配其他分辨率
						local itemtipY = 660 + (hVar.SCREEN.h - 768) / 2 --适配其他分辨率
						hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1}}, nil, 1, itemtipX, itemtipY, 0)
					elseif (rewardType == 4) then --4:英雄
						--显示英雄tip
						local herotipX = 400 + (hVar.SCREEN.w - 1024) / 2 --适配其他分辨率
						local herotipY = 600 + (hVar.SCREEN.h - 768) / 2 --适配其他分辨率
						hGlobal.event:event("LocalEvent_HeroCardInfo", rewardT[2])
					elseif (rewardType == 5) then --5:英雄将魂
						--
					elseif (rewardType == 6) then --6:战术技能卡碎片
						--显示战术技能卡碎片tip
						local tacticId = rewardT[2] or 0
						local tacticNum = rewardT[3] or 0
						local tacticLv = rewardT[4] or 1
						hApi.ShowTacticCardTip(rewardType, tacticId, tacticLv)
					elseif (rewardType == 7) then --7:游戏币(服务器处理，客户端只拼日志)
						--显示游戏币介绍的tip
						hApi.ShowGameCoinTip()
					elseif (rewardType == 8) then --8:网络宝箱(服务器处理，客户端只拼日志)
						--显示道具tip
						local itemtipX = 400 + (hVar.SCREEN.w - 1024) / 2 --适配其他分辨率
						local itemtipY = 660 + (hVar.SCREEN.h - 768) / 2 --适配其他分辨率
						hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1}}, nil, 1, itemtipX, itemtipY, 0)
					elseif (rewardType == 9) then --9:抽奖类战术技能卡
						--显示道具tip
						local itemtipX = 400 + (hVar.SCREEN.w - 1024) / 2 --适配其他分辨率
						local itemtipY = 660 + (hVar.SCREEN.h - 768) / 2 --适配其他分辨率
						hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1}}, nil, 1, itemtipX, itemtipY, 0)
					elseif (rewardType == 10) then --10:红装神器
						--显示道具tip
						local itemtipX = 400 + (hVar.SCREEN.w - 1024) / 2 --适配其他分辨率
						local itemtipY = 660 + (hVar.SCREEN.h - 768) / 2 --适配其他分辨率
						hGlobal.event:event("LocalEvent_ShowItemTipFram", {{rewardT[2], 1}}, nil, 1, itemtipX, itemtipY, 0)
					elseif (rewardType == 11) then --11:神器晶石
						--显示神器晶石介绍的tip
						hApi.ShowRedEquipDeribsTip()
					end
				end,
			})
			_BanDiffTipChildUI["baseBtn" .. n].handle.s:setOpacity(0) --只响应事件，不显示
		end
	end
	
	--绘制标题线条
	_BanDiffTipChildUI["Line_title"] = hUI.image:new({
		parent = _RankTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:title_line",
		x = _offX,
		y = _offY + 130 - 110 * (-1),
		w = 940,
		h = 4,
	})
	
	--绘制基础奖池
	local basePool = hVar.MAP_INFO[mapName].DiffMode[3].basePool
	local basePoolShow = {}
	for i = 1, #basePool, 1 do
		local idx = basePool[i]
		for j = 1, #hVar.MAP_DIFF_BASE_CHEST_POOL[idx], 1 do
			table.insert(basePoolShow, hVar.MAP_DIFF_BASE_CHEST_POOL[idx][j])
		end
	end
	local offsetX = 0
	local offsetY = 130 - 25 - 110 * 0
	_createPoolUI(basePoolShow, offsetX, offsetY)
	
	--绘制基础文字
	_BanDiffTipChildUI["Label_base"] = hUI.label:new({
		parent = _RankTipParent,
		size = 24,
		x = _offX,
		y = _offY + 220 - 110 * 0,
		width = 800,
		align = "MC",
		font = hVar.FONTC,
		text = "公共奖池",
		border = 1,
	})
	_BanDiffTipChildUI["Label_base"].handle.s:setColor(ccc3(255, 255, 255))
	
	--绘制基础线条
	_BanDiffTipChildUI["Line_base"] = hUI.image:new({
		parent = _RankTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:title_line",
		x = _offX,
		y = _offY + 130 - 110 * 0,
		w = 940,
		h = 4,
	})
	
	--绘制蓝色奖池（奖池1）
	local chestPool = hVar.MAP_INFO[mapName].DiffMode.chestPool
	local bluePool = chestPool[hVar.ITEM_QUALITY.BLUE]
	local offsetX = 0
	local offsetY = 130 - 25 - 110 * 1
	_createPoolUI(bluePool, offsetX, offsetY)
	
	--绘制蓝色文字
	_BanDiffTipChildUI["Label_blue"] = hUI.label:new({
		parent = _RankTipParent,
		size = 24,
		x = _offX,
		y = _offY + 220 - 110 * 1,
		width = 800,
		align = "MC",
		font = hVar.FONTC,
		text = "第1档奖池",
		border = 1,
	})
	_BanDiffTipChildUI["Label_blue"].handle.s:setColor(ccc3(212, 212, 255))
	
	--绘制线条1
	_BanDiffTipChildUI["Line_1"] = hUI.image:new({
		parent = _RankTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:title_line",
		x = _offX,
		y = _offY + 130 - 110 * 1,
		w = 940,
		h = 4,
	})
	
	--绘制黄色奖池（奖池2）
	local goldPool = chestPool[hVar.ITEM_QUALITY.GOLD]
	local offsetX = 0
	local offsetY = 130 - 25 - 110 * 2
	_createPoolUI(goldPool, offsetX, offsetY)
	
	--绘制黄色文字
	_BanDiffTipChildUI["Label_gold"] = hUI.label:new({
		parent = _RankTipParent,
		size = 24,
		x = _offX,
		y = _offY + 220 - 110 * 2,
		width = 800,
		align = "MC",
		font = hVar.FONTC,
		text = "第2档奖池",
		border = 1,
	})
	_BanDiffTipChildUI["Label_gold"].handle.s:setColor(ccc3(255, 212, 128))
	
	--绘制线条2
	_BanDiffTipChildUI["Line_2"] = hUI.image:new({
		parent = _RankTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:title_line",
		x = _offX,
		y = _offY + 130 - 110 * 2,
		w = 940,
		h = 4,
	})
	
	--绘制橙色奖池（奖池3）
	local orangePool = chestPool[hVar.ITEM_QUALITY.RED]
	local offsetX = 0
	local offsetY = 130 - 25 - 110 * 3
	_createPoolUI(orangePool, offsetX, offsetY)
	
	--绘制黄色文字
	_BanDiffTipChildUI["Label_orange"] = hUI.label:new({
		parent = _RankTipParent,
		size = 24,
		x = _offX,
		y = _offY + 220 - 110 * 3,
		width = 800,
		align = "MC",
		font = hVar.FONTC,
		text = "第3档奖池",
		border = 1,
	})
	_BanDiffTipChildUI["Label_orange"].handle.s:setColor(ccc3(255, 128, 0))
	
	--绘制线条3
	_BanDiffTipChildUI["Line_3"] = hUI.image:new({
		parent = _RankTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:title_line",
		x = _offX,
		y = _offY + 130 - 110 * 3,
		w = 940,
		h = 4,
	})
	
	--绘制红色奖池（奖池4）
	local redPool = chestPool[hVar.ITEM_QUALITY.ORANGE]
	local offsetX = 0
	local offsetY = 130 - 25 - 110 * 4
	_createPoolUI(redPool, offsetX, offsetY)
	
	--绘制红色文字
	_BanDiffTipChildUI["Label_red"] = hUI.label:new({
		parent = _RankTipParent,
		size = 24,
		x = _offX,
		y = _offY + 220 - 110 * 4,
		width = 800,
		align = "MC",
		font = hVar.FONTC,
		text = "第4档奖池",
		border = 1,
	})
	_BanDiffTipChildUI["Label_red"].handle.s:setColor(ccc3(255, 64, 0))
	
	--绘制线条4
	_BanDiffTipChildUI["Line_4"] = hUI.image:new({
		parent = _RankTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:title_line",
		x = _offX,
		y = _offY + 130 - 110 * 4,
		w = 940,
		h = 4,
	})
end

--获取剧情关卡进度
hApi.GetStageSchedule = function()
	
	local ret = 0
	
	local chapterNow = 0
	
	--更新每章的按钮状态
	for i = 1, #hVar.tab_chapter, 1 do
		--本章第一关的前置关卡，是否已通关
		local tChapt = hVar.tab_chapter[i]
		local firstmap = tChapt. firstmap --本章第一关
		local isFinishFirstMap = LuaGetPlayerMapAchi(firstmap, hVar.ACHIEVEMENT_TYPE.LEVEL) or 0 --是否通关本章第一关
		if isFinishFirstMap == 1 then
			chapterNow = i
		else
			break
		end
	end
	
	if chapterNow > 0 then
		local lastmapDone = false --本章的最后一关是否计算过了
		local currentmap = hVar.tab_chapter[chapterNow].firstmap
		while true do
			--附加常规模式的星数
			local isFinish = (LuaGetPlayerMapAchi(currentmap, hVar.ACHIEVEMENT_TYPE.LEVEL) or 0) --本关的常规模式的星数
			if isFinish == 1 then
			
				--跳转到下一个地图
				local tabM = hVar.MAP_INFO[currentmap]
				
				
				
				--下一个地图是否存在
				if (tabM == nil) then
					break
				end
				
				local nextmap = tabM.nextmap[1] --下一张图
				
				--print("hApi.GetStageSchedule:",nextmap,currentmap,ret)
				
				--下一个地图是否有效
				if (nextmap == nil) or (nextmap == currentmap) then
					ret = tabM.level
					break
				end
				
				--如果最后一关是已经计算过了，跳出循环
				if lastmapDone then
					--print("如果最后一关是已经计算过了，跳出循环")
					break
				end
				
				--是否到最后一个地图
				if (nextmap == lastmap) then
					lastmapDone = true --标记最后一关是已经计算过了
					--print("标记最后一关是已经计算过了")
				end
			
			
				--loop
				if tabM.level >= ret then
					ret = tabM.level
				end
				currentmap = nextmap
			else
				break
			end
		end
	end
	
	return ret
	
end


--分段更新的脚本接口(参数1,1)
hApi.Update_Start = function(Protocol,Level)
	--g_Update_Start_Over = 1
	update_start(Protocol,Level)
end

--检测是否已经分段更新完成
hApi.IsUpdate2Done = function()
	--local IsTester = CCUserDefault:sharedUserDefault():getIntegerForKey("xl_account_test") --正式版检测
	
	local result = game_update_is_level_loaded(1)
	if result then
		return true
	else
		local isFinishMap9 = LuaGetPlayerMapAchi("world/td_009_jmhj", hVar.ACHIEVEMENT_TYPE.LEVEL) or 0 --第9关是否解锁
		if (isFinishMap9 == 0) then --未通关，不需要更新
			return true
		else
			--"需要更新资源才能进入\n即将下载所需要的资源包！"
			hGlobal.UI.MsgBox(hVar.tab_string["__TEXT_DownloadResourcePackage"],{
				font = hVar.FONTC,
				ok = function()
					--g_curPlayerName = nil
					--Save_playerList = nil
					--Save_PlayerData = nil
					--Save_PlayerLog = nil
					hApi.Update_Start(1,1)
					if __G_MainMenuWorld then
						__G_MainMenuWorld:del()
						__G_MainMenuWorld = nil
					end
					if __G_SelectMapWorld then
						__G_SelectMapWorld:del()
						__G_SelectMapWorld = nil
					end
					
					--隐藏新主界面
					if hGlobal.UI.Phone_MainPanelFrm then
						hGlobal.UI.Phone_MainPanelFrm:show(0)
					end
					
					--隐藏新选择关卡界面
					if hGlobal.UI.MapSelectMainFrm_New then
						hGlobal.UI.MapSelectMainFrm_New:show(0)
					end
					
					--隐藏商店界面
					if hGlobal.UI.NetShopFramII then
						hGlobal.UI.NetShopFramII:show(0)
					end
				end,
				cancel = function()
					
				end,
			},nil,nil,{"UI:tip",nil,nil,nil,nil,0.8})
			
			return false
		end
	end
end

--获取当前地图中某玩家建造的某些塔的数量
hApi.GetBuildTowerNum = function(w, targetPos, buildIdList)
	
	--print("hApi.GetBuildTowerNum:",hVar.UNIT_TYPE.TOWER,targetPos)
	
	local num = 0
	
	w:enumunit(function(eu)
		--print("hApi.GetBuildTowerNum1:",eu.data.type,eu.data.owner)
		if (eu.data.type==hVar.UNIT_TYPE.TOWER) and (eu.data.owner == targetPos) and (eu.data.IsDead ~= 1) and (eu.attr.hp > 0) then
			if type(buildIdList) == "table" then
				for i = 1, #buildIdList do
					--print("hApi.GetBuildTowerNum2:",eu.data.id,buildIdList[i])
					if eu.data.id == buildIdList[i] then
						num = num + 1
					end
				end
			elseif type(buildIdList) == "number" then
				if eu.data.id == buildIdList then
					num = num + 1
				end
			end
		end
	end)

	return num
end

--如果是中立塔基需要转换数据信息(世界，点中的单位)
hApi.CheckChangeTDUpgrade = function(world,target)
	
	local targetPos = target:getowner():getpos()
	local playerMe = world:GetPlayerMe()
	local changeTdUpgrade = false
	if playerMe and playerMe:getgod() and playerMe:getgod().td_upgrade then
		local td_upgrade_me = playerMe:getgod().td_upgrade[target.data.id]
		if (targetPos == 21 or targetPos == 22) and (playerMe:getforce() == target:getowner():getforce()) then
			local mapInfo = world.data.tdMapInfo
			if mapInfo and mapInfo.buildTogether then
				changeTdUpgrade = true
			end
		end
	end

	return changeTdUpgrade
end

--获取当前技能升级配置中升级技能的最大等级，
hApi.GetTowerSkillMaxLv = function(world,player,skillInfo)
	local maxSkillLv = skillInfo.maxLv or 1
	--print("hApi.GetTowerSkillMaxLv1:",skillInfo.maxLvRelyOnTactic)
	if skillInfo.maxLvRelyOnTactic then
		local maxLvInfo = skillInfo.maxLvInfo
		local tacticId = maxLvInfo.tacticId
		local maxLvList = maxLvInfo.maxLv
		
		--print("hApi.GetTowerSkillMaxLv2:",tacticId,maxLvList)

		local tacticLv = -1
		--获取本局激活的战术技能卡
		local tTactics = player:gettactics()
		if tTactics then
			--遍历战术技能卡执行生效流程
			for n = 1, #tTactics, 1 do
				if tTactics[n]~=0 then
					local id, lv = tTactics[n][1],tTactics[n][2]
					--print("hApi.GetTowerSkillMaxLv3:",id,lv,tacticId)
					if id == tacticId then
						tacticLv = lv
						break
					end
				end
			end
			
			--print("hApi.GetTowerSkillMaxLv5:",tacticLv,#maxLvList)
			
			if tacticLv > 0 and tacticLv <= #maxLvList then
				maxSkillLv = maxLvList[tacticLv]
				--print("hApi.GetTowerSkillMaxLv4:",maxSkillLv)
			end
		end
	end

	return maxSkillLv
end

--检测该坐标是否在水里
hApi.IsPosInWater = function(worldX, worldY)
	local result = 0
	local w = hGlobal.WORLD.LastWorldMap
	
	if w then
		--检测是否在水里
		for i = 1, #w.data.__waterRegionT, 1 do
			local region = w.data.__waterRegionT[i]
			local px = region.x
			local py = region.y
			local pw = region.w
			local ph = region.h
			local regionModel = region.model
			
			local left = px - pw / 2
			local right = px + pw / 2
			local top = py - ph / 2
			local bottom = py + ph / 2
			
			--在水区域里
			if (worldX > left) and (worldX < right) and (worldY > top) and (worldY < bottom) then
				--进行点击测试
				--[[
				local tUnitList = nil
				if (hVar.SYS_IS_NEWTD_APP == 1) then --新塔防app程序
					--第4个参数， 可以不填， 如果填了并且 ＝ 1， 就是只检测场景物件， 不检测角色
					tUnitList = {xlScene_HitTest(hGlobal.WORLD_SCENE[w.data.scenetype], worldX, worldY, 1)}
				else
					tUnitList = {xlScene_HitTest(hGlobal.WORLD_SCENE[w.data.scenetype], worldX, worldY)}
				end
				]]
				--第4个参数， 可以不填， 如果填了并且 ＝ 1， 就是只检测场景物件， 不检测角色
				local tUnitList = {xlScene_HitTest(hGlobal.WORLD_SCENE[w.data.scenetype], worldX, worldY, 1)}
				--print("xlScene_HitTest", "num=", #tUnitList)
				
				if (#tUnitList > 0) then
					--选中单位或场景物件
					local resultSum = 0
					
					for j = 1, #tUnitList, 1 do
						--存在场景物件，就认为该点可到达
						local pCha = tUnitList[j]
						local nType = xlCha_GetType(pCha)
						if (nType == hVar.UNIT_TYPE.SCEOBJ) then
							--print("点击测试", j, nType)
							resultSum = resultSum + 0
						end
						
						--[[
						if (hVar.SYS_IS_NEWTD_APP == 1) then --新塔防app程序
							--
						else
							--都是非船单位，才认为该点可到达
							local c = tUnitList[j]
							local u = hApi.findUnitByCha(c)
							if u and (u.data.IsDead ~= 1) then
								--print("点击测试", j, u.data.name)
								local tag = hVar.tab_unit[u.data.id] and hVar.tab_unit[u.data.id].tag
								if tag and tag[hVar.UNIT_TAG_TYPE.OTHER.TAG_BOAT] then
									resultSum = resultSum + 1
								end
							end
						end
						]]
					end
					
					result = result + resultSum
				else
					--没有选中单位或场景物件，说明该点就是在水里，不能点中
					result = 1
				end
				
				break
			end
		end
	end
	
	if (result > 0) then
		return 1
	else
		return 0
	end
end

--检测某波次发的兵是否已经全部被消灭
hApi.IsAllUnitInWaveKilled = function(wave)
	local ret = false
	
	local w = hGlobal.WORLD.LastWorldMap
	if w and wave then
		
		local mapInfo = w.data.tdMapInfo
		if mapInfo then
		
			local unitAll = 0
			
			if mapInfo.showFlagInfo[wave] then
				for tgrId, num in pairs(mapInfo.showFlagInfo[wave]) do
					unitAll = unitAll + num
				end
			end
			
			if unitAll > 0 and mapInfo.deadUnitPerWave[wave] then
				if unitAll <= mapInfo.deadUnitPerWave[wave] then
					ret = true
				end
			end
		end
	
	end

	return ret
end

--设置波次角色被消灭或漏怪
hApi.SetUnitInWaveKilled = function(wave)
	local w = hGlobal.WORLD.LastWorldMap
	if w then
		local mapInfo = w.data.tdMapInfo
		if mapInfo then
			if wave and wave > 0 and wave <= mapInfo.totalWave and mapInfo.deadUnitPerWave[wave] then
				mapInfo.deadUnitPerWave[wave] = mapInfo.deadUnitPerWave[wave] + 1
			end
		end
	end
end

--------------------------------------------------------------------------------------------------------------------------
--【获取居中排列表】
--[[
	nMiddlePostion：居中的X值
	nInterval：间距
]]
--------------------------------------------------------------------------------------------------------------------------
hApi.GetCenterAlignmentPosition = function(nMiddlePostion, nInterval)
	if type(nInterval) == "number" and type(nMiddlePostion) == "number" then
		local tBasePosition = {
			[1] = {nMiddlePostion},																	--有一个UI时的坐标
			[2] = {nMiddlePostion-(nInterval/2),   nMiddlePostion+(nInterval/2)},											--有两个UI时的坐标
			[3] = {nMiddlePostion-(nInterval/2)*2, nMiddlePostion,                 nMiddlePostion+(nInterval/2)*2},							--有三个UI时的坐标
			[4] = {nMiddlePostion-(nInterval/2)*3, nMiddlePostion-(nInterval/2),   nMiddlePostion+(nInterval/2),                   nMiddlePostion+(nInterval/2)*3},
			[5] = {nMiddlePostion-(nInterval/2)*4, nMiddlePostion-(nInterval/2)*2, nMiddlePostion, nMiddlePostion+(nInterval/2)*2, nMiddlePostion+(nInterval/2)*4},
		}
		return tBasePosition
	end
end

--释放png, plist的纹理缓存
hApi.ReleasePngTextureCache = function()
	--png表
	local pngFileNameList =
	{
		--effect
		"effect/acid01.png",
		"effect/Acid_1.png",
		"effect/Acid_2.png",
		"effect/airfield_1.png",
		"effect/airfield_2.png",
		"effect/airfield_3.png",
		"effect/armor.b2sp",
		"effect/arrow_06.png",
		"effect/arrow_07.png",
		"effect/arrow_13.png",
		"effect/aura04.png",
		"effect/Aura_1.png",
		"effect/autocast.png",
		"effect/automat.png",
		"effect/Band_aid.png",
		"effect/baozha.png",
		"effect/barrel.png",
		"effect/bb_energy.png",
		"effect/bb_fire_eff.png",
		"effect/bb_lz_eff.png",
		"effect/behit_jiguanpao_b.png",
		"effect/behit_tegong_c.png",
		"effect/bindong.png",
		"effect/blackfog.png",
		"effect/blackfog1.png",
		"effect/blocks.b2sp",
		"effect/blocks.png",
		"effect/blink.png",
		"effect/block01.png",
		"effect/block02.png",
		"effect/Blood_1.png",
		"effect/Blood_2.png",
		"effect/blood_new.png",
		"effect/blood_new5.png",
		"effect/blood_new6.png",
		"effect/blood_new7.png",
		"effect/blowit_sign.png",
		"effect/body.b2sp",
		"effect/bolang.png",
		"effect/bomb3.png",
		"effect/boss_laser.png",
		"effect/boss1.png",
		"effect/boss2.png",
		"effect/boss3.png",
		"effect/boss4.png",
		"effect/boss6.png",
		"effect/boss6_s.png",
		"effect/bossf.png",
		"effect/bossgun_fire1.png",
		"effect/bossf_2.png",
		"effect/box.png",
		"effect/box2.png",
		"effect/break_down.png",
		"effect/buff_n0.png",
		"effect/buff_n1.png",
		"effect/buff_n2.png",
		"effect/buff_n3.png",
		"effect/buff_n4.png",
		"effect/buff_n5.png",
		"effect/buff_n6.png",
		"effect/buff_n7.png",
		"effect/buff_n8.png",
		"effect/buff_n9.png",
		"effect/buff_n10.png",
		"effect/buff_n11.png",
		"effect/buff_n12.png",
		"effect/buff_n13.png",
		"effect/buff_n14.png",
		"effect/buff_n15.png",
		"effect/buff_n16.png",
		"effect/buff_n17.png",
		"effect/buff_n18.png",
		"effect/burst01.png",
		"effect/burst_1.png",
		"effect/burst_2.png",
		"effect/burst_3.png",
		"effect/chain_001.png",
		"effect/chain_002.png",
		"effect/chain_003.png",
		"effect/chain_004.png",
		"effect/chain_005.png",
		"effect/chain_006.png",
		"effect/charge_tower.png",
		"effect/chenmo.png",
		"effect/chip.png",
		"effect/circle.png",
		"effect/circle1.png",
		"effect/circle2.png",
		"effect/circle3.png",
		"effect/circlebutton.png",
		"effect/coin.png",
		"effect/cobweb01.png",
		"effect/dadan.png",
		"effect/dadan_fly.png",
		"effect/dadan_fly_black.png",
		"effect/dadan_hit_black.png",
		"effect/daodan2.png",
		"effect/daodan_up.png",
		"effect/daodan_up_black.png",
		"effect/daoguang.png",
		"effect/daoguang01.png",
		"effect/daoguang02.png",
		"effect/daoguang03.png",
		"effect/daoguang04.png",
		"effect/daoguang05.png",
		"effect/ddta.png",
		"effect/diamond.png",
		"effect/dinji.png",
		"effect/downstone_mm.png",
		"effect/draghand.png",
		"effect/duest_mm.png",
		"effect/dupao.png",
		"effect/dust.png",
		"effect/dust2.png",
		"effect/dust3.png",
		"effect/dust4.png",
		"effect/dusty.png",
		"effect/electronic.png",
		"effect/electronic2.png",
		"effect/electronic3.png",
		"effect/enemy_tower.png",
		"effect/enemy_tower2.png",
		"effect/enemy_tower3.png",
		"effect/enemy_tower4.png",
		"effect/fan1.png",
		"effect/fan2.png",
		"effect/fantanpao.png",
		"effect/feibiao.png",
		"effect/fire02.png",
		"effect/fire06.png",
		"effect/fireball.png",
		"effect/fireball6.png",
		"effect/fireball8.png",
		"effect/fireball9.png",
		"effect/fireball_01.png",
		"effect/fireball_02.png",
		"effect/fireball_03.png",
		"effect/flycannon_huojian.png",
		"effect/fragment.png",
		"effect/GlacialSpike.png",
		"effect/gate.png",
		"effect/guang.png",
		"effect/guang2.png",
		"effect/guang3.png",
		"effect/hanqi.png",
		"effect/heal01.png",
		"effect/hit.png",
		"effect/hit_armor.png",
		"effect/hit_armor2.png",
		"effect/hit_body.png",
		"effect/hit_wall.png",
		"effect/hole_fire.png",
		"effect/hole_lighting.png",
		"effect/hole_poison.png",
		"effect/hook_head2.png",
		"effect/hook_middle2.png",
		"effect/hpbox.png",
		"effect/hpbox2.png",
		"effect/huoyou.png",
		"effect/iced.png",
		"effect/ice_ball.png",
		"effect/ice_explosion.png",
		"effect/ice_explosion2.png",
		"effect/ice_spike_01.png",
		"effect/impulse.png",
		"effect/jiantou.png",
		"effect/jiantou2.png",
		"effect/jt.png",
		"effect/julang.png",
		"effect/juqi.png",
		"effect/katongbaozha.png",
		"effect/katongzha.png",
		"effect/koushui.png",
		"effect/lanqiu.png",
		"effect/laser.png",
		"effect/laser_control.png",
		"effect/laser_door.png",
		"effect/laser_door2.png",
		"effect/laser2.png",
		"effect/laser3.png",
		"effect/laser4.png",
		"effect/laser5.png",
		"effect/laser6.png",
		"effect/laser7.png",
		"effect/laser8.png",
		"effect/laserball_explosion.png",
		"effect/leishe.png",
		"effect/LightningHit_3.png",
		"effect/luoxuan.png",
		"effect/lvup_attack.png",
		"effect/lvup_skill.png",
		"effect/mana01.png",
		"effect/maze3_11.png",
		"effect/metal_balloon_shadow.png",
		"effect/mguncbase000.png",
		"effect/miaozhun.png",
		"effect/mine.png",
		"effect/mini_dici.png",
		"effect/mofadan.png",
		"effect/mubei.png",
		"effect/mubei2.png",
		"effect/myztx.pvr.ccz",
		"effect/net_sky01.png",
		"effect/net_sky02.png",
		"effect/net_sky03.png",
		"effect/net_sky04.png",
		"effect/nuclear.png",
		"effect/obstacle.png",
		"effect/obstacle2.png",
		"effect/obstacle3.png",
		"effect/openchest.png",
		"effect/paotai.png",
		"effect/paotaidizuo.png",
		"effect/plate.png",
		"effect/pojiadanbaozha.png",
		"effect/power_tower.png",
		"effect/roar01.png",
		"effect/ranktv.png",
		"effect/scan.png",
		"effect/screen.png",
		"effect/select_circle.png",
		"effect/select_circle2.png",
		"effect/select_light.png",
		"effect/select_triangle.png",
		"effect/sf.png",
		"effect/sf2.png",
		"effect/sf3.png",
		"effect/sf4.png",
		"effect/sf5.png",
		"effect/shadow.png",
		"effect/shadow2.png",
		"effect/shadow3.png",
		"effect/shandian.png",
		"effect/shield01.png",
		"effect/shield02.png",
		"effect/shield03.png",
		"effect/shield04.png",
		"effect/shipcore.png",
		"effect/shixue.png",
		"effect/shixue2.png",
		"effect/shop.png",
		"effect/shuijing.png",
		"effect/shuijing2.png",
		"effect/shuijing3.png",
		"effect/smoke.png",
		"effect/smoke01.png",
		"effect/smoke03.png",
		"effect/smoke04.png",
		"effect/smoke05.png",
		"effect/smoke06.png",
		"effect/space_ladder.png",
		"effect/space_star.png",
		"effect/space_sun.png",
		"effect/spark.png",
		"effect/spark2.png",
		"effect/spark3.png",
		"effect/start_ani.png",
		"effect/start1.png",
		"effect/start2.png",
		"effect/stone01.png",
		"effect/stone02.png",
		"effect/strengthen2.png",
		"effect/Summon_1.png",
		"effect/T_heal.png",
		"effect/T_save.png",
		"effect/tactic.png",
		"effect/taizi_ex.png",
		"effect/td_paota1_bullet.png",
		"effect/td_paota2_bullet.png",
		"effect/td_paota_bullet.png",
		"effect/tdgaosheta_base.png",
		"effect/tdjiqiangta_base.png",
		"effect/tdpaotaita_base.png",
		"effect/tdshejita_base.png",
		"effect/teleport.png",
		"effect/testbump_a.png",
		"effect/thunder.png",
		"effect/thunder_storm.png",
		"effect/thunder2.png",
		"effect/thunder3.png",
		"effect/timer01.png",
		"effect/timer02.png",
		"effect/timg.png",
		"effect/tishi.png",
		"effect/tnt.png",
		"effect/touming.png",
		"effect/touming2.png",
		"effect/transport1.png",
		"effect/trap.png",
		"effect/upgrade.png",
		"effect/waiting.png",
		"effect/wall.b2sp",
		"effect/warning.png",
		"effect/warning2.png",
		"effect/WarStomp.png",
		"effect/way_arrow.png",
		"effect/whirlwind.png",
		"effect/whirlwind_f.png",
		"effect/whirlwind2.png",
		"effect/wushang1-1.png",
		"effect/wushuang1.png",
		"effect/xianjing_1.png",
		"effect/xianjing_2.png",
		"effect/xianjing_2_1.png",
		"effect/xuanwo.png",
		"effect/yanwu.png",
		"effect/yingzi.png",
		"effect/youtong.png",
		"effect/Z_raid.png",
		"effect/Z_raid_red.png",
		"effect/zhadan.png",
		"effect/zhadan2.png",
		"effect/zhadan3.png",
		"effect/zhadan4.png",
		"effect/zhadan5.png",
		"effect/zhadan6.png",
		"effect/zhadan7.png",
		"effect/zhua.png",
		"effect/zidan1.png",
		"effect/zidan2.png",
		"effect/zidan3.png",
		"effect/zidan4.png",
		"effect/zidan5.png",
		"effect/zidan5_t1.png",
		"effect/zidan5_t2.png",
		"effect/zidan6.png",
		"effect/zidan7.png",
		"effect/zidan8.png",
		"effect/zidan9.png",
		"effect/zidan10.png",
		"effect/zidan11.png",
		"effect/zidan12.png",
		"effect/zidan13.png",
		"effect/zidan13_t1.png",
		"effect/zidan13_t2.png",
		"effect/zidan14.png",
		"effect/zidan14_t1.png",
		"effect/zidan14_t2.png",
		"effect/zidan15.png",
		"effect/zidan16.png",
		"effect/zidan17.png",
		"effect/zidan18.png",
		"effect/zidan22.png",
		"effect/zidan23.png",
		"effect/zidan24.png",
		"effect/zidan25.png",
		"effect/zidan.png",
		"effect/zwyb.png",
		
		--icon/border
		"icon/border/0.png",
		"icon/border/1000.png",
		
		--icon/head
		"icon/head/broadcast_n.png",
		"icon/head/tank_touxiang.png",
		
		--icon/hero
		"icon/hero/boss_01.png",
		"icon/hero/boss_02.png",
		"icon/hero/boss_03.png",
		"icon/hero/boss_04.png",
		"icon/hero/boss_05.png",
		"icon/hero/boss_06.png",
		"icon/hero/pet_01.png",
		"icon/hero/pet_02.png",
		"icon/hero/pet_03.png",
		"icon/hero/pet_04.png",
		"icon/hero/soldier_01.png",
		"icon/hero/soldier_02.png",
		"icon/hero/soldier_03.png",
		"icon/hero/tili_oil.png",
		"icon/hero/tank_01.png",
		"icon/hero/tank_02.png",
		"icon/hero/truck.png",
		
		--icon/item
		"icon/item/chest_1.png",
		"icon/item/chest_2.png",
		"icon/item/chest_3.png",
		"icon/item/chest_4.png",
		"icon/item/chest_5.png",
		"icon/item/gun_1.png",
		"icon/item/gun_2.png",
		"icon/item/gun_3.png",
		"icon/item/gun_4.png",
		"icon/item/gun_5.png",
		"icon/item/gun_6.png",
		"icon/item/gun_7.png",
		"icon/item/gun_8.png",
		"icon/item/gun_9.png",
		"icon/item/gun_10.png",
		"icon/item/gun_11.png",
		"icon/item/gun_12.png",
		"icon/item/gun_13.png",
		"icon/item/gun_14.png",
		"icon/item/iap_gift_lv1.png",
		"icon/item/iap_gift_lv2.png",
		"icon/item/iap_gift_lv3.png",
		"icon/item/iap_gift_lv4.png",
		"icon/item/iap_gift_lv5.png",
		"icon/item/iap_gift_lv6.png",
		"icon/item/icon_garage_01.png",
		"icon/item/icon_garage_02.png",
		"icon/item/icon_garage_03.png",
		"icon/item/icon_garage_04.png",
		"icon/item/icon_remains_01.png",
		"icon/item/icon_remains_02.png",
		"icon/item/icon_remains_03.png",
		"icon/item/icon_remains_04.png",
		"icon/item/icon_remains_05.png",
		"icon/item/item_001.png",
		"icon/item/item_001.png",
		"icon/item/item_002.png",
		"icon/item/item_003.png",
		"icon/item/item_004.png",
		"icon/item/item_005.png",
		"icon/item/item_006.png",
		"icon/item/item_007.png",
		"icon/item/item_008.png",
		"icon/item/item_010.png",
		"icon/item/item_011.png",
		"icon/item/item_012.png",
		"icon/item/item_013.png",
		"icon/item/item_014.png",
		"icon/item/item_015.png",
		"icon/item/item_016.png",
		"icon/item/item_017.png",
		"icon/item/item_018.png",
		"icon/item/item_019.png",
		"icon/item/item_020.png",
		"icon/item/item_021.png",
		"icon/item/item_022.png",
		"icon/item/item_023.png",
		"icon/item/item_024.png",
		"icon/item/item_025.png",
		"icon/item/item_026.png",
		"icon/item/item_027.png",
		"icon/item/item_028.png",
		"icon/item/item_029.png",
		"icon/item/item_030.png",
		"icon/item/item_031.png",
		"icon/item/item_032.png",
		"icon/item/item_033.png",
		"icon/item/item_034.png",
		"icon/item/item_035.png",
		"icon/item/item_036.png",
		"icon/item/item_037.png",
		"icon/item/item_038.png",
		"icon/item/item_039.png",
		"icon/item/item_040.png",
		"icon/item/item_041.png",
		"icon/item/item_042.png",
		"icon/item/item_043.png",
		"icon/item/item_044.png",
		"icon/item/item_045.png",
		"icon/item/item_046.png",
		"icon/item/item_047.png",
		"icon/item/item_048.png",
		"icon/item/item_049.png",
		"icon/item/item_050.png",
		"icon/item/item_051.png",
		"icon/item/item_052.png",
		"icon/item/item_053.png",
		"icon/item/item_054.png",
		"icon/item/item_055.png",
		"icon/item/item_056.png",
		"icon/item/item_057.png",
		"icon/item/item_058.png",
		"icon/item/item_059.png",
		"icon/item/item_060.png",
		"icon/item/item_061.png",
		"icon/item/item_062.png",
		"icon/item/item_063.png",
		"icon/item/item_064.png",
		"icon/item/item_065.png",
		"icon/item/item_066.png",
		"icon/item/item_067.png",
		"icon/item/item_068.png",
		"icon/item/item_069.png",
		"icon/item/item_070.png",
		"icon/item/item_071.png",
		"icon/item/item_072.png",
		"icon/item/item_073.png",
		"icon/item/item_074.png",
		"icon/item/item_075.png",
		"icon/item/item_076.png",
		"icon/item/item_077.png",
		"icon/item/item_078.png",
		"icon/item/item_079.png",
		"icon/item/item_080.png",
		"icon/item/item_081.png",
		"icon/item/item_082.png",
		"icon/item/item_083.png",
		"icon/item/item_084.png",
		"icon/item/item_085.png",
		"icon/item/item_086.png",
		"icon/item/item_087.png",
		"icon/item/item_088.png",
		"icon/item/item_089.png",
		"icon/item/item_090.png",
		"icon/item/item_091.png",
		"icon/item/item_092.png",
		"icon/item/item_093.png",
		"icon/item/item_094.png",
		"icon/item/item_095.png",
		"icon/item/item_096.png",
		"icon/item/item_097.png",
		"icon/item/item_098.png",
		"icon/item/item_099.png",
		"icon/item/item_100.png",
		"icon/item/item_101.png",
		"icon/item/item_102.png",
		"icon/item/item_103.png",
		"icon/item/item_104.png",
		"icon/item/item_105.png",
		"icon/item/item_106.png",
		"icon/item/item_107.png",
		"icon/item/item_108.png",
		"icon/item/item_109.png",
		"icon/item/item_110.png",
		"icon/item/item_111.png",
		"icon/item/item_112.png",
		"icon/item/item_113.png",
		"icon/item/item_114.png",
		"icon/item/item_115.png",
		"icon/item/item_116.png",
		"icon/item/item_117.png",
		"icon/item/item_118.png",
		"icon/item/item_119.png",
		"icon/item/item_120.png",
		"icon/item/item_121.png",
		"icon/item/item_122.png",
		"icon/item/item_123.png",
		"icon/item/item_124.png",
		"icon/item/item_125.png",
		"icon/item/item_126.png",
		"icon/item/item_127.png",
		"icon/item/item_128.png",
		"icon/item/item_129.png",
		"icon/item/item_130.png",
		"icon/item/item_131.png",
		"icon/item/item_132.png",
		"icon/item/item_133.png",
		"icon/item/item_134.png",
		"icon/item/item_135.png",
		"icon/item/item_136.png",
		"icon/item/item_137.png",
		"icon/item/item_138.png",
		"icon/item/pet_01.png",
		"icon/item/pet_02.png",
		"icon/item/pet_03.png",
		"icon/item/pet_04.png",
		"icon/item/tili_oil.png",
		"icon/item/tower_01.png",
		"icon/item/tower_02.png",
		"icon/item/tower_03.png",
		"icon/item/tower_04.png",
		"icon/item/tower_05.png",
		"icon/item/tower_bunker.png",
		"icon/item/tower_bunker2.png",
		"icon/item/tower_container.png",
		"icon/item/tower_container2.png",
		"icon/item/towergun_1.png",
		"icon/item/towergun_2.png",
		"icon/item/towergun_3.png",
		"icon/item/towergun_4.png",
		"icon/item/towergun_5.png",
		"icon/item/towergun_6.png",
		"icon/item/towergun_7.png",
		"icon/item/towergun_8.png",
		"icon/item/towergun_9.png",
		"icon/item/towergun_10.png",
		"icon/item/towergun_normal.png",
		"icon/item/towergun_selectbox.png",
		"icon/item/vip_01.png",
		"icon/item/vip_02.png",
		"icon/item/vip_03.png",
		"icon/item/vip_04.png",
		"icon/item/vip_05.png",
		
		--icon/portrait
		"icon/portrait/tank_icon01.png",
		"icon/portrait/tank_icon02.png",
		"icon/portrait/tank_icon03.png",
		
		--icon/skill
		"icon/skill/def_bomb.png",
		"icon/skill/def_fire.png",
		"icon/skill/def_physic.png",
		"icon/skill/def_poison.png",
		"icon/skill/def_thunder.png",
		"icon/skill/grenade_child.png",
		"icon/skill/grenade_crit.png",
		"icon/skill/grenade_fire.png",
		"icon/skill/grenade_num.png",
		"icon/skill/icon_fag1.png",
		"icon/skill/icon_fag2.png",
		"icon/skill/icon_mana.png",
		"icon/skill/icon1.png",
		"icon/skill/icon2.png",
		"icon/skill/icon3.png",
		"icon/skill/icon4.png",
		"icon/skill/icon4_full.png",
		"icon/skill/icon5.png",
		"icon/skill/icon6.png",
		"icon/skill/icon7.png",
		"icon/skill/icon8.png",
		"icon/skill/l4.png",
		"icon/skill/l5.png",
		"icon/skill/skill_cd.png",
		"icon/skill/skill1.png",
		"icon/skill/skill2.png",
		"icon/skill/skill3.png",
		"icon/skill/skill4.png",
		"icon/skill/skill5.png",
		"icon/skill/skill6.png",
		"icon/skill/skill7.png",
		"icon/skill/skill8.png",
		"icon/skill/skill9.png",
		"icon/skill/unit_cishe.png",
		"icon/skill/unit_huodou.png",
		"icon/skill/unit_jiqiren.png",
		"icon/skill/unit_mowang.png",
		"icon/skill/unit_spider.png",
		"icon/skill/unit_wanghun.png",
		"icon/skill/unit_wugui.png",
		
		--icon/skil
		"icon/skil/skin_000.png",
		"icon/skil/skin_001.png",
		"icon/skil/skin_002.png",
		"icon/skil/skin_003.png",
		"icon/skil/skin_004.png",
		"icon/skil/skin_005.png",
		"icon/skil/skin_006.png",
		"icon/skil/skin_icon_001.png",
		"icon/skil/skin_icon_002.png",
		"icon/skil/skin_icon_003.png",
		"icon/skil/skin_icon_004.png",
		"icon/skil/skin_icon_005.png",
		"icon/skil/skin_icon_006.png",
		
		--icon/xlobj
		"icon/xlobj/airship01.png",
		"icon/xlobj/airship01_title.png",
		"icon/xlobj/airship02.png",
		"icon/xlobj/airship02_title.png",
		"icon/xlobj/airship03.png",
		"icon/xlobj/airship03_title.png",
		"icon/xlobj/airship04.png",
		"icon/xlobj/airship04_title.png",
		"icon/xlobj/bio01.png",
		"icon/xlobj/bio01_title.png",
		"icon/xlobj/bio02.png",
		"icon/xlobj/bio02_title.png",
		"icon/xlobj/bio03.png",
		"icon/xlobj/bio03_title.png",
		"icon/xlobj/bio04.png",
		"icon/xlobj/bio04_title.png",
		"icon/xlobj/mechanics01.png",
		"icon/xlobj/mechanics01_title.png",
		"icon/xlobj/mechanics02.png",
		"icon/xlobj/mechanics02_title.png",
		"icon/xlobj/mechanics03.png",
		"icon/xlobj/mechanics03_title.png",
		"icon/xlobj/mechanics04.png",
		"icon/xlobj/mechanics04_title.png",
		"icon/xlobj/plate01.png",
		"icon/xlobj/plate01_title.png",
		"icon/xlobj/plate02.png",
		"icon/xlobj/plate02_title.png",
		"icon/xlobj/plate03.png",
		"icon/xlobj/plate03_title.png",
		"icon/xlobj/plate04.png",
		"icon/xlobj/plate04_title.png",
		"icon/xlobj/spider01.png",
		"icon/xlobj/spider01_title.png",
		"icon/xlobj/spider02.png",
		"icon/xlobj/spider02_title.png",
		"icon/xlobj/spider03.png",
		"icon/xlobj/spider03_title.png",
		"icon/xlobj/spider04.png",
		"icon/xlobj/spider04_title.png",
		"icon/xlobj/walle01.png",
		"icon/xlobj/walle01_title.png",
		"icon/xlobj/walle02.png",
		"icon/xlobj/walle02_title.png",
		"icon/xlobj/walle03.png",
		"icon/xlobj/walle03_title.png",
		"icon/xlobj/walle04.png",
		"icon/xlobj/walle04_title.png",
		"icon/xlobj/yoda01.png",
		"icon/xlobj/yoda01_title.png",
		"icon/xlobj/yoda02.png",
		"icon/xlobj/yoda02_title.png",
		"icon/xlobj/yoda03.png",
		"icon/xlobj/yoda03_title.png",
		"icon/xlobj/yoda04.png",
		"icon/xlobj/yoda04_title.png",
		"icon/xlobj/zerg01.png",
		"icon/xlobj/zerg01_title.png",
		"icon/xlobj/zerg02.png",
		"icon/xlobj/zerg02_title.png",
		"icon/xlobj/zerg03.png",
		"icon/xlobj/zerg03_title.png",
		"icon/xlobj/zerg04.png",
		"icon/xlobj/zerg04_title.png",
		
		--maze
		"maze/crystal_stone01.png",
		"maze/crystal_stone02.png",
		"maze/crystal_stone03.png",
		"maze/crystal_stone04.png",
		"maze/crystal_stone05.png",
		"maze/crystal_stone06.png",
		"maze/mazeskin_001_small.png",
		"maze/mazeskin_002_small.png",
		"maze/mazeskin_003_small.png",
		"maze/mazeskin_004_small.png",
		"maze/mazeskin_005_small.png",
		"maze/mazeskin_006_small.png",
		"maze/mazeskin_011_small.png",
		"maze/mazeskin_012_small.png",
		"maze/mazeskin_013_small.png",
		"maze/mazeskin_014_small.png",
		"maze/mazeskin_015_small.png",
		"maze/mazeskin_016_small.png",
		"maze/mazeskin_017_small.png",
		"maze/mazeskin_highwall_001.png",
		"maze/mazeskin_highwall_002.png",
		"maze/mazeskin_midwall_003.png",
		"maze/mazeskin_flatwall_004.png",
		"maze/mazeskin_flatwall_005.png",
		"maze/mazeskin_highwall_006.png",
		"maze/mazeskin_011.png",
		"maze/mazeskin_012.png",
		"maze/mazeskin_013.png",
		"maze/mazeskin_014.png",
		"maze/mazeskin_015.png",
		"maze/mazeskin_016.png",
		"maze/mazeskin_017.png",
		"maze/space_back_01.jpg",
		"maze/space_back_02.jpg",
		"maze/space_back_03.jpg",
		"maze/space_back_04.jpg",
		"maze/space_back_05.jpg",
		"maze/space_back_06.jpg",
		"maze/space_back_07.jpg",
		"maze/space_back_01_small.png",
		"maze/space_back_02_small.png",
		"maze/space_back_03_small.png",
		"maze/space_back_04_small.png",
		"maze/space_back_05_small.png",
		"maze/space_back_06_small.png",
		"maze/space_back_07_small.png",
		"maze/starlight.png",
		
		--misc
		"misc/account_set.png",
		"misc/age12+.png",
		"misc/arrow.png",
		"misc/arrow_ext.png",
		"misc/atkRange.png",
		"misc/bar_remould_bg.png",
		"misc/barrage_off.png",
		"misc/barrage_on.png",
		"misc/black_border.png",
		"misc/block.png",
		"misc/buttonback.png",
		"misc/buttonback2.png",
		"misc/buttonred.png",
		"misc/button_back.png",
		"misc/button_null.png",
		"misc/buy_coins.png",
		"misc/cancel.png",
		"misc/chapter_arrow.png",
		"misc/chat.png",
		"misc/chat_icon.png",
		"misc/coin2.png",
		"misc/circle.png",
		"misc/circlemask.png",
		"misc/close.png",
		"misc/cloud.png",
		"misc/cloud_1.png",
		"misc/cloud_2.png",
		"misc/cloud_item.png",
		"misc/confimbtn.png",
		"misc/debris.png",
		"misc/debris_l.png",
		"misc/debris_r.png",
		"misc/debris1.png",
		"misc/decal_mask.png",
		"misc/diamond_slot.png",
		"misc/direction.png",
		"misc/flag.png",
		"misc/floatnumber_bg.png",
		"misc/fog.png",
		"misc/frm_b.png",
		"misc/gear.png",
		"misc/gophermachine.png",
		"misc/gamebbs.png",
		"misc/game_coins.png",
		"misc/gift.png",
		"misc/gradual.png",
		"misc/gray_mask_16.png",
		"misc/icon_backb.png",
		"misc/iconb_lock.png",
		"misc/iconb_nolock.png",
		"misc/jdt.png",
		"misc/jdt1.png",
		"misc/jdt2.png",
		"misc/jdt3.png",
		"misc/jdt4.png",
		"misc/Joystick_04.png",
		"misc/Joystick_05.png",
		"misc/language_en.png",
		"misc/language_sc.png",
		"misc/lightline.png",
		"misc/lockline.png",
		"misc/lockline.png",
		"misc/login_border.png",
		"misc/login_ios.png",
		"misc/login_oneplayer.png",
		"misc/login_options.png",
		"misc/login_phone.png",
		"misc/login_pressstart.png",
		"misc/login_qq.png",
		"misc/login_start.png",
		"misc/login_wx.png",
		"misc/logintv_btn2.png",
		"misc/ltt.png",
		"misc/maintain.png",
		--"misc/mask.png", --系统默认图片路径，不释放
		"misc/mask_16.png",
		"misc/mask_white.png",
		"misc/minilock.png",
		"misc/mp_bar.png",
		"misc/next_day.png",
		"misc/num_blue.png",
		"misc/ok.png",
		"misc/photo_frame.png",
		"misc/portrait_mask.png",
		"misc/progress.png",
		"misc/psword.png",
		"misc/r_mask_16.png",
		"misc/rank_line.png",
		"misc/ranktv.png",
		"misc/redbtn1_1.png",
		"misc/redbtn1_2.png",
		"misc/redbtn2_1.png",
		"misc/redbtn2_2.png",
		"misc/redbtn3_1.png",
		"misc/redbtn3_2.png",
		"misc/s1.png",
		"misc/scrollBtn.png",
		"misc/selectbg.png",
		"misc/selectbg2.png",
		"misc/selectbg3.png",
		"misc/selectbg4.png",
		"misc/setting.png",
		"misc/setting2.png",
		"misc/shadow.png",
		"misc/space_sun.png",
		"misc/tactics_machine.png",
		"misc/task.png",
		"misc/tb.png",
		"misc/slot.png",
		"misc/speed.png",
		"misc/tfback.png",
		"misc/tipfrm.png",
		"misc/title_line.png",
		"misc/update.png",
		"misc/valuebar.png",
		"misc/valuebar_back.png",
		"misc/valuebar_back2.png",
		"misc/valuebar_new.png",
		"misc/valuebar_old.png",
		"misc/waterfall.png",
		"misc/vip1.png",
		"misc/wave_icon.png",
		"misc/weekstar.png",
		"misc/win_back.png",
		"misc/xiangkuang.png",
		"misc/y_mask_16.png",
		"misc/zan.png",
		"misc/tactics_machine.png",
		"misc/maintain.png",
		"misc/weaponrack.png",
		"misc/weaponrack_btn.png",
		"misc/zhezhao.jpg",
		"misc/zan.png",
		
		--misc/addition
		"misc/addition/blackdragon.png",
		"misc/addition/c_hammer.png",
		"misc/addition/card_endless_back.png",
		"misc/addition/card_endless_mask.png",
		"misc/addition/cg.png",
		"misc/addition/cg_label.png",
		"misc/addition/change_arrow.png",
		"misc/addition/comment.png",
		"misc/addition/comment_button.png",
		"misc/addition/comment_panel.png",
		"misc/addition/commentbtn.png",
		"misc/addition/construction_panel.png",
		"misc/addition/debris_bg_less.png",
		"misc/addition/debris_bg_more.png",
		"misc/addition/dialogbg.png",
		"misc/addition/dialogue_01.png",
		"misc/addition/dialogue_02.png",
		"misc/addition/dialogue_03.png",
		"misc/addition/dialogue_short.png",
		"misc/addition/difficulty_01.png",
		"misc/addition/difficulty_02.png",
		"misc/addition/difficulty_03.png",
		"misc/addition/difficulty_04.png",
		"misc/addition/giftcard_title.png",
		"misc/addition/icon_add.png",
		"misc/addition/info_center_panel.png",
		"misc/addition/mining_gas.png",
		"misc/addition/mining_return.png",
		"misc/addition/mining_stone.png",
		"misc/addition/menu_btn_exitgame.png",
		"misc/addition/menu_btn_music.png",
		"misc/addition/menu_btn_reply.png",
		"misc/addition/menu_btn_return.png",
		"misc/addition/morizhanche.jpg",
		"misc/addition/pan.png",
		"misc/addition/pet_panel.png",
		"misc/addition/pettalk_btn.png",
		"misc/addition/pettalk_mining_fight.png",
		"misc/addition/randsieve.png",
		"misc/addition/reply_button.png",
		"misc/addition/rewards_panel.png",
		"misc/addition/sound_off.png",
		"misc/addition/sound_on.png",
		"misc/addition/stage.png",
		"misc/addition/stage_en.png",
		"misc/addition/stage_number.png",
		"misc/addition/stage_tray_01.png",
		"misc/addition/stage_tray_02.png",
		"misc/addition/star_light2.png",
		"misc/addition/story_panel.png",
		"misc/addition/story_panel_mask.png",
		"misc/addition/talk_panel.png",
		"misc/addition/tank.png",
		"misc/addition/tank_bg.png",
		"misc/addition/tank_anniu.png",
		"misc/addition/tank_anniu2.png",
		"misc/addition/tank_dikuang.png",
		"misc/addition/tank_gou01.png",
		"misc/addition/tank_jiantou01.png",
		"misc/addition/tank_jiantou02.png",
		"misc/addition/tank_mingzi01.png",
		"misc/addition/tank_mingzi02.png",
		"misc/addition/tank_pifu02.png",
		"misc/addition/tank_pifu03.png",
		"misc/addition/tank_touxiang01.png",
		"misc/addition/tank_touxiang02.png",
		"misc/addition/tank_xinxikuang.png",
		"misc/addition/tank_xuanche_tab_down.png",
		"misc/addition/tank_xuanche_tab_mid.png",
		"misc/addition/tank_xuanche_tab_up.png",
		"misc/addition/tank_pifu_kuang.png",
		"misc/addition/tank_xuanche01.png",
		"misc/addition/tank_xuanche02.png",
		"misc/addition/tank_xuanche03.png",
		"misc/addition/tinyboss_circle.png",
		"misc/addition/tinyboss_label.png",
		"misc/addition/valuebar_back3.png",
		"misc/addition/valuebar3.png",
		"misc/addition/warning.png",
		
		--misc/billboard
		"misc/billboard/bg_ng_graywhite.png",
		"misc/billboard/btn_empty.png",
		"misc/billboard/kuang5.png",
		"misc/billboard/kuang8.png",
		"misc/billboard/msgbox5.png",
		"misc/billboard/top.png",
		"misc/billboard/top3.png",
		"misc/billboard/top10.png",
		"misc/billboard/top20.png",
		"misc/billboard/top50.png",
		"misc/billboard/top100.png",
		
		--misc/chariotconfig
		"misc/chariotconfig/arrow_l.png",
		"misc/chariotconfig/arrow_r.png",
		"misc/chariotconfig/bin.png",
		"misc/chariotconfig/boardbg.png",
		"misc/chariotconfig/button10.png",
		"misc/chariotconfig/chip.png",
		"misc/chariotconfig/chip_bar.png",
		"misc/chariotconfig/chip_bar_lock.png",
		"misc/chariotconfig/chip_hammer.png",
		"misc/chariotconfig/chip_lock.png",
		"misc/chariotconfig/chip_merge.png",
		"misc/chariotconfig/chip_null.png",
		"misc/chariotconfig/chip_panel.png",
		"misc/chariotconfig/chip_unlock.png",
		"misc/chariotconfig/currency_keshi.png",
		"misc/chariotconfig/equipbg_blue.png",
		"misc/chariotconfig/equipbg_orange.png",
		"misc/chariotconfig/equipbg_red.png",
		"misc/chariotconfig/equipbg_white.png",
		"misc/chariotconfig/equipbg_yellow.png",
		"misc/chariotconfig/equipgridbg.png",
		"misc/chariotconfig/go_equips.png",
		"misc/chariotconfig/itemgrid.png",
		"misc/chariotconfig/itemgrid2.png",
		"misc/chariotconfig/minilock.png",
		"misc/chariotconfig/next_r.png",
		"misc/chariotconfig/point.png",
		"misc/chariotconfig/skill_gague.png",
		"misc/chariotconfig/skill_ironbuff.png",
		"misc/chariotconfig/skill_trees.png",
		"misc/chariotconfig/storehousebg.png",
		"misc/chariotconfig/tidy.png",
		"misc/chariotconfig/tough_learned_01.png",
		"misc/chariotconfig/tough_learned_02.png",
		"misc/chariotconfig/tough_learned_03.png",
		"misc/chariotconfig/tough_learned_04.png",
		"misc/chariotconfig/tough_learned_05.png",
		"misc/chariotconfig/tough_learned_06.png",
		"misc/chariotconfig/workshop_equips.png",
		"misc/chariotconfig/workshop_list_panel.png",
		"misc/chariotconfig/workshop_skill01.png",
		"misc/chariotconfig/workshop_skill02.png",
		"misc/chariotconfig/workshop_skill03.png",
		"misc/chariotconfig/ws_tab01.png",
		"misc/chariotconfig/ws_tab01_selected.png",
		"misc/chariotconfig/ws_tab02.png",
		"misc/chariotconfig/ws_tab02_selected.png",
		"misc/chariotconfig/ws_tab03.png",
		"misc/chariotconfig/ws_tab03_selected.png",
		"misc/chariotconfig/ws_tab04.png",
		"misc/chariotconfig/ws_tab04_selected.png",
		
		--misc/chest
		"misc/chest/astro_btnbg.png",
		"misc/chest/bg_9s_2.png",
		"misc/chest/bg_ng_attr.png",
		"misc/chest/bg_ng_graygray.png",
		"misc/chest/bg_ng_graywhite.png",
		"misc/chest/bg_ng_grayyellow_light.png",
		"misc/chest/bottom9g.png",
		"misc/chest/bottom9s.png",
		"misc/chest/brood_panel.png",
		"misc/chest/brood_panel_title.png",
		"misc/chest/btn_close_1.png",
		"misc/chest/btn_title_h.png",
		"misc/chest/btn_title_n.png",
		"misc/chest/button_blue.png",
		"misc/chest/button_green_small.png",
		"misc/chest/button_red.png",
		"misc/chest/button_yellow_small.png",
		"misc/chest/chatbubble_battle.png",
		"misc/chest/chatbubble_l.png",
		"misc/chest/chatbubble_r.png",
		"misc/chest/chatbubble_redpacket_empty.png",
		"misc/chest/chatbubble_redpacket.png",
		"misc/chest/chatsend.png",
		"misc/chest/chest_01.png",
		"misc/chest/chest_02.png",
		"misc/chest/chest_03.png",
		"misc/chest/chest_04.png",
		"misc/chest/chest_05.png",
		"misc/chest/chest_bg.png",
		"misc/chest/chest_img_bg2.png",
		"misc/chest/chest_img_bg3.png",
		"misc/chest/chest_img_bg4.png",
		"misc/chest/chest_img_rd_center.png",
		"misc/chest/debris_10.png",
		"misc/chest/debris_50.png",
		"misc/chest/dragon_exit_button.png",
		"misc/chest/dragon_exit_button2.png",
		"misc/chest/dragon_maptab.png",
		"misc/chest/dragon_maptab_selected.png",
		"misc/chest/dragon_panel.png",
		"misc/chest/dragon_start_game.png",
		"misc/chest/Effect_bx1.png",
		"misc/chest/Effect_bx2.png",
		"misc/chest/Effect_bx3.png",
		"misc/chest/Effect_bx4.png",
		"misc/chest/green_point1.png",
		"misc/chest/green_point2.png",
		"misc/chest/green_point3.png",
		"misc/chest/icon_chat_dragon.png",
		"misc/chest/itembtn.png",
		"misc/chest/itembtn2.png",
		"misc/chest/itemtip.png",
		"misc/chest/jdd1.png",
		"misc/chest/jdt1.png",
		"misc/chest/jdt2.png",
		"misc/chest/outpost_panel_2.png",
		"misc/chest/outpost_panel_addones.png",
		"misc/chest/outpost_panel_title.png",
		"misc/chest/purchase_border.png",
		"misc/chest/pvp_panel_3.png",
		"misc/chest/pvp_panel_diff_selected.png",
		"misc/chest/pvp_panel_diff1.png",
		"misc/chest/pvp_panel_diff2.png",
		"misc/chest/pvp_panel_diff3.png",
		"misc/chest/pvp_panel_diff4.png",
		"misc/chest/pvp_panel_title.png",
		"misc/chest/redpacket.png",
		"misc/chest/redpacket_bg.png",
		"misc/chest/redpacket_close.png",
		"misc/chest/redpacket_cover.png",
		"misc/chest/redpacket_cover_empty.png",
		"misc/chest/redpacket_detail_bg.png",
		"misc/chest/redpacket_open.png",
		"misc/chest/redpacket_open_big.png",
		"misc/chest/Sprite_Light_Green.png",
		"misc/chest/Sprite_Shine.png",
		"misc/chest/Sprite_Text.png",
		"misc/chest/star_yellow.png",
		"misc/chest/task_s9.png",
		"misc/chest/tutorial_arrow_right.png",
		
		--misc/continuouskilling
		"misc/continuouskilling/blood1.png",
		"misc/continuouskilling/blood2.png",
		"misc/continuouskilling/blood3.png",
		"misc/continuouskilling/blood4.png",
		"misc/continuouskilling/continuouskilling.png",
		"misc/continuouskilling/kill.png",
		
		--misc/gameover
		"misc/gameover/icon_exp.png",
		"misc/gameover/icon_gold.png",
		"misc/gameover/icon_man.png",
		"misc/gameover/icon_time.png",
		"misc/gameover/star_dark.png",
		"misc/gameover/star_light.png",
		
		--misc/guidepicture
		"misc/guidepicture/controlguide.png",
		"misc/guidepicture/controlguide_en.png",
		
		--misc/gopherboom
		"misc/gopherboom/bar.png",
		"misc/gopherboom/gopher1.png",
		"misc/gopherboom/gopher2.png",
		"misc/gopherboom/gopher3.png",
		"misc/gopherboom/gopher4.png",
		"misc/gopherboom/gou.png",
		
		--misc/guidepicture
		"misc/guidepicture/controlguide.png",
		"misc/guidepicture/controlguide_en.png",
		
		--misc/hpbar
		"misc/hpbar/boss_hp.png",
		"misc/hpbar/boss_hp_back.png",
		"misc/hpbar/hpbar_back.png",
		"misc/hpbar/hpbar_green.png",
		"misc/hpbar/hpbar_green_right.png",
		"misc/hpbar/hpbar_red.png",
		"misc/hpbar/hpbar_red_right.png",
		"misc/hpbar/hpbar_yellow.png",
		"misc/hpbar/hpbar_yellow_right.png",
		
		--misc/selectmap
		"misc/selectmap/circlebg.png",
		"misc/selectmap/lock.png",
		"misc/selectmap/star.png",
		"misc/selectmap/unlock.png",
		
		--misc/share
		"misc/share/bg_btn_share.png",
		"misc/share/qrcode.png",
		"misc/share/sharebtn.png",
		"misc/share/sharetacticsbg12029.png",
		"misc/share/sharetacticstitle12029.png",
		"misc/share/sharetankskin01.jpg",
		"misc/share/sharetankskin02.jpg",
		"misc/share/sharetankskin03.jpg",
		"misc/share/sharetankskin04.jpg",
		
		--misc/skillup
		"misc/skillup/addtimes.png",
		"misc/skillup/arrow_down.png",
		"misc/skillup/back.png",
		"misc/skillup/background.png",
		"misc/skillup/btn_close.png",
		"misc/skillup/btn_levelup.png",
		"misc/skillup/btnicon_change.png",
		"misc/skillup/btnicon_info.png",
		"misc/skillup/btnicon_unlock.png",
		"misc/skillup/btnicon_upgrade.png",
		"misc/skillup/build.png",
		"misc/skillup/build_2.png",
		"misc/skillup/exp.png",
		"misc/skillup/expbar.png",
		"misc/skillup/expbar_bg.png",
		"misc/skillup/gold.png",
		"misc/skillup/goldnum_bg.png",
		"misc/skillup/keshi.png",
		"misc/skillup/line.png",
		"misc/skillup/lock.png",
		"misc/skillup/msgbox.png",
		"misc/skillup/msgbox4.png",
		"misc/skillup/msgbox6.png",
		"misc/skillup/mu_coin.png",
		"misc/skillup/mu_coin_world.png",
		"misc/skillup/mu_coin_world_l.png",
		"misc/skillup/mu_coin_world_s.png",
		"misc/skillup/select.png",
		"misc/skillup/select2.png",
		"misc/skillup/select_l.png",
		"misc/skillup/sepline.png",
		"misc/skillup/skillbg.png",
		"misc/skillup/skillpoint.png",
		"misc/skillup/skillpoint_bg.png",
		"misc/skillup/talk.png",
		"misc/skillup/talk_2.png",
		"misc/skillup/tap.png",
		"misc/skillup/tick.png",
		"misc/skillup/upgrade.png",
		"misc/skillup/upgrade_arrow.png",
		"misc/skillup/upgrade_effect.png",
		
		--misc/tactics
		"misc/tactics/Slot.png",
		"misc/tactics/SlotBG.png",
		"misc/tactics/slot_green.png",
		"misc/tactics/slot_purple.png",
		"misc/tactics/slot_red.png",
		"misc/tactics/slot_yellow.png",
		"misc/tactics/tac01.png",
		"misc/tactics/tac02.png",
		"misc/tactics/tac03.png",
		"misc/tactics/tac04.png",
		"misc/tactics/tac05.png",
		"misc/tactics/tac06.png",
		"misc/tactics/tac07.png",
		"misc/tactics/tac08.png",
		"misc/tactics/tac09.png",
		"misc/tactics/tac10.png",
		"misc/tactics/tac11.png",
		"misc/tactics/tac12.png",
		"misc/tactics/tac13.png",
		"misc/tactics/tac14.png",
		
		--misc/task
		"misc/task/achievement_panel.png",
		"misc/task/activity_icon_01.png",
		"misc/task/activity_icon_02.png",
		"misc/task/activity_icon_03.png",
		"misc/task/checkin_panel.png",
		"misc/task/debris_multy.png",
		"misc/task/event_frame.png",
		"misc/task/event_selected.png",
		"misc/task/events_panel.png",
		"misc/task/fail_circle.png",
		"misc/task/gamecoin01.png",
		"misc/task/gas_panel.png",
		"misc/task/gas_progress.png",
		"misc/task/gas_progress_bg.png",
		"misc/task/gas_trade.png",
		"misc/task/ironbuf_button.png",
		"misc/task/ironbuf_panel.png",
		"misc/task/ironbuf_refresh.png",
		"misc/task/ironbuf_tray_01.png",
		"misc/task/ironbuf_tray_02.png",
		"misc/task/ironbuf_tray_03.png",
		"misc/task/ironbuf_tray_04.png",
		"misc/task/ironbuf_tray_01_2.png",
		"misc/task/ironbuf_tray_02_2.png",
		"misc/task/ironbuf_tray_03_2.png",
		"misc/task/ironbuf_tray_04_2.png",
		"misc/task/mail_panel.png",
		"misc/task/mail_type05.png",
		"misc/task/mail_type06.png",
		"misc/task/mail_type07.png",
		"misc/task/mail_type08.png",
		"misc/task/medal_mini.png",
		"misc/task/mission_bar.png",
		"misc/task/mission_bar02.png",
		"misc/task/mission_go.png",
		"misc/task/mission_medal_01.png",
		"misc/task/mission_medal_02.png",
		"misc/task/mission_medal_03.png",
		"misc/task/mission_medal_04.png",
		"misc/task/mission_medal_05.png",
		"misc/task/mission_panel.png",
		"misc/task/mission_progress.png",
		"misc/task/mission_progress_01.png",
		"misc/task/mission_progress_02.png",
		"misc/task/mission_progress_03.png",
		"misc/task/mission_progress2.png",
		"misc/task/mission_tick.png",
		"misc/task/randommap_maze_lift.png",
		"misc/task/randommap_maze_ranking.png",
		"misc/task/randommap_space_lift.png",
		"misc/task/stage_lock.png",
		"misc/task/tab_checkin_01.png",
		"misc/task/tab_checkin_02.png",
		"misc/task/tab_events_01.png",
		"misc/task/tab_events_02.png",
		"misc/task/tab_events_03.png",
		"misc/task/tab_events_04.png",
		"misc/task/tab_frame_selected.png",
		"misc/task/tab_mail_01.png",
		"misc/task/tab_mail_02.png",
		"misc/task/tab_mission_01.png",
		"misc/task/tab_mission_02.png",
		"misc/task/task_000.png",
		"misc/task/task_001.png",
		"misc/task/task_002.png",
		"misc/task/task_003.png",
		"misc/task/task_004.png",
		"misc/task/task_005.png",
		"misc/task/task_006.png",
		"misc/task/task_007.png",
		"misc/task/task_008.png",
		"misc/task/task_009.png",
		"misc/task/task_010.png",
		"misc/task/task_011.png",
		"misc/task/task_012.png",
		"misc/task/task_013.png",
		"misc/task/task_014.png",
		"misc/task/task_015.png",
		"misc/task/task_016.png",
		"misc/task/task_017.png",
		"misc/task/task_018.png",
		"misc/task/task_019.png",
		"misc/task/task_stone.png",
		"misc/task/TaskSelectBG.png",
		"misc/task/tili.png",
		"misc/task/tili_gas_barrel.png",
		"misc/task/tili_oil.png",
		"misc/task/waiting.png",
		
		--misc/tempbag
		"misc/tempbag/arrow.png",
		"misc/tempbag/bagborder.png",
		"misc/tempbag/blackbg.png",
		"misc/tempbag/close.png",
		"misc/tempbag/iconbag.png",
		"misc/tempbag/invertedtrg.png",
		"misc/tempbag/square.png",
		"misc/tempbag/storehouse.png",
		
		--misc/totalsettlement
		"misc/totalsettlement/cup.png",
		"misc/totalsettlement/process.png",
		"misc/totalsettlement/process_light.png",
		
		--misc/treasure
		"misc/treasure/background.jpg",
		"misc/treasure/cangbaotu_high.png",
		"misc/treasure/cangbaotu_normal.png",
		"misc/treasure/giftcard_bg.png",
		"misc/treasure/lb.png",
		"misc/treasure/line.png",
		"misc/treasure/medal_background_mask.png",
		"misc/treasure/medal_center.png",
		"misc/treasure/medal_content.png",
		"misc/treasure/medal_content2.png",
		"misc/treasure/medal_desk2.png",
		"misc/treasure/medal_deskcloth_mask.png",
		"misc/treasure/medal_jiangbei.png",
		"misc/treasure/medal_xing.png",
		"misc/treasure/medal_xingbian.png",
		"misc/treasure/pedestal.png",
		"misc/treasure/pedestal_beam.png",
		"misc/treasure/pedestal_panel.png",
		"misc/treasure/treasure001-01.png",
		"misc/treasure/treasure001-02.png",
		"misc/treasure/treasure002-01.png",
		"misc/treasure/treasure002-02.png",
		"misc/treasure/treasure003-01.png",
		"misc/treasure/treasure003-02.png",
		"misc/treasure/treasure004-01.png",
		"misc/treasure/treasure004-02.png",
		"misc/treasure/treasure005-01.png",
		"misc/treasure/treasure005-02.png",
		"misc/treasure/treasure006-01.png",
		"misc/treasure/treasure006-02.png",
		"misc/treasure/treasure007-01.png",
		"misc/treasure/treasure007-02.png",
		"misc/treasure/treasure008-01.png",
		"misc/treasure/treasure008-02.png",
		"misc/treasure/treasure009-01.png",
		"misc/treasure/treasure009-02.png",
		"misc/treasure/treasure001.png",
		"misc/treasure/treasure002.png",
		"misc/treasure/treasure003.png",
		"misc/treasure/treasure004.png",
		"misc/treasure/treasure005.png",
		"misc/treasure/treasure006.png",
		"misc/treasure/treasure007.png",
		"misc/treasure/treasure008.png",
		"misc/treasure/treasure009.png",
		"misc/treasure/tutorial_circle_big.png",
		
		--misc/ugc
		"misc/ugc/ugc_addbtn.png",
		"misc/ugc/ugc_background.png",
		"misc/ugc/ugc_border_select.png",
		"misc/ugc/ugc_border1.png",
		"misc/ugc/ugc_border2.png",
		"misc/ugc/ugc_gobtn.png",
		"misc/ugc/ugc_gobtn3.png",
		"misc/ugc/ugc_scroll1.png",
		"misc/ugc/ugc_scroll2.png",
		"misc/ugc/ugc_scroll3.png",
		"misc/ugc/ugc_title.png",
		"misc/ugc/ugc_wall1.png",
		"misc/ugc/ugc_wall2.png",
		"misc/ugc/ugc_wall3.png",
		
		--panel
		"panel/9sprite_bg_1.png",
		"panel/icon_privacy1.png",
		"panel/icon_privacy2.png",
		"panel/icon_privacy3.png",
		"panel/card_back.png",
		"panel/panel_part_00.png",
		"panel/panel_part_chat.png",
		
		--panel/update
		"panel/update/00001.png",
		"panel/update/00002.png",
		"panel/update/00003.png",
		"panel/update/00004.png",
		"panel/update/00005.png",
		"panel/update/00006.png",
		"panel/update/00007.png",
		"panel/update/00008.png",
		"panel/update/00009.png",
		"panel/update/00010.png",
		"panel/update/00011.png",
		"panel/update/00012.png",
		"panel/update/00013.png",
		"panel/update/00014.png",
		"panel/update/00015.png",
		"panel/update/00016.png",
		"panel/update/00017.png",
		"panel/update/00018.png",
		"panel/update/00019.png",
		"panel/update/00020.png",
	}
	
	--单位模型ccz表
	local pngModelFileNameList =
	{
		--模型文件ccz
		"unit/airship.png",
		"unit/airship2.png",
		"unit/airship2shadow.png",
		--"unit/airship3.png", --有死亡动作的不删除
		--"unit/airship3shadow.png", --有死亡动作的不删除
		"unit/airshipgun.pvr.ccz",
		--"unit/alien_queen.png", --有死亡动作的不删除
		"unit/arm_world.png",
		"unit/ball_robot.png",
		"unit/binggongchang_battle.pvr.ccz",
		"unit/binggongchang_world.pvr.ccz",
		"unit/bio_spider.png",
		"unit/blackdragon_world.png",
		"unit/bluecarrier_battle.png",
		"unit/bluecarrier_world.png",
		"unit/bossgun1.png",
		"unit/bossgun2.png",
		"unit/brain.png",
		"unit/daodan.pvr.ccz",
		"unit/dragon.png",
		"unit/dragon_stand.png",
		"unit/egg_battle.png",
		"unit/egg_world.png",
		"unit/egg2_battle.png",
		"unit/egg2_world.png",
		"unit/eve_battle.png",
		"unit/eve_world.png",
		"unit/fag.png",
		"unit/game.png",
		"unit/gaosheta_battle.png",
		"unit/gaosheta_grow_world_world.png",
		--"unit/gazer_battle.png", --有死亡动作的不删除
		--"unit/gazer_world.png", --有死亡动作的不删除
		"unit/grenade_battle.pvr.ccz",
		"unit/grenade_world.pvr.ccz",
		"unit/hydralisk.png",
		"unit/ironman_world.png",
		"unit/jeep_green.png",
		"unit/jeep_spider_world.png",
		"unit/jeep_spider2_world.png",
		"unit/jeep_tank.png",
		"unit/jeep_tank2.png",
		"unit/jeep3.png",
		"unit/jeep3_dead.png",
		"unit/jeep4.png",
		"unit/jeepenergy.pvr.ccz",
		"unit/jeepgun.png",
		"unit/jeepgun_a.png",
		"unit/jeepgun_b.png",
		"unit/jeepgun_spider2.png",
		"unit/jeepgun_tank.png",
		"unit/jeepgun1.png",
		"unit/jeepgun1_a.png",
		"unit/jeepgun2.png",
		"unit/jeepgun2_a.png",
		"unit/jeepgun3.png",
		"unit/jeepgun3_a.png",
		"unit/jeepgun3_b.png",
		"unit/jeepgun4.png",
		"unit/jeepgun5.png",
		"unit/jeepgun6.png",
		"unit/jeepgun7.png",
		"unit/jeepgun8.png",
		"unit/jeepgun8_a.png",
		"unit/jeepgun8_b.png",
		"unit/jeepgun9.png",
		"unit/jeepgun9_a.png",
		"unit/jeepgun9_b.png",
		"unit/jeepgun10.png",
		"unit/jeepgun10_a.png",
		"unit/jeepgun10_b.png",
		"unit/jeepgun11.png",
		"unit/jeepgun11_a.png",
		"unit/jeepgun12.png",
		"unit/jeepgun12_a.png",
		"unit/jeepgun12_b.png",
		"unit/jeepgun13.png",
		"unit/jeepgun13_a.png",
		"unit/jeepgun13_b.png",
		"unit/jeepgun14.png",
		"unit/jeepgun15.png",
		"unit/jeeplamp.pvr.ccz",
		"unit/jeeplamplight.pvr.ccz",
		"unit/jeeplamplight2.pvr.ccz",
		"unit/jeepshadow.pvr.ccz",
		"unit/jeepthunder.pvr.ccz",
		"unit/jeepwheel.pvr.ccz",
		"unit/jeepwheel1.pvr.ccz",
		"unit/jeepwheel2.pvr.ccz",
		"unit/jiguangta_battle.png",
		"unit/jiguangta_grow_world.png",
		"unit/jiguangta_world.png",
		"unit/jiqiangta_battle.png",
		"unit/jiqiangta_grow_world_world.png",
		"unit/machine_gun_battle.png",
		"unit/machine_gun_world.png",
		--"unit/metal_balloon_battle.png", --有死亡动作的不删除
		--"unit/metal_balloon_world.png", --有死亡动作的不删除
		"unit/metal_balloon2_battle.png",
		"unit/metal_balloon2_world.png",
		--"unit/metal_beast.png", --有死亡动作的不删除
		"unit/metal_brain.png",
		--"unit/metal_spider_battle.png", --有死亡动作的不删除
		--"unit/metal_spider_world.png", --有死亡动作的不删除
		--"unit/metal_spider2_battle.png", --有死亡动作的不删除
		--"unit/metal_spider2_world.png", --有死亡动作的不删除
		--"unit/monster_battle.png", --有死亡动作的不删除
		--"unit/monster_world.png", --有死亡动作的不删除
		"unit/mpeb.png",
		"unit/mpew.png",
		"unit/nest_world.png",
		"unit/oldwomen_battle.pvr.ccz",
		"unit/oldwomen_world.pvr.ccz",
		"unit/paotaita_battle.png",
		"unit/paotaita_grow_world_world.png",
		"unit/plate_battle.png",
		"unit/plate_world.png",
		"unit/ramiel_battle.png",
		"unit/ramiel_world.png",
		"unit/robot.png",
		"unit/rpgzombie.png",
		"unit/scientist_battle.png",
		"unit/scientist_world.png",
		"unit/shejita_battle.png",
		"unit/shejita_grow_world_world.png",
		--"unit/shield_robot.png", --有死亡动作的不删除
		--"unit/sky_fortress_battle.png", --有死亡动作的不删除
		--"unit/sky_fortress_world.png", --有死亡动作的不删除
		"unit/soldier_battle.png",
		"unit/soldier_world.png",
		"unit/soldier2_battle.png",
		"unit/soldier2_world.png",
		"unit/soldier3_battle.png",
		"unit/soldier3_world.png",
		"unit/spaceship.png",
		"unit/spider.png",
		"unit/super_robot_battle.png",
		"unit/super_robot_world.png",
		"unit/superairship_battle.png",
		"unit/superairship_world.png",
		"unit/taizi_world.png",
		"unit/tank_battle.png",
		"unit/tank_world.png",
		"unit/tankweapon_battle.png",
		"unit/tankweapon_world.png",
		"unit/tdpaota3_battle.pvr.ccz",
		"unit/tdpaota3_world.pvr.ccz",
		"unit/techcenter_world.png",
		"unit/tentacle.png",
		"unit/tie.png",
		"unit/train01_battle.png",
		"unit/train02_battle.png",
		"unit/truck.png",
		"unit/ugly_spider.png",
		"unit/ultimaairship_battle.png",
		"unit/ultimaairship_world.png",
		"unit/walle.png",
		"unit/warrior.png",
		"unit/yoda_battle.png",
		"unit/yoda_world.png",
		--"unit/zhangyuguai_battle.png", --有死亡动作的不删除
		"unit/zhangyuguai_small.png",
		--"unit/zhangyuguai_world.png", --有死亡动作的不删除
	}
	
	--plist表
	local plistFileNameList =
	{
		--effect
		"effect/acid01.plist",
		"effect/arrow_04.plist",
		"effect/aura04.plist",
		"effect/automat.plist",
		"effect/bb_energy.plist",
		"effect/bb_fire.plist",
		"effect/behit_jiguanpao_b.plist",
		"effect/behit_tegong_c.plist",
		"effect/blackfog.plist",
		"effect/blackfog1.plist",
		"effect/bolang.plist",
		"effect/boss_laser.plist",
		"effect/burst01.plist",
		"effect/blink.plist",
		"effect/circlebutton.plist",
		"effect/daoguang02.plist",
		"effect/downstone_mm.plist",
		"effect/duest_mm.plist",
		"effect/dupao.plist",
		"effect/dust2.plist",
		"effect/dusty.plist",
		"effect/fire02.plist",
		"effect/fire06.plist",
		"effect/flycannon_huojian.plist",
		"effect/force_shield.plist",
		"effect/ground02.plist",
		"effect/heal01.plist",
		"effect/mana01.plist",
		"effect/metal_balloon_shadow.plist",
		"effect/myztx.plist",
		"effect/net_sky01.plist",
		"effect/net_sky02.plist",
		"effect/net_sky03.plist",
		"effect/net_sky04.plist",
		"effect/nuclear.plist",
		"effect/openchest.plist",
		"effect/plate.plist",
		"effect/pojiadanbaozha.plist",
		"effect/roar01.plist",
		"effect/scan.plist",
		"effect/shield01.plist",
		"effect/smoke01.plist",
		"effect/smoke03.plist",
		"effect/smoke04.plist",
		"effect/smoke05.plist",
		"effect/smoke06.plist",
		"effect/spark.plist",
		"effect/spark2.plist",
		"effect/spark3.plist",
		"effect/start1.plist",
		"effect/start2.plist",
		"effect/tactic.plist",
		"effect/testbump_a.plist",
		"effect/thunder.plist",
		"effect/thunder2.plist",
		"effect/thunder3.plist",
		"effect/wushang1-1.plist",
		"effect/wushuang1.plist",
		"effect/xuanwo.plist",
		"effect/zidan.plist",
		"effect/chip.plist",
		
		--misc
		"misc/psword.plist",
		
		--misc/treasure
		"misc/treasure/treasure001.plist",
		"misc/treasure/treasure002.plist",
		"misc/treasure/treasure003.plist",
		"misc/treasure/treasure004.plist",
		"misc/treasure/treasure005.plist",
		"misc/treasure/treasure006.plist",
		"misc/treasure/treasure007.plist",
		"misc/treasure/treasure008.plist",
		"misc/treasure/treasure009.plist",
	}
	
	--单位模型plist表
	local plistModelFileNameList =
	{
		--模型文件plist
		"unit/airship.plist",
		"unit/airship2.plist",
		"unit/airship2shadow.plist",
		--"unit/airship3.plist", --有死亡动作的不删除
		--"unit/airship3shadow.plist", --有死亡动作的不删除
		"unit/airshipgun.plist",
		--"unit/alien_queen.plist", --有死亡动作的不删除
		"unit/arm_world.plist",
		"unit/ball_robot.plist",
		"unit/binggongchang_battle.plist",
		"unit/binggongchang_world.plist",
		"unit/bio_spider.plist",
		"unit/blackdragon_world.plist",
		"unit/bluecarrier_battle.plist",
		"unit/bluecarrier_world.plist",
		"unit/bossgun1.plist",
		"unit/bossgun2.plist",
		"unit/brain.plist",
		"unit/daodan.plist",
		"unit/dragon.plist",
		"unit/dragon_stand.plist",
		"unit/egg_battle.plist",
		"unit/egg_world.plist",
		"unit/egg2_battle.plist",
		"unit/egg2_world.plist",
		"unit/eve_battle.plist",
		"unit/eve_world.plist",
		"unit/fag.plist",
		"unit/game.plist",
		"unit/gaosheta_battle.plist",
		"unit/gaosheta_grow_world_world.plist",
		--"unit/gazer_battle.plist", --有死亡动作的不删除
		--"unit/gazer_world.plist", --有死亡动作的不删除
		"unit/grenade_battle.plist",
		"unit/grenade_world.plist",
		"unit/hydralisk.plist",
		"unit/ironman_world.plist",
		"unit/jeep_green.plist",
		"unit/jeep_spider_world.plist",
		"unit/jeep_spider2_world.plist",
		"unit/jeep_tank.plist",
		"unit/jeep_tank2.plist",
		"unit/jeep3.plist",
		"unit/jeep3_dead.plist",
		"unit/jeep4.plist",
		"unit/jeepenergy.plist",
		"unit/jeepgun.plist",
		"unit/jeepgun_a.plist",
		"unit/jeepgun_b.plist",
		"unit/jeepgun_spider2.plist",
		"unit/jeepgun_tank.plist",
		"unit/jeepgun1.plist",
		"unit/jeepgun1_a.plist",
		"unit/jeepgun2.plist",
		"unit/jeepgun2_a.plist",
		"unit/jeepgun3.plist",
		"unit/jeepgun3_a.plist",
		"unit/jeepgun3_b.plist",
		"unit/jeepgun4.plist",
		"unit/jeepgun5.plist",
		"unit/jeepgun6.plist",
		"unit/jeepgun7.plist",
		"unit/jeepgun8.plist",
		"unit/jeepgun8_a.plist",
		"unit/jeepgun8_b.plist",
		"unit/jeepgun9.plist",
		"unit/jeepgun9_a.plist",
		"unit/jeepgun9_b.plist",
		"unit/jeepgun10.plist",
		"unit/jeepgun10_a.plist",
		"unit/jeepgun10_b.plist",
		"unit/jeepgun11.plist",
		"unit/jeepgun11_a.plist",
		"unit/jeepgun12.plist",
		"unit/jeepgun12_a.plist",
		"unit/jeepgun12_b.plist",
		"unit/jeepgun13.plist",
		"unit/jeepgun13_a.plist",
		"unit/jeepgun13_b.plist",
		"unit/jeepgun14.plist",
		"unit/jeepgun15.plist",
		"unit/jeeplamp.plist",
		"unit/jeeplamplight.plist",
		"unit/jeeplamplight2.plist",
		"unit/jeepshadow.plist",
		"unit/jeepthunder.plist",
		"unit/jeepwheel.plist",
		"unit/jeepwheel1.plist",
		"unit/jeepwheel2.plist",
		"unit/jiguangta_battle.plist",
		"unit/jiguangta_grow_world.plist",
		"unit/jiguangta_world.plist",
		"unit/jiqiangta_battle.plist",
		"unit/jiqiangta_grow_world_world.plist",
		"unit/machine_gun_battle.plist",
		"unit/machine_gun_world.plist",
		--"unit/metal_balloon_battle.plist", --有死亡动作的不删除
		--"unit/metal_balloon_world.plist", --有死亡动作的不删除
		"unit/metal_balloon2_battle.plist",
		"unit/metal_balloon2_world.plist",
		--"unit/metal_beast.plist", --有死亡动作的不删除
		"unit/metal_brain.plist",
		--"unit/metal_spider_battle.plist", --有死亡动作的不删除
		--"unit/metal_spider_world.plist", --有死亡动作的不删除
		--"unit/metal_spider2_battle.plist", --有死亡动作的不删除
		--"unit/metal_spider2_world.plist", --有死亡动作的不删除
		--"unit/monster_battle.plist", --有死亡动作的不删除
		--"unit/monster_world.plist", --有死亡动作的不删除
		"unit/mpeb.plist",
		"unit/mpew.plist",
		"unit/nest_world.plist",
		"unit/oldwomen_battle.plist",
		"unit/oldwomen_world.plist",
		"unit/paotaita_battle.plist",
		"unit/paotaita_grow_world_world.plist",
		"unit/plate_battle.plist",
		"unit/plate_world.plist",
		"unit/ramiel_battle.plist",
		"unit/ramiel_world.plist",
		"unit/robot.plist",
		"unit/rpgzombie.plist",
		"unit/scientist_battle.plist",
		"unit/scientist_world.plist",
		"unit/shejita_battle.plist",
		"unit/shejita_grow_world_world.plist",
		--"unit/shield_robot.plist", --有死亡动作的不删除
		--"unit/sky_fortress_battle.plist", --有死亡动作的不删除
		--"unit/sky_fortress_world.plist", --有死亡动作的不删除
		"unit/soldier_battle.plist",
		"unit/soldier_world.plist",
		"unit/soldier2_battle.plist",
		"unit/soldier2_world.plist",
		"unit/soldier3_battle.plist",
		"unit/soldier3_world.plist",
		"unit/spaceship.plist",
		"unit/spider.plist",
		"unit/super_robot_battle.plist",
		"unit/super_robot_world.plist",
		"unit/superairship_battle.plist",
		"unit/superairship_world.plist",
		"unit/taizi_world.plist",
		"unit/tank_battle.plist",
		"unit/tank_world.plist",
		"unit/tankweapon_battle.plist",
		"unit/tankweapon_world.plist",
		"unit/tdpaota3_battle.plist",
		"unit/tdpaota3_world.plist",
		"unit/techcenter_world.plist",
		"unit/tentacle.plist",
		"unit/tie.plist",
		"unit/train01_battle.plist",
		"unit/train02_battle.plist",
		"unit/truck.plist",
		"unit/ugly_spider.plist",
		"unit/ultimaairship_battle.plist",
		"unit/ultimaairship_world.plist",
		"unit/walle.plist",
		"unit/warrior.plist",
		"unit/yoda_battle.plist",
		"unit/yoda_world.plist",
		--"unit/zhangyuguai_battle.plist", --有死亡动作的不删除
		"unit/zhangyuguai_small.plist",
		--"unit/zhangyuguai_world.plist", --有死亡动作的不删除
	}
	
	--xlobj表
	local xlobjFileNameList =
	{
		--xlobj
		"block_floor.png",
		"block_floor01.png",
		"block_floor02.png",
		"block_floor03.png",
		"block_floor04.png",
		"boundary.png",
		"bunker.png",
		"bunker2.png",
		"cheku.png",
		"cliff_infect01.png",
		"cliff_infect02.png",
		"cliff01.png",
		"cliff02.png",
		"cliff03.png",
		"cliff04.png",
		"cliff05.png",
		"cliff06.png",
		"cliff07.png",
		"cliff08.png",
		"cliff09.png",
		"cliff10.png",
		"cliff11.png",
		"cliff12.png",
		"cliff13.png",
		"cliff14.png",
		"cliff15.png",
		"cloud_64_48.png",
		"cloud_64_48_2.png",
		"cloud_128_96.png",
		"container01.png",
		"container01_a.png",
		"container01_b.png",
		"container01_c.png",
		"container01_d1.png",
		"container01_d2.png",
		"container01_d3.png",
		"container02.png",
		"container02_a.png",
		"container02_b.png",
		"container02_c.png",
		"container02_d1.png",
		"container02_d2.png",
		"container02_d3.png",
		"container03.png",
		"container03_a.png",
		"container03_b.png",
		"container03_c.png",
		"container03_d1.png",
		"container03_d2.png",
		"container04.png",
		"container04_a.png",
		"container04_b.png",
		"container04_c.png",
		"container04_d1.png",
		"container04_d2.png",
		"container04_d3.png",
		"creep_01.png",
		"creep_02.png",
		"creep_03.png",
		"creep_04.png",
		"creep_net.png",
		"crystal.png",
		"crystal2.png",
		"crystal3.png",
		"ditai1.png",
		"ditai2.png",
		"ditai3.png",
		"entrance.png",
		"fire_hole.png",
		"floor_deck.png",
		"floor_ice.png",
		"floor_ice2.png",
		"floor_ice3.png",
		"floor_ice4.png",
		"floor_ice5.png",
		"floor_ice6.png",
		"floor_ice7.png",
		"floor_ice8.png",
		"floor_ice9.png",
		"floor_infect.png",
		"floor_infect2.png",
		"floor_infect3.png",
		"floor_infect4.png",
		"floor_stone.png",
		"floor_stone2.png",
		"floor_stone3.png",
		"floor_stone4.png",
		"garage_01.png",
		"garage_02.png",
		"garage_03.png",
		"garage_04.png",
		"gas_barrel.png",
		"hole01.png",
		"hole02.png",
		"hole03.png",
		"hole04.png",
		"hole05.png",
		"jiantou1.png",
		"jiantou2.png",
		"jiantou3.png",
		"jiantou4.png",
		"jiantou5.png",
		"jiantou6.png",
		"jiantou7.png",
		"jiantou8.png",
		"jiantou9.png",
		"jiantou10.png",
		"jiantou11.png",
		"jiantou12.png",
		"jiantou13.png",
		"jiantou14.png",
		"jiantou15.png",
		"jidicheku.png",
		"jidicheku2.png",
		"map_editor.png",
		"maze1_01.png",
		"maze1_02.png",
		"maze1_03.png",
		"maze1_04.png",
		"maze1_05.png",
		"maze1_06.png",
		"maze1_07.png",
		"maze1_08.png",
		"maze1_09.png",
		"maze1_10.png",
		"maze1_11.png",
		"maze1_12.png",
		"maze1_13.png",
		"maze1_14.png",
		"maze1_15.png",
		"maze1_16.png",
		"maze4_01.png",
		"maze4_02.png",
		"maze4_03.png",
		"maze4_04.png",
		"maze4_05.png",
		"maze4_06.png",
		"maze4_07.png",
		"maze4_08.png",
		"maze4_09.png",
		"maze4_10.png",
		"maze4_11.png",
		"maze4_12.png",
		"maze4_13.png",
		"maze4_14.png",
		"maze4_15.png",
		"maze4_16.png",
		"men7.png",
		"men8.png",
		"men10.png",
		"men11.png",
		"mine_crystal01.png",
		"mine_crystal02.png",
		"mine_crystal03.png",
		"mine_stone01.png",
		"mine_stone02.png",
		"mine_stone03.png",
		"mine_stone04.png",
		"nest.png",
		"nest2.png",
		"nuclear_barrel.png",
		"oildrum.png",
		"pet.png",
		"prison_wall_x_01.png",
		"prison_wall_x_02.png",
		"prison_wall_x_03.png",
		"prison_wall01.png",
		"prison_wall02.png",
		"prison_wall03.png",
		"prison_x.png",
		"prison01.png",
		"prison02.png",
		"prison03.png",
		"prison04.png",
		"prison05.png",
		"rail01.png",
		"rail02.png",
		"rail03.png",
		"remains_01.png",
		"remains_02.png",
		"remains_03.png",
		"remains_04.png",
		"remains_05.png",
		"shop.png",
		"shop2.png",
		"shop3.png",
		"spaceship.png",
		"terrain_a_01.png",
		"terrain_a_02.png",
		"terrain_a_03.png",
		"terrain_a_04.png",
		"terrain_a_05.png",
		"terrain_b_01.png",
		"terrain_b_02.png",
		"terrain_b_03.png",
		"terrain_b_04.png",
		"terrain_b_05.png",
		"terrain_b_06.png",
		"terrain_b_07.png",
		"tower01.png",
		"tower02.png",
		"tower03.png",
		"tower04.png",
		"tower05.png",
		"track09_2.png",
		"track13_ex.png",
		"treasure01.png",
		"treasure02.png",
		"treasure03.png",
		"treasure04.png",
		"treasure05.png",
		"vg.png",
		"wall_game.png",
		"wall_screen.png",
		"wall01_new.png",
		"wall02_new.png",
		"wall03_new.png",
		"xlobjs.png",
	}
	
	--删除png
	for i = 1, #pngFileNameList, 1 do
		local pnFfileName = pngFileNameList[i]
		hResource.model:releasePngByKey(pnFfileName)
	end
	
	--删除plist
	for i = 1, #plistFileNameList, 1 do
		local plistFileName = plistFileNameList[i]
		hResource.model:releasePlistByKey(nil, plistFileName)
		xlReleaseResourceFromPList("data/image/" .. plistFileName)
	end
	
	--删除xlobj
	for i = 1, #xlobjFileNameList, 1 do
		local pnFfileName = xlobjFileNameList[i]
		hResource.model:releaseXLObjByKey(pnFfileName)
	end
	
	--删除xlobj plist
	local plistFileName_xlobj = "xlobjs.plist"
	hResource.model:releasePlistByKey(nil, plistFileName_xlobj)
	xlReleaseResourceFromPList("data/xlobj/" .. plistFileName_xlobj)
	
	--删除单位模型ccz文件和plist文件
	local world = hGlobal.WORLD.LastWorldMap
	local bEnableRemoved = false
	if (world == nil) then --当world不存在时，可以删除单位模型
		bEnableRemoved = true
	else
		local mapInfo = world.data.tdMapInfo
		--游戏结束或者已经暂停(结束)，可以删除单位模型
		if (mapInfo.mapState >= hVar.MAP_TD_STATE.PAUSE) then
			bEnableRemoved = true
		else
			local regionId = world.data.randommapIdx or 0
			if (regionId > 0) then
				print("randommapIdx=", world.data.randommapIdx)
				bEnableRemoved = true
			else
				local currentWave = mapInfo.wave
				print("currentWave=", currentWave)
				if (currentWave % 5 == 0) then --每5波清理一次
					bEnableRemoved = true
				end
			end
		end
	end
	print("清理英雄模型资源="..tostring(bEnableRemoved))
	if (bEnableRemoved) then
		--删除单位模型ccz
		for i = 1, #pngModelFileNameList, 1 do
			local pnFfileName = pngModelFileNameList[i]
			hResource.model:releasePngByKey(pnFfileName)
		end
		
		--删除单位模型plist
		for i = 1, #plistModelFileNameList, 1 do
			local plistFileName = plistModelFileNameList[i]
			hResource.model:releasePlistByKey(nil, plistFileName)
			xlReleaseResourceFromPList("data/image/" .. plistFileName)
		end
	end
	
	--删除吴国城镇遮罩图
	local texture = CCTextureCache:sharedTextureCache():textureForKey("data/map/town/tback_wu_water_mask.png")
	if texture then
		CCTextureCache:sharedTextureCache():removeTexture(texture)
		print("清空吴国城镇遮罩图！")
	end
	
	--删除tback_blackdragon_nest图
	local texture = CCTextureCache:sharedTextureCache():textureForKey("data/map/other/tback_blackdragon_nest.jpg")
	if texture then
		CCTextureCache:sharedTextureCache():removeTexture(texture)
		print("清空tback_blackdragon_nest图！")
	end
	
	--删除loading_en图
	local texture = CCTextureCache:sharedTextureCache():textureForKey("data/map/other/loading_en.jpg")
	if texture then
		CCTextureCache:sharedTextureCache():removeTexture(texture)
		print("清空loading_en图！")
	end
	
	--删除logintv图
	local texture = CCTextureCache:sharedTextureCache():textureForKey("data/map/other/logintv.png")
	if texture then
		CCTextureCache:sharedTextureCache():removeTexture(texture)
		print("清空logintv图！")
	end
	
	--删除logintv2图
	local texture = CCTextureCache:sharedTextureCache():textureForKey("data/map/other/logintv2.png")
	if texture then
		CCTextureCache:sharedTextureCache():removeTexture(texture)
		print("清空logintv2图！")
	end
	
	--删除英雄例会资源
	--hUI.SYSAutoReleaseUI:addModel("portrait",tabU.portrait)
	--hResource.model:releaseCache(hVar.TEMP_HANDLE_TYPE.UI_GRID_AUTO_RELEASE)
	local tRelease = {}
	local tPng = hUI.SYSAutoReleaseUI.png
	for i = 1, #tPng, 1 do
		local path = tPng[i]
		tRelease[path] = 1
	end
	hResource.model:releasePng(tRelease)
	hUI.SYSAutoReleaseUI.png = {idx = {}}
	
	--调用程序接口清理显存
	if xlRemoveUnusedTextures then
		xlRemoveUnusedTextures()
	end
	
	--回收lua内存
	local vm = collectgarbage("count")
	local vmM = vm / 1000 --兆
	if (vmM >= 168) then
		--collectgarbage() --geyachao: 查bug临时去掉，待恢复
		print("回收lua内存 collectgarbage()")
	end
end

--存储大菠萝的垮地图
LuaSaveDiaboData = function(oUnit)
	--bind_weapon = 0, --绑定的武器typeId
	--score = 0, --得分
	--deathcount = 0, --死亡次数
	--deathscore = 0, --第一次死亡的得分
	--tankbuffs = {}, --坦克的buff
	--tankweaponbuffs = {}, --坦克的武器buff
	--heros = {}, --坦克的英雄数据
	local diablodata = hGlobal.LocalPlayer.data.diablodata --大菠萝数据
	
	--依次遍历坦克身上的buff，存储tankbuffs
	local tt = oUnit.data["buffs"]
	if tt.index then
		for buff_key, n in pairs(tt.index) do
			if n and (n ~= 0) then
				local oID = tt[n]
				local oBuff = hClass.action:find(oID)
				if oBuff then --目标身上已有此buff
					local buffId = oBuff.data.skillId --buff的技能id
					local buffLv = oBuff.data.level --buff的等级
					local pasttime = oBuff.data.past --buff的经过时间
					local maxtime = oBuff.data.maxtime --buff的最大时间
					
					--加buff
					local tCastParam =
					{
						castId = oBuff.data.castId,
						targetC = oBuff.data.targetC,
						IsAttack = oBuff.data.IsAttack,
						IsCast = oBuff.data.IsCast,
						IsFlee = oBuff.data.IsFlee,
						maxtime = maxtime - pasttime, --geyachao: buff最大生存时间
						buffTick = oBuff.data.buffTick, --geyachao: buff的tick间隔
						buffTickDmg = oBuff.data.buffTickDmg, --geyachao: buff的tick释放的伤害
						buffTickDmgMode = oBuff.data.buffTickDmgMode, --geyachao: buff的tick释放的伤害类型
						buffTickSkillId = oBuff.data.buffTickSkillId, --geyachao: buff的tick释放的技能
						buffTickLv = oBuff.data.buffTickLv, --geyachao: buff的tick释放的技能等级
						buffRemoveSkillId = oBuff.data.buffRemoveSkillId, --geyachao: buff移除时释放的技能
						buffRemoveLv = oBuff.data.buffRemoveLv, --geyachao: buf移除时释放的技能等级
						level = buffLv,	--geyachao: buff等级
						buffState_Stun = oBuff.data.buffState_Stun, --geyachao: buff是否眩晕
						buffState_BianDa = oBuff.data.buffState_BianDa, --geyachao: buff是否变大
						buffState_ImmuePhysic = oBuff.data.buffState_ImmuePhysic, --geyachao: buff是否物理免疫
						buffState_ImmueMagic = oBuff.data.buffState_ImmueMagic, --geyachao: buff是否法术免疫
						buffState_ImmueWuDi = oBuff.data.buffState_ImmueWuDi, --geyachao: buff是否无敌
						buffState_ImmueControl = oBuff.data.buffState_ImmueControl, --geyachao: buff是否免控
						buffState_SufferChaos = oBuff.data.buffState_SufferChaos, --geyachao: buff是否混乱
						buffState_SufferBlow = oBuff.data.buffState_SufferBlow, --geyachao: buff是否吹风
						buffState_SufferChuanCi = oBuff.data.buffState_SufferChuanCi, --geyachao: buff是否穿刺
						buffState_SufferSleep = oBuff.data.buffState_SufferSleep, --geyachao: buff是否沉睡
					}
					table.insert(diablodata.tankbuffs, --坦克的buff
					{
						buffId = buffId,
						gridX = oBuff.data.gridX,
						gridY = oBuff.data.gridY,
						tCastParam = tCastParam,
					})
					--print("坦克的buff", buffId)
				end
			end
		end
	end
	
	--存储坦克的武器
	local bindWeapon = oUnit.data.bind_weapon
	diablodata.bind_weapon = bindWeapon.data.id --绑定的武器typeId
	
	--依次遍历坦克武器身上的buff，存储tankweaponbuffs
	local tt = bindWeapon.data["buffs"]
	if tt.index then
		for buff_key, n in pairs(tt.index) do
			if n and (n ~= 0) then
				local oID = tt[n]
				local oBuff = hClass.action:find(oID)
				if oBuff then --目标身上已有此buff
					local buffId = oBuff.data.skillId --buff的技能id
					local buffLv = oBuff.data.level --buff的等级
					local pasttime = oBuff.data.past --buff的经过时间
					local maxtime = oBuff.data.maxtime --buff的最大时间
					
					--加buff
					local tCastParam =
					{
						castId = oBuff.data.castId,
						targetC = oBuff.data.targetC,
						IsAttack = oBuff.data.IsAttack,
						IsCast = oBuff.data.IsCast,
						IsFlee = oBuff.data.IsFlee,
						maxtime = maxtime - pasttime, --geyachao: buff最大生存时间
						buffTick = oBuff.data.buffTick, --geyachao: buff的tick间隔
						buffTickDmg = oBuff.data.buffTickDmg, --geyachao: buff的tick释放的伤害
						buffTickDmgMode = oBuff.data.buffTickDmgMode, --geyachao: buff的tick释放的伤害类型
						buffTickSkillId = oBuff.data.buffTickSkillId, --geyachao: buff的tick释放的技能
						buffTickSkillIdT = oBuff.data.buffTickSkillIdT, --geyachao: buff的目标tick释放的技能
						buffTickLv = oBuff.data.buffTickLv, --geyachao: buff的tick释放的技能等级
						buffRemoveSkillId = oBuff.data.buffRemoveSkillId, --geyachao: buff移除时释放的技能
						buffRemoveLv = oBuff.data.buffRemoveLv, --geyachao: buf移除时释放的技能等级
						level = buffLv,	--geyachao: buff等级
						buffState_Stun = oBuff.data.buffState_Stun, --geyachao: buff是否眩晕
						buffState_BianDa = oBuff.data.buffState_BianDa, --geyachao: buff是否变大
						buffState_ImmuePhysic = oBuff.data.buffState_ImmuePhysic, --geyachao: buff是否物理免疫
						buffState_ImmueMagic = oBuff.data.buffState_ImmueMagic, --geyachao: buff是否法术免疫
						buffState_ImmueWuDi = oBuff.data.buffState_ImmueWuDi, --geyachao: buff是否无敌
						buffState_ImmueControl = oBuff.data.buffState_ImmueControl, --geyachao: buff是否免控
						buffState_SufferChaos = oBuff.data.buffState_SufferChaos, --geyachao: buff是否混乱
						buffState_SufferBlow = oBuff.data.buffState_SufferBlow, --geyachao: buff是否吹风
						buffState_SufferChuanCi = oBuff.data.buffState_SufferChuanCi, --geyachao: buff是否穿刺
						buffState_SufferSleep = oBuff.data.buffState_SufferSleep, --geyachao: buff是否沉睡
					}
					table.insert(diablodata.tankweaponbuffs, --坦克武器的buff
					{
						buffId = buffId,
						gridX = oBuff.data.gridX,
						gridY = oBuff.data.gridY,
						tCastParam = tCastParam,
					})
					--print("坦克武器的buff", buffId)
				end
			end
		end
	end
	
	--存储英雄的战术技能数据
	local oHero = oUnit:gethero()
	if oHero then
		diablodata.heros.itemSkillT = {}
		for i = 1, #oHero.data.itemSkillT, 1 do
			oHero.data.itemSkillT[i].activeItemLastCastTime = 0 --上次释放事件为0
			diablodata.heros.itemSkillT[i] = oHero.data.itemSkillT[i]
		end
		--print("英雄的战术技能数据", oHero.data.itemSkillT and #oHero.data.itemSkillT)
	end
end


--单次显示坦克冒烟特效
hApi.ShowTankSmokeEff = function(oUnit, scale)
	local hero_x, hero_y = hApi.chaGetPos(oUnit.handle) --我方小兵的坐标
	local hero_bx, hero_by, hero_bw, hero_bh = oUnit:getbox() --我方小兵的包围盒
	local tx = hero_x + (hero_bx + hero_bw / 2) --中心点x位置
	local ty = hero_y + (hero_by + hero_bh / 2) --中心点y位置
	scale = scale or 1
	--local screenX, screenY = hApi.world2view(tx, ty) --屏幕坐标
	
	local facing = oUnit.data.facing
	local moveSpeed = oUnit:GetMoveSpeed()
	if (oUnit.handle.UnitInMove == 0) then
		moveSpeed = 0
	end
	--print(facing, moveSpeed)
	local scaleFrom = 1.0
	local scaleTo = 1.5
	local speed = moveSpeed / 4
	local angle = 360 - facing
	local speedY = 80
	local showTime = 1.3
	
	--local fangle = angle * math.pi / 180 --弧度制
	--local toX = speed * math.cos(fangle) * showTime
	--local toY = speed * math.sin(fangle) * showTime
	local toX = speed * hApi.Math.Cos(angle) * showTime
	local toY = speed * hApi.Math.Sin(angle) * showTime
	
	--冒烟的图标
	local ctrl = hUI.image:new({
		parent = oUnit:getworld().handle.worldLayer,
		model = "effect/yanwu.png",
		x = tx,
		y = -ty + 30,
		z = 100000,
		scale = scaleFrom * scale,
	})
	--ctrl.handle.s:setVisible(false)
	
	--播放动画
	--CCEaseSineOut:create(
	local moveV = CCMoveBy:create(showTime, ccp(0, speedY * showTime)) --垂直位移
	local move = CCMoveBy:create(showTime, ccp(toX, toY)) --位移
	local scaleBig = CCScaleTo:create(showTime, scaleTo) --变大
	local fadeTo = CCEaseSineIn:create(CCFadeTo:create(showTime, 0)) --淡入
	
	local array = CCArray:create()
	array:addObject(moveV)
	array:addObject(move)
	array:addObject(scaleBig)
	array:addObject(fadeTo)
	
	local spawn = CCSpawn:create(array)
	local callback = CCCallFunc:create(function() --回调
		ctrl:del()
	end)
	local sequence = CCSequence:createWithTwoActions(spawn, callback)
	ctrl.handle._n:runAction(sequence) --action
end






--整数转换为16进制
-- 128 -> /80
local int2hex = function(c)
	local hc = string.format("%#x", c)
	if (#hc >= 3) then --0x??
		hc = string.sub(hc, 3)
	end
	if (#hc == 1) then
		hc = "0" .. hc
	end
	hc = "/" .. hc
	
	return hc
end

--https://blog.csdn.net/allenjay11/article/details/53207888
--通常都说到，汉字范围从0x4E00到0x9FA5，这是指Unicode编码。对于UTF-8还要做转换。 
--其中，0x4E00 用二进制表示为 100111000000000 
--换成UTF-8码就是 11100100 10111000 10000000，即 228, 184, 128 
--同理，0x9FA5为 11101001 10111110 10100101，即 233, 190, 165 
--可以看出，中文UTF-8编码用3个字节表示。
--前面分析了中文UTF-8的编码范围了，所以lua只要用 string.byte(s, i) 取到字符的byte值（字符集通常记 code point）
--比较第一个字节是228-233，而且接下来两个字节都是 128-191，就可以简单认定为中文了
hApi.StringEncodeEmoji = function(text)
--function hApi.StringEncodeEmoji(text)
	--不是字符串，不处理
	if (type(text) ~= "string") then
		return text
	end
	
	--检测文本中是否有表情，如果没有，不需要转换
	local bExistedEmoji = false
	for i = 1, #text, 1 do
		local c = string.byte(text, i)
		if (c >= 240) then
			bExistedEmoji = true --有emoji
			break
		end
	end
	
	--没有emoji，不需要转换
	if (not bExistedEmoji) then
		return text
	end
	
	local ss = {}
	local k = 1
	
	while true do
		--处理完毕
		if (k > #text) then
			break
		end
		
		local c = string.byte(text, k)
		--print("c=" .. c)
		
		--无效的字符？
		if (not c) then
			break
		end
		
		if (c < 192) then --英文、数字
			table.insert(ss, string.char(c))
			
			k = k + 1
		elseif (c < 224) then --英文符号
			local c1 = string.byte(text, k + 1)
			
			table.insert(ss, string.char(c) .. string.char(c1))
			
			k = k + 2
		elseif (c < 240) then --中文
			--if (c >= 228) and (c <= 233) then --中文
				local c1 = string.byte(text, k + 1)
				local c2 = string.byte(text, k + 2)
				
				local a1,a2,a3,a4 = 128,191,128,191
				if (c == 228) then
					a1 = 184
				elseif (c == 233) then
					a2, a4 = 190, c1 ~= 190 and 191 or 165
				end
				
				if c1>=a1 and c1<=a2 and c2>=a3 and c2<=a4 then --普通中文
					table.insert(ss, string.char(c, c1, c2))
				else
					--中文特殊符号
					local c1 = string.byte(text, k + 1)
					local c2 = string.byte(text, k + 2)
					
					local hc = int2hex(c)
					local hc1 = int2hex(c1)
					local hc2 = int2hex(c2)
					
					table.insert(ss, hc .. hc1 .. hc2)
				end
			--else --中文符号
			--	local c1 = string.byte(text, k + 1)
			--	local c2 = string.byte(text, k + 2)
			--	
			--	local hc = int2hex(c)
			--	local hc1 = int2hex(c1)
			--	local hc2 = int2hex(c2)
			--	
			--	table.insert(ss, hc .. hc1 .. hc2)
			--end
			
			k = k + 3
		elseif (c < 248) then --表情(长度4)
			local c1 = string.byte(text, k + 1)
			local c2 = string.byte(text, k + 2)
			local c3 = string.byte(text, k + 3)
			
			local hc = int2hex(c)
			local hc1 = int2hex(c1)
			local hc2 = int2hex(c2)
			local hc3 = int2hex(c3)
			
			table.insert(ss, hc .. hc1 .. hc2 .. hc3)
			
			k = k + 4
		elseif (c < 252) then --表情(长度5)
			local c1 = string.byte(text, k + 1)
			local c2 = string.byte(text, k + 2)
			local c3 = string.byte(text, k + 3)
			local c4 = string.byte(text, k + 4)
			
			local hc = int2hex(c)
			local hc1 = int2hex(c1)
			local hc2 = int2hex(c2)
			local hc3 = int2hex(c3)
			local hc4 = int2hex(c4)
			
			table.insert(ss, hc .. hc1 .. hc2 .. hc3 .. hc4)
			
			k = k + 5
		elseif (c < 254) then --表情(长度6)
			local c1 = string.byte(text, k + 1)
			local c2 = string.byte(text, k + 2)
			local c3 = string.byte(text, k + 3)
			local c4 = string.byte(text, k + 4)
			local c5 = string.byte(text, k + 5)
			
			local hc = int2hex(c)
			local hc1 = int2hex(c1)
			local hc2 = int2hex(c2)
			local hc3 = int2hex(c3)
			local hc4 = int2hex(c4)
			local hc5 = int2hex(c5)
			
			table.insert(ss, hc .. hc1 .. hc2 .. hc3 .. hc4 .. hc5)
			
			k = k + 6
		end
	end
	
	return table.concat(ss)
end



--16进制转换为整数
-- /80 -> 128
local hex2int = function(h)
	local hex = string.sub(h, 2, 3)
	--print("hex=", hex)
	local hexStr = "0x" .. hex
	
	local bit = string.format("%d", hexStr)
	bit = tonumber(bit)
	--print("bit=", bit)
	return bit
end

--将文字转表情
hApi.StringDecodeEmoji = function(text)
--function hApi.StringDecodeEmoji(text)
	--不是字符串，不处理
	if (type(text) ~= "string") then
		return text
	end
	
	local slashpos = string.find(text, "/")
	
	--没有"/"
	if (slashpos == nil) then
		return text
	end
	
	--转译"/"
	--/8f
	local ss = ""
	while (slashpos ~= nil) do
		local prep = string.sub(text, 1, slashpos - 1)
		local emoji = string.sub(text, slashpos, slashpos + 2)
		local post = string.sub(text, slashpos + 3, -1)
		--print("prep=\""..prep.."\"", "emoji=\""..emoji.."\"", "post=\""..post.."\"")
		
		local c = hex2int(emoji)
		ss = ss .. prep .. string.char(c)
		
		text = post
		slashpos = string.find(text, "/")
	end
	
	ss = ss .. text
	
	return ss
end


--获得表情字符串的英文长度（英文长度为1，中文长度为2，也可自己传入参数指定中英文长度）
--一般用于起名时检测长度
hApi.GetStringEmojiENLength = function(text, enLength, cnLength)
--function hApi.GetStringEmojiENLength(text)
	--不是字符串，不处理
	if (type(text) ~= "string") then
		return 0
	end
	
	enLength = enLength or 1
	cnLength = cnLength or 2
	
	local length = 0
	local k = 1
	
	while true do
		--处理完毕
		if (k > #text) then
			break
		end
		
		local c = string.byte(text, k)
		--print("c=" .. c)
		
		--无效的字符？
		if (not c) then
			break
		end
		
		if (c < 192) then --英文
			k = k + 1
			length = length + enLength
		elseif (c < 224) then --英文符号
			k = k + 2
			length = length + enLength
		elseif (c < 240) then --中文
			k = k + 3
			length = length + cnLength
		elseif (c < 248) then
			k = k + 4
			length = length + cnLength
		elseif (c < 252) then
			k = k + 5
			length = length + cnLength
		elseif (c < 254) then
			k = k + 6
			length = length + cnLength
		end
	end
	
	return length
end

--获得表情字符串的中文界面显示的长度（中文长度为1，表情长度为1，英文长度略大于0.5）
--一般用于中文界面绘制文本
hApi.GetStringEmojiCNLength = function(text)
--function hApi.GetStringEmojiCNLength(text)
	--不是字符串，不处理
	if (type(text) ~= "string") then
		return 0
	end
	
	local length = 0
	local k = 1
	
	while true do
		--处理完毕
		if (k > #text) then
			break
		end
		
		local c = string.byte(text, k)
		--print("c=" .. c)
		
		--无效的字符？
		if (not c) then
			break
		end
		
		if (c < 192) then --英文
			k = k + 1
			length = length + 0.66
			
			--字符 空格
			if (c == 32) then --空格
				length = length - 0.66 + 0.333333
			--字符 !
			elseif (c == 33) then --!
				length = length - 0.66 + 0.33
			--字符 "
			elseif (c == 34) then --"
				length = length - 0.66 + 0.36
			--字符 #
			elseif (c == 35) then --#
				length = length - 0.66 + 0.78
			--字符 $
			elseif (c == 36) then --$
				length = length - 0.66 + 0.62
			--字符 %
			elseif (c == 37) then --%
				length = length - 0.66 + 0.99
			--字符 &
			elseif (c == 38) then --&
				length = length - 0.66 + 0.78
			--字符 '
			elseif (c == 39) then --'
				length = length - 0.66 + 0.19
			--字符 (
			elseif (c == 40) then --(
				length = length - 0.66 + 0.44
			--字符 )
			elseif (c == 41) then --)
				length = length - 0.66 + 0.44
			--字符 *
			elseif (c == 42) then --*
				length = length - 0.66 + 0.51
			--字符 +
			elseif (c == 43) then --+
				length = length - 0.66 + 0.83
			--字符 ,
			elseif (c == 44) then --,
				length = length - 0.66 + 0.32
			--字符 -
			elseif (c == 45) then ---
				length = length - 0.66 + 0.33
			--字符 .
			elseif (c == 46) then --.
				length = length - 0.66 + 0.32
			--字符 /
			elseif (c == 47) then --/
				length = length - 0.66 + 0.29
			--字符 0
			elseif (c == 48) then --0
				length = length - 0.66 + 0.61
			--字符 1
			elseif (c == 49) then --1
				length = length - 0.66 + 0.61
			--字符 2
			elseif (c == 50) then --2
				length = length - 0.66 + 0.61
			--字符 3
			elseif (c == 51) then --3
				length = length - 0.66 + 0.61
			--字符 4
			elseif (c == 52) then --4
				length = length - 0.66 + 0.61
			--字符 5
			elseif (c == 53) then --5
				length = length - 0.66 + 0.61
			--字符 6
			elseif (c == 54) then --6
				length = length - 0.66 + 0.61
			--字符 7
			elseif (c == 55) then --7
				length = length - 0.66 + 0.61
			--字符 8
			elseif (c == 56) then --8
				length = length - 0.66 + 0.61
			--字符 9
			elseif (c == 57) then --9
				length = length - 0.66 + 0.61
			--字符 :
			elseif (c == 58) then --:
				length = length - 0.66 + 0.32
			--字符 ;
			elseif (c == 59) then --;
				length = length - 0.66 + 0.32
			--字符 <
			elseif (c == 60) then --<
				length = length - 0.66 + 0.83
			--字符 =
			elseif (c == 61) then --=
				length = length - 0.66 + 0.83
			--字符 >
			elseif (c == 62) then -->
				length = length - 0.66 + 0.83
			--字符 ?
			elseif (c == 63) then -->
				length = length - 0.66 + 0.54
			--字符 @
			elseif (c == 64) then --@
				length = length - 0.66 + 1.01
			--字符 A
			elseif (c == 65) then --A
				length = length - 0.66 + 0.78
			--字符 C
			elseif (c == 67) then --C
				length = length - 0.66 + 0.78
			--字符 D
			elseif (c == 68) then --D
				length = length - 0.66 + 0.78
			--字符 E
			elseif (c == 69) then --E
				length = length - 0.66 + 0.61
			--字符 F
			elseif (c == 70) then --F
				length = length - 0.66 + 0.58
			--字符 G
			elseif (c == 71) then --G
				length = length - 0.66 + 0.89
			--字符 H
			elseif (c == 72) then --H
				length = length - 0.66 + 0.80
			--字符 I
			elseif (c == 73) then --I
				length = length - 0.66 + 0.38
			--字符 J
			elseif (c == 74) then --J
				length = length - 0.66 + 0.49
			--字符 K
			elseif (c == 75) then --K
				length = length - 0.66 + 0.71
			--字符 L
			elseif (c == 76) then --L
				length = length - 0.66 + 0.50
			--字符 M
			elseif (c == 77) then --M
				length = length - 0.66 + 1.02
			--字符 N
			elseif (c == 78) then --N
				length = length - 0.66 + 0.86
			--字符 O
			elseif (c == 79) then --O
				length = length - 0.66 + 0.90
			--字符 Q
			elseif (c == 81) then --Q
				length = length - 0.66 + 0.90
			--字符 R
			elseif (c == 82) then --R
				length = length - 0.66 + 0.72
			--字符 T
			elseif (c == 84) then --T
				length = length - 0.66 + 0.56
			--字符 U
			elseif (c == 85) then --U
				length = length - 0.66 + 0.79
			--字符 V
			elseif (c == 86) then --V
				length = length - 0.66 + 0.68
			--字符 W
			elseif (c == 87) then --W
				length = length - 0.66 + 1.01
			--字符 X
			elseif (c == 88) then --X
				length = length - 0.66 + 0.72
			--字符 Y
			elseif (c == 89) then --Y
				length = length - 0.66 + 0.65
			--字符 Z
			elseif (c == 90) then --Z
				length = length - 0.66 + 0.68
			--字符 [
			elseif (c == 91) then --[
				length = length - 0.66 + 0.41
			--字符 \
			elseif (c == 92) then --\
				length = length - 0.66 + 0.28
			--字符 ]
			elseif (c == 93) then --]
				length = length - 0.66 + 0.41
			--字符 ^
			elseif (c == 94) then --^
				length = length - 0.66 + 0.99
			--字符 _
			elseif (c == 95) then --_
				length = length - 0.66 + 0.51
			--字符 `
			elseif (c == 96) then --`
				length = length - 0.66 + 0.49
			--字符 a
			elseif (c == 97) then --a
				length = length - 0.66 + 0.68
			--字符 b
			elseif (c == 98) then --b
				length = length - 0.66 + 0.68
			--字符 c
			elseif (c == 99) then --c
				length = length - 0.66 + 0.57
			--字符 d
			elseif (c == 100) then --d
				length = length - 0.66 + 0.68
			--字符 f
			elseif (c == 102) then --f
				length = length - 0.66 + 0.37
			--字符 g
			elseif (c == 103) then --g
				length = length - 0.66 + 0.68
			--字符 h
			elseif (c == 104) then --h
				length = length - 0.66 + 0.63
			--字符 i
			elseif (c == 105) then --i
				length = length - 0.66 + 0.34
			--字符 j
			elseif (c == 106) then --j
				length = length - 0.66 + 0.35
			--字符 k
			elseif (c == 107) then --k
				length = length - 0.66 + 0.63
			--字符 l
			elseif (c == 108) then --l
				length = length - 0.66 + 0.34
			--字符 m
			elseif (c == 109) then --m
				length = length - 0.66 + 0.94
			--字符 n
			elseif (c == 110) then --n
				length = length - 0.66 + 0.64
			--字符 o
			elseif (c == 111) then --o
				length = length - 0.66 + 0.64
			--字符 p
			elseif (c == 112) then --p
				length = length - 0.66 + 0.68
			--字符 q
			elseif (c == 113) then --q
				length = length - 0.66 + 0.68
			--字符 r
			elseif (c == 114) then --r
				length = length - 0.66 + 0.44
			--字符 s
			elseif (c == 115) then --s
				length = length - 0.66 + 0.51
			--字符 t
			elseif (c == 116) then --t
				length = length - 0.66 + 0.39
			--字符 u
			elseif (c == 117) then --u
				length = length - 0.66 + 0.62
			--字符 v
			elseif (c == 118) then --v
				length = length - 0.66 + 0.55
			--字符 w
			elseif (c == 119) then --w
				length = length - 0.66 + 0.90
			--字符 x
			elseif (c == 120) then --x
				length = length - 0.66 + 0.56
			--字符 y
			elseif (c == 121) then --y
				length = length - 0.66 + 0.57
			--字符 z
			elseif (c == 122) then --z
				length = length - 0.66 + 0.55
			--字符 {
			elseif (c == 123) then --{
				length = length - 0.66 + 0.49
			--字符 |
			elseif (c == 124) then --|
				length = length - 0.66 + 0.49
			--字符 }
			elseif (c == 125) then --}
				length = length - 0.66 + 0.49
			--字符 ~
			elseif (c == 126) then --~
				length = length - 0.66 + 0.82
			end
		elseif (c < 224) then --英文符号
			k = k + 2
			length = length + 0.66
		elseif (c < 240) then --中文
			k = k + 3
			length = length + 1
		elseif (c < 248) then
			k = k + 4
			length = length + 1.18 --表情略大一点
		elseif (c < 252) then
			k = k + 5
			length = length + 1.18 --表情略大一点
		elseif (c < 254) then
			k = k + 6
			length = length + 1.18 --表情略大一点
		end
	end
	
	return length
end

hApi.ShowGetResurceFloatNum = function(sType,num)
	local icon = ""
	local strText = ""
	local contentX = 0
	local contentY = 0
	local width = 140
	local iconX = 0
	local iconY = 0
	local contentSize = 32
	if sType == "chip" then
		local offw = 0
		if num < 10 then
			offw = 0
		elseif num < 100 then
			offw = offw + contentSize
		elseif num < 1000 then
			offw = offw + contentSize * 2
		elseif num < 10000 then
			offw = offw + contentSize * 3
		else
			offw = offw + contentSize * 4
		end
		icon ="ICON:CHIP_BROKEN"
		strText = " + "..tostring(num)
		iconX = - 16 - offw/4
		iconY = - 2
		contentX = - 20 - offw/4
		width = width + offw/2
	end
	hUI.floatNumber:new({
		x = hVar.SCREEN.w / 2,
		y = hVar.SCREEN.h / 2 + contentSize/2 + 3,
		align = "MC",
		text = "",
		lifetime = 1000,
		fadeout = -550,
		moveY = 32,
	}):addtext("", hVar.FONTC, contentSize + 2, "MC", 0, 0,nil,width)

	hUI.floatNumber:new({
		x = hVar.SCREEN.w / 2 + contentX,
		y = hVar.SCREEN.h / 2 + contentY ,
		align = "MC",
		text = "",
		lifetime = 1000,
		fadeout = -550,
		moveY = 32,
		font = "num",
	}):addtext(strText, "num", contentSize, "LC", 0, 0,nil)

	hUI.floatNumber:new({
		text = "",
		size = 16,
		x = hVar.SCREEN.w / 2 + iconX,
		y = hVar.SCREEN.h / 2 + iconY,
		align = "LC",
		icon = icon,
		iconWH = 36,
		lifetime = 1000,
		fadeout = -550,
		moveY = 32,
	})
end

hApi.NotEnoughResource = function(sType)
	local strText = hVar.tab_string["not_enough"]
	local iconX = 0
	local iconY = - 6
	local contentX = 0
	local contentY = 0
	local contentSize = 40
	local width = 1
	local icon = ""
	if g_Cur_Language == 3 then
		strText = " "..strText
		width = 400
		if sType == "skillpoint" then
			iconX = 168
			contentX = - 178
			icon = "misc/skillup/skillpoint.png"
		elseif sType == "coin" then
			iconX = 170
			contentX = - 178
			icon = "misc/skillup/mu_coin.png"
		elseif sType == "keshi" then
			iconX = 170
			contentX = - 178
			icon = "misc/skillup/keshi.png"
		elseif sType == "man" then
			iconX = 164
			iconY = - 2
			contentX = - 178
			icon = "misc/gameover/icon_man.png"
		elseif sType == "dishu" then
			iconX = 168
			contentX = - 178
			iconY = -4
			icon = "misc/coin2.png"
		end
	elseif g_Cur_Language == 4 then
		strText = "    "..strText
		contentSize = 38
		contentX = -70
		width = 290
		if sType == "skillpoint" then
			iconX = -30
			icon = "misc/skillup/skillpoint.png"
		elseif sType == "coin" then
			iconX = -30
			icon = "misc/skillup/mu_coin.png"
		elseif sType == "keshi" then
			iconX = -30
			icon = "misc/skillup/keshi.png"
		elseif sType == "man" then
			iconX = -36
			iconY = - 2
			icon = "misc/gameover/icon_man.png"
		elseif sType == "dishu" then
			iconX = -36
			iconY = -4
			icon = "misc/coin2.png"
		end
	else
		strText = "    "..strText
		contentSize = 38
		width = 180
		if sType == "skillpoint" then
			iconX = -30
			contentX = -70
			icon = "misc/skillup/skillpoint.png"
		elseif sType == "coin" then
			iconX = -30
			contentX = -70
			icon = "misc/skillup/mu_coin.png"
		elseif sType == "keshi" then
			iconX = -30
			contentX = -70
			icon = "misc/skillup/keshi.png"
		elseif sType == "man" then
			iconX = -36
			contentX = -70
			iconY = - 2
			icon = "misc/gameover/icon_man.png"
		elseif sType == "dishu" then
			iconX = -36
			contentX = -64
			iconY = -4
			icon = "misc/coin2.png"
		end
	end
	hUI.floatNumber:new({
		x = hVar.SCREEN.w / 2 + contentX,
		y = hVar.SCREEN.h / 2 + contentY ,
		align = "MC",
		text = "",
		lifetime = 1000,
		fadeout = -550,
		moveY = 32,
	}):addtext(strText, hVar.FONTC, contentSize, "LC", 0, 0,nil,width)

	hUI.floatNumber:new({
		font = "numGreen",
		text = "",
		size = 16,
		x = hVar.SCREEN.w / 2 + iconX,
		y = hVar.SCREEN.h / 2 + iconY,
		align = "LC",
		icon = icon,
		iconWH = 36,
		lifetime = 1000,
		fadeout = -550,
		moveY = 32,
	})
end

hApi.ChangeLanguage = function()
	language_config = {}
	language_config[1] = {"默认", "DEFAULT", "default", "coh_2018"}
	language_config[2] = {"简体中文", "DEFAULT", "default", "coh_2018"}
	language_config[3] = {"繁体中文", "DEFAULT", "default", "coh_2018"}
	language_config[4] = {"英语", "EN", "en", "coh_2018"}
	language_config[5] = {"日语", "JP", "jp", "coh_2018"}
	local languageName = language_config[g_language_setting][3]
	if g_lua_src == 1 then
		hApi.LoadScripts("tabs/",hDefine.LocalString[languageName])
	else
		xlDoFile("data/"..languageName..".lan")
	end
	if type(g_string)=="table" then
		--加载字符串(一切ok!)
		for k,v in pairs(g_string)do
			hVar[k] = v
		end
	end
	PreloadTxtManager.func.ChangeLanguage()
end

hApi.CheckLanguage = function()
	--print("hApi.CheckLanguage")
	local language = CCUserDefault:sharedUserDefault():getIntegerForKey("xl_language")
	--print("language",language)
	if language == 0 then
		local system_lang = ""
		if xlSystemLanguage then
			system_lang = xlSystemLanguage()
		end
		--繁体
		if system_lang == "zh-Hant" or system_lang == "zh-Hant-CN" or system_lang == "zh-TW" or system_lang == "zh-HK" then
			g_language_setting = 3
		else
			local sys_lang = CCApplication:sharedApplication():getCurrentLanguage()
			--print("sys_lang",sys_lang)
			if sys_lang == 1 then		--	国语
				g_language_setting = 1
			elseif sys_lang == 8 then	--	韩文
				g_language_setting = 3
			elseif sys_lang == 9 then	--	日语
				g_language_setting = 5
			else
				g_language_setting = 4
			end
		end
		CCUserDefault:sharedUserDefault():setIntegerForKey("xl_language",g_language_setting)
		CCUserDefault:sharedUserDefault():flush()
	else
		g_language_setting = language
	end
	if g_language_setting == 1 or g_language_setting == 2 then
		g_Cur_Language = 1
	elseif g_language_setting == 3 then
		g_Cur_Language = 2
	elseif g_language_setting == 4 then
		g_Cur_Language = 3
	elseif g_language_setting == 5 then
		g_Cur_Language = 4
	end
end

hApi.ChangeScreenMode = function()
	if g_CurScreenMode == 1 then		--无锁定
		if type(xlGetScreenRotation) == "function" and type(xlRotateScreen) == "function" then
			local orientation, lock_flag = xlGetScreenRotation()
			xlRotateScreen(orientation, 0)
		end
	elseif g_CurScreenMode == 2 then	--竖屏
		if type(xlRotateScreen) == "function" then
			xlRotateScreen(1, 1)
		end
	elseif g_CurScreenMode == 3 then	--横屏
		if type(xlRotateScreen) == "function" then
			xlRotateScreen(2, 1)
		end
	end
end

hApi.LockScreenRotation = function()
	if g_CurScreenMode == 1 then--只有横竖屏无锁定的情况下需要强行锁定
		if type(xlGetScreenRotation) == "function" and type(xlRotateScreen) == "function" then
			local orientation, lock_flag = xlGetScreenRotation()
			xlRotateScreen(orientation, 1)
		end
	--其余都是硬锁  不需要改
	end
end

hApi.RecoverScreenRotation = function()
	if g_CurScreenMode == 1 then--只有横竖屏无锁定的情况下需要解除锁定
		if type(xlGetScreenRotation) == "function" and type(xlRotateScreen) == "function" then
			local orientation, lock_flag = xlGetScreenRotation()
			xlRotateScreen(orientation, 0)
		end
	--其余都是硬锁  不需要改
	end
end

hApi.ResetViewMode = function()
	if g_CurViewMode == 1 then
		xlView_SetScale(1)
	elseif g_CurViewMode == 2 then
		xlView_SetScale(0.9)
	elseif g_CurViewMode == 3 then
		xlView_SetScale(1.1)
	end
end

hApi.SwitchDanmu = function(nState)
	local TargetPlatform = CCApplication:sharedApplication():getTargetPlatform()
	--IOS
	if g_tTargetPlatform.kTargetWindows ~= TargetPlatform then
		xlSaveIntToKeyChain("closedanmu",nState)
	--windows
	else
		CCUserDefault:sharedUserDefault():setIntegerForKey("closedanmu",nState)
		CCUserDefault:sharedUserDefault():flush()
	end
end

hApi.GetDanmuState = function()
	local nState = 0
	local TargetPlatform = CCApplication:sharedApplication():getTargetPlatform()
	--IOS
	if g_tTargetPlatform.kTargetWindows ~= TargetPlatform then
		nState = xlGetIntFromKeyChain("closedanmu")
	--windows
	else
		nState = CCUserDefault:sharedUserDefault():getIntegerForKey("closedanmu")
	end
	return nState
end

hApi.SaveGuestInfo_IOS = function()
	local iChannelId = xlGetChannelId()
	if iChannelId < 100 then
		local TargetPlatform = CCApplication:sharedApplication():getTargetPlatform()
		if g_tTargetPlatform.kTargetWindows ~= TargetPlatform then
			xlSaveIntToKeyChain("xl_guest_uid",g_guest_uid)
			xlSaveStringToKeyChain("xl_guest_pw",g_guest_pw)
			xlSaveStringToKeyChain("xl_guest_name",g_guest_name)
		end
	end
end

--创建恢复存档界面
hApi.CreateRestoreSaveDataFrm = function()
	g_DisableShowOption = 1
	local _curChoose = 0

	local _Code_LeaveFunc = function()
		if hGlobal.UI.RestoreSaveDataFrm then
			hGlobal.UI.RestoreSaveDataFrm:del()
			hGlobal.UI.RestoreSaveDataFrm = nil
		end
		hGlobal.event:listen("LocalEvent_RestoreSaveDataSuccess","closefrm",nil)
		g_DisableShowOption = 0
	end

	local _Code_SetButtonState = function()
		local _frm = hGlobal.UI.RestoreSaveDataFrm
		if _frm then
			local _childUI = _frm.childUI
			if _childUI["btn_ok"] then
				if g_loadServerSaveData == 1 then
					_childUI["btn_ok"]:setstate(0)
				else
					_childUI["btn_ok"]:setstate(1)
				end
				if _curChoose > 0 then
					hApi.AddShader(_childUI["btn_ok"].handle.s, "normal")
				else
					hApi.AddShader(_childUI["btn_ok"].handle.s, "gray")
				end
			end
		end
	end

	--开始新游戏
	local _Code_StartNewGame = function()
		hApi.clearTimer("RestoreSaveDataFail")
		--选择不恢复后  设置重开游戏标记为1  防止下次进入时没有cfg文件 再一次弹恢复存档界面
		LuaSetPlayerStartNewGame(g_curPlayerName,1)
		LuaSavePlayerList()
		g_loadServerSaveData = 0
		hGlobal.event:event("LocalEvent_autologin")
		local _frm = hGlobal.UI.Phone_MainPanelFrm
		if _frm and _frm.childUI["panel_bg_logo1"] then
			_frm.childUI["panel_bg_logo1"]:setstate(1)
		end
		_Code_LeaveFunc()
	end

	--恢复数据
	local _Code_Restoredata = function()
		if g_cur_net_state == -1 then
			hUI.floatNumber:new({
				x = hVar.SCREEN.w / 2,
				y = hVar.SCREEN.h / 2,
				align = "MC",
				text = "",
				lifetime = 1000,
				fadeout = -550,
				moveY = 32,
			}):addtext(hVar.tab_string["keepnetworkconnected"], hVar.FONTC, 32, "MC", 0, 0,nil,1)
			return
		end

		--一开始屏蔽操作
		hUI.NetDisable(99999)

		--恢复失败
		hApi.addTimerOnce("RestoreSaveDataFail",20000,function()
			hUI.NetDisable(0)
			g_loadServerSaveData = 0
			_Code_SetButtonState()
			--请稍后再试
			hUI.floatNumber:new({
				x = hVar.SCREEN.w / 2,
				y = hVar.SCREEN.h / 2,
				align = "MC",
				text = "",
				lifetime = 1000,
				fadeout = -550,
				moveY = 32,
			}):addtext(hVar.tab_string["wattingPlease"], hVar.FONTC, 32, "MC", 0, 0,nil,1)
		end)
		
		g_loadServerSaveData = 1
		hGlobal.event:event("LocalEvent_autologin")
		_Code_SetButtonState()
	end

	local _Code_ChooseBtn = function(nIndex)
		local _frm = hGlobal.UI.RestoreSaveDataFrm
		if _frm then
			_curChoose = nIndex
			local _childUI = _frm.childUI
			for i = 1,2 do
				if i == nIndex then
					if _childUI["img_chooseOk"..i] then
						_childUI["img_chooseOk"..i].handle._n:setVisible(true)
					end
				else
					if _childUI["img_chooseOk"..i] then
						_childUI["img_chooseOk"..i].handle._n:setVisible(false)
					end
				end
			end
		end
		_Code_SetButtonState()
	end

	local _Code_RestoreSaveDataSuccess = function()
		--只有恢复成功后才可以自动连接 否则不能自动连接
		hUI.floatNumber:new({
			x = hVar.SCREEN.w / 2,
			y = hVar.SCREEN.h / 2,
			align = "MC",
			text = "",
			lifetime = 1000,
			fadeout = -550,
			moveY = 32,
		}):addtext(hVar.tab_string["restoredatasuccessful"], hVar.FONTC, 32, "MC", 0, 0,nil,1)
		hApi.clearTimer("RestoreSaveDataFail")
		_Code_LeaveFunc()
		local _frm = hGlobal.UI.Phone_MainPanelFrm
		if _frm and _frm.childUI["panel_bg_logo1"] then
			_frm.childUI["panel_bg_logo1"]:setstate(1)
		end
		hUI.NetDisable(0)
	end

	_Code_LeaveFunc()

	local width = 560
	local height = 380

	hGlobal.UI.RestoreSaveDataFrm = hUI.frame:new({
		x = hVar.SCREEN.w/2 - width/2,
		y = hVar.SCREEN.h/2 + height/2,
		w = width,
		h = height,
		z = 100,
		show = 0,
		--dragable = 2,
		dragable = 4, 
		autoactive = 0,
		background = "misc/skillup/msgbox4.png",
		failcall = 1, --出按钮区域抬起也会响应事件
		--background = -1, --无底图
		border = 0, --无边框
	})

	local _frm = hGlobal.UI.RestoreSaveDataFrm
	local _parent = _frm.handle._n
	local _childUI = _frm.childUI

	_childUI["lab_text1"] = hUI.label:new({
		parent = _parent,
		x = 50,
		y = -88,
		align = "LC",
		size = 28,
		border = 1,
		width = 396,
		height =  160,
		font = hVar.FONTC,
		text = hVar.tab_string["restoredatatext1"],
	})

	_childUI["btn_choose1"] = hUI.button:new({
		parent = _parent,
		--model = "misc/mask.png",
		model ="misc/button_null.png",
		dragbox = _childUI["dragBox"],
		x = width/2,
		y = -90,
		w = 500,
		h = 80,
		code = function()
			_Code_ChooseBtn(1)
		end
	})

	_childUI["img_choose1"] = hUI.image:new({
		parent = _parent,
		model = "UI:Button_SelectBorder",
		x = 490,
		y = -90,
		w = 54,
		h = 54,
	})

	_childUI["img_chooseOk1"] = hUI.image:new({
		parent = _parent,
		model = "UI:ok",
		x = 490,
		y = -90,
		--w = 54,
		--h = 54,
	})
	_childUI["img_chooseOk1"].handle._n:setVisible(false)
	

	_childUI["lab_text2"] = hUI.label:new({
		parent = _parent,
		x = 50,
		y = -188,
		align = "LC",
		size = 28,
		border = 1,
		width = 396,
		height =  160,
		font = hVar.FONTC,
		text = hVar.tab_string["restoredatatext2"],
	})

	_childUI["btn_choose2"] = hUI.button:new({
		parent = _parent,
		--model = "misc/mask.png",
		model ="misc/button_null.png",
		dragbox = _childUI["dragBox"],
		x = width/2,
		y = -190,
		w = 500,
		h = 80,
		code = function()
			_Code_ChooseBtn(2)
		end
	})

	_childUI["img_choose2"] = hUI.image:new({
		parent = _parent,
		model = "UI:Button_SelectBorder",
		x = 490,
		y = -190,
		w = 54,
		h = 54,
	})

	_childUI["img_chooseOk2"] = hUI.image:new({
		parent = _parent,
		model = "UI:ok",
		x = 490,
		y = -190,
		--w = 54,
		--h = 54,
	})
	_childUI["img_chooseOk2"].handle._n:setVisible(false)

	_childUI["btn_ok"] = hUI.button:new({
		parent = _parent,
		model = "misc/addition/cg.png",
		dragbox = _childUI["dragBox"],
		label = {text = hVar.tab_string["confirm"],size = 28,y= 4,font = hVar.FONTC,},
		scaleT = 0.95,
		x = width/2,
		y = - 300,
		scale = 0.9,
		--scale = 0.95,
		code = function(self)
			if _curChoose == 1 then
				_Code_Restoredata()
			elseif _curChoose == 2 then
				_Code_StartNewGame()
			end
		end,
	})
	_Code_ChooseBtn(0)

	hGlobal.event:listen("LocalEvent_RestoreSaveDataSuccess","closefrm",_Code_RestoreSaveDataSuccess)

	_frm:show(1)
	_frm:active()
end

--检测是否达成宝物属性位条件
hApi.GetTreasureAttrFinishTag = function(world, treasureInfo)
	local tTreasureAttrTag = {}
	
	--依次遍历每个宝物属性位
	for tx = 1, hVar.TREASURE_ATTR.ATTR_MAXCOUNT, 1 do
		print("\n")
		print("treasure_attr=", tx)
		
		local finishTag = 0
		
		local tCondition = hVar.TREASURE_ATTR_UNLOCK_CONDITION[tx] --宝物属性条件表
		if tCondition then
			--地图内的宝物达成条件
			if world then
				local mapInfo = world.data.tdMapInfo
				local mapState = mapInfo.mapState
				
				--游戏胜利
				if (mapInfo.mapState == hVar.MAP_TD_STATE.SUCCESS) then
					--检测地图名是否符合条件
					local isMapOK = false
					local tMapName = tCondition.mapName
					local mapname = world.data.map --当前地图名
					
					if (type(tMapName) == "string") then
						if (tMapName == mapname) then
							print("  need=", mapname)
							isMapOK = true
						end
					elseif (type(tMapName) == "table") then
						for m = 1, #tMapName, 1 do
							print("  need=", tMapName[m])
							if (tMapName[m] == mapname) then
								isMapOK = true
								break
							end
						end
					end
					print("  mapname=", mapname)
					print("  isMapOK=", isMapOK)
					
					--地图名一致
					if isMapOK then
						--检测地图配置id是否符合条件
						local isSessionCfgIdOK = false
						local sessionCfgId = tCondition.sessionCfgId or -1 --地图配置id
						local sessionCfgIdNow = world.data.session_cfgId --当前地图配置id
						
						if (sessionCfgId > 0) then
							if (sessionCfgIdNow == sessionCfgId) then --地图配置id相同
								isSessionCfgIdOK = true
							end
						else --不限地图配置
							isSessionCfgIdOK = true
						end
						print("  sessionCfgId=", sessionCfgId)
						print("  sessionCfgIdNow=", sessionCfgIdNow)
						print("  isSessionCfgIdOK=", isSessionCfgIdOK)
						
						--地图配置id一致
						if isSessionCfgIdOK then
							--检测地图难度是否符合条件
							local isDifficultyOK = false
							local mapDifficultyMin = tCondition.mapDifficultyMin or -1 --挑战最小难度
							local mapDifficultyMax = tCondition.mapDifficultyMax or -1 --挑战最大难度
							local mapDifficulty = mapInfo.mapDifficulty --当前游戏难度
							
							if (mapDifficulty >= mapDifficultyMin) and (mapDifficulty <= mapDifficultyMax) then
								isDifficultyOK = true
							elseif (mapDifficultyMin > 0) and (mapDifficultyMax == -1) then  --限最低难度
								if (mapDifficulty >= mapDifficultyMin) then
									isDifficultyOK = true
								end
							elseif (mapDifficultyMin == -1) and (mapDifficultyMax > 0) then  --限最高难度
								if (mapDifficulty <= mapDifficultyMax) then
									isDifficultyOK = true
								end
							elseif (mapDifficultyMin == -1) and (mapDifficultyMax == -1) then  --不限难度
								isDifficultyOK = true
							end
							print("  mapDifficultyMin=", mapDifficultyMin)
							print("  mapDifficultyMax=", mapDifficultyMax)
							print("  mapDifficulty=", mapDifficulty)
							print("  isDifficultyOK=", isDifficultyOK)
							
							--难度一致
							if isDifficultyOK then
								--检测使用英雄是否符合条件
								local isHeroOK = false
								local allHero = world:GetSelectedHeroList()
								local tUseHero = tCondition.useHero or -1 --出场英雄条件表
								
								if (type(tUseHero) == "table") then
									--如果出场英雄条件表包含多个英雄，那么这些英雄必须全携带才算符合条件
									local requireNum = #tUseHero --需要携带指定英雄的数量
									print("  requireNum=", requireNum)
									local currentNum = 0 --当前已携带指定英雄的数量
									for h = 1, #tUseHero, 1 do
										local heroId = tUseHero[h]
										for c = 1, #allHero, 1 do
											if (allHero[c] == heroId) then
												currentNum = currentNum + 1
												break
											end
										end
									end
									
									print("  currentNum=", currentNum)
									--需要的英雄全部携带，才算符合条件
									if (currentNum >= requireNum) then
										isHeroOK = true
									end
								elseif (type(tUseHero) == "number") then
									if (tUseHero > 0) then
										for c = 1, #allHero, 1 do
											if (allHero[c] == tUseHero) then
												isHeroOK = true
												break
											end
										end
									elseif (tUseHero == -1) then --不限英雄
										isHeroOK = true
									end
								end
								print("  isHeroOK=", isHeroOK)
								
								--英雄一致
								if isHeroOK then
									--检测禁用英雄是否符合条件
									local isHeroBanOK = true
									--local allHero = world:GetSelectedHeroList()
									local useHeroBan = tCondition.useHeroBan or -1 --禁用英雄条件表
									
									if (type(useHeroBan) == "table") then
										--如果禁用英雄条件表包含多个英雄，那么这些英雄必须全不携带才算符合条件
										for h = 1, #useHeroBan, 1 do
											local heroId_Ban = useHeroBan[h]
											for c = 1, #allHero, 1 do
												if (allHero[c] == heroId_Ban) then
													isHeroBanOK = false
													print("  heroId_Ban=", allHero[c])
													break
												end
											end
											
											--已发现携带了禁用英雄，不需要继续检测后续英雄，直接跳出循环
											if (not isHeroBanOK) then
												break
											end
										end
									elseif (type(useHeroBan) == "number") then
										if (useHeroBan > 0) then
											for c = 1, #allHero, 1 do
												if (allHero[c] == useHeroBan) then
													isHeroBanOK = false
													break
												end
											end
										elseif (useHeroBan == -1) then --不限禁用英雄
											--isHeroBanOK = true
										end
									end
									print("  isHeroBanOK=", isHeroBanOK)
									
									--禁用英雄一致
									if isHeroBanOK then
										--检测英雄死亡次数是否符合条件
										local isHeroDeathOK = false
										local heroDeathCountMax = tCondition.heroDeathCountMax or -1 --英雄死亡次数最大值
										local me = world:GetPlayerMe()
										local upos = me:getpos()
										local currentDeathCount = world.data.statistics.deadCount[upos] or 0 --当前英雄死亡次数
										if (heroDeathCountMax > 0) then
											if (currentDeathCount <= heroDeathCountMax) then
												isHeroDeathOK = true
											end
										elseif (heroDeathCountMax == -1) then --不限英雄死亡次数
											isHeroDeathOK = true
										end
										print("  heroDeathCountMax=", heroDeathCountMax)
										print("  currentDeathCount=", currentDeathCount)
										print("  isHeroDeathOK=", isHeroDeathOK)
										
										--英雄死亡次数一致
										if isHeroDeathOK then
											--检测使用指定几个英雄是否符合条件
											local isHeroIncludeOK = false
											--local allHero = world:GetSelectedHeroList()
											local tUseHeroInclude = tCondition.useHeroInclude or -1 --出场指定几个英雄条件表
											
											if (type(tUseHeroInclude) == "table") then
												local tUseHero = tUseHeroInclude.heros or {} --指定英雄列表
												local requireNum = tUseHeroInclude.num or 0 --指定数量
												print("  requireNum=", requireNum)
												local currentNum = 0 --当前已携带英雄的数量
												for h = 1, #tUseHero, 1 do
													local heroId = tUseHero[h]
													for c = 1, #allHero, 1 do
														if (allHero[c] == heroId) then
															currentNum = currentNum + 1
															break
														end
													end
												end
												
												print("  currentNum=", currentNum)
												--需要的英雄全部携带，才算符合条件
												if (currentNum >= requireNum) then
													isHeroIncludeOK = true
												end
											else --无限制
												isHeroIncludeOK = true
											end
											print("  isHeroIncludeOK=", isHeroIncludeOK)
											
											--指定几个英雄一致
											if isHeroIncludeOK then
												--检测通关时间是否符合条件
												local isGameTimeOK = false
												local gameTimeMax = tCondition.gameTimeMax or -1 --最长通关时间（单位:秒）
												local gameTimeNow = math.ceil(world:gametime() / 1000) --当前通关时间
												if (gameTimeMax > 0) then
													if (gameTimeNow <= gameTimeMax) then
														isGameTimeOK = true
													end
												elseif (gameTimeMax == -1) then --不限通关时间
													isGameTimeOK = true
												end
												print("  gameTimeMax=", gameTimeMax)
												print("  gameTimeNow=", gameTimeNow)
												print("  isGameTimeOK=", isGameTimeOK)
												
												--通关时间一致
												if isGameTimeOK then
													--检测生命点数是否符合条件
													local isLifeOK = false
													local lifeMin = tCondition.lifeMin or -1 --最小生命点数
													local nForceMe = me:getforce() --我的势力
													local forcePlayer = world:GetForce(nForceMe)
													local lifeNow = forcePlayer:getresource(hVar.RESOURCE_TYPE.LIFE) or 0 --当前生命点数
													if (lifeNow > 0) then
														if (lifeNow >= lifeMin) then
															isLifeOK = true
														end
													elseif (lifeNow == -1) then --不限生命点数
														isLifeOK = true
													end
													print("  lifeMin=", lifeMin)
													print("  lifeNow=", lifeNow)
													print("  isLifeOK=", isLifeOK)
													
													--生命点数一致
													if isLifeOK then
														--检测携带装备是否符合条件
														local isEquipOK = false
														local heros = me.heros
														local tUseItem = tCondition.useItem or -1 --携带装备条件表
														
														if (type(tUseItem) == "table") then
															--如果携带装备条件表包含多个装备，那么这些装备必须全携带才算符合条件
															local requireNum = #tUseItem --需要携带指定装备的数量
															print("  requireNum=", requireNum)
															local currentNum = 0 --当前已携带指定装备的数量
															for e = 1, #tUseItem, 1 do
																local itemId = tUseItem[e]
																local itemIdFindFlag = false --本次装备是否找到
																for h = 1, #heros, 1 do
																	local oHero = heros[h]
																	local tEquipment = oHero.data.equipment
																	for i = 1, #tEquipment, 1 do
																		local oItem = tEquipment[i]
																		if oItem and (oItem ~= 0) then
																			local oId = oItem[hVar.ITEM_DATA_INDEX.ID]
																			if (oId == itemId) then
																				itemIdFindFlag = true
																				currentNum = currentNum + 1
																				break
																			end
																		end
																	end
																	
																	--本次装备已找到，不需要继续查找下个英雄
																	if itemIdFindFlag then
																		break
																	end
																end
															end
															
															print("  currentNum=", currentNum)
															--需要的英雄全部携带，才算符合条件
															if (currentNum >= requireNum) then
																isEquipOK = true
															end
														elseif (type(tUseItem) == "number") then
															if (tUseItem > 0) then
																local itemIdFindFlag = false --本次装备是否找到
																for h = 1, #heros, 1 do
																	local oHero = heros[h]
																	local tEquipment = oHero.data.equipment
																	for i = 1, #tEquipment, 1 do
																		local oItem = tEquipment[i]
																		if oItem and (oItem ~= 0) then
																			local oId = oItem[hVar.ITEM_DATA_INDEX.ID]
																			if (oId == tUseItem) then
																				itemIdFindFlag = true
																				currentNum = currentNum + 1
																				break
																			end
																		end
																	end
																	
																	--本次装备已找到，不需要继续查找下个英雄
																	if itemIdFindFlag then
																		break
																	end
																end
															elseif (tUseItem == -1) then --不限装备
																isEquipOK = true
															end
														end
														print("  isEquipOK=", isEquipOK)
														
														--装备一致
														if isEquipOK then
															--检测地图里的指定塔数量是否符合条件
															local isTowerOK = false
															local tBuildTower = tCondition.buildTower or -1 --地图内塔建造次数表
															if (type(tBuildTower) == "table") then
																local towerId = tBuildTower.towerId or 0 --塔类战术卡id
																local towerNum = tBuildTower.towerNum or 0 --塔数量
																local towerCurrentNum = 0
																if (towerId > 0) then
																	local tabT = hVar.tab_tactics[towerId]
																	if tabT then
																		local remouldUnlock = tabT.remouldUnlock
																		if remouldUnlock then
																			--依次遍历每个需要检测的塔的总数量
																			world:enumunit(function(eu)
																				if (eu.data.type == hVar.UNIT_TYPE.TOWER) and (eu:getowner() == me) then --我的塔
																					local euId = eu.data.id
																					local bFindTower = false
																					for r = 1, #remouldUnlock, 1 do
																						local tRe = remouldUnlock[r]
																						if (type(tRe) == "table") then
																							for t = 1, #tRe, 1 do
																								if (tRe[t] == euId) then
																									bFindTower = true
																									break
																								end
																							end
																						end
																						
																						if bFindTower then
																							break
																						end
																					end
																					
																					if bFindTower then
																						towerCurrentNum = towerCurrentNum + 1
																					end
																				end
																			end)
																		end
																	end
																end
																
																print("  towerId=", towerId)
																print("  towerNum=", towerNum)
																print("  towerCurrentNum=", towerCurrentNum)
																
																--当前地图内指定塔数量达到需要数量
																if (towerCurrentNum >= towerNum) then
																	isTowerOK = true
																end
															else --无限制
																isTowerOK = true
															end
															print("  isTowerOK=", isTowerOK)
															
															--塔数量一致
															if isTowerOK then
																--检测携带战术卡是否符合条件
																local isTacticOK = false
																local useTactic = tCondition.useTactic --使用战术卡条件表
																if (type(useTactic) == "number") then
																	useTactic = {useTactic,}
																end
																
																if (type(useTactic) == "table") then
																	local requireNum = #useTactic --需要携带战术卡的数量
																	print("  requireNum=", requireNum)
																	local currentNum = 0 --当前已携带战术卡的数量
																	
																	--将携带的战术卡转字典
																	local tUseTacticDic = {}
																	
																	--统计开场携带的战术卡
																	--local me = world:GetPlayerMe()
																	--local upos = me:getpos()
																	local tTactics = world:gettactics(upos) --本局所有的战术技能卡
																	for i = 1, #tTactics, 1 do
																		--print(i, "tTactics[i]=", tTactics[i])
																		if tTactics[i]~=0 then
																			local id, lv, typeId = tTactics[i][1], tTactics[i][2], tTactics[i][3]
																			tUseTacticDic[id] = lv
																			--print("开场携带的战术卡", id, lv)
																		end
																	end
																	
																	--统计本局抽到的战术卡
																	local tPlayerInfo = world.data.endless_build_tactics[upos]
																	if tPlayerInfo then
																		local perWave = tPlayerInfo.perWave
																		if perWave then
																			--遍历每波的选卡
																			for wave = 1, #perWave, 1 do
																				local tacticId = perWave[wave].id --战术卡id
																				local tacticLv = perWave[wave].lv --战术卡lv
																				tUseTacticDic[tacticId] = tacticLv
																				--print("遍历每波的选卡", tacticId, tacticLv)
																			end
																		end
																	end
																	
																	--依次遍历是否符合条件
																	for i = 1, #useTactic, 1 do
																		local tacticId = useTactic[i]
																		print("  tacticId=", tacticId)
																		if tUseTacticDic[tacticId] then --已携带
																			currentNum = currentNum + 1
																		end
																	end
																	
																	print("  currentNum=", currentNum)
																	--需要的战术卡全部携带，才算符合条件
																	if (currentNum >= requireNum) then
																		isTacticOK = true
																	end
																else --无限制
																	isTacticOK = true
																end
																print("  isTacticOK=", isTacticOK)
																
																--携带战术卡一致
																if isTacticOK then
																	--检测漏怪是否符合条件
																	local isEscapeEnemyOK = true
																	local escapeEnemy = tCondition.escapeEnemy --漏怪条件表
																	if (type(escapeEnemy) == "table") then
																		local typeId = escapeEnemy.typeId --漏怪id
																		local maxCount = escapeEnemy.maxCount --漏怪最大次数
																		local EscapeUnits = world.data.statistics.EscapeUnits --本局漏怪信息表
																		local escapeNum = EscapeUnits[typeId] or 0
																		print("  typeId=", typeId)
																		print("  maxCount=", maxCount)
																		print("  escapeNum=", escapeNum)
																		if (escapeNum > maxCount) then
																			isEscapeEnemyOK = false
																		end
																	else --无限制
																		--isEscapeEnemyOK = true
																	end
																	print("  isEscapeEnemyOK=", isEscapeEnemyOK)
																	
																	--漏怪一致
																	if isEscapeEnemyOK then
																		--达成全部条件
																		finishTag = 1
																		print("  达成全部条件")
																		
																		--一些属性位的特殊处理
																		if (tx == hVar.TREASURE_ATTR.QUNYINGGE_WINCOUNT_PURPLECARD_NUM) then --群英阁、人族无敌胜利抽到紫卡数量
																			--统计本地抽到紫卡的数量
																			local purpleNum = 0
																			--local me = world:GetPlayerMe()
																			--local upos = me:getpos()
																			local tPlayerInfo = world.data.endless_build_tactics[upos]
																			if tPlayerInfo then
																				local perWave = tPlayerInfo.perWave
																				if perWave then
																					--遍历每波的选卡
																					for wave = 1, #perWave, 1 do
																						local tacticId = perWave[wave].id --战术卡id
																						local tacticLv = perWave[wave].lv --战术卡lv
																						local tabT = hVar.tab_tactics[tacticId]
																						if tabT then
																							if (tabT.quality == hVar.ENDLESS_TACTICCARD_COLOR.RED) then --紫卡
																								purpleNum = purpleNum + 1
																							end
																						end
																					end
																				end
																			end
																			
																			print("  purpleNum=", purpleNum)
																			finishTag = purpleNum
																		end
																	end
																end
															end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			else --地图之外的统计数据
				if (tx == hVar.TREASURE_ATTR.HERO_COUNT_WEI) then --魏国英雄总数量
					local weiNum = 0 --魏国英雄总数量
					local tHeroCards = Save_PlayerData.herocard --我的英雄数据
					for i = 1, #hVar.HERO_AVAILABLE_LIST, 1 do
						local id = hVar.HERO_AVAILABLE_LIST[i].id
						local tabU = hVar.tab_unit[id]
						local role_country = tabU.role_country
						if (role_country == hVar.BUILDING_COUNTRY.WEI) then --魏国
							if tHeroCards then
								for i = 1, #tHeroCards, 1 do
									if (type(tHeroCards[i]) == "table") then
										local typeId = tHeroCards[i].id
										if (typeId == id) then --找到了
											weiNum = weiNum + 1
											break
										end
									end
								end
							end
						end
					end
					
					print("  weiNum=", weiNum)
					finishTag = weiNum
					
				elseif (tx == hVar.TREASURE_ATTR.HERO_COUNT_FEMALE) then --女性英雄总数量
					local femaleNum = 0 --女性英雄总数量
					local tHeroCards = Save_PlayerData.herocard --我的英雄数据
					for i = 1, #hVar.HERO_AVAILABLE_LIST, 1 do
						local id = hVar.HERO_AVAILABLE_LIST[i].id
						local tabU = hVar.tab_unit[id]
						local role_sex = tabU.role_sex
						if (role_sex == hVar.ROLE_SEX.FEMALE) then --女性
							if tHeroCards then
								for i = 1, #tHeroCards, 1 do
									if (type(tHeroCards[i]) == "table") then
										local typeId = tHeroCards[i].id
										if (typeId == id) then --找到了
											femaleNum = femaleNum + 1
											break
										end
									end
								end
							end
						end
					end
					print("  femaleNum=", femaleNum)
					finishTag = femaleNum
					
				elseif (tx == hVar.TREASURE_ATTR.TOWER_COUNT_LV5) then --五级塔总数量
					local towerNum = 0 --五级塔总数量
					local tTactics = LuaGetPlayerSkillBook()
					if tTactics then
						for i = 1,#tTactics, 1 do
							if type(tTactics[i])=="table" then
								local id, lv, num = unpack(tTactics[i])
								
								--存在表项
								if hVar.tab_tactics[id] then
									local type = hVar.tab_tactics[id].type --战术技能卡类型
									if (type == hVar.TACTICS_TYPE.TOWER) or (type == hVar.TACTICS_TYPE.SPECIAL) then --此类专属于塔、特种塔类战术技能卡，放在此处
										--5级
										if (lv == 5) then
											towerNum = towerNum + 1
										end
									end
								end
							end
						end
					end
					
					print("  towerNum=", towerNum)
					finishTag = towerNum
					
				elseif (tx == hVar.TREASURE_ATTR.CHAPTER_UNLOCKED_NUM) then --解锁章节总数量
					local chapterNum = 0 --解锁章节总数量
					for i = 1, #hVar.tab_chapter do
						local tabChapter = hVar.tab_chapter[i]
						local lastmap = tabChapter.lastmap --最后一关
						local isFinishMap = (LuaGetPlayerMapAchi(lastmap, hVar.ACHIEVEMENT_TYPE.LEVEL) or 0) --是否通关
						if (isFinishMap == 1) then --已通关最后一关
							chapterNum = chapterNum + 1
						else --未通关最后一关
							chapterNum = chapterNum + 1
							
							break
						end
					end
					
					print("  chapterNum=", chapterNum)
					finishTag = chapterNum
					
				elseif (tx == hVar.TREASURE_ATTR.HERO_COUNT_LV15) then --15级英雄总数量
					local heroLv15Num = 0 --15级英雄总数量
					local tHeroCards = Save_PlayerData.herocard --我的英雄数据
					for i = 1, #hVar.HERO_AVAILABLE_LIST, 1 do
						local id = hVar.HERO_AVAILABLE_LIST[i].id
						if tHeroCards then
							for i = 1, #tHeroCards, 1 do
								if (type(tHeroCards[i]) == "table") then
									local typeId = tHeroCards[i].id
									if (typeId == id) then --找到了
										if (tHeroCards[i].attr.level >= 15) then --15级
											heroLv15Num = heroLv15Num + 1
										end
										
										break
									end
								end
							end
						end
					end
					print("  heroLv15Num=", heroLv15Num)
					finishTag = heroLv15Num
					
				end
			end
		end
		
		print("  finishTag=", finishTag)
		tTreasureAttrTag[tx] = finishTag
	end
	
	return tTreasureAttrTag
end

--获得宝物的收藏评分
hApi.GetTreasureScore = function()
	local totalscore = 0
	
	local treasure = LuaGetTreasureBook() --宝物表
	if (type(treasure) == "table") then
		for tr = 1, #treasure, 1 do
			local id = treasure[tr][1] --宝物id
			local star = treasure[tr][2] --宝物星级
			local num = treasure[tr][3] --宝物碎片数量
			local score = 0
			
			if (star > 0) then
				local tabTreasure = hVar.tab_treasure[id]
				if tabTreasure then
					--每获得一个宝物 + 10分
					--每获得一个高级宝物 + 20分
					--宝物每升1颗星 +2分
					local quality = tabTreasure.quality or 0 --品质
					score = score + quality * 10 + (star - 1) * 2
					
					--升满5星额外 + 10分
					if (star == hVar.TREASURE_LVUP_INFO.maxTreasureLv) then
						score = score + 10
					end
				end
			end
			
			totalscore = totalscore + score
		end
	end
	
	return totalscore
end

--获取公告
hApi.RequestAnnouncement = function()
	local iChannelId = xlGetChannelId()
	--内网固定取100
	if g_lua_src == 1 then
		iChannelId = 100
	end
	local url = string.format("http://update.xingames.com/config_tank.php?cid=%d",iChannelId)
	xlHttpClient_Get(url,"announcement")
end

--获取测试公告
hApi.RequestTestAnnouncement = function()
	if (g_is_account_test == 2 or g_lua_src == 1) then
		g_AnnouncementTest = 1
		local url = string.format("http://update.xingames.com/config_tank.php?cid=%d",999)
		xlHttpClient_Get(url,"announcement")
	end
end

--创建二选一的框
--创建2选1的框
function hApi.ShowSelectMsgBox(num, ...)
	--先清除上一次的英雄将魂说明面板
	if hGlobal.UI.HeroWakenTipFrame then
		hGlobal.UI.HeroWakenTipFrame:del()
		hGlobal.UI.HeroWakenTipFrame = nil
	end
	
	--移除事件监听：收到请求挑战普通剧情地图结果返回
	hGlobal.event:listen("LocalEvent_RequireBattleNormalRet", "__RequireBattleMsgBoxlRet", nil)
	
	local on_receive_require_battle_normal_ret = hApi.DoNothing --收到请求挑战普通剧情地图事件返回
	local currentIdx = 0
	
	
	local arg = {...}
	
	--创建战术卡说明tip
	hGlobal.UI.HeroWakenTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = 100009,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--
				
			end
		end,
	})
	hGlobal.UI.HeroWakenTipFrame:active()

	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2
	
	local IMGBG_WIDTH = hVar.SCREEN.w
	local IMGBG_HEIGHT = hVar.SCREEN.h
	
	local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", _offX, _offY, IMGBG_WIDTH, IMGBG_HEIGHT, hGlobal.UI.HeroWakenTipFrame)
	img9:setOpacity(128)
	
	local _HeroDebrisTipParent = hGlobal.UI.HeroWakenTipFrame.handle._n
	local _HeroDebrisTipChildUI = hGlobal.UI.HeroWakenTipFrame.childUI
	
	--依次绘制按钮
	local BTN_WIDTH = 270 * 1.0
	local BTN_HEIGHT = 68 * 1.0
	local X_OFFSET = 64
	local Y_OFFSET = 0
	local BTN_LEFT = _offX - math.floor(num / 2) * (X_OFFSET + BTN_WIDTH) --第一个x坐标
	if ((num % 2) == 0) then --偶数
		BTN_LEFT = _offX - math.floor(num / 2) * (X_OFFSET + BTN_WIDTH) + (X_OFFSET + BTN_WIDTH) / 2
	end
	local BTN_TOP = _offY --第一个y坐标
	for i = 1, num ,1 do
		local tParam = arg[i] or {}
		
		--创建按钮
		_HeroDebrisTipChildUI["TacticIconBG_" .. i] = hUI.button:new({ --作为按钮是为了挂载子控件
			parent = _HeroDebrisTipParent,
			x = BTN_LEFT + (i - 1) * (X_OFFSET + BTN_WIDTH),
			y = BTN_TOP,
			w = BTN_WIDTH,
			h = BTN_HEIGHT,
			model = "misc/addition/cg.png",
			dragbox = hGlobal.UI.HeroWakenTipFrame.childUI["dragBox"],
			scaleT = 0.98,
			code = function()
				local tomap = tParam.tomap or ""
				local tomapmode = tParam.tomapmode or hVar.MAP_TD_TYPE.NORMAL
				hGlobal.event:event("Event_TurnToMap",tomap,tomapmode)
				if (tomap ~= "") then
					g_DisableShowOption = 0
					if (tomap ~= hVar.MainBase) then
						--记录idx
						currentIdx = i
						
						--挡操作
						hUI.NetDisable(30000)
						
						--发起请求，挑战普通剧情地图
						local MapDifficulty = 0
						SendCmdFunc["require_battle_normal"](tomap, MapDifficulty)
					else
						--禁止/允许游戏内的点击事件
						local bIngoreAction = true
						hApi.SetTouchEnable_Diablo(1, bIngoreAction)
						
						local w = hGlobal.WORLD.LastWorldMap
						local currentMapMode = w.data.tdMapInfo and (w.data.tdMapInfo.mapMode)
						local map = w.data.map
						local tabM = hVar.MAP_INFO[map]
						local chapterId = 1
						if tabM then
							chapterId = tabM.chapter or 1
						end
						
						--关闭同步日志文件
						hApi.SyncLogClose()
						--关闭非同步日志文件
						hApi.AsyncLogClose()
						
						--隐藏可能的选人界面
						if hGlobal.UI.PhoneSelectedHeroFrm2 then
							hGlobal.UI.PhoneSelectedHeroFrm2:show(0)
							hGlobal.UI.PhoneSelectedHeroFrmBG.handle.s:setVisible(false) --隐藏背景框挡板
							hApi.clearTimer("__SELECT_HERO_UPDATE__")
							hApi.clearTimer("__SELECT_TOWER_UPDATE__")
							hApi.clearTimer("__SELECT_TACTIC_UPDATE__")
						end
						
						--记录本局还未使用的道具技能
						local activeskill = {}
						local me = w:GetPlayerMe()
						local oHero = me.heros[1]
						--local typeId = oHero.data.id --英雄类型id
						local itemSkillT = oHero.data.itemSkillT
						if (itemSkillT) then
							for k = hVar.TANKSKILL_EMPTY + 1, #itemSkillT, 1 do
								local activeItemId = itemSkillT[k].activeItemId --主动技能的CD
								local activeItemLv = itemSkillT[k].activeItemLv --主动技能的等级
								local activeItemNum = itemSkillT[k].activeItemNum --主动技能的使用次数
								local activeItemCD = itemSkillT[k].activeItemCD --主动技能的CD
								local activeItemLastCastTime = itemSkillT[k].activeItemLastCastTime --主动技能的上次释放的时间（单位:秒）
								
								--存储
								activeskill[#activeskill+1] = {id = activeItemId, lv = activeItemLv, num = activeItemNum,}
							end
						end
						
						--记录本局武器等级
						local basic_weapon_level = 1
						local oUnit = oHero:getunit()
						if oUnit then
							if (oUnit.data.bind_weapon ~= 0) then
								basic_weapon_level = oUnit.data.bind_weapon.attr.attack[6]
							end
						end
						
						--记录本局还存在的宠物
						local follow_pet_units = {}
						--geyachao: 大菠萝瓦力传送
						local rpgunits = w.data.rpgunits
						for u, u_worldC in pairs(rpgunits) do
							for _, walle_id in ipairs(hVar.MY_TANK_FOLLOW_ID) do
								if (u.data.id == walle_id) then
									follow_pet_units[#follow_pet_units+1] = {id = u.data.id, lv = u.attr.lv, star = u.attr.star,}
								end
							end
						end
						
						--记录本局营救科学家的数据
						local statistics_rescue_count = w.data.statistics_rescue_count --大菠萝营救的科学家数量(随机关单局数据)
						local statistics_rescue_num = w.data.statistics_rescue_num --大菠萝营救的科学家数量(随机关累加数据)
						local statistics_rescue_costnum = w.data.statistics_rescue_costnum --大菠萝营救的科学家消耗数量
						
						if (hGlobal.WORLD.LastWorldMap ~= nil) then
							hGlobal.WORLD.LastWorldMap:del()
							
							hGlobal.LocalPlayer:setfocusworld(nil)
							hApi.clearCurrentWorldScene()
						end
						
						--大菠萝数据初始化
						--geyachao: 对话2选1，复用本局的大菠萝数据
						--hGlobal.LocalPlayer.data.diablodata = LuaInitDiabloData()
						hGlobal.LocalPlayer.data.diablodata.activeskill = activeskill --坦克的上一局主动技能
						hGlobal.LocalPlayer.data.diablodata.basic_weapon_level = basic_weapon_level --坦克的上一局武器等级
						hGlobal.LocalPlayer.data.diablodata.follow_pet_units = follow_pet_units --坦克的上一局的宠物
						hGlobal.LocalPlayer.data.diablodata.statistics_rescue_count = statistics_rescue_count --营救的科学家数量(随机关单局数据)
						hGlobal.LocalPlayer.data.diablodata.statistics_rescue_num = statistics_rescue_num --营救的科学家数量(随机关累加数据)
						hGlobal.LocalPlayer.data.diablodata.statistics_rescue_costnum = statistics_rescue_costnum --营救的科学家消耗数量
						--战术卡信息
						hGlobal.LocalPlayer.data.diablodata.tTacticInfo = nil
						--宝箱信息
						hGlobal.LocalPlayer.data.diablodata.tChestInfo = nil
						--战车生命百分比
						hGlobal.LocalPlayer.data.diablodata.hpRate = nil
						--随机迷宫层数和小关数
						hGlobal.LocalPlayer.data.diablodata.randommapStage = nil
						hGlobal.LocalPlayer.data.diablodata.randommapIdx = nil
						
						--清除界面
						if hGlobal.UI.HeroWakenTipFrame then
							hGlobal.UI.HeroWakenTipFrame:del()
							hGlobal.UI.HeroWakenTipFrame = nil
						end
						
						--移除事件监听：收到请求挑战普通剧情地图结果返回
						hGlobal.event:listen("LocalEvent_RequireBattleNormalRet", "__RequireBattleMsgBoxlRet", nil)
						
						--切换到配置坦克地图
						--[[
						local mapname = tomap
						local MapDifficulty = 0
						local MapMode = tomapmode --地图模式
						xlScene_LoadMap(g_world, mapname, MapDifficulty, MapMode)
						]]
						local mapname = tomap
						if (mapname == hVar.MainBase) then
							GameManager.GameStart(hVar.GameType.MAINBASS)
						else
							--随机迷宫地图
							local data2 = hApi.ReadParamWithDepth(hGlobal.LocalPlayer.data.diablodata,nil,{},10)
							GameManager.GameStart(hVar.GameType.FOURSR, data2)
						end
					end
				end
			end,
		})
		--按钮文字
		_HeroDebrisTipChildUI["TacticIconBG_" .. i].childUI["name"] = hUI.label:new({
			parent = _HeroDebrisTipChildUI["TacticIconBG_" .. i].handle._n,
			x = 0,
			y = 2,
			width = 300,
			size = tParam.size or 28,
			border = 1,
			text = tParam.text or "",
			font = hVar.FONTC,
			align = "MC",
		})
	end
	
	--函数：收到请求挑战普通剧情地图事件返回
	on_receive_require_battle_normal_ret = function(result, pvpcoin, mapName, mapDiff, battlecfg_id)
		--print("on_receive_require_battle_normal_ret", result, pvpcoin, mapName, mapDiff, battlecfg_id)
		
		--操作成功
		if (result == 1) then
			local tParam = arg[currentIdx] or {}
			
			--禁止/允许游戏内的点击事件
			local bIngoreAction = true
			hApi.SetTouchEnable_Diablo(1, bIngoreAction)
			
			local w = hGlobal.WORLD.LastWorldMap
			local currentMapMode = w.data.tdMapInfo and (w.data.tdMapInfo.mapMode)
			local map = w.data.map
			local tabM = hVar.MAP_INFO[map]
			local chapterId = 1
			if tabM then
				chapterId = tabM.chapter or 1
			end
			
			--关闭同步日志文件
			hApi.SyncLogClose()
			--关闭非同步日志文件
			hApi.AsyncLogClose()
			
			--隐藏可能的选人界面
			if hGlobal.UI.PhoneSelectedHeroFrm2 then
				hGlobal.UI.PhoneSelectedHeroFrm2:show(0)
				hGlobal.UI.PhoneSelectedHeroFrmBG.handle.s:setVisible(false) --隐藏背景框挡板
				hApi.clearTimer("__SELECT_HERO_UPDATE__")
				hApi.clearTimer("__SELECT_TOWER_UPDATE__")
				hApi.clearTimer("__SELECT_TACTIC_UPDATE__")
			end
			
			--记录本局还未使用的道具技能
			local activeskill = {}
			local me = w:GetPlayerMe()
			local oHero = me.heros[1]
			--local typeId = oHero.data.id --英雄类型id
			local itemSkillT = oHero.data.itemSkillT
			if (itemSkillT) then
				for k = hVar.TANKSKILL_EMPTY + 1, #itemSkillT, 1 do
					local activeItemId = itemSkillT[k].activeItemId --主动技能的CD
					local activeItemLv = itemSkillT[k].activeItemLv --主动技能的等级
					local activeItemNum = itemSkillT[k].activeItemNum --主动技能的使用次数
					local activeItemCD = itemSkillT[k].activeItemCD --主动技能的CD
					local activeItemLastCastTime = itemSkillT[k].activeItemLastCastTime --主动技能的上次释放的时间（单位:秒）
					
					--存储
					activeskill[#activeskill+1] = {id = activeItemId, lv = activeItemLv, num = activeItemNum,}
				end
			end
			
			--记录本局武器等级
			local basic_weapon_level = 1
			local oUnit = oHero:getunit()
			if oUnit then
				if (oUnit.data.bind_weapon ~= 0) then
					basic_weapon_level = oUnit.data.bind_weapon.attr.attack[6]
				end
			end
			
			--记录本局还存在的宠物
			local follow_pet_units = {}
			--geyachao: 大菠萝瓦力传送
			local rpgunits = w.data.rpgunits
			for u, u_worldC in pairs(rpgunits) do
				for _, walle_id in ipairs(hVar.MY_TANK_FOLLOW_ID) do
					if (u.data.id == walle_id) then
						follow_pet_units[#follow_pet_units+1] = {id = u.data.id, lv = u.attr.lv, star = u.attr.star,}
					end
				end
			end
			
			--记录本局营救科学家的数据
			local statistics_rescue_count = w.data.statistics_rescue_count --大菠萝营救的科学家数量(随机关单局数据)
			local statistics_rescue_num = w.data.statistics_rescue_num --大菠萝营救的科学家数量(随机关累加数据)
			local statistics_rescue_costnum = w.data.statistics_rescue_costnum --大菠萝营救的科学家消耗数量
			local weapon_attack_state = w.data.weapon_attack_state --自动开枪标记
			
			if (hGlobal.WORLD.LastWorldMap ~= nil) then
				hGlobal.WORLD.LastWorldMap:del()
				
				hGlobal.LocalPlayer:setfocusworld(nil)
				hApi.clearCurrentWorldScene()
			end
			
			--大菠萝数据初始化
			--geyachao: 对话2选1，复用本局的大菠萝数据
			--hGlobal.LocalPlayer.data.diablodata = LuaInitDiabloData()
			hGlobal.LocalPlayer.data.diablodata.activeskill = activeskill --坦克的上一局主动技能
			hGlobal.LocalPlayer.data.diablodata.basic_weapon_level = basic_weapon_level --坦克的上一局武器等级
			hGlobal.LocalPlayer.data.diablodata.follow_pet_units = follow_pet_units --坦克的上一局的宠物
			hGlobal.LocalPlayer.data.diablodata.statistics_rescue_count = statistics_rescue_count --营救的科学家数量(随机关单局数据)
			hGlobal.LocalPlayer.data.diablodata.statistics_rescue_num = statistics_rescue_num --营救的科学家数量(随机关累加数据)
			hGlobal.LocalPlayer.data.diablodata.statistics_rescue_costnum = statistics_rescue_costnum --营救的科学家消耗数量
			--命恢复满
			hGlobal.LocalPlayer.data.diablodata.lifecount = hVar.DEFAULT_LIFT_NUM
			hGlobal.LocalPlayer.data.diablodata.deathcount = 0
			hGlobal.LocalPlayer.data.diablodata.canbuylife = hVar.CAN_BUY_LIFE_NUM
			--自动开枪标记
			hGlobal.LocalPlayer.data.diablodata.weapon_attack_state = weapon_attack_state
			--战术卡信息
			hGlobal.LocalPlayer.data.diablodata.tTacticInfo = nil
			--宝箱信息
			hGlobal.LocalPlayer.data.diablodata.tChestInfo = nil
			--战车生命百分比
			hGlobal.LocalPlayer.data.diablodata.hpRate = nil
			--随机迷宫层数和小关数
			hGlobal.LocalPlayer.data.diablodata.randommapStage = nil
			hGlobal.LocalPlayer.data.diablodata.randommapIdx = nil
			
			--清除界面
			if hGlobal.UI.HeroWakenTipFrame then
				hGlobal.UI.HeroWakenTipFrame:del()
				hGlobal.UI.HeroWakenTipFrame = nil
			end
			
			--移除事件监听：收到请求挑战普通剧情地图结果返回
			hGlobal.event:listen("LocalEvent_RequireBattleNormalRet", "__RequireBattleMsgBoxlRet", nil)
			
			--切换到配置坦克地图
			--[[
			local mapname = tomap
			local MapDifficulty = 0
			local MapMode = tomapmode --地图模式
			xlScene_LoadMap(g_world, mapname, MapDifficulty, MapMode)
			]]
			local mapname = tomap
			local banLimitTable = {battlecfg_id = battlecfg_id,}
			--print(mapName, mapDiff, battlecfg_id)
			xlScene_LoadMap(g_world, mapName, mapDiff, tParam.tomapmode, nil, banLimitTable)
		end
	end
	
	--添加事件监听：收到请求挑战普通剧情地图结果返回
	hGlobal.event:listen("LocalEvent_RequireBattleNormalRet", "__RequireBattleMsgBoxlRet", on_receive_require_battle_normal_ret)
	
	--标记新手图通关
	LuaSetPlayerMapAchi(hVar.GuideMap, hVar.ACHIEVEMENT_TYPE.LEVEL, 1)
	
	--发红装
	--SendCmdFunc["guide_add_redequip"]()
	
	--上传游戏结束数据到服务器（引导图，黑龙对话）
	local nIsWin = 1
	local maxStar = 3
	local expAdd = 0
	hApi.SendGameResultInfo(nIsWin, maxStar, expAdd)
	
	--清空
	GameManager.SetGameInfo("tacticInfo","clear")
	GameManager.SetGameInfo("chestInfo","clear")
	GameManager.SetGameInfo("ckscore","clear")
	hGlobal.WORLD.LastWorldMap.data.statistics_rescue_count = 0
	hGlobal.WORLD.LastWorldMap.data.statistics_rescue_num = 0
	
	--存档
	--"二选一界面"
	local keyList = {"skill","card","map","bag", "material", "log",}
	LuaSavePlayerData_Android_Upload(keyList, "二选一界面")
end
--hApi.ShowSelectMsgBox(2, {text = "继续探险", size = 28, tomap = "world/csys_001", tomapmode = hVar.MAP_TD_TYPE.NORMAL,}, {text = "跟随黑龙", size = 28, tomap = hVar.MainBase, tomapmode = hVar.MAP_TD_TYPE.TANKCONFIG,})

hApi.RecordLastLoginType = function(key)
	--记录最后一次登录方式
	g_AccountAutoLogin = {
		key = key,
	}
	local str = "g_AccountAutoLogin =" .. TableToString(g_AccountAutoLogin)
	xlSaveGameData(g_localfilepath.."account_antologin.cfg",str)
end

hApi.RecordPhoneLoginInfo = function(md5)
	g_phonelogin = {
		md5 = md5,
	}
	local str = "g_phonelogin =" .. TableToString(g_phonelogin)
	xlSaveGameData(g_localfilepath.."phonelogin.cfg",str)
end

hApi.RecordIosLoginInfo = function(md5)
	g_ioslogin = {
		md5 = md5,
	}
	local str = "g_ioslogin =" .. TableToString(g_ioslogin)
	xlSaveGameData(g_localfilepath.."ioslogin.cfg",str)
end

hApi.RecordLoginInfo = function(stype,md5)
	if stype == "wx" then
		g_wxlogin = {
			md5 = md5,
		}
		local str = "g_wxlogin =" .. TableToString(g_wxlogin)
		xlSaveGameData(g_localfilepath.."wxlogin.cfg",str)
	elseif stype == "qq" then
		g_qqlogin = {
			md5 = md5,
		}
		local str = "g_qqlogin =" .. TableToString(g_qqlogin)
		xlSaveGameData(g_localfilepath.."qqlogin.cfg",str)
	end
end

hApi.RecordNoQueryPermissionProcess = function(nState)
	g_noQueryPermission = {
		state = nState,
	}
	local str = "g_noQueryPermission =" .. TableToString(g_ioslogin)
	xlSaveGameData(g_localfilepath.."noQueryPermission.cfg",str)
end

--读取所有本地文件
hApi.ReadLocalFile = function()
	if hApi.FileExists(g_localfilepath.."account_antologin.cfg","full") then
		xlLoadGameData(g_localfilepath.."account_antologin.cfg")
	else
		--预加载
		hGlobal.event:event("LocalEvent_CreatePrivacyAgreementFrm_async")
		hGlobal.event:event("LocalEvent_CreateProtocolAgreementFrm_async")
	end
	if hApi.FileExists(g_localfilepath.."phonelogin.cfg","full") then
		xlLoadGameData(g_localfilepath.."phonelogin.cfg")
	end
	if hApi.FileExists(g_localfilepath.."ioslogin.cfg","full") then
		xlLoadGameData(g_localfilepath.."ioslogin.cfg")
	end
	if hApi.FileExists(g_localfilepath.."wxlogin.cfg","full") then
		xlLoadGameData(g_localfilepath.."wxlogin.cfg")
	end
	if hApi.FileExists(g_localfilepath.."qqlogin.cfg","full") then
		xlLoadGameData(g_localfilepath.."qqlogin.cfg")
	end
	if hApi.FileExists(g_localfilepath.."noQueryPermission.cfg","full") then
		xlLoadGameData(g_localfilepath.."noQueryPermission.cfg")
	end
	if hApi.FileExists(g_localfilepath.."allowprivacy.cfg","full") then
		xlLoadGameData(g_localfilepath.."allowprivacy.cfg")
	else
		g_AllowPrivacy = 0
		
		--geyachao: 应王总要求，苹果版本，默认都是开隐藏勾勾狂启勾选，并且选中框，点了也没反应
		local iChannelId = getChannelInfo()
		if (iChannelId == 1) then
			g_AllowPrivacy = 1
		end
	end
	hGlobal.event:event("LocalEvent_InitNewGuestLoginInfo")
end

hApi.RotateScreen = function(mode)
	if mode == 1 or mode == 2 then	--竖屏
		hVar.SCREEN_MODE = hVar.SCREEN_MODE_DEFINE.VERTICAL
	elseif mode == 3 or mode == 4 then	--横屏
		hVar.SCREEN_MODE = hVar.SCREEN_MODE_DEFINE.HORIZONTAL
	else
		return
	end

	if type(xlSetOrientation) == "function" then
		xlSetOrientation(mode)
		--xlSetScreenSize(hVar.SCREEN.w, hVar.SCREEN.h)
		if hVar.SCREEN_MODE == hVar.SCREEN_MODE_DEFINE.VERTICAL then
			xlSetScreenSize(hVar.SCREEN.h, hVar.SCREEN.w)
		elseif hVar.SCREEN_MODE == hVar.SCREEN_MODE_DEFINE.HORIZONTAL then
			xlSetScreenSize(hVar.SCREEN.w, hVar.SCREEN.h)
		end
	end
end

--------------------------------------------------------------------------------------
--临时函数
--[[
--游戏内存储数据
LuaSetPlayerTempGameInfoByType2 = function(strType, key, value)
	local db = hGlobal.LocalPlayer.data.diablodata
	if (db == nil) then
		db = LuaInitDiabloData()
		hGlobal.LocalPlayer.data.diablodata = db
	end
	
	local tInfo = db[strType]
	if (tInfo == nil) then
		tInfo = {}
		db[strType] = tInfo
	end
	
	tInfo[key] = value
end
]]

--[[
--游戏内读取数据
LuaGetPlayerTempGameInfoByType2 = function(strType, key)
	local db = hGlobal.LocalPlayer.data.diablodata
	if (db == nil) then
		db = LuaInitDiabloData()
		hGlobal.LocalPlayer.data.diablodata = db
	end
	
	local tInfo = db[strType]
	if (tInfo == nil) then
		tInfo = {}
		db[strType] = tInfo
	end
	
	return tInfo[key]
end
]]

--初始化大菠萝数据
LuaInitDiabloData = function()
	local diablodata =
	{
		bind_weapon = 0, --绑定的武器typeId
		score = 0, --得分
		lifecount = hVar.DEFAULT_LIFT_NUM, --命数量
		canbuylife = hVar.CAN_BUY_LIFE_NUM,--可以购买命的数量 
		deathcount = 0, --死亡次数
		deathscore = 0, --第一次死亡的得分
		tankbuffs = {}, --坦克的buff
		tankweaponbuffs = {}, --坦克的武器buff
		heros = {}, --坦克的英雄数据
	}
	
	--print(debug.traceback())
	
	return diablodata
end
--------------------------------------------------------------------------------------


--寻找目标点周围一个可造塔的坐标
--返回值: 是否成功, 重叠的单位, 坐标点x, 坐标点y
local _A1, _A2, _A3, _A4, _B1, _B2, _B3, _B4 = {}, {}, {}, {}, {}, {}, {}, {}
function hApi.FindNearbyPoint(worldX, worldY)
	worldX = math.floor((worldX) / 12) * 12
	worldY = math.floor((worldY) / 12) * 12
	
	local tPoints =
	{
		[1] = {worldX, worldY},
		[2] = {worldX - hVar.ROLE_COLLISION_EDGE, worldY},
		[3] = {worldX + hVar.ROLE_COLLISION_EDGE, worldY},
		[4] = {worldX, worldY - hVar.ROLE_COLLISION_EDGE},
		[5] = {worldX, worldY + hVar.ROLE_COLLISION_EDGE},
		[6] = {worldX - hVar.ROLE_COLLISION_EDGE, worldY - hVar.ROLE_COLLISION_EDGE},
		[7] = {worldX + hVar.ROLE_COLLISION_EDGE, worldY - hVar.ROLE_COLLISION_EDGE},
		[8] = {worldX - hVar.ROLE_COLLISION_EDGE, worldY + hVar.ROLE_COLLISION_EDGE},
		[9] = {worldX + hVar.ROLE_COLLISION_EDGE, worldY + hVar.ROLE_COLLISION_EDGE},
	}
	
	local nResult = hVar.CAST_POINT_SKILL_RESULT.NONE --是否成功
	local nResultX, nResultY = 0, 0 --坐标点x, 坐标点y
	local tCollapeUnit = nil --重叠的单位
	
	local nResult_0 = hVar.CAST_POINT_SKILL_RESULT.NONE --是否成功(第1个结果)
	local tCollapeUnit_0 = nil --重叠的单位(第1个结果)

	local w = hGlobal.WORLD.LastWorldMap
	local index = 0
	local TERRAIN_EDGE = 64 --纹理格子大小
	
	--print()
	for i = 1, #tPoints, 1 do
		local pointX = tPoints[i][1]
		local pointY = tPoints[i][2]
		
		--检测该点是否是障碍物
		local result = xlScene_IsGridBlock(g_world, pointX / 24, pointY / 24) --某个坐标是否是障碍
		--print("i=",i, "result=", result)
		if (result == 0) then
			--不是障碍，检测是否在水里
			result = hApi.IsPosInWater(pointX, pointY)
		end
		
		if (result >= 1) then --不能到达
			--无效的目标点
			nResult = hVar.CAST_POINT_SKILL_RESULT.INVALID_POINT
			
			--存储第1个结果
			if (i == 1) then
				nResult_0 = hVar.CAST_POINT_SKILL_RESULT.INVALID_POINT --是否成功(第1个结果)
			end
		else
			--相交的单位
			local collapseUnit = nil
			
			--检测待摆放单位是否和和已有单位相交
			--local boxRange = 48
			_A1.X = pointX - hVar.ROLE_BUILD_TOWER_DIS_MIN / 2
			_A1.Y = pointY - hVar.ROLE_BUILD_TOWER_DIS_MIN / 2
			_A2.X = pointX + hVar.ROLE_BUILD_TOWER_DIS_MIN / 2
			_A2.Y = pointY - hVar.ROLE_BUILD_TOWER_DIS_MIN / 2
			_A3.X = pointX + hVar.ROLE_BUILD_TOWER_DIS_MIN / 2
			_A3.Y = pointY + hVar.ROLE_BUILD_TOWER_DIS_MIN / 2
			_A4.X = pointX - hVar.ROLE_BUILD_TOWER_DIS_MIN / 2
			_A4.Y = pointY + hVar.ROLE_BUILD_TOWER_DIS_MIN / 2
				
				
			--检测是否和单位box重叠
			w:enumunit(function(eu)
				if (collapseUnit == nil) then
					--小兵、英雄、驻守英雄
					if (eu.data.type == hVar.UNIT_TYPE.UNIT) or (eu.data.type == hVar.UNIT_TYPE.HERO) or (eu.data.type == hVar.UNIT_TYPE.HERO_STATION) then
						--if (eu:GetSpaceType() == hVar.UNIT_SPACE_TYPE.SPACE_GROUND) then--目标的空间类型为地面单位
							local eu_x, eu_y = hApi.chaGetPos(eu.handle) --坐标
							local eu_bx, eu_by, eu_bw, eu_bh = eu:getbox() --包围盒
							local eu_center_x = eu_x + (eu_bx + eu_bw / 2) --中心点x位置
							local eu_center_y = eu_y + (eu_by + eu_bh / 2) --中心点y位置
							
							_B1.X = eu_center_x - eu_bw / 2
							_B1.Y = eu_center_y - eu_bh / 2
							_B2.X = eu_center_x + eu_bw / 2
							_B2.Y = eu_center_y - eu_bh / 2
							_B3.X = eu_center_x + eu_bw / 2
							_B3.Y = eu_center_y + eu_bh / 2
							_B4.X = eu_center_x - eu_bw / 2
							_B4.Y = eu_center_y + eu_bh / 2
							
							--两个矩形是否相交
							if hApi.RectIntersectRect(_A1, _A2, _A3, _A4, _B1, _B2, _B3, _B4) then
								--标记相交单位
								collapseUnit = eu
								--print("collapseUnit=", collapseUnit.data.name)
							end
						--end
					end
				end
			end)
			
			--已通过检测，不和别的单位相交
			if (collapseUnit == nil) then
				--相交的塔
				local collapseTower = nil
				w:enumunit(function(eu)
					if (collapseTower == nil) then
						--塔、建筑、图腾
						if (eu.data.type == hVar.UNIT_TYPE.TOWER) or (eu.data.type == hVar.UNIT_TYPE.BUILDING) or (eu.data.type == hVar.UNIT_TYPE.HERO_TOKEN) then
							local eu_x, eu_y = hApi.chaGetPos(eu.handle) --坐标
							local eu_bx, eu_by, eu_bw, eu_bh = eu:getbox() --包围盒
							local eu_center_x = eu_x + (eu_bx + eu_bw / 2) --中心点x位置
							local eu_center_y = eu_y + (eu_by + eu_bh / 2) --中心点y位置
							
							local dx = eu_center_x - pointX
							local dy = eu_center_y - pointY
							local dis = dx * dx + dy * dy
							--local DIS_MIN = 48
							
							--两个圆是否相交
							if (dis < hVar.ROLE_BUILD_TOWER_DIS_MIN * hVar.ROLE_BUILD_TOWER_DIS_MIN) then
								--标记相交塔
								collapseTower = eu
								--print("collapseTower=", collapseTower.data.name)
							end
						end
					end
				end)
				
				--已通过检测，不和别的塔相交
				if (collapseTower == nil) then
					--检测目标点的坐标和初始传入的坐标，偏移程度
					local dx = math.abs(pointX - worldX)
					local dy = math.abs(pointY - worldY)
					
					if (dx > TERRAIN_EDGE / 2) or (dy > TERRAIN_EDGE / 2) then
						--该路面不能建造塔
						nResult = hVar.CAST_POINT_SKILL_RESULT.INVALID_ROAD
						
						--存储第1个结果
						if (i == 1) then
							nResult_0 = hVar.CAST_POINT_SKILL_RESULT.COLLAPSE_TOWER --是否成功(第1个结果)
							tCollapeUnit_0 = collapseTower --重叠的单位(第1个结果)
						end
					else
						--成功
						nResult = hVar.CAST_POINT_SKILL_RESULT.SUCCESS
						tCollapeUnit = nil
						nResultX = pointX
						nResultY = pointY
						
						break
					end
				else
					--目标点和附近建筑重叠
					nResult = hVar.CAST_POINT_SKILL_RESULT.COLLAPSE_TOWER
					tCollapeUnit = collapseTower
					
					--存储第1个结果
					if (i == 1) then
						nResult_0 = hVar.CAST_POINT_SKILL_RESULT.COLLAPSE_TOWER --是否成功(第1个结果)
						tCollapeUnit_0 = collapseTower --重叠的单位(第1个结果)
					end
				end
			else
				--目标点和单位重叠
				nResult = hVar.CAST_POINT_SKILL_RESULT.COLLAPSE_UNIT
				tCollapeUnit = collapseUnit
				
				--存储第1个结果
				if (i == 1) then
					nResult_0 = hVar.CAST_POINT_SKILL_RESULT.COLLAPSE_UNIT --是否成功(第1个结果)
					tCollapeUnit_0 = collapseUnit --重叠的单位(第1个结果)
				end
			end
		end
	end
	
	if (nResult == hVar.CAST_POINT_SKILL_RESULT.SUCCESS) then --成功
		return nResult, tCollapeUnit, nResultX, nResultY
	else --失败
		return nResult_0, tCollapeUnit_0, nResultX, nResultY
	end
end

--显示PVP兵符介绍的tip
hApi.ShowPvpCoinTip = function()
	--删除上一次兵符界面
	if hGlobal.UI.PhonePvpoinFrm then
		hGlobal.UI.PhonePvpoinFrm:del()
		hGlobal.UI.PhonePvpoinFrm = nil
	end
	
	--移除事件监听：我的体力信息返回事件
	hGlobal.event:listen("LocalEvent_TiLiInfo_Ret", "__TiLiInfo_PvpCoin_", nil)
	--移除事件监听：兑换体力返回事件
	hGlobal.event:listen("LocalEvent_ExchangeTiLi_Ret", "__ExchangeTiLi_PvpCoin_", nil)
	--移除事件监听：横竖屏切换
	hGlobal.event:listen("LocalEvent_SpinScreen", "__SpinScreen_PvpCoin_", nil)
	
	local on_receive_TiLi_baseInfoRet_bf = hApi.DoNothing --我的体力信息返回事件
	local on_receive_ExchangeTiLiRet_bf = hApi.DoNothing --兑换体力返回事件
	local on_spine_screen_event_bf = hApi.DoNothing --横竖屏切换
	
	--创建兵符面板
	hGlobal.UI.PhonePvpoinFrm = hUI.frame:new(
	{
		x = hVar.SCREEN.w / 2 - 460 / 2,
		y = hVar.SCREEN.h / 2 + 800 / 2 + 0,
		--z = 100002,
		w = 500,
		h = 800,
		dragable = 2,
		show = 1, --一开始不显示
		border = 0, --"UI:TileFrmBasic_thin",
		--border = "UI:TileFrmBack_PVP",
		--background = "panel/panel_part_pvp_00.png",
		background = 0, --"misc/skillup/msgbox6.png", --"UI:Tactic_Background",
		autoactive = 0,
		
		--点击事件
		codeOnTouch = function(self, x, y, sus)
			--在外部点击
			if (sus == 0) then
				self.childUI["closeBtn"].data.code()
			end
		end,
	})
	hGlobal.UI.PhonePvpoinFrm:active()
	
	--创建9宫格贴图(create)
	hApi.CCScale9SpriteCreate("data/image/misc/task/gas_panel.png", 250, -400, 455, 719, hGlobal.UI.PhonePvpoinFrm)
	
	--[[
	local onclickevent = nil
	local MsgSelections = nil
	MsgSelections = {
		style = "mini",
		select = 0,
		ok = function()
			onclickevent()
		end,
		--cancel = function()
		--	onclickevent()
		--end,
		--cancelFun = cancelCallback, --点否的回调函数
		--textOk = "领取",
		textOk = hVar.tab_string["__Get__"], --language
		--textCancel = "确定", --language
		--textCancel = hVar.tab_string["Exit_Ack"], --language
		userflag = 0, --用户的标记
	}
	local msgBox = hGlobal.UI.MsgBox("", MsgSelections)
	msgBox:active()
	msgBox:show(1,"fade",{time=0.08})
	]]
	local msgBox = hGlobal.UI.PhonePvpoinFrm
	
	--背景底图
	msgBox.childUI["BG"] = hUI.image:new({
		parent = msgBox.handle._n,
		model = "misc/mask_white.png",
		x = 0,
		y = 0,
		z = -100,
		w = hVar.SCREEN.w * 2,
		h = hVar.SCREEN.h * 2,
	})
	msgBox.childUI["BG"].handle.s:setOpacity(88)
	msgBox.childUI["BG"].handle.s:setColor(ccc3(0, 0, 0))
	
	--关闭按钮
	msgBox.childUI["closeBtn"] = hUI.button:new({
		parent = msgBox.handle._n,
		dragbox = msgBox.childUI["dragBox"],
		model = "misc/skillup/btn_close.png",
		x = hGlobal.UI.PhonePvpoinFrm.data.w - 78,
		y = -140,
		--w = 48,
		--h = 48,
		scaleT = 0.95,
		code = function()
			--移除事件监听：我的体力信息返回事件
			hGlobal.event:listen("LocalEvent_TiLiInfo_Ret", "__TiLiInfo_PvpCoin_", nil)
			--移除事件监听：兑换体力返回事件
			hGlobal.event:listen("LocalEvent_ExchangeTiLi_Ret", "__ExchangeTiLi_PvpCoin_", nil)
			--移除事件监听：横竖屏切换
			hGlobal.event:listen("LocalEvent_SpinScreen", "__SpinScreen_PvpCoin_", nil)
			
			msgBox:del()
			hGlobal.UI.PhonePvpoinFrm = nil
			
			--如果有world，允许操作
			local world = hGlobal.WORLD.LastWorldMap
			if world then
				world.data.keypadEnabled = true
			end
		end,
	})
	
	--[[
	--体力条底图
	msgBox.childUI["tiliBG"] = hUI.image:new({
		parent = msgBox.handle._n,
		--dragbox = msgBox.childUI["dragBox"],
		model = "misc/task/mission_bar.png",
		x = 240,
		y = -100,
		scale = 0.8,
	})
	]]
	
	--[[
	--体力图标
	msgBox.childUI["tiliIcon"] = hUI.image:new({
		parent = msgBox.handle._n,
		--dragbox = msgBox.childUI["dragBox"],
		model = "misc/task/tili.png",
		x = 130,
		y = -254,
		w = 64,
		h = 64,
	})
	]]
	
	--体力进度条
	msgBox.childUI["tiliProgress"] = hUI.valbar:new({
		parent = msgBox.handle._n,
		x = 108,
		y = -256,
		w = 308,
		h = 54,
		align = "LC",
		size = 24,
		back = {model = "misc/task/gas_progress_bg.png", x = 0, y = 0, w = 308, h = 54},
		model = "misc/task/gas_progress.png",
		--model = "misc/progress.png",
		v = 0,
		max = 100,
	})
	
	--体力值
	msgBox.childUI["tiliProgressValue"] = hUI.label:new({
		parent = msgBox.handle._n,
		x = 264,
		y = -258 + 1,
		width = 300,
		font = "numWhite",
		size = 32,
		border = 0,
		align = "MC",
		text = "",
	})
	
	--体力上限前缀
	msgBox.childUI["tiliDailyMaxPrefix"] = hUI.label:new({
		parent = msgBox.handle._n,
		x = 220,
		y = -410,
		width = 300,
		font = hVar.FONTC,
		size = 26,
		border = 1,
		align = "MC",
		text = "MAX", --hVar.tab_string["__TEXT_DailyBaseTili"] .. ":",
	})
	
	--体力上限值
	msgBox.childUI["tiliDailyMaxValue"] = hUI.label:new({
		parent = msgBox.handle._n,
		x = 280,
		y = -410 - 2,
		width = 300,
		font = "numWhite",
		size = 24,
		border = 0,
		align = "LC",
		text = "",
	})
	
	--[[
	--每日基础产量
	msgBox.childUI["tiliDailyBaseExportPrefix"] = hUI.label:new({
		parent = msgBox.handle._n,
		x = 220,
		y = -470,
		width = 300,
		font = hVar.FONTC,
		size = 26,
		border = 1,
		align = "MC",
		text = "MAX", --hVar.tab_string["__TEXT_DailyBaseTili"] .. ":",
	})
	]]
	--每日基础产量图片
	msgBox.childUI["tiliDailyBaseExportPrefix"] = hUI.image:new({
		parent = msgBox.handle._n,
		x = 220,
		y = -470,
		model = "misc/task/tili_oil.png",
		w = 56,
		h = 56,
	})
	
	--每日基础产量值
	msgBox.childUI["tiliDailyBaseExportValue"] = hUI.label:new({
		parent = msgBox.handle._n,
		x = 280,
		y = -470 - 2,
		width = 300,
		font = "numWhite",
		size = 24,
		border = 0,
		align = "LC",
		text = "",
	})
	
	--[[
	--每日宠物产量
	msgBox.childUI["tiliDailyPetExportPrefix"] = hUI.label:new({
		parent = msgBox.handle._n,
		x = 160,
		y = -470,
		width = 300,
		font = hVar.FONTC,
		size = 26,
		border = 1,
		align = "LC",
		text = hVar.tab_string["__TEXT_DailyPetTili"] .. ":",
	})
	]]
	
	--每日基础产量图片
	msgBox.childUI["tiliDailyPetExportPrefix"] = hUI.button:new({ --作为按钮是为了挂载子控件
		parent = msgBox.handle._n,
		x = 220,
		y = -530,
		model = -1,
		w = 56,
		h = 56,
	})
	
	--每日宠物产量值
	msgBox.childUI["tiliDailyPetExportValue"] = hUI.label:new({
		parent = msgBox.handle._n,
		x = 280,
		y = -530 - 2,
		width = 300,
		font = "numWhite",
		size = 24,
		border = 0,
		align = "LC",
		text = "",
	})
	
	--[[
	--兑换区域底图
	msgBox.childUI["tiliExchangeBG"] = hUI.image:new({
		parent = msgBox.handle._n,
		model = "misc/treasure/medal_content.png",
		x = 250,
		y = -320,
		w = 300,
		h = 90,
	})
	
	--兑换的氪石图标
	msgBox.childUI["tiliExchangeKeShiIcon"] = hUI.image:new({
		parent = msgBox.handle._n,
		model = "misc/skillup/keshi.png",
		x = 170,
		y = -320 + 14,
		w = 56,
		h = 56,
	})
	
	--兑换的氪石数量
	msgBox.childUI["tiliExchangeKeShiValue"] = hUI.label:new({
		parent = msgBox.handle._n,
		width = 300,
		x = 170,
		y = -320 - 26,
		font = "num",
		size = 24,
		border = 0,
		align = "MC",
		text = "10",
	})
	
	--兑换的"兑换"文字
	msgBox.childUI["tiliExchangeKeShiPrefix"] = hUI.label:new({
		parent = msgBox.handle._n,
		width = 300,
		x = 250,
		y = -320,
		font = "numWhite",
		size = 26,
		border = 1,
		align = "MC",
		text = "=", --"兑换"
	})
	
	--兑换的体力图标
	msgBox.childUI["tiliExchangeTiLiIcon"] = hUI.image:new({
		parent = msgBox.handle._n,
		model = "misc/task/tili.png",
		x = 330,
		y = -320 + 14,
		w = 50 * 0.8,
		h = 60 * 0.8,
	})
	
	--兑换的体力数量
	msgBox.childUI["tiliExchangeTiLiValue"] = hUI.label:new({
		parent = msgBox.handle._n,
		width = 300,
		x = 330,
		y = -320 - 26,
		font = "numWhite",
		size = 24,
		border = 0,
		align = "MC",
		text = "10",
	})
	msgBox.childUI["tiliExchangeTiLiValue"].handle.s:setColor(ccc3(0, 255, 0))
	]]
	
	--兑换按钮
	msgBox.childUI["tiliExchangeBtn"] = hUI.button:new({
		parent = msgBox.handle._n,
		model = "misc/task/gas_trade.png",
		dragbox = msgBox.childUI["dragBox"],
		x = 260,
		y = -710,
		--label = {font = hVar.FONTC, width = 300, size = 32, border = 1, align = "MC", x = 120, y = 1, "",}, --"兑换"
		scale = 1.0,
		scaleT = 0.95,
		code = function()
			--local strText = "您的主公已更名为：" .. rgName --language
			local strText = hVar.tab_string["__TEXT_ExchangeTiLiReally"] --language
			hGlobal.UI.MsgBox(strText, {
				font = hVar.FONTC,
				ok = function()
					--检测gameserver版本号是否为最新
					if (not hApi.CheckGameServerVersionControl()) then
						return
					end
					
					--挡操作
					hUI.NetDisable(30000)
					
					--请求查询请求兑换体力
					SendCmdFunc["tank_exchange_tili"]()
				end,
				cancel = function()
				end,
			})
		end,
	})
	msgBox.childUI["tiliExchangeBtn"]:setstate(-1) --默认隐藏
	
	--剩余兑换次数文字
	msgBox.childUI["tiliExchangeCount"] = hUI.label:new({
		parent = msgBox.handle._n,
		width = 300,
		x = 260 + 120,
		y = -710 + 20,
		font = "numWhite",
		size = 28,
		border = 0,
		align = "MC",
		text = "",
	})
	
	--函数：我的体力信息返回事件
	on_receive_TiLi_baseInfoRet_bf = function(tiliDailyMax, tiliNow, tiliDailyBuyCount, tiliBuyCount, tiliDailySupply, dailyKeShiExport, dailyTiLiExport, dailyChestExport, keshiExportNow, tiliExportNow, chestExportNow)
		--print("收到我的体力信息返回事件", tiliDailyMax, tiliNow, tiliDailyBuyCount, tiliBuyCount, tiliDailySupply, dailyKeShiExport, dailyTiLiExport, dailyChestExport, keshiExportNow, tiliExportNow, chestExportNow)
		
		--取消挡操作
		hUI.NetDisable(0)
		
		--更新进度条
		msgBox.childUI["tiliProgress"]:setV(tiliNow, tiliDailyMax)
		
		--更新体力值
		msgBox.childUI["tiliProgressValue"]:setText(tostring(tiliNow) .. "/" .. tostring(tiliDailyMax))
		
		--更新体力上限
		msgBox.childUI["tiliDailyMaxValue"]:setText(tiliDailyMax)
		
		--更新每日基础产量值
		msgBox.childUI["tiliDailyBaseExportValue"]:setText(tiliDailySupply)
		
		--更新每日宠物体力产量值
		if (dailyTiLiExport > 0) then
			--删除之前的挖矿宠物图标
			for p = 1, 10, 1 do
				hApi.safeRemoveT(msgBox.childUI["tiliDailyPetExportPrefix"].childUI, "pet" .. p)
			end
			
			msgBox.childUI["tiliDailyPetExportValue"]:setText(dailyTiLiExport)
			
			--依次绘制挖体力的宠物图标
			local watiliNum = 0
			local pet_unit = hVar.tab_unit[hVar.MY_TANK_ID].pet_unit
			if pet_unit then
				for p = 1, #pet_unit, 1 do
					local watili = LuaGetHeroPetInWaTiLi(hVar.MY_TANK_ID, p)
					if (watili == 1) then --在挖体力
						local itemId = pet_unit[p].requireDebris[1]
						--宠物n
						watiliNum = watiliNum + 1
						msgBox.childUI["tiliDailyPetExportPrefix"].childUI["pet" .. watiliNum] = hUI.image:new({
							parent = msgBox.childUI["tiliDailyPetExportPrefix"].handle._n,
							x = 0,
							y = -4,
							model = hVar.tab_item[itemId].icon,
							w = 64,
							h = 64,
						})
					end
				end
				
				--分散一点
				if ((watiliNum % 2) == 1) then --奇数
					for n = 1, watiliNum, 1 do
						local WH = 24
						local cx = -(watiliNum - 1) / 2 * WH
						local px = cx + (n - 1) * WH
						local py = -2
						msgBox.childUI["tiliDailyPetExportPrefix"].childUI["pet" .. n]:setXY(px, py)
					end
				elseif ((watiliNum % 2) == 0) then --偶数
					for n = 1, watiliNum, 1 do
						local WH = 24
						local cx = -(watiliNum) / 2 * WH + WH / 2
						local px = cx + (n - 1) * WH
						local py = -2
						msgBox.childUI["tiliDailyPetExportPrefix"].childUI["pet" .. n]:setXY(px, py)
					end
				end
			end
		elseif (dailyTiLiExport == 0) then
			--删除之前的挖矿宠物图标
			for p = 1, 10, 1 do
				hApi.safeRemoveT(msgBox.childUI["tiliDailyPetExportPrefix"].childUI, "pet" .. p)
			end
			
			msgBox.childUI["tiliDailyPetExportValue"]:setText("")
		end
		
		--更新可兑换次数
		local leftcount = tiliDailyBuyCount - tiliBuyCount
		if (leftcount < 0) then
			leftcount = 0
		end
		msgBox.childUI["tiliExchangeBtn"]:setstate(1)
		--msgBox.childUI["tiliExchangeBtn"].childUI["label"]:setText(hVar.tab_string["__TEXT_Exchange"] .. "(" .. tostring(leftcount) .. ")")
		msgBox.childUI["tiliExchangeCount"]:setText(leftcount)
		if (leftcount > 0) then
			hApi.AddShader(msgBox.childUI["tiliExchangeBtn"].handle.s, "normal")
			--msgBox.childUI["tiliExchangeBtn"].childUI["label"].handle.s:setColor(ccc3(255, 255, 255))
			msgBox.childUI["tiliExchangeCount"].handle.s:setColor(ccc3(255, 255, 255))
		else
			hApi.AddShader(msgBox.childUI["tiliExchangeBtn"].handle.s, "gray")
			--msgBox.childUI["tiliExchangeBtn"].childUI["label"].handle.s:setColor(ccc3(192, 192, 192))
			msgBox.childUI["tiliExchangeCount"].handle.s:setColor(ccc3(192, 192, 192))
		end
	end
	
	--函数：兑换返回事件
	on_receive_ExchangeTiLiRet_bf = function(result)
		--print("on_receive_ExchangeTiLiRet_bf", result)
		
		--取消挡操作
		hUI.NetDisable(0)
		
		--操作成功
		if (result == 1) then
			--冒字
			local strText = hVar.tab_string["ios_exchange_success"] -- "兑换成功！"
			hUI.floatNumber:new({
				x = hVar.SCREEN.w / 2,
				y = hVar.SCREEN.h / 2,
				align = "MC",
				text = "",
				lifetime = 2000,
				fadeout = -550,
				moveY = 32,
			}):addtext(strText, hVar.FONTC, 32, "MC", 0, 0, nil, 1)
			
			--播放出售音效
			hApi.PlaySound("pay_gold")
			
			--再次查询玩家体力产量信息
			SendCmdFunc["tank_reqiure_tili_info"]()
		end
	end
	
	--函数：横竖屏切换
	on_spine_screen_event_bf = function()
		--关闭本界面
		if hGlobal.UI.PhonePvpoinFrm then
			hGlobal.UI.PhonePvpoinFrm.childUI["closeBtn"].data.code()
		end
		
		--重新绘制本界面
		hApi.ShowPvpCoinTip()
	end
	
	--添加事件监听：我的体力信息返回事件
	hGlobal.event:listen("LocalEvent_TiLiInfo_Ret", "__TiLiInfo_PvpCoin_", on_receive_TiLi_baseInfoRet_bf)
	--添加事件监听：兑换体力返回事件
	hGlobal.event:listen("LocalEvent_ExchangeTiLi_Ret", "__ExchangeTiLi_PvpCoin_", on_receive_ExchangeTiLiRet_bf)
	--移除事件监听：横竖屏切换
	hGlobal.event:listen("LocalEvent_SpinScreen", "__SpinScreen_PvpCoin_", on_spine_screen_event_bf)
	
	--挡操作
	hUI.NetDisable(30000)
	
	--请求查询玩家体力产量信息
	SendCmdFunc["tank_reqiure_tili_info"]()
end
--[[
hApi.ShowPvpCoinTip()
]]

--上传游戏结束数据到服务器
hApi.SendGameResultInfo = function(nIsWin, maxStar, expAdd)
	local world = hGlobal.WORLD.LastWorldMap
	local me = world:GetPlayerMe()
	local uposMe = me:getpos()
	
	--当前在使用的战车id
	local tankIdx = LuaGetHeroTankIdx()
	local tankId = hVar.tab_unit[hVar.MY_TANK_ID].tank_unit[tankIdx]
	
	local sCmd = ""
	local battlecfg_id = 0 --服务器战斗id
	if world.data.banLimitTable then
		battlecfg_id = world.data.banLimitTable.battlecfg_id
	end
	sCmd = sCmd .. tostring(battlecfg_id) .. ";"					--战斗id
	sCmd = sCmd .. tostring(tankId) .. ";"						--战车id
	sCmd = sCmd .. tostring(world.data.map) .. ";"					--地图名
	sCmd = sCmd .. tostring(world.data.MapMode) .. ";"				--地图模式
	sCmd = sCmd .. tostring(world.data.MapDifficulty) .. ";"			--地图难度
	sCmd = sCmd .. tostring(nIsWin) .. ";"						--是否胜利
	sCmd = sCmd .. tostring(maxStar) .. ";"						--评价星星
	sCmd = sCmd .. tostring(world:gametime()) .. ";"				--游戏时间（秒）
	sCmd = sCmd .. tostring(expAdd) .. ";"						--增加的经验值
	sCmd = sCmd .. tostring(world.data.statistics_rescue_count) .. ";"		--营救的科学家数量
	sCmd = sCmd .. tostring(world.data.statistics.killEnemyNum[uposMe] or 0) .. ";"	--击杀的单位数量
	sCmd = sCmd .. tostring(world.data.statistics.killBossNum[uposMe] or 0) .. ";"	--击杀的boss数量
	sCmd = sCmd .. tostring(world.data.statistics.deadCount[uposMe] or 0) .. ";"	--战车死亡的数量
	sCmd = sCmd .. tostring(world.data.statistics_dmg_hurt) .. ";"			--受到的总伤害值
	
	sCmd = sCmd .. tostring(0) .. ";"						--保留字段1
	sCmd = sCmd .. tostring(0) .. ";"						--保留字段2
	sCmd = sCmd .. tostring(0) .. ";"						--保留字段3
	sCmd = sCmd .. tostring(0) .. ";"						--保留字段4
	sCmd = sCmd .. tostring(0) .. ";"						--保留字段5
	sCmd = sCmd .. tostring(0) .. ";"						--保留字段6
	
	--前哨阵地波次
	if (world.data.map == hVar.QianShaoZhenDiMap) then
		sCmd = sCmd .. tostring(world.data.tdMapInfo.wave) .. ";" --前哨阵地波次
	else
		sCmd = sCmd .. tostring(0) .. ";" --前哨阵地波次
	end
	
	--随机迷宫层数
	if (world.data.map == hVar.RandomMap) then
		local nStageValue = world.data.randommapStage * 10 + world.data.randommapIdx
		sCmd = sCmd .. tostring(nStageValue) .. ";" --随机迷宫层数
	else
		sCmd = sCmd .. tostring(0) .. ";" --随机迷宫层数
	end
	
	--本局使用的战术卡
	local tacticNum = 0
	local sTacticCmd = ""
	local tacticInfo = GameManager.GetGameInfo("tacticInfo")
	for key,value in pairs(tacticInfo) do
		sTacticCmd = sTacticCmd .. tostring(key) .. ":" .. tostring(value) .. ";"
		tacticNum = tacticNum + 1
	end
	sCmd = sCmd .. tostring(tacticNum) .. ";"			--使用的战术卡数量
	sCmd = sCmd .. tostring(sTacticCmd) .. ""			--使用的战术卡信息
	
	--本局抽到的宝箱
	local chestNum = 0
	local sChestCmd = ""
	local chestinfo = GameManager.GetGameInfo("chestInfo")
	for key,value in pairs(chestinfo) do
		sChestCmd = sChestCmd .. tostring(key) .. ":" .. tostring(value) .. ";"
		chestNum = chestNum + 1
	end
	sCmd = sCmd .. tostring(chestNum) .. ";"			--抽到的宝箱数量
	sCmd = sCmd .. tostring(sChestCmd) .. ""			--抽到的宝箱信息
	
	--上传数据
	SendCmdFunc["tank_send_game_result"](sCmd)
end

--生成新无尽群英阁的抽卡信息
function hApi.GenerateSelectCardList(oPlayer, unitId)
	local w = hGlobal.WORLD.LastWorldMap
	local mapInfo = w.data.tdMapInfo
	--local me = w:GetPlayerMe() --我的玩家对象
	--local tTactics = me:gettactics() --本局我的战术卡
	
	--重新组织池子
	local tEndlessTacticCardPool = {}
	
	--拷贝人族无敌全局池子
	for poolIdx, tTacticList in pairs(hVar.UnitAuraGroupDefine_New[unitId]) do
		tEndlessTacticCardPool[poolIdx] = {}
		
		for idx, tTactic in ipairs(tTacticList) do
			tEndlessTacticCardPool[poolIdx][idx] = tTactic
		end
	end
	
	--[[
	--提炼出玩家拥有的战术卡，将玩家本身拥有的战术卡放入对应的池子（放入的池子品=卡片的品质-1）
	local tTactics = LuaGetPlayerSkillBook()
	if tTactics then
		for i = 1, #tTactics, 1 do
			if (type(tTactics[i]) == "table") then
				local id, lv, num = unpack(tTactics[i])
				--存在表项
				local tabT = hVar.tab_tactics[id]
				if tabT then
					local type = tabT.type --战术技能卡类型
					if (type == hVar.TACTICS_TYPE.OTHER) then --此类专属于一般战术卡
						--检测是否重复
						if (lv > 0) then
							--检测是否在可展示的战术卡列表里
							local bEnableShow = false
							for t = 1, #hVar.tab_tacticsEx, 1 do
								if (hVar.tab_tacticsEx[t] == id) then --找到了
									bEnableShow = true
								end
							end
							--在可展示的战术卡列表里
							if bEnableShow then
								--检测是否不在过滤的战术卡里
								local bFilterTactic = false
								for t = 1, #hVar.ENDLESS_TACTICCARD_FILTERS, 1 do
									if (hVar.ENDLESS_TACTICCARD_FILTERS[t] == id) then --找到了
										bFilterTactic = true
									end
								end
								--不在过滤的战术卡里
								if (not bFilterTactic) then
									--加入相应的池子（放入的池子品=卡片的品质-1）
									--print(hVar.tab_tactics[id].name, id, lv, num)
									local poolIdx = tabT.quality - 1
									if (poolIdx < hVar.ENDLESS_TACTICCARD_COLOR.WHITE) then
										poolIdx = hVar.ENDLESS_TACTICCARD_COLOR.WHITE
									end
									if (poolIdx > hVar.ENDLESS_TACTICCARD_COLOR.COLOR_MAX) then
										poolIdx = hVar.ENDLESS_TACTICCARD_COLOR.COLOR_MAX
									end
									
									--玩家本身拥有的战术卡，本局最大选择次数为1次，如果为主动战术卡，群英阁可使用1次，人族无敌可使用2次
									local maxcount = 1
									if tabT.activeSkill then
										if (mapInfo.freeBuildTowerMode == 1) and (mapInfo.mapMode == hVar.MAP_TD_TYPE.ENDLESS) then --自由造塔模式，无尽地图模式
											--群英阁
											maxcount = 1
										elseif (w.data.session_cfgId == 10) then --人族无敌
											--人族无敌
											maxcount = 2
										elseif (w.data.session_cfgId == 12) then --守卫剑阁
											--守卫剑阁
											maxcount = 1
										elseif (w.data.session_cfgId == 13) then --双人守卫剑阁
											--双人守卫剑阁
											maxcount = 2
										elseif (w.data.session_cfgId == 15) then --决战虚鲲
											--决战虚鲲
											maxcount = 1
										end
									end
									tEndlessTacticCardPool[poolIdx][#tEndlessTacticCardPool[poolIdx]+1] = {id = id, lv = lv, maxcount = maxcount,}
								end
							end
						end
					end
				end
			end
		end
	end
	]]
	
	--随机3个卡片
	local tTacticcardIndex = {}
	for i = 1, 3, 1 do
		while true do
			--先随机一个池子
			local poolIdx = 0
			local poolValue = math.random(1, 100)
			for color = 1, hVar.ENDLESS_TACTICCARD_COLOR.COLOR_MAX, 1 do
				if (poolValue <= hVar.ENDLESS_TACTICCARD_COLOR_PROBABLITY[color]) then --落在此池子里
					poolIdx = color
					break
				else
					poolValue = poolValue - hVar.ENDLESS_TACTICCARD_COLOR_PROBABLITY[color]
				end
			end
			if (poolIdx > 0) then
				local poolNum = #tEndlessTacticCardPool[poolIdx] --本池子卡片的数量
				if (poolNum > 0) then
					--print("poolIdx=", poolIdx)
					local randIdx = math.random(1, poolNum)
					
					--检测是否重复
					local bExisted = false
					for j = 1, #tTacticcardIndex, 1 do
						if (tTacticcardIndex[j].poolIdx == poolIdx) and (tTacticcardIndex[j].index == randIdx) then
							bExisted = true
							break
						end
					end
					
					--不重复的卡片，或者卡片本局选择次数未达上限
					if (not bExisted) then
						--此战术卡不在本局玩家已有的战术卡里，或者卡片本局选择次数未达上限
						local bPlayerCardExisted = false
						local tTactic = tEndlessTacticCardPool[poolIdx][randIdx]
						local auraId = tTactic.id
						local lv = tTactic.lv
						local maxcount = tTactic.maxcount --本局最大次数
						local currentcount = 0 --本局已选择次数
						
						--依次遍历每个玩家的本局选择的战术卡，计算总共已选择的次数
						for pos, tPlayerInfo in pairs(w.data.endless_build_tactics) do
							local count = tPlayerInfo[auraId] or 0
							currentcount = currentcount + count
						end
						
						if (currentcount >= maxcount) then
							bPlayerCardExisted = true
						end
						
						--本局玩家未出现的的卡片
						if (not bPlayerCardExisted) then
							tTacticcardIndex[#tTacticcardIndex+1] = {poolIdx = poolIdx, index = randIdx}
							--print("    randIdx=", randIdx)
							break
						else
							--print("    randIdx=", randIdx, " 本局已出现，作废")
						end
					else
						--print("    randIdx=", randIdx, " 重复，作废")
					end
				else
					--print("poolIdx=", poolIdx, " 无内容，作废")
				end
			end
		end
	end
	
	--弹出选战术卡的界面tip
	local tCardList = {}
	for i = 1, #tTacticcardIndex, 1 do
		local poolIdx = tTacticcardIndex[i].poolIdx
		local index = tTacticcardIndex[i].index
		local tTactic = tEndlessTacticCardPool[poolIdx][index]
		tCardList[#tCardList+1] = tTactic
		
		local auraId = tTactic.id
		--print(hVar.tab_stringT[auraId][1])
	end
	
	return tCardList
end

--人族无敌弹出游戏内选择卡片的tip
function hApi.ShowSelectCardTip_RZWD(tCardList, unitId, tCallback)
	--print(rewardType, auraId, tacticLv)
	--iPhoneX黑边宽
	local iPhoneX_WIDTH = 0
	if (g_phone_mode == 4) then --iPhoneX
		iPhoneX_WIDTH = 80
	end
	
	local OnClickDownEvent = hApi.DoNothing --函数：按下事件
	local OnClickEvent = hApi.DoNothing --函数：点击事件
	local OnGenerateDrawCard = hApi.DoNothing --函数：生成抽卡界面
	local OnAntoSelectTimer = hApi.DoNothing --函数：倒计时自动选择timer
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2
	local WIDTH = hVar.SCREEN.w --550
	local HEIGHT = hVar.SCREEN.h --380
	local CARD_NUM = 0 --卡片数量
	local CARD_OFFSET_X = 220 --卡片x间距
	local CARD_SCALE = 1.0
	local CARD_WIDTH = 161 * CARD_SCALE
	local CARD_HEIGHT = 180 * CARD_SCALE
	local ACTION_BEGIN_TIME = 150 --动画开始的等待时间（毫秒）
	local ACTION_ROT_TIME = 150 --动画翻卡的时间（毫秒）
	local ACTION_WAIT_TIME = 300 --动画翻卡的间隔时间（毫秒）
	
	--动画完成情况
	local sendNum = 0
	local receiveNum = 0
	local current_tCardList = nil
	local AUTOSELECTTIME = 60 --动选择的倒计时默认值
	local current_autoselecttime = AUTOSELECTTIME --自动选择的倒计时（秒）
	
	--先清除上一次的人族无敌选择卡片面板
	if hGlobal.UI.GameCoinTipFrame then
		hGlobal.UI.GameCoinTipFrame:del()
	end
	
	--清除倒计时自动选择的timer
	hApi.clearTimer("__TD__DRAWCARD_AUTOSELECT_TIMER__")
	
	--创建人族无敌游戏内选择卡片界面
	hGlobal.UI.GameCoinTipFrame = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = hZorder.CommonUIFrame,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--按下事件
				OnClickDownEvent(screenX, screenY)
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--清除技能说明面板
				--hGlobal.UI.GameCoinTipFrame:del()
				--hGlobal.UI.GameCoinTipFrame = nil
				--print("点击事件（有可能在控件外部点击）")
				OnClickEvent(screenX, screenY)
			end
		end,
	})
	hGlobal.UI.GameCoinTipFrame:active()
	
	local _RedEquipDeribsTipParent = hGlobal.UI.GameCoinTipFrame.handle._n
	local _RedEquipDeribsTipChildUI = hGlobal.UI.GameCoinTipFrame.childUI
	
	--创建人族无敌选择卡片图片背景
	--[[
	_RedEquipDeribsTipChildUI["ItemBG_1"] = hUI.image:new({
		parent = _RedEquipDeribsTipParent,
		--model = "UI_frm:slot",
		--animation = "normal",
		model = "UI:TacticBG",
		x = _offX,
		y = _offY - 235,
		w = 250,
		h = 380,
	})
	_RedEquipDeribsTipChildUI["ItemBG_1"].handle.s:setOpacity(204) --战术卡tip背景图片透明度为204
	]]
	
	--背景底图(挡操作)
	_RedEquipDeribsTipChildUI["BG"] = hUI.button:new({
		parent = _RedEquipDeribsTipParent,
		model = "misc/mask.png",
		x = 0,
		y = 0,
		z = -100,
		w = hVar.SCREEN.w * 2,
		h = hVar.SCREEN.h * 2,
		dragbox = hGlobal.UI.GameCoinTipFrame.childUI["dragBox"],
		scaleT = 1.0,
		code = function()
			--print("挡操作")
		end,
	})
	_RedEquipDeribsTipChildUI["BG"].handle.s:setOpacity(0)
	
	--背景图（九宫格）
	local img9 = hApi.CCScale9SpriteCreate("data/image/misc/task/ironbuf_panel.png", hVar.SCREEN.w/2, hVar.SCREEN.h/2, 700, 614, hGlobal.UI.GameCoinTipFrame)
	--img9:setOpacity(204)
	
	--[[
	--创建人族无敌选择卡片图标
	_RedEquipDeribsTipChildUI["TacticIcon"] = hUI.image:new({
		parent = _RedEquipDeribsTipParent,
		model = "icon/item/chip06.png",
		x = _offX - 80,
		y = _offY - 95,
		w = 58,
		h = 58,
	})
	]]
	
	--人族无敌选卡标题
	_RedEquipDeribsTipChildUI["TacticName"] = hUI.label:new({
		parent = _RedEquipDeribsTipParent,
		size = 28,
		x = _offX,
		y = _offY + 150,
		width = 500,
		align = "MC",
		font = hVar.FONTC,
		--text = "请选择一张科技效果", --language
		text = "", --hVar.tab_string["__TEXT_PLEASE_SELECT_TECHONOGY_CARD"], --language
		border = 1,
		scale = tacticNameScale, --缩放
	})
	_RedEquipDeribsTipChildUI["TacticName"].handle.s:setColor(ccc3(255, 255, 0))
	
	--[[
	--英雄驻守描述
	_RedEquipDeribsTipChildUI["TacticIntro"] = hUI.label:new({
		parent = _RedEquipDeribsTipParent,
		size = 20,
		x = _offX - 250,
		y = _offY - 120,
		width = 510,
		align = "LT",
		font = hVar.FONTC,
		--text = hVar.tab_string["__SHENQI_CRTSTAL_INTRODUCE"],
		text = "将英雄移动到驻守点，使其驻守在此处，并大幅增强驻守英雄的能力。",
		border = 1,
		RGB = {236, 236, 236,},
	})
	]]
	
	--关闭按钮
	_RedEquipDeribsTipChildUI["closeBtn"] = hUI.button:new({
		parent = _RedEquipDeribsTipParent,
		dragbox = hGlobal.UI.GameCoinTipFrame.childUI["dragBox"],
		--model = "UI:BTN_Close", --BTN:PANEL_CLOSE
		model = "misc/mask.png",
		--x = hVar.SCREEN.w - iPhoneX_WIDTH - 40 * _ScaleW,
		--y = -34 * _ScaleH,
		--x = hVar.SCREEN.w - iPhoneX_WIDTH * 2 - 57,
		x = _offX + 304,
		y = _offY + 200,
		z = 100,
		w = 96,
		h = 96,
		scaleT = 0.95,
		code = function()
			local world = hGlobal.WORLD.LastWorldMap
			
			--移除监听人族无敌，再抽一次的回调
			hGlobal.event:listen("LocalEvent_QunYingGe_RedrawCard_Ret", "TD_RedrawCard_Ret_UI_", nil)
			
			--删除本界面
			hGlobal.UI.GameCoinTipFrame:del()
			hGlobal.UI.GameCoinTipFrame = nil
			
			--清除倒计时自动选择的timer
			hApi.clearTimer("__TD__DRAWCARD_AUTOSELECT_TIMER__")
			
			--如果在游戏里关闭此界面，恢复暂停
			local mapInfo = world.data.tdMapInfo
			if (mapInfo.isNoWaitFrame == true) then --不等待同步帧模式
				--print(mapInfo.mapState, hVar.MAP_TD_STATE.PAUSE)
				if (mapInfo.mapState == hVar.MAP_TD_STATE.PAUSE) then --当前是暂停状态
					--进入恢复
					world:pause(0)
					mapInfo.mapState = mapInfo.mapLastState
					mapInfo.mapLastState = hVar.MAP_TD_STATE.IDLE
					
					--恢复游戏当前速率
					hGlobal.event:event("LocalEvent_ResumeSpeed")
				end
			--普通模式，挑战模式，恢复暂停
			elseif (mapInfo.mapMode == hVar.MAP_TD_TYPE.NORMAL) or (mapInfo.mapMode == hVar.MAP_TD_TYPE.DIFFICULT) then
				if (mapInfo.mapState == hVar.MAP_TD_STATE.PAUSE) then --当前是暂停状态
					--进入恢复
					world:pause(0)
					mapInfo.mapState = mapInfo.mapLastState
					mapInfo.mapLastState = hVar.MAP_TD_STATE.IDLE
					
					--恢复游戏当前速率
					hGlobal.event:event("LocalEvent_ResumeSpeed")
				end
			end
			
			if type(tCallback) == "table" then
				--print(_tCallback[1], _tCallback[2])
				hGlobal.event:event("LocalEvent_CloseAuraBack", tCallback[2])
			end
		end,
	})
	_RedEquipDeribsTipChildUI["closeBtn"].handle.s:setOpacity(0) --只响应事件，不显示
	--关闭图标
	_RedEquipDeribsTipChildUI["closeBtn"].childUI["icon"] = hUI.button:new({
		parent = _RedEquipDeribsTipChildUI["closeBtn"].handle._n,
		model = "misc/skillup/btn_close.png",
		--model = "BTN:PANEL_CLOSE",
		align = "MC",
		x = 0,
		y = 0,
		scale = 1.0,
	})
	
	--确定按钮
	_RedEquipDeribsTipChildUI["btnOK"] = hUI.button:new({ --作为按钮只是为了挂载子控件
		parent = _RedEquipDeribsTipParent,
		x = _offX,
		y = _offY - 294,
		model = "misc/task/ironbuf_button.png",
		w = 152,
		h = 85,
		label = {x = 0, y = 1, text = "", size = 32, font = hVar.FONTC, align = "MC", width = 300, border = 1,}, --"确定" --hVar.tab_string["Exit_Ack"]
		--[[
		dragbox = hGlobal.UI.GameCoinTipFrame.childUI["dragBox"],
		scaleT = 0.95,
		code = function()
			--动画未完成，不处理
			if (receiveNum < sendNum) then
				return
			end
			
			--选中的战术卡索引
			local selectIdx = 0
			for i = 1, CARD_NUM, 1 do
				local ctrli = _RedEquipDeribsTipChildUI["TacticCard_" .. i]
				if (ctrli.data.selectstate == 1) then
					selectIdx = i
					break
				end
			end
			
			if (selectIdx > 0) then
				local world = hGlobal.WORLD.LastWorldMap
				
				--移除监听人族无敌，再抽一次的回调
				hGlobal.event:listen("LocalEvent_QunYingGe_RedrawCard_Ret", "TD_RedrawCard_Ret_UI_", nil)
				
				hGlobal.UI.GameCoinTipFrame:del()
				hGlobal.UI.GameCoinTipFrame = nil
				
				--清除倒计时自动选择的timer
				hApi.clearTimer("__TD__DRAWCARD_AUTOSELECT_TIMER__")
				
				--如果在游戏里关闭此界面，恢复暂停
				local mapInfo = world.data.tdMapInfo
				--print(mapInfo.mapState, hVar.MAP_TD_STATE.PAUSE)
				if (mapInfo.mapState == hVar.MAP_TD_STATE.PAUSE) then --当前是暂停状态
					--进入恢复
					world:pause(0)
					mapInfo.mapState = mapInfo.mapLastState
					mapInfo.mapLastState = hVar.MAP_TD_STATE.IDLE
					
					--恢复游戏当前速率
					hGlobal.event:event("LocalEvent_ResumeSpeed")
				end
				
				--卡片生效（人族无敌）
				local player = world:GetPlayerMe()
				local auraId = current_tCardList[selectIdx].id
				local tacticLv = current_tCardList[selectIdx].lv
				local maxcount = current_tCardList[selectIdx].maxcount
				local tacticNum = 1 --道具使用次数
				local tabT = hVar.tab_tactics[auraId]
				if tabT then
					local itemId = tabT.itemId
					local tabI = hVar.tab_item[itemId]
					if tabI then
						local activeSkill = tabI.activeSkill
						if activeSkill then
							tacticNum = activeSkill.count
						end
					end
				end
				
				--发送指令联机选卡结果
				hApi.AddCommand(hVar.Operation.SelectDrawCardRet, auraId, tacticLv, tacticNum)
			end
		end,
		]]
	})
	_RedEquipDeribsTipChildUI["btnOK"]:setstate(0)
	
	--自动选择的倒计时提示文字
	_RedEquipDeribsTipChildUI["TacticAutoSelectPostfix"] = hUI.label:new({
		parent = _RedEquipDeribsTipParent,
		size = 22,
		x = _offX - 240 - 52,
		y = _offY - 190 - 2,
		width = 500,
		align = "LC",
		font = hVar.FONTC,
		--text = "秒后自动选择", --language
		text = hVar.tab_string["__SecondToAutoSelect"], --language
		border = 1,
		RGB = {255, 255, 0,},
	})
	
	--自动选择的时间值
	_RedEquipDeribsTipChildUI["TacticAutoSelectTime"] = hUI.label:new({
		parent = _RedEquipDeribsTipParent,
		size = 20,
		x = _offX - 240 - 56,
		y = _offY - 190 - 4 + 0, --数字字体有1像素的偏差
		width = 500,
		align = "RC",
		font = "numWhite",
		text = current_autoselecttime, --language
		border = 0,
	})
	_RedEquipDeribsTipChildUI["TacticAutoSelectTime"].handle.s:setColor(ccc3(255, 255, 0))
	
	--重抽一次需要的游戏币
	local shopitemId = 649
	local tabShopItem = hVar.tab_shopitem[shopitemId] or {}
	local itemId = tabShopItem.itemID or 0
	local rmbCost = tabShopItem.rmb or 0
	
	--当前剩余重抽的次数
	local world = hGlobal.WORLD.LastWorldMap
	local me = world:GetPlayerMe()
	local myPos = me:getpos()
	local maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT --默认值
	if (world.data.session_cfgId == 10) then --人族无敌
		maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_RENZUWUD
	elseif (world.data.session_cfgId == 12) then --守卫剑阁
		maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_SWJG
	elseif (world.data.session_cfgId == 13) then --双人守卫剑阁
		maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_SWJG2
	elseif (world.data.session_cfgId == 15) then --决战虚鲲
		maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_JZXK
	end
	
	if (world.data.endless_redraw_count[myPos] == nil) then
		world.data.endless_redraw_count[myPos] = {}
	end
	local currentcount = world.data.endless_redraw_count[myPos][unitId] or 0
	local leftcount = maxcount - currentcount
	if (leftcount < 0) then
		leftcount = 0
	end
	
	--本次抽卡所属的波次
	local world = hGlobal.WORLD.LastWorldMap
	local mapInfo = world.data.tdMapInfo
	--local currentWave = mapInfo.wave
	--检测波次是否一致
	local drawCardWave = 1 --本次抽卡属于哪一波（防止已经领取卡片了再收到回调）
	local tPlayerInfo = world.data.endless_build_tactics[myPos] or {}
	if tPlayerInfo.perWave then
		drawCardWave = #tPlayerInfo.perWave+1
	end
	
	--不等待同步帧模式，不自动选择
	if (mapInfo.isNoWaitFrame == true) then
		_RedEquipDeribsTipChildUI["TacticAutoSelectPostfix"]:setText("")
	elseif (mapInfo.mapMode == hVar.MAP_TD_TYPE.NORMAL) or (mapInfo.mapMode == hVar.MAP_TD_TYPE.DIFFICULT) then --普通模式，挑战模式，不自动选择
		_RedEquipDeribsTipChildUI["TacticAutoSelectPostfix"]:setText("")
	end

	--如果存在重抽次数，才创建重抽按钮
	if (leftcount > 0) and (drawCardWave >= hVar.ENDLESS_TACTICCARD_REDRAW_BEGIN_WAVE) then
		--重抽一次按钮
		_RedEquipDeribsTipChildUI["btnReDraw"] = hUI.button:new({
			parent = _RedEquipDeribsTipParent,
			x = _offX + 260,
			y = _offY - 294,
			model = "misc/mask.png",
			w = 180,
			h = 90,
			--label = {x = 0, y = -3, text = hVar.tab_string["__RE_EXCHANGE2__"], size = 36, font = hVar.FONTC, align = "MC", width = 300, border = 1,}, --"重抽一次"
			dragbox = hGlobal.UI.GameCoinTipFrame.childUI["dragBox"],
			scaleT = 0.95,
			code = function()
				--动画未完成，不处理
				if (receiveNum < sendNum) then
					return
				end
				
				--未连接db服务器，不能操作
				if (g_cur_net_state ~= 1) then
					--冒字
					--local strText = "不能连接到网络" --language
					local strText = hVar.tab_string["ios_err_network_cannot_conn"] --language
					hUI.floatNumber:new({
						x = hVar.SCREEN.w / 2,
						y = hVar.SCREEN.h / 2,
						align = "MC",
						text = "",
						lifetime = 2000,
						fadeout = -550,
						moveY = 32,
					}):addtext(strText, hVar.FONTC, 32, "MC", 0, 0, nil, 1)
					
					return
				end
				
				--重新计算剩余次数
				local me = world:GetPlayerMe()
				local myPos = me:getpos()
				local maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT --默认值
				if (world.data.session_cfgId == 10) then --人族无敌
					maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_RENZUWUD
				elseif (world.data.session_cfgId == 12) then --守卫剑阁
					maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_SWJG
				elseif (world.data.session_cfgId == 13) then --双人守卫剑阁
					maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_SWJG2
				elseif (world.data.session_cfgId == 15) then --决战虚鲲
					maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_JZXK
				end
				if (world.data.endless_redraw_count[myPos] == nil) then
					world.data.endless_redraw_count[myPos] = {}
				end
				local currentcount = world.data.endless_redraw_count[myPos][unitId] or 0
				local leftcount = maxcount - currentcount
				if (leftcount < 0) then
					leftcount = 0
				end
				
				--检测是否有剩余次数
				if (leftcount <= 0) then
					--冒字
					--local strText = "本局重抽次数已用完！" --language
					local strText = hVar.tab_string["__TEXT_Cant_Redraw_ThisGame"] --language
					hUI.floatNumber:new({
						x = hVar.SCREEN.w / 2,
						y = hVar.SCREEN.h / 2,
						align = "MC",
						text = "",
						lifetime = 2000,
						fadeout = -550,
						moveY = 32,
					}):addtext(strText, hVar.FONTC, 32, "MC", 0, 0, nil, 1)
					
					return
				end
				
				--检测游戏币是否足够
				if (LuaGetPlayerRmb() < rmbCost) then
					--local strText = "游戏币不足" --language
					local strText = hVar.tab_string["ios_not_enough_game_coin"] --language
					hUI.floatNumber:new({
						x = hVar.SCREEN.w / 2,
						y = hVar.SCREEN.h / 2,
						align = "MC",
						text = "",
						lifetime = 2000,
						fadeout = -550,
						moveY = 32,
					}):addtext(strText, hVar.FONTC, 32, "MC", 0, 0, nil, 1)
					
					return
				end
				
				--可以重抽一次
				--挡操作
				hUI.NetDisable(30000)
				
				--发送指令，人族无敌重抽一次
				local wave = 1 --本次抽卡属于哪一波（防止已经领取卡片了再收到回调）
				local tPlayerInfo = world.data.endless_build_tactics[myPos] or {}
				if tPlayerInfo.perWave then
					wave = #tPlayerInfo.perWave+1
				end
				SendCmdFunc["renzuwudi_redrawcard"](unitId, wave)
			end,
		})
		_RedEquipDeribsTipChildUI["btnReDraw"].handle.s:setOpacity(0) --只挂载子控件，不显示
		--按钮图片
		_RedEquipDeribsTipChildUI["btnReDraw"].childUI["icon"] = hUI.image:new({
			parent = _RedEquipDeribsTipChildUI["btnReDraw"].handle._n,
			--model = "UI:PANEL_MENU_BTN_BIG",
			model = "misc/task/ironbuf_refresh.png",
			align = "MC",
			x = 0,
			y = 0,
			w = 87,
			h = 87,
		})
		--如果重抽次数为0，灰掉按钮
		if (leftcount <= 0) then
			hApi.AddShader(_RedEquipDeribsTipChildUI["btnReDraw"].childUI["icon"].handle.s, "gray") --灰掉
		end
		--重抽一次文字
		_RedEquipDeribsTipChildUI["btnReDraw"].childUI["label"] = hUI.label:new({
			parent = _RedEquipDeribsTipChildUI["btnReDraw"].handle._n,
			size = 26,
			align = "MC",
			x = 0,
			y = 0,
			font = "numWhite",
			width = 300,
			--text = "重抽一次", --language
			--text = hVar.tab_string["__RE_EXCHANGE2__"] .. " (" .. leftcount .. ")", --language
			--text = "(" .. leftcount .. ")", --language
			text = leftcount,
			border = 1,
			--RGB = {255, 236, 0,}
		})
		--_RedEquipDeribsTipChildUI["btkReDraw"]:setstate(0)
		--[[
		--消耗文字前缀
		_RedEquipDeribsTipChildUI["btnReDraw"].childUI["costLabelPrefix"] = hUI.label:new({
			parent = _RedEquipDeribsTipChildUI["btnReDraw"].handle._n,
			size = 25,
			align = "RC",
			--border = 1,
			x = -12,
			y = 50 + 5,
			font = hVar.FONTC,
			width = 300,
			--text = "消耗", --language
			text = hVar.tab_string["__TEXT_CONSUME"], --language
			border = 1,
			RGB = {255, 236, 0,}
		})
		]]
		--游戏币图标
		_RedEquipDeribsTipChildUI["btnReDraw"].childUI["gamecoin"] = hUI.image:new({
			parent = _RedEquipDeribsTipChildUI["btnReDraw"].handle._n,
			model = "misc/skillup/keshi.png",
			align = "MC",
			x = -20,
			y = 60 + 4,
			w = 42,
			h = 42,
		})
		--消耗游戏币值
		_RedEquipDeribsTipChildUI["btnReDraw"].childUI["costLabelValue"] = hUI.label:new({
			parent = _RedEquipDeribsTipChildUI["btnReDraw"].handle._n,
			size = 24,
			align = "LC",
			--border = 1,
			x = 0,
			y = 60 + 2,
			font = "num",
			width = 300,
			text = rmbCost,
			border = 1,
		})
	end
	
	--如果没有重抽次数，确定按钮居中对齐
	--if (leftcount <= 0) then
	--	local px, py = _RedEquipDeribsTipChildUI["btnOK"].data.x, _RedEquipDeribsTipChildUI["btnOK"].data.y
	--	_RedEquipDeribsTipChildUI["btnOK"]:setXY(_offX, py)
	--end
	
	--按下事件
	OnClickDownEvent = function(touchX, touchY)
		--检测点击到确认按钮内
		--确定按钮
		local okBtn = _RedEquipDeribsTipChildUI["btnOK"]
		if okBtn then
			local cx = okBtn.data.x --中心点x坐标
			local cy = okBtn.data.y --中心点y坐标
			local cw, ch = okBtn.data.w, okBtn.data.h
			local lx, ly = cx - cw / 2, cy - ch / 2 --最左上侧坐标
			local rx, ry = lx + cw, ly + ch --最右下角坐标
			--print(i, lx, rx, touchX)
			--print("click" ..  i,  "x=" .. okBtn.data.x, touchX, touchY, lx, rx, ly, ry)
			if (touchX >= lx) and (touchX <= rx) and (touchY >= ly) and (touchY <= ry) then
				--print("down ok")
				
				--缩小再放大
				local act1 = CCEaseSineIn:create(CCScaleTo:create(0.1, 0.95))
				local act2 = CCEaseSineOut:create(CCScaleTo:create(0.1, 1.0))
				local a = CCArray:create()
				a:addObject(act1)
				a:addObject(act2)
				local sequence = CCSequence:create(a)
				okBtn.handle._n:stopAllActions()
				okBtn.handle._n:runAction(sequence)
			end
		end
	end
	
	--点击事件
	OnClickEvent = function(touchX, touchY)
		--检测点击到了哪个战术卡框内
		for i = 1, CARD_NUM, 1 do
			local ctrli = _RedEquipDeribsTipChildUI["TacticCard_" .. i]
			if ctrli then
				local cx = ctrli.data.x --中心点x坐标
				local cy = ctrli.data.y --中心点y坐标
				local cw, ch = ctrli.data.w, ctrli.data.h
				local lx, ly = cx - cw / 2, cy - ch / 2 --最左上侧坐标
				local rx, ry = lx + cw, ly + ch --最右下角坐标
				--print(i, lx, rx, touchX)
				--print("click" ..  i,  "x=" .. ctrli.data.x, touchX, touchY, lx, rx, ly, ry)
				if (touchX >= lx) and (touchX <= rx) and (touchY >= ly) and (touchY <= ry) then
					--print("点击到了哪个战术卡的框内" .. i)
					
					--动画未完成，不处理
					if (receiveNum < sendNum) then
						return
					end
					
					--标记选中
					if (_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate == 0) then
						_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate = 1
						--_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle._n:setVisible(true)
						ctrli.childUI["selectbox"].handle._n:setVisible(true)
						_RedEquipDeribsTipChildUI["TacticCard_SelectBox_" .. i].handle._n:setVisible(true)
					elseif (_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate == 1) then
						_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate = 0
						--_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle._n:setVisible(false)
						ctrli.childUI["selectbox"].handle._n:setVisible(false)
						_RedEquipDeribsTipChildUI["TacticCard_SelectBox_" .. i].handle._n:setVisible(false)
					end
					
					--取消其他卡片选中框
					for j = 1, CARD_NUM, 1 do
						if (i ~= j) then
							if (_RedEquipDeribsTipChildUI["TacticCard_" .. j].data.selectstate == 1) then
								_RedEquipDeribsTipChildUI["TacticCard_" .. j].data.selectstate = 0
								--_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. j].handle._n:setVisible(false)
								_RedEquipDeribsTipChildUI["TacticCard_" .. j].childUI["selectbox"].handle._n:setVisible(false)
								_RedEquipDeribsTipChildUI["TacticCard_SelectBox_" .. j].handle._n:setVisible(false)
							end
						end
					end
					
					--[[
					--动画
					local act1 = CCFadeTo:create(1.0, 212)
					local act2 = CCScaleTo:create(1.0, CARD_SCALE - 0.01)
					local act12 = CCSpawn:createWithTwoActions(act1, act2) --同步1
					local act3 = CCFadeTo:create(1.0, 255)
					local act4 = CCScaleTo:create(1.0, CARD_SCALE - 0.03)
					local act34 = CCSpawn:createWithTwoActions(act3, act4) --同步2
					local a = CCArray:create()
					a:addObject(act12)
					a:addObject(act34)
					local sequence = CCSequence:create(a)
					_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle.s:stopAllActions()
					_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle.s:runAction(CCRepeatForever:create(sequence))
					]]
					
					--更新确定按钮状态
					if (_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate == 1) then
						_RedEquipDeribsTipChildUI["btnOK"]:setstate(1)
					elseif (_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate == 0) then
						_RedEquipDeribsTipChildUI["btnOK"]:setstate(0)
					end
				end
			end
		end
		
		--检测点击到确认按钮内
		--确定按钮
		local okBtn = _RedEquipDeribsTipChildUI["btnOK"]
		if okBtn then
			local cx = okBtn.data.x --中心点x坐标
			local cy = okBtn.data.y --中心点y坐标
			local cw, ch = okBtn.data.w, okBtn.data.h
			local lx, ly = cx - cw / 2, cy - ch / 2 --最左上侧坐标
			local rx, ry = lx + cw, ly + ch --最右下角坐标
			--print(i, lx, rx, touchX)
			--print("click" ..  i,  "x=" .. okBtn.data.x, touchX, touchY, lx, rx, ly, ry)
			if (touchX >= lx) and (touchX <= rx) and (touchY >= ly) and (touchY <= ry) then
				--print("ok")
				
				--动画未完成，不处理
				if (receiveNum < sendNum) then
					return
				end
				
				--选中的战术卡索引
				local selectIdx = 0
				for i = 1, CARD_NUM, 1 do
					local ctrli = _RedEquipDeribsTipChildUI["TacticCard_" .. i]
					if (ctrli.data.selectstate == 1) then
						selectIdx = i
						break
					end
				end
				
				if (selectIdx > 0) then
					local world = hGlobal.WORLD.LastWorldMap
					local auraId = current_tCardList[selectIdx].id
					local tabA = hVar.tab_aura[auraId]
					local crystal = tabA.crystal or 0
					local me = world:GetPlayerMe()
					local goldNow = me:getresource(hVar.RESOURCE_TYPE.GOLD)
					if (goldNow >= crystal) then
						local world = hGlobal.WORLD.LastWorldMap
						
						--移除监听人族无敌，再抽一次的回调
						hGlobal.event:listen("LocalEvent_QunYingGe_RedrawCard_Ret", "TD_RedrawCard_Ret_UI_", nil)
						
						--删除本界面
						hGlobal.UI.GameCoinTipFrame:del()
						hGlobal.UI.GameCoinTipFrame = nil
						
						--清除倒计时自动选择的timer
						hApi.clearTimer("__TD__DRAWCARD_AUTOSELECT_TIMER__")
						
						--如果在游戏里关闭此界面，恢复暂停
						local mapInfo = world.data.tdMapInfo
						if (mapInfo.isNoWaitFrame == true) then --不等待同步帧模式
							--print(mapInfo.mapState, hVar.MAP_TD_STATE.PAUSE)
							if (mapInfo.mapState == hVar.MAP_TD_STATE.PAUSE) then --当前是暂停状态
								--进入恢复
								world:pause(0)
								mapInfo.mapState = mapInfo.mapLastState
								mapInfo.mapLastState = hVar.MAP_TD_STATE.IDLE
								
								--恢复游戏当前速率
								hGlobal.event:event("LocalEvent_ResumeSpeed")
							end
						--普通模式，挑战模式，恢复暂停
						elseif (mapInfo.mapMode == hVar.MAP_TD_TYPE.NORMAL) or (mapInfo.mapMode == hVar.MAP_TD_TYPE.DIFFICULT) then
							--print(mapInfo.mapState, hVar.MAP_TD_STATE.PAUSE)
							if (mapInfo.mapState == hVar.MAP_TD_STATE.PAUSE) then --当前是暂停状态
								--进入恢复
								world:pause(0)
								mapInfo.mapState = mapInfo.mapLastState
								mapInfo.mapLastState = hVar.MAP_TD_STATE.IDLE
								
								--恢复游戏当前速率
								hGlobal.event:event("LocalEvent_ResumeSpeed")
							end
						end
						
						--卡片生效（人族无敌）
						local player = world:GetPlayerMe()
						local auraId = current_tCardList[selectIdx].id
						local tacticLv = current_tCardList[selectIdx].lv
						local maxcount = current_tCardList[selectIdx].maxcount
						local tacticNum = 1 --道具使用次数
						--[[
						local tabT = hVar.tab_tactics[auraId]
						if tabT then
							local itemId = tabT.itemId
							local tabI = hVar.tab_item[itemId]
							if tabI then
								local activeSkill = tabI.activeSkill
								if activeSkill then
									tacticNum = activeSkill.count
								end
							end
						end
						]]
						
						--发送指令联机选卡结果
						local index = 0
						local u_worldI = 0
						if type(tCallback) == "table" then
							index = tCallback[2][1]
							u_worldI = tCallback[2][2]:getworldI()
						end
						--print("发送指令联机选卡结果 B")
						--print(auraId, tacticLv, tacticNum, index, u_worldI)
						hApi.AddCommand(hVar.Operation.SelectDrawCardRet, auraId, tacticLv, tacticNum, index, u_worldI)
					else
						hApi.NotEnoughResource("coin")
					end
				end
			end
		end
	end
	
	--自动选择抽卡的timer
	OnAntoSelectTimer = function()
		local world = hGlobal.WORLD.LastWorldMap
		
		--world已不存在，直接返回
		if (world == nil) then
			--清除此timer
			hApi.clearTimer("__TD__DRAWCARD_AUTOSELECT_TIMER__")
			
			return
		end
		
		--本界面已不存在，直接返回
		if (hGlobal.UI.GameCoinTipFrame == nil) then
			--清除此timer
			hApi.clearTimer("__TD__DRAWCARD_AUTOSELECT_TIMER__")
			
			return
		end
		
		local mapInfo = world.data.tdMapInfo
		
		--游戏结束或者已经暂停(结束)则不处理后续流程
		if (mapInfo.mapState >= hVar.MAP_TD_STATE.PAUSE) then
			return
		end
		
		--不等待同步帧模式不处理后续流程
		if (mapInfo.isNoWaitFrame == true) then
			return
		end
		
		--普通模式，挑战模式，不处理后续流程
		if (mapInfo.mapMode == hVar.MAP_TD_TYPE.NORMAL) or (mapInfo.mapMode == hVar.MAP_TD_TYPE.DIFFICULT) then
			return
		end
		
		--自动选择倒计时
		current_autoselecttime = current_autoselecttime - 1
		if (current_autoselecttime < 0) then
			current_autoselecttime = 0
		end
		
		--更新倒计时界面值
		if _RedEquipDeribsTipChildUI["TacticAutoSelectTime"] then
			_RedEquipDeribsTipChildUI["TacticAutoSelectTime"]:setText(current_autoselecttime)
		end
		
		--倒计时为0，自动选择
		if (current_autoselecttime == 0) then
			--自动选择
			--选中的战术卡索引
			local selectIdx = 0
			for i = 1, CARD_NUM, 1 do
				local ctrli = _RedEquipDeribsTipChildUI["TacticCard_" .. i]
				if (ctrli.data.selectstate == 1) then
					selectIdx = i
					break
				end
			end
			
			--默认选择第一个
			if (selectIdx == 0) then
				selectIdx = 1
			end
			
			--移除监听人族无敌，再抽一次的回调
			hGlobal.event:listen("LocalEvent_QunYingGe_RedrawCard_Ret", "TD_RedrawCard_Ret_UI_", nil)
			
			--删除本界面
			hGlobal.UI.GameCoinTipFrame:del()
			hGlobal.UI.GameCoinTipFrame = nil
			
			--清除倒计时自动选择的timer
			hApi.clearTimer("__TD__DRAWCARD_AUTOSELECT_TIMER__")
			
			--[[
			--如果在游戏里关闭此界面，恢复暂停
			local mapInfo = world.data.tdMapInfo
			--print(mapInfo.mapState, hVar.MAP_TD_STATE.PAUSE)
			if (mapInfo.mapState == hVar.MAP_TD_STATE.PAUSE) then --当前是暂停状态
				--进入恢复
				world:pause(0)
				mapInfo.mapState = mapInfo.mapLastState
				mapInfo.mapLastState = hVar.MAP_TD_STATE.IDLE
				
				--恢复游戏当前速率
				hGlobal.event:event("LocalEvent_ResumeSpeed")
			end
			]]
			
			--卡片生效（人族无敌）
			local player = world:GetPlayerMe()
			local auraId = current_tCardList[selectIdx].id
			local tacticLv = current_tCardList[selectIdx].lv
			local maxcount = current_tCardList[selectIdx].maxcount
			local tacticNum = 1 --道具使用次数
			--[[
			local tabT = hVar.tab_tactics[auraId]
			if tabT then
				local itemId = tabT.itemId
				local tabI = hVar.tab_item[itemId]
				if tabI then
					local activeSkill = tabI.activeSkill
					if activeSkill then
						tacticNum = activeSkill.count
					end
				end
			end
			]]
			
			--发送指令联机选卡结果（自动选择）
			local index = 0
			local u_worldI = 0
			if type(tCallback) == "table" then
				index = tCallback[2][1]
				u_worldI = tCallback[2][2]:getworldI()
			end
			--print("发送指令联机选卡结果 A")
			hApi.AddCommand(hVar.Operation.SelectDrawCardRet, auraId, tacticLv, tacticNum, index, u_worldI)
		end
	end
	
	--生成抽卡界面
	OnGenerateDrawCard = function(tCardList)
		--存储数据
		current_tCardList = tCardList
		CARD_NUM = #tCardList --卡片数量
		
		current_autoselecttime = AUTOSELECTTIME --自动选择的倒计时（秒）
		
		local CARD_OFFSET_Y = 0
		
		--依次绘制卡牌
		for i = 1, CARD_NUM, 1 do
			local auraId = current_tCardList[i].id
			local tacticLv = current_tCardList[i].lv
			local tabA = hVar.tab_aura[auraId]
			
			--删除之前可能存在的卡片
			hApi.safeRemoveT(_RedEquipDeribsTipChildUI, "TacticCard_BG_" .. i)
			hApi.safeRemoveT(_RedEquipDeribsTipChildUI, "TacticCard_" .. i)
			hApi.safeRemoveT(_RedEquipDeribsTipChildUI, "TacticCard_Mask_" .. i)
			hApi.safeRemoveT(_RedEquipDeribsTipChildUI, "TacticCard_SelectBox_" .. i)
			
			--卡背按钮
			_RedEquipDeribsTipChildUI["TacticCard_BG_" .. i] = hUI.image:new({
				parent = _RedEquipDeribsTipParent,
				x = _offX - (CARD_NUM / 2) * CARD_OFFSET_X + i * CARD_OFFSET_X - CARD_OFFSET_X / 2,
				y = _offY + CARD_OFFSET_Y,
				--scale = 0.8,
				w = CARD_WIDTH,
				h = CARD_HEIGHT,
				model = "misc/addition/card_endless_back.png",
			})
			
			--卡牌
			--print(auraId)
			local quality = tabA.quality
			local strModel = ""
			if (quality == hVar.ENDLESS_TACTICCARD_COLOR.WHITE) then
				strModel = "misc/addition/card_endless1.png"
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.YELLOW) then
				strModel = "misc/addition/card_endless2.png"
			--elseif (quality == hVar.ITEM_QUALITY.GOLD) then
			--	strModel = "misc/addition/card_endless3.png"
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.RED) then
				strModel = "misc/addition/card_endless4.png"
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.PURPLE) then
				strModel = "misc/addition/card_endless5.png"
			end
			--卡牌按钮
			_RedEquipDeribsTipChildUI["TacticCard_" .. i] = hUI.button:new({ --作为按钮只是为了挂载子控件
				parent = _RedEquipDeribsTipParent,
				x = _offX - (CARD_NUM / 2) * CARD_OFFSET_X + i * CARD_OFFSET_X - CARD_OFFSET_X / 2,
				y = _offY + CARD_OFFSET_Y,
				--scale = 0.8,
				w = CARD_WIDTH,
				h = CARD_HEIGHT,
				model = strModel,
				--[[
				dragbox = hGlobal.UI.GameCoinTipFrame.childUI["dragBox"],
				scaleT = 1.0,
				code = function()
					--动画未完成，不处理
					if (receiveNum < sendNum) then
						return
					end
					
					--标记选中
					if (_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate == 0) then
						_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate = 1
						_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle._n:setVisible(true)
						_RedEquipDeribsTipChildUI["TacticCard_SelectBox_" .. i].handle._n:setVisible(true)
					elseif (_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate == 1) then
						_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate = 0
						_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle._n:setVisible(false)
						_RedEquipDeribsTipChildUI["TacticCard_SelectBox_" .. i].handle._n:setVisible(false)
					end
					
					--取消其他卡片选中框
					for j = 1, CARD_NUM, 1 do
						if (i ~= j) then
							if (_RedEquipDeribsTipChildUI["TacticCard_" .. j].data.selectstate == 1) then
								_RedEquipDeribsTipChildUI["TacticCard_" .. j].data.selectstate = 0
								_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. j].handle._n:setVisible(false)
								_RedEquipDeribsTipChildUI["TacticCard_SelectBox_" .. j].handle._n:setVisible(false)
							end
						end
					end
					
					--动画
					local act1 = CCFadeTo:create(1.0, 212)
					local act2 = CCScaleTo:create(1.0, CARD_SCALE - 0.01)
					local act12 = CCSpawn:createWithTwoActions(act1, act2) --同步1
					local act3 = CCFadeTo:create(1.0, 255)
					local act4 = CCScaleTo:create(1.0, CARD_SCALE - 0.03)
					local act34 = CCSpawn:createWithTwoActions(act3, act4) --同步2
					local a = CCArray:create()
					a:addObject(act12)
					a:addObject(act34)
					local sequence = CCSequence:create(a)
					_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle.s:stopAllActions()
					_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle.s:runAction(CCRepeatForever:create(sequence))
					
					--更新确定按钮状态
					if (_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate == 1) then
						_RedEquipDeribsTipChildUI["btnOK"]:setstate(1)
					elseif (_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate == 0) then
						_RedEquipDeribsTipChildUI["btnOK"]:setstate(0)
					end
				end,
				]]
			})
			
			_RedEquipDeribsTipChildUI["TacticCard_" .. i].handle.s:setOpacity(0) --只挂载子控件，不显示
			_RedEquipDeribsTipChildUI["TacticCard_" .. i].data.selectstate = 0 --标记状态时未选中
			_RedEquipDeribsTipChildUI["TacticCard_" .. i].handle._n:setVisible(false)
			
			--[[
			--卡牌标题
			_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["title"] = hUI.label:new({
				parent = _RedEquipDeribsTipChildUI["TacticCard_" .. i].handle._n,
				x = 0,
				y = 68,
				width = 300,
				size = 28,
				align = "MC",
				font = hVar.FONTC,
				text = "", --hVar.tab_stringT[auraId][1],
				border = 1,
				RGB = {255, 255, 0,},
			})
			if (quality == hVar.ITEM_QUALITY.WHITE) then
				_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["title"].handle.s:setColor(ccc3(hVar.ITEMLEVEL[hVar.ITEM_QUALITY.WHITE].NAMERGB[1], hVar.ITEMLEVEL[hVar.ITEM_QUALITY.WHITE].NAMERGB[2], hVar.ITEMLEVEL[hVar.ITEM_QUALITY.WHITE].NAMERGB[3]))
			elseif (quality == hVar.ITEM_QUALITY.BLUE) then
				_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["title"].handle.s:setColor(ccc3(hVar.ITEMLEVEL[hVar.ITEM_QUALITY.GOLD].NAMERGB[1], hVar.ITEMLEVEL[hVar.ITEM_QUALITY.GOLD].NAMERGB[2], hVar.ITEMLEVEL[hVar.ITEM_QUALITY.GOLD].NAMERGB[3]))
			elseif (quality == hVar.ITEM_QUALITY.GOLD) then
				_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["title"].handle.s:setColor(ccc3(hVar.ITEMLEVEL[hVar.ITEM_QUALITY.RED].NAMERGB[1], hVar.ITEMLEVEL[hVar.ITEM_QUALITY.RED].NAMERGB[2], hVar.ITEMLEVEL[hVar.ITEM_QUALITY.RED].NAMERGB[3]))
			elseif (quality == hVar.ITEM_QUALITY.RED) then
				_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["title"].handle.s:setColor(ccc3(hVar.ITEMLEVEL[hVar.ITEM_QUALITY.ORANGE].NAMERGB[1], hVar.ITEMLEVEL[hVar.ITEM_QUALITY.ORANGE].NAMERGB[2], hVar.ITEMLEVEL[hVar.ITEM_QUALITY.ORANGE].NAMERGB[3]))
			else
				_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["title"].handle.s:setColor(ccc3(hVar.ITEMLEVEL[6].NAMERGB[1], hVar.ITEMLEVEL[6].NAMERGB[2], hVar.ITEMLEVEL[6].NAMERGB[3]))
			end
			]]
			--卡牌介绍
			local introText = hVar.tab_stringA[auraId] and hVar.tab_stringA[auraId][1+tacticLv] or ("未知卡片描述" .. auraId)
			local introTextLength = (#introText)
			--print("introTextLength=", introTextLength)
			local introFontSize = 22
			local DESC_WIDTH = 170
			--先尝试一行
			_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["description"] = hUI.label:new({
				parent = _RedEquipDeribsTipChildUI["TacticCard_" .. i].handle._n,
				x = 0,
				y = -90,
				--width = 170,
				size = introFontSize,
				align = "MT",
				font = hVar.FONTC,
				text = introText,
				border = 1,
				--RGB = {255, 255, 255,},
			})
			local description_w = _RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["description"]:getWH()
			--print(description_w)
			if (description_w > DESC_WIDTH) then
				hApi.safeRemoveT(_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI, "description")
				--居左对齐
				_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["description"] = hUI.label:new({
					parent = _RedEquipDeribsTipChildUI["TacticCard_" .. i].handle._n,
					x = -DESC_WIDTH/2 + introFontSize/2,
					y = -80,
					width = DESC_WIDTH,
					size = introFontSize,
					align = "LT",
					font = hVar.FONTC,
					text = introText,
					border = 1,
					--RGB = {255, 255, 255,},
				})
			end
			--卡牌文字颜色
			local NAMERGB = nil
			if (quality == hVar.ENDLESS_TACTICCARD_COLOR.WHITE) then
				NAMERGB = hVar.ITEMLEVEL[1].NAMERGB
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.YELLOW) then
				NAMERGB = hVar.ITEMLEVEL[3].NAMERGB
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.RED) then
				NAMERGB = hVar.ITEMLEVEL[5].NAMERGB
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.PURPLE) then
				NAMERGB = {255, 0, 255,}
			end
			if NAMERGB then
				_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["description"].handle.s:setColor(ccc3(NAMERGB[1], NAMERGB[2], NAMERGB[3]))
			end
			
			--卡牌品质
			local strModelQuality = ""
			if (quality == hVar.ENDLESS_TACTICCARD_COLOR.WHITE) then
				strModelQuality = "misc/task/ironbuf_tray_01.png"
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.YELLOW) then
				strModelQuality = "misc/task/ironbuf_tray_02.png"
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.RED) then
				strModelQuality = "misc/task/ironbuf_tray_03.png"
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.PURPLE) then
				strModelQuality = "misc/task/ironbuf_tray_04.png"
			end
			_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["quality"] = hUI.image:new({
				parent = _RedEquipDeribsTipChildUI["TacticCard_" .. i].handle._n,
				x = 0,
				y = -40,
				model = strModelQuality,
				scale = 1.2,
			})
			
			--卡牌图标
			_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["icon"] = hUI.image:new({
				parent = _RedEquipDeribsTipChildUI["TacticCard_" .. i].handle._n,
				x = 0,
				y = 10,
				z = 1,
				model = tabA.showmodel,
				scale = 1.5,
			})
			
			--卡牌水晶
			local crystal = tabA.crystal or 0
			if (crystal > 0) then
				local crystalY = 0
				
				--如果有描述文字，水晶往下一点
				if (#introText > 0) then
					crystalY = -30
				end
				
				--水晶图标
				_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["crystal"] = hUI.image:new({
					parent = _RedEquipDeribsTipChildUI["TacticCard_" .. i].handle._n,
					x = 0 - 36,
					y = -120 + crystalY,
					z = 1,
					model = "misc/skillup/mu_coin.png",
					scale = 0.8,
				})
				
				--水晶数值
				_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["crystalNum"] = hUI.label:new({
					parent = _RedEquipDeribsTipChildUI["TacticCard_" .. i].handle._n,
					x = 0,
					y = -120 + crystalY - 2,
					width = DESC_WIDTH,
					size = 22,
					align = "LC",
					font = "numBlue",
					text = crystal,
					border = 0,
				})
				if (crystal >= 1000) then
					_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["crystalNum"]:setXY(-10, -120 + crystalY - 2)
				end
			end
			
			--卡牌选中框
			local strModelSelect = ""
			if (quality == hVar.ENDLESS_TACTICCARD_COLOR.WHITE) then
				strModelSelect = "misc/task/ironbuf_tray_01_2.png"
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.YELLOW) then
				strModelSelect = "misc/task/ironbuf_tray_02_2.png"
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.RED) then
				strModelSelect = "misc/task/ironbuf_tray_03_2.png"
			elseif (quality == hVar.ENDLESS_TACTICCARD_COLOR.PURPLE) then
				strModelSelect = "misc/task/ironbuf_tray_04_2.png"
			end
			_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["selectbox"] = hUI.image:new({
				parent = _RedEquipDeribsTipChildUI["TacticCard_" .. i].handle._n,
				x = 0,
				y = -40,
				model = strModelSelect,
				scale = 1.2,
			})
			_RedEquipDeribsTipChildUI["TacticCard_" .. i].childUI["selectbox"].handle._n:setVisible(false)
			--[[
			_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i] = hUI.image:new({
				parent = _RedEquipDeribsTipParent,
				x = _offX - (CARD_NUM / 2) * CARD_OFFSET_X + i * CARD_OFFSET_X - CARD_OFFSET_X / 2,
				y = _offY + CARD_OFFSET_Y - 40,
				scale = 1.2,
				model = strModelSelect,
			})
			_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle._n:setVisible(false)
			--_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle.s:setColor(ccc3(0, 255, 0))
			--_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle.s:setOpacity(212)
			--_RedEquipDeribsTipChildUI["TacticCard_Mask_" .. i].handle.s:setScale(CARD_SCALE - 0.03)
			]]
			
			--卡牌选中的勾勾
			_RedEquipDeribsTipChildUI["TacticCard_SelectBox_" .. i] = hUI.image:new({
				parent = _RedEquipDeribsTipParent,
				size = 32,
				x = _offX - (CARD_NUM / 2) * CARD_OFFSET_X + i * CARD_OFFSET_X - CARD_OFFSET_X / 2 + CARD_WIDTH / 2 - 56,
				y = _offY - CARD_HEIGHT / 2 + 56,
				model = "misc/button_null.png", --"UI:finish",
			})
			_RedEquipDeribsTipChildUI["TacticCard_SelectBox_" .. i].handle._n:setVisible(false)
			
			--动画完成
			local callback = function()
				receiveNum = receiveNum + 1
			end
			
			--旋转
			local nextstep = function()
				--播放翻卡音效
				if (quality == hVar.ITEM_QUALITY.WHITE) then
					hApi.PlaySound("eff_pickup")
				elseif (quality == hVar.ITEM_QUALITY.BLUE) then
					hApi.PlaySound("eff_pickup")
				else
					hApi.PlaySound("eff_pickup")  --zhongjiang
				end
				
				_RedEquipDeribsTipChildUI["TacticCard_BG_" .. i].handle._n:setVisible(false)
				_RedEquipDeribsTipChildUI["TacticCard_" .. i].handle._n:setVisible(true)
				
				_RedEquipDeribsTipChildUI["TacticCard_" .. i].handle._n:runAction(CCSequence:createWithTwoActions(CCOrbitCamera:create(0.15,-1,0,90,90,0,0),CCCallFunc:create(callback)))
			end
			--翻转
			local a = CCArray:create()
			a:addObject(CCCallFunc:create(function()
				--动画开始
				sendNum = sendNum + 1
			end))
			a:addObject(CCDelayTime:create(ACTION_BEGIN_TIME / 1000 + ACTION_WAIT_TIME / 1000 * (i - 1)))
			a:addObject(CCOrbitCamera:create(ACTION_ROT_TIME / 1000, 1, 0, 0, 90, 0, 0))
			a:addObject(CCCallFunc:create(nextstep))
			_RedEquipDeribsTipChildUI["TacticCard_BG_" .. i].handle._n:runAction(CCSequence:create(a))
		end
		
		--刷新按钮的状态
		--确定按钮
		_RedEquipDeribsTipChildUI["btnOK"]:setstate(0)
		
		--重新计算剩余次数
		local me = world:GetPlayerMe()
		local myPos = me:getpos()
		local maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT --默认值
		if (world.data.session_cfgId == 10) then --人族无敌
			maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_RENZUWUD
		elseif (world.data.session_cfgId == 12) then --守卫剑阁
			maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_SWJG
		elseif (world.data.session_cfgId == 13) then --双人守卫剑阁
			maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_SWJG2
		elseif (world.data.session_cfgId == 15) then --决战虚鲲
			maxcount = hVar.ENDLESS_TACTICCARD_REDRAW_MAXCOUNT_JZXK
		end
		if (world.data.endless_redraw_count[myPos] == nil) then
			world.data.endless_redraw_count[myPos] = {}
		end
		local currentcount = world.data.endless_redraw_count[myPos][unitId] or 0
		local leftcount = maxcount - currentcount
		if (leftcount < 0) then
			leftcount = 0
		end
		
		if (leftcount > 0) then --有剩余次数
			if _RedEquipDeribsTipChildUI["btnReDraw"] then
				hApi.AddShader(_RedEquipDeribsTipChildUI["btnReDraw"].childUI["icon"].handle.s, "normal") --正常
				--_RedEquipDeribsTipChildUI["btnReDraw"].childUI["label"]:setText(hVar.tab_string["__RE_EXCHANGE2__"] .. " (" .. leftcount .. ")")
				--_RedEquipDeribsTipChildUI["btnReDraw"].childUI["label"]:setText("(" .. leftcount .. ")")
				_RedEquipDeribsTipChildUI["btnReDraw"].childUI["label"]:setText(leftcount)
			end
		else --没次数了
			if _RedEquipDeribsTipChildUI["btnReDraw"] then
				hApi.AddShader(_RedEquipDeribsTipChildUI["btnReDraw"].childUI["icon"].handle.s, "gray") --灰掉
				--_RedEquipDeribsTipChildUI["btnReDraw"].childUI["label"]:setText(hVar.tab_string["__RE_EXCHANGE2__"] .. " (" .. leftcount .. ")")
				--_RedEquipDeribsTipChildUI["btnReDraw"].childUI["label"]:setText("(" .. leftcount .. ")")
				_RedEquipDeribsTipChildUI["btnReDraw"].childUI["label"]:setText(leftcount)
			end
		end
		
		--更新倒计时界面值
		if _RedEquipDeribsTipChildUI["TacticAutoSelectTime"] then
			_RedEquipDeribsTipChildUI["TacticAutoSelectTime"]:setText(current_autoselecttime)
		end
		
		--不等待同步帧模式，不自动选择
		local mapInfo = world.data.tdMapInfo
		if (mapInfo.isNoWaitFrame == true) then
			_RedEquipDeribsTipChildUI["TacticAutoSelectTime"]:setText("")
		end
		
		--普通模式，挑战模式，不自动选择
		if (mapInfo.mapMode == hVar.MAP_TD_TYPE.NORMAL) or (mapInfo.mapMode == hVar.MAP_TD_TYPE.DIFFICULT) then
			_RedEquipDeribsTipChildUI["TacticAutoSelectTime"]:setText("")
		end
		
		--清除倒计时自动选择的timer
		hApi.clearTimer("__TD__DRAWCARD_AUTOSELECT_TIMER__")
		
		--倒计时自动选择的timer
		hApi.addTimerForever("__TD__DRAWCARD_AUTOSELECT_TIMER__", hVar.TIMER_MODE.GAMETIME, 1000, OnAntoSelectTimer)
	end
	
	--生成抽卡界面
	OnGenerateDrawCard(tCardList)
	
	--监听人族无敌，再抽一次的回调
	hGlobal.event:listen("LocalEvent_QunYingGe_RedrawCard_Ret", "TD_RedrawCard_Ret_UI_", function(result, orderId, unitId, wave)
		--print("LocalEvent_QunYingGe_RedrawCard_Ret", result, orderId, unitId, wave)
		local world = hGlobal.WORLD.LastWorldMap
		if (result == 1) then --操作成功
			if world then
				--检测波次是否一致
				local drawCardWave = 1 --本次抽卡属于哪一波（防止已经领取卡片了再收到回调）
				local me = world:GetPlayerMe()
				local myPos = me:getpos()
				local tPlayerInfo = world.data.endless_build_tactics[myPos] or {}
				if tPlayerInfo.perWave then
					drawCardWave = #tPlayerInfo.perWave+1
				end
				
				--是当前波次的抽卡
				if (drawCardWave == wave) then
					--标记抽卡次数加1
					if (world.data.endless_redraw_count[myPos] == nil) then
						world.data.endless_redraw_count[myPos] = {}
					end
					local my_count = world.data.endless_redraw_count[myPos][unitId] or 0
					world.data.endless_redraw_count[myPos][unitId] = my_count + 1
					
					--生成新无尽群英阁抽卡列表
					local tCardList = hApi.GenerateSelectCardList(me, unitId)
					print("3选1界面再抽一次")
					print("playerPos=", myPos)
					print("drawCardWave=", drawCardWave)
					print("unitId=", unitId)
					print("tCardList=", tCardList)
					if (tPlayerInfo.perWaveCardList == nil) then
						tPlayerInfo.perWaveCardList = {}
					end
					if (tPlayerInfo.perWaveCardList[drawCardWave] == nil) then
						tPlayerInfo.perWaveCardList[drawCardWave] = {}
					end
					--统计每波的抽卡信息
					tPlayerInfo.perWaveCardList[drawCardWave][unitId] = tCardList
					
					--刷新抽卡界面
					OnGenerateDrawCard(tCardList)
				end
			end
		end
	end)
end
--[[
--测试 --test
local tCardList = {
	{id = 1000,lv=1,},
	{id = 1001,lv=1,},
	{id = 1002,lv=1,},
}
hApi.ShowSelectCardTip_RZWD(tCardList)
]]

function hApi.GetDistanceByPathCount(u,res)
	if nil == u or ni == res then
		return -2
	end
	
	if nil == u.handle._c or nil == res.handle._c then
		return -2
	end
	
	local dis = xlMap_GetPathCount(u.handle._c,res.handle._c)
	--local info = string.format("xlMap_GetPathCount u:[%s] t:[%s] u.x:%d u.y:%d t.x:%d t.y:%d pathCount:%d\n",u.data.name,res.data.name,u.data.gridX,u.data.gridY,res.data.gridX,res.data.gridY,dis)
	--xlLG("ai",info)
	return dis
end

--三角函数类
hApi.Math = {}
hApi.Math.NUM = 360 --360分圆
hApi.Math.ANGLE = 360 / hApi.Math.NUM --360分圆的最小角度

--余弦表
hApi.Math.CosTable =
{
	[0] = 1,     --0
	[1] = 0.99984769515639,     --1
	[2] = 0.9993908270191,      --2
	[3] = 0.99862953475457,     --3
	[4] = 0.99756405025982,     --4
	[5] = 0.99619469809175,     --5
	[6] = 0.99452189536827,     --6
	[7] = 0.99254615164132,     --7
	[8] = 0.99026806874157,     --8
	[9] = 0.98768834059514,     --9
	[10] = 0.98480775301221,    --10
	[11] = 0.98162718344766,    --11
	[12] = 0.97814760073381,    --12
	[13] = 0.97437006478524,    --13
	[14] = 0.970295726276,      --14
	[15] = 0.96592582628907,    --15
	[16] = 0.96126169593832,    --16
	[17] = 0.95630475596304,    --17
	[18] = 0.95105651629515,    --18
	[19] = 0.94551857559932,    --19
	[20] = 0.93969262078591,    --20
	[21] = 0.9335804264972,     --21
	[22] = 0.92718385456679,    --22
	[23] = 0.92050485345244,    --23
	[24] = 0.9135454576426,     --24
	[25] = 0.90630778703665,    --25
	[26] = 0.89879404629917,    --26
	[27] = 0.89100652418837,    --27
	[28] = 0.88294759285893,    --28
	[29] = 0.8746197071394,     --29
	[30] = 0.86602540378444,    --30
	[31] = 0.85716730070211,    --31
	[32] = 0.84804809615643,    --32
	[33] = 0.83867056794542,    --33
	[34] = 0.82903757255504,    --34
	[35] = 0.81915204428899,    --35
	[36] = 0.80901699437495,    --36
	[37] = 0.79863551004729,    --37
	[38] = 0.78801075360672,    --38
	[39] = 0.77714596145697,    --39
	[40] = 0.76604444311898,    --40
	[41] = 0.75470958022277,    --41
	[42] = 0.74314482547739,    --42
	[43] = 0.73135370161917,    --43
	[44] = 0.71933980033865,    --44
	[45] = 0.70710678118655,    --45
	[46] = 0.694658370459,      --46
	[47] = 0.6819983600625,     --47
	[48] = 0.66913060635886,    --48
	[49] = 0.65605902899051,    --49
	[50] = 0.64278760968654,    --50
	[51] = 0.62932039104984,    --51
	[52] = 0.61566147532566,    --52
	[53] = 0.60181502315205,    --53
	[54] = 0.58778525229247,    --54
	[55] = 0.57357643635105,    --55
	[56] = 0.55919290347075,    --56
	[57] = 0.54463903501503,    --57
	[58] = 0.5299192642332,     --58
	[59] = 0.51503807491005,    --59
	[60] = 0.5, --60
	[61] = 0.48480962024634,    --61
	[62] = 0.46947156278589,    --62
	[63] = 0.45399049973955,    --63
	[64] = 0.43837114678908,    --64
	[65] = 0.4226182617407,     --65
	[66] = 0.4067366430758,     --66
	[67] = 0.39073112848927,    --67
	[68] = 0.37460659341591,    --68
	[69] = 0.3583679495453,     --69
	[70] = 0.34202014332567,    --70
	[71] = 0.32556815445716,    --71
	[72] = 0.30901699437495,    --72
	[73] = 0.29237170472274,    --73
	[74] = 0.275637355817,      --74
	[75] = 0.25881904510252,    --75
	[76] = 0.24192189559967,    --76
	[77] = 0.22495105434386,    --77
	[78] = 0.20791169081776,    --78
	[79] = 0.19080899537654,    --79
	[80] = 0.17364817766693,    --80
	[81] = 0.15643446504023,    --81
	[82] = 0.13917310096007,    --82
	[83] = 0.12186934340515,    --83
	[84] = 0.10452846326765,    --84
	[85] = 0.087155742747658,   --85
	[86] = 0.069756473744125,   --86
	[87] = 0.052335956242944,   --87
	[88] = 0.034899496702501,   --88
	[89] = 0.017452406437283,   --89
	[90] = 0,        --90
	[91] = -0.017452406437283,  --91
	[92] = -0.034899496702501,  --92
	[93] = -0.052335956242944,  --93
	[94] = -0.069756473744125,  --94
	[95] = -0.087155742747658,  --95
	[96] = -0.10452846326765,   --96
	[97] = -0.12186934340515,   --97
	[98] = -0.13917310096007,   --98
	[99] = -0.15643446504023,   --99
	[100] = -0.17364817766693,  --100
	[101] = -0.19080899537654,  --101
	[102] = -0.20791169081776,  --102
	[103] = -0.22495105434386,  --103
	[104] = -0.24192189559967,  --104
	[105] = -0.25881904510252,  --105
	[106] = -0.275637355817,    --106
	[107] = -0.29237170472274,  --107
	[108] = -0.30901699437495,  --108
	[109] = -0.32556815445716,  --109
	[110] = -0.34202014332567,  --110
	[111] = -0.3583679495453,   --111
	[112] = -0.37460659341591,  --112
	[113] = -0.39073112848927,  --113
	[114] = -0.4067366430758,   --114
	[115] = -0.4226182617407,   --115
	[116] = -0.43837114678908,  --116
	[117] = -0.45399049973955,  --117
	[118] = -0.46947156278589,  --118
	[119] = -0.48480962024634,  --119
	[120] = -0.5,       --120
	[121] = -0.51503807491005,  --121
	[122] = -0.5299192642332,   --122
	[123] = -0.54463903501503,  --123
	[124] = -0.55919290347075,  --124
	[125] = -0.57357643635105,  --125
	[126] = -0.58778525229247,  --126
	[127] = -0.60181502315205,  --127
	[128] = -0.61566147532566,  --128
	[129] = -0.62932039104984,  --129
	[130] = -0.64278760968654,  --130
	[131] = -0.65605902899051,  --131
	[132] = -0.66913060635886,  --132
	[133] = -0.6819983600625,   --133
	[134] = -0.694658370459,    --134
	[135] = -0.70710678118655,  --135
	[136] = -0.71933980033865,  --136
	[137] = -0.73135370161917,  --137
	[138] = -0.74314482547739,  --138
	[139] = -0.75470958022277,  --139
	[140] = -0.76604444311898,  --140
	[141] = -0.77714596145697,  --141
	[142] = -0.78801075360672,  --142
	[143] = -0.79863551004729,  --143
	[144] = -0.80901699437495,  --144
	[145] = -0.81915204428899,  --145
	[146] = -0.82903757255504,  --146
	[147] = -0.83867056794542,  --147
	[148] = -0.84804809615643,  --148
	[149] = -0.85716730070211,  --149
	[150] = -0.86602540378444,  --150
	[151] = -0.8746197071394,   --151
	[152] = -0.88294759285893,  --152
	[153] = -0.89100652418837,  --153
	[154] = -0.89879404629917,  --154
	[155] = -0.90630778703665,  --155
	[156] = -0.9135454576426,   --156
	[157] = -0.92050485345244,  --157
	[158] = -0.92718385456679,  --158
	[159] = -0.9335804264972,   --159
	[160] = -0.93969262078591,  --160
	[161] = -0.94551857559932,  --161
	[162] = -0.95105651629515,  --162
	[163] = -0.95630475596304,  --163
	[164] = -0.96126169593832,  --164
	[165] = -0.96592582628907,  --165
	[166] = -0.970295726276,    --166
	[167] = -0.97437006478524,  --167
	[168] = -0.97814760073381,  --168
	[169] = -0.98162718344766,  --169
	[170] = -0.98480775301221,  --170
	[171] = -0.98768834059514,  --171
	[172] = -0.99026806874157,  --172
	[173] = -0.99254615164132,  --173
	[174] = -0.99452189536827,  --174
	[175] = -0.99619469809175,  --175
	[176] = -0.99756405025982,  --176
	[177] = -0.99862953475457,  --177
	[178] = -0.9993908270191,   --178
	[179] = -0.99984769515639,  --179
	[180] = -1, --180
	[181] = -0.99984769515639,  --181
	[182] = -0.9993908270191,   --182
	[183] = -0.99862953475457,  --183
	[184] = -0.99756405025982,  --184
	[185] = -0.99619469809175,  --185
	[186] = -0.99452189536827,  --186
	[187] = -0.99254615164132,  --187
	[188] = -0.99026806874157,  --188
	[189] = -0.98768834059514,  --189
	[190] = -0.98480775301221,  --190
	[191] = -0.98162718344766,  --191
	[192] = -0.97814760073381,  --192
	[193] = -0.97437006478524,  --193
	[194] = -0.970295726276,    --194
	[195] = -0.96592582628907,  --195
	[196] = -0.96126169593832,  --196
	[197] = -0.95630475596304,  --197
	[198] = -0.95105651629515,  --198
	[199] = -0.94551857559932,  --199
	[200] = -0.93969262078591,  --200
	[201] = -0.9335804264972,   --201
	[202] = -0.92718385456679,  --202
	[203] = -0.92050485345244,  --203
	[204] = -0.9135454576426,   --204
	[205] = -0.90630778703665,  --205
	[206] = -0.89879404629917,  --206
	[207] = -0.89100652418837,  --207
	[208] = -0.88294759285893,  --208
	[209] = -0.8746197071394,   --209
	[210] = -0.86602540378444,  --210
	[211] = -0.85716730070211,  --211
	[212] = -0.84804809615643,  --212
	[213] = -0.83867056794542,  --213
	[214] = -0.82903757255504,  --214
	[215] = -0.81915204428899,  --215
	[216] = -0.80901699437495,  --216
	[217] = -0.79863551004729,  --217
	[218] = -0.78801075360672,  --218
	[219] = -0.77714596145697,  --219
	[220] = -0.76604444311898,  --220
	[221] = -0.75470958022277,  --221
	[222] = -0.74314482547739,  --222
	[223] = -0.73135370161917,  --223
	[224] = -0.71933980033865,  --224
	[225] = -0.70710678118655,  --225
	[226] = -0.694658370459,    --226
	[227] = -0.6819983600625,   --227
	[228] = -0.66913060635886,  --228
	[229] = -0.65605902899051,  --229
	[230] = -0.64278760968654,  --230
	[231] = -0.62932039104984,  --231
	[232] = -0.61566147532566,  --232
	[233] = -0.60181502315205,  --233
	[234] = -0.58778525229247,  --234
	[235] = -0.57357643635105,  --235
	[236] = -0.55919290347075,  --236
	[237] = -0.54463903501503,  --237
	[238] = -0.52991926423321,  --238
	[239] = -0.51503807491005,  --239
	[240] = -0.5,       --240
	[241] = -0.48480962024634,  --241
	[242] = -0.46947156278589,  --242
	[243] = -0.45399049973955,  --243
	[244] = -0.43837114678908,  --244
	[245] = -0.4226182617407,   --245
	[246] = -0.4067366430758,   --246
	[247] = -0.39073112848927,  --247
	[248] = -0.37460659341591,  --248
	[249] = -0.3583679495453,   --249
	[250] = -0.34202014332567,  --250
	[251] = -0.32556815445716,  --251
	[252] = -0.30901699437495,  --252
	[253] = -0.29237170472274,  --253
	[254] = -0.275637355817,    --254
	[255] = -0.25881904510252,  --255
	[256] = -0.24192189559967,  --256
	[257] = -0.22495105434387,  --257
	[258] = -0.20791169081776,  --258
	[259] = -0.19080899537655,  --259
	[260] = -0.17364817766693,  --260
	[261] = -0.15643446504023,  --261
	[262] = -0.13917310096006,  --262
	[263] = -0.12186934340515,  --263
	[264] = -0.10452846326765,  --264
	[265] = -0.087155742747658, --265
	[266] = -0.069756473744126, --266
	[267] = -0.052335956242944, --267
	[268] = -0.034899496702502, --268
	[269] = -0.017452406437283, --269
	[270] = 0,       --270
	[271] = 0.017452406437283,  --271
	[272] = 0.034899496702501,  --272
	[273] = 0.052335956242944,  --273
	[274] = 0.069756473744125,  --274
	[275] = 0.087155742747658,  --275
	[276] = 0.10452846326765,   --276
	[277] = 0.12186934340515,   --277
	[278] = 0.13917310096007,   --278
	[279] = 0.15643446504023,   --279
	[280] = 0.17364817766693,   --280
	[281] = 0.19080899537654,   --281
	[282] = 0.20791169081776,   --282
	[283] = 0.22495105434386,   --283
	[284] = 0.24192189559967,   --284
	[285] = 0.25881904510252,   --285
	[286] = 0.275637355817,     --286
	[287] = 0.29237170472274,   --287
	[288] = 0.30901699437495,   --288
	[289] = 0.32556815445716,   --289
	[290] = 0.34202014332567,   --290
	[291] = 0.3583679495453,    --291
	[292] = 0.37460659341591,   --292
	[293] = 0.39073112848927,   --293
	[294] = 0.4067366430758,    --294
	[295] = 0.4226182617407,    --295
	[296] = 0.43837114678908,   --296
	[297] = 0.45399049973955,   --297
	[298] = 0.46947156278589,   --298
	[299] = 0.48480962024634,   --299
	[300] = 0.5,        --300
	[301] = 0.51503807491005,   --301
	[302] = 0.5299192642332,    --302
	[303] = 0.54463903501503,   --303
	[304] = 0.55919290347075,   --304
	[305] = 0.57357643635105,   --305
	[306] = 0.58778525229247,   --306
	[307] = 0.60181502315205,   --307
	[308] = 0.61566147532566,   --308
	[309] = 0.62932039104984,   --309
	[310] = 0.64278760968654,   --310
	[311] = 0.65605902899051,   --311
	[312] = 0.66913060635886,   --312
	[313] = 0.6819983600625,    --313
	[314] = 0.694658370459,     --314
	[315] = 0.70710678118655,   --315
	[316] = 0.71933980033865,   --316
	[317] = 0.73135370161917,   --317
	[318] = 0.74314482547739,   --318
	[319] = 0.75470958022277,   --319
	[320] = 0.76604444311898,   --320
	[321] = 0.77714596145697,   --321
	[322] = 0.78801075360672,   --322
	[323] = 0.79863551004729,   --323
	[324] = 0.80901699437495,   --324
	[325] = 0.81915204428899,   --325
	[326] = 0.82903757255504,   --326
	[327] = 0.83867056794542,   --327
	[328] = 0.84804809615643,   --328
	[329] = 0.85716730070211,   --329
	[330] = 0.86602540378444,   --330
	[331] = 0.8746197071394,    --331
	[332] = 0.88294759285893,   --332
	[333] = 0.89100652418837,   --333
	[334] = 0.89879404629917,   --334
	[335] = 0.90630778703665,   --335
	[336] = 0.9135454576426,    --336
	[337] = 0.92050485345244,   --337
	[338] = 0.92718385456679,   --338
	[339] = 0.9335804264972,    --339
	[340] = 0.93969262078591,   --340
	[341] = 0.94551857559932,   --341
	[342] = 0.95105651629515,   --342
	[343] = 0.95630475596304,   --343
	[344] = 0.96126169593832,   --344
	[345] = 0.96592582628907,   --345
	[346] = 0.970295726276,     --346
	[347] = 0.97437006478524,   --347
	[348] = 0.97814760073381,   --348
	[349] = 0.98162718344766,   --349
	[350] = 0.98480775301221,   --350
	[351] = 0.98768834059514,   --351
	[352] = 0.99026806874157,   --352
	[353] = 0.99254615164132,   --353
	[354] = 0.99452189536827,   --354
	[355] = 0.99619469809175,   --355
	[356] = 0.99756405025982,   --356
	[357] = 0.99862953475457,   --357
	[358] = 0.9993908270191,    --358
	[359] = 0.99984769515639,   --359
	[360] = 1,  --360
}

--求余弦函数
hApi.Math.Cos = function(angle)
	angle = angle % 360
	if (angle < 0) then
		angle = angle + 360
	end
	local num = math.floor(angle / hApi.Math.ANGLE)
	local cosValue = hApi.Math.CosTable[num]
	return cosValue
end

--求正弦函数
hApi.Math.Sin = function(angle)
	return hApi.Math.Cos(angle - 90)
end

--检测是否有背包的道具可装备到英雄身上
hApi.CheckBagTakeOnEquip = function()
	--检测战车装备是否已满
	local bEquipFull = true
	for i = 1, hVar.ItemGridLine * hVar.ItemGridCow, 1 do
		local _,oEquip = LuaFindEquipByPos({"hero", hVar.MY_TANK_ID, i,})
		--print(i, oEquip)
		if (oEquip == 0) then --无装备
			bEquipFull = false
			break
		end
	end
	--print("bEquipFull=", bEquipFull)
	
	--检测背包是否有装备
	local bBagHaveItem = false
	local vipLv = LuaGetPlayerVipLv()
	local pageNum = LuaGetPlayerBagPageNum(vipLv)
	local bagNum = pageNum * hVar.PLAYERBAG_X_NUM * hVar.PLAYERBAG_Y_NUM
	for i = 1, bagNum, 1 do
		local _,oEquip = LuaFindEquipByPos({"storehouse", i,})
		--print(i, oEquip)
		if (type(oEquip) == "table") then --有装备
			bBagHaveItem = true
			break
		end
	end
	--print("bBagHaveItem=", bBagHaveItem)
	
	return ((not bEquipFull) and bBagHaveItem)
end


local tBubbleAreaMsg = {}
local BubbleSingleArenaMsg = function(userName, noticeInfo, noticeType, nDiff, onFinished)
	
	local bgPosY = 35 + 128 --父控件y坐标
	local bgWidth = 1140 --父控件宽度
	local bgHeight = 50 --父控件高度
	local bgLineHeight = 3 --父控件线条高度
	local textSize = 42 --文字大小
	local textDistance = 5 --文字间距
	local text1OffsetX = 8 - 12 --第一个文字的偏移x
	
	--播放的速度倍率，如果后续等待广播的队列数量太多，对于一些类型的文字，要加快速度
	local timeRatio = 1.0
	
	--文字默认显示1秒，需要额外显示的秒数
	local disappearTime = 0 --秒
	
	local button = nil
	
	--如果存在上一次的控件，不重复绘制
	if hGlobal.UI.ArenaMsgButton then
		--老控件
		button = hGlobal.UI.ArenaMsgButton
		
		--删除之前的文字
		for i = 1, 20, 1 do
			hApi.safeRemoveT(button.childUI["labelParent"].childUI, "LabelText" .. i) 
		end
		--print("存在，老控件")
	else
		--print("不存在，新控件")
		--新控件
		button = hUI.frame:new({
			parent = nil,
			--model = "misc/mask.png",
			model = -1,
			x = hVar.SCREEN.w/2,
			y = hVar.SCREEN.h - bgPosY,
			z = 100001,
			w = 1,
			h = 1,
			background = -1,
			border = 0,
		})
		--button.handle.s:setOpacity(0) --不显示，只用于控制
		hGlobal.UI.ArenaMsgButton = button
		
		--背景图1
		button.childUI["RoomMyRankBG1"] = hUI.image:new({
			parent = button.handle._n,
			model = "UI:BLACK", --"UI:AttrBg",
			x = 0,
			y = 1,
			w = bgWidth,
			h = bgHeight,
		})
		button.childUI["RoomMyRankBG1"].handle.s:setOpacity(144)
		--local img9 = hApi.CCScale9SpriteCreateWithSpriteFrameName("data/image/ui/TacticBG.png", 2, 1, 1200, 60, button)
		--img9:setOpacity(204)
		
		--背景图2
		button.childUI["RoomMyRankBG2"] = hUI.image:new({
			parent = button.handle._n,
			model = "ui/title_line.png",
			x = 0 + 1,
			y = 1 + bgHeight / 2,
			w = bgWidth + 2, --图片右边缺一点点
			h = bgLineHeight,
		})
		
		--背景图3
		button.childUI["RoomMyRankBG3"] = hUI.image:new({
			parent = button.handle._n,
			model = "ui/title_line.png",
			x = 0 + 1,
			y = 1 - bgHeight / 2,
			w = bgWidth + 2, --图片右边缺一点点
			h = bgLineHeight,
		})
		
		--文字的父控件
		button.childUI["labelParent"] = hUI.button:new({ --作为按钮是为了挂载子控件
			parent = button.handle._n,
			model = -1,
			x = 0,
			y = 0,
			w = 1,
			h = 1,
		})
		
		--裁剪区域
		local clipWidth = bgWidth - 4
		local _BTC_ClippingRect = {-clipWidth / 2, bgHeight / 2, clipWidth, bgHeight, 0} -- {x, y, w, h, show}
		local ClipNode, SpriteMask, pSpriteMaskN = hApi.CreateClippingNode(button, _BTC_ClippingRect, 98, _BTC_ClippingRect[5], "_BTC_ClippingRect")
		button.data.ClipNode = ClipNode
	end
	
	--待绘制的文字列表
	local bubblelist = nil
	
	if (noticeType == hVar.BUBBLE_NOTICE_TYPE.RED_EQUIP) then --获得4孔神器
		--多显示几秒
		disappearTime = -1 --默认等待1秒，-1表示不中央等待了
		
		--播放速度倍率
		timeRatio = 1.0
		
		--道具名
		local itemName = hVar.tab_stringI[nDiff] and hVar.tab_stringI[nDiff][1] or ("未知道具" .. nDiff)
		-- local itemName = "测试道具123"
		
		--待绘制的文字列表
		bubblelist =
		{
			{text = tostring(userName), color = ccc3(0, 255, 0),},
			{text = tostring(noticeInfo), color = ccc3(255, 255, 255),},
			{text = "4" .. hVar.tab_string["__TEXT__Slot"], color = ccc3(255, 136, 0),}, --"4孔"
			{text = itemName, color = ccc3(255, 64, 0),},
			{text = "!!!", color = ccc3(255, 255, 255),},
		}
	elseif (noticeType == hVar.BUBBLE_NOTICE_TYPE.PET_STARUP) then --宠物升星（解锁）
		--多显示几秒
		disappearTime = -1 --默认等待1秒，-1表示不中央等待了
		
		--播放速度倍率
		timeRatio = 1.0
		
		--宠物名
		local petName = hVar.tab_stringU[nDiff] and hVar.tab_stringU[nDiff][1] or ("未知宠物" .. nDiff)
		-- petName = "测试宠物" .. tostring(nDiff)
		
		-- 星级
		local starNum = noticeInfo
		-- starNum = "2"
		local nStar = assert(tonumber(starNum), "星级无法转换为number")
		assert(nStar > -1, "星级数据错误：" .. nStar)
		
		if nStar == 0 then
			-- 宠物解锁
			bubblelist =
			{
				{text = tostring(userName), color = ccc3(0, 255, 0),},
				{text = hVar.tab_string["__TEXT_SCROLL_NOTICE_UNLOCK"] .. hVar.tab_string["__TEXT_SCROLL_NOTICE_PET"], color = ccc3(255, 255, 255),}, --"解锁了宠物"
				{text = petName, color = ccc3(255, 136, 0),},
				{text = "!!!", color = ccc3(255, 255, 255),},
			}
		else
			-- 宠物升星
			bubblelist =
			{
				{text = tostring(userName), color = ccc3(0, 255, 0),},
				{text = hVar.tab_string["__TEXT__De"] .. hVar.tab_string["__TEXT_SCROLL_NOTICE_PET"], color = ccc3(255, 255, 255),}, --"的宠物"
				{text = petName, color = ccc3(255, 136, 0),},
				{text = hVar.tab_string["__TEXT__UpgrateTo"], color = ccc3(255, 255, 255),}, --"升到了"
				{text = starNum .. hVar.tab_string["__TEXT_star"], color = ccc3(255, 255, 0),}, --"X星"
				{text = "!!!", color = ccc3(255, 255, 255),},
			}
		end
	elseif (noticeType == hVar.BUBBLE_NOTICE_TYPE.WEAPON_STARUP) then --武器枪升星（解锁）
		--多显示几秒
		disappearTime = -1 --默认等待1秒，-1表示不中央等待了
		
		--播放速度倍率
		timeRatio = 1.0
		
		--武器名
		local weaponName = hVar.tab_stringU[nDiff] and hVar.tab_stringU[nDiff][1] or ("未知武器" .. nDiff)
		-- weaponName = "测试武器" .. tostring(nDiff)

		-- 星级
		local starNum = noticeInfo
		-- starNum = "2"
		local nStar = assert(tonumber(starNum), "星级无法转换为number")
		assert(nStar > -1, "星级数据错误：" .. nStar)
		
		if nStar == 0 then
			-- 武器解锁
			bubblelist =
			{
				{text = tostring(userName), color = ccc3(0, 255, 0),},
				{text = hVar.tab_string["__TEXT_SCROLL_NOTICE_UNLOCK"] .. hVar.tab_string["__TEXT_SCROLL_NOTICE_WEAPON"], color = ccc3(255, 255, 255),}, --"解锁了武器"
				{text = weaponName, color = ccc3(255, 136, 0),},
				{text = "!!!", color = ccc3(255, 255, 255),},
			}
		else
			-- 武器升星
			bubblelist =
			{
				{text = tostring(userName), color = ccc3(0, 255, 0),},
				{text = hVar.tab_string["__TEXT__De"] .. hVar.tab_string["__TEXT_SCROLL_NOTICE_WEAPON"], color = ccc3(255, 255, 255),}, --"的武器"
				{text = weaponName, color = ccc3(255, 136, 0),},
				{text = hVar.tab_string["__TEXT__UpgrateTo"], color = ccc3(255, 255, 255),}, --"升到了"
				{text = starNum .. hVar.tab_string["__TEXT_star"], color = ccc3(255, 255, 0),}, --"X星"
				{text = "!!!", color = ccc3(255, 255, 255),},
			}
		end
	end
	
	--如果存在要广播的文字，进行广播
	if (#bubblelist > 0) then
		--[[
		--计算文字的总长度
		local textLength = 0
		for i = 1, #bubblelist, 1 do
			local text = bubblelist[i].text
			local length = hApi.GetStringEmojiCNLength(text) --处理表情，中文长度
			textLength = textLength + length * textSize + textDistance
		end
		]]
		
		--依次绘制
		local actionTotal = #bubblelist --动画总数量
		local actionFinish = 0 --动画完成数量
		--local leftLength = -textLength / 2 + textDistance + text1OffsetX
		local textLengthList = {}
		for i = 1, #bubblelist, 1 do
			local text_i = bubblelist[i].text
			local color_i = bubblelist[i].color
			--local length_i = hApi.GetStringEmojiCNLength(text_i) --处理表情，中文长度
			
			--绘制文字
			--local toX = leftLength + length_i * textSize / 2
			local toY = -2
			local beginX = 0 --toX + bgWidth
			local beginY = toY
			button.childUI["labelParent"].childUI["LabelText" .. i] = hUI.label:new({
				--parent = button.childUI["labelParent"].handle._n,
				parent = button.data.ClipNode,
				x = beginX,
				--y = beginY,
				y = beginY,
				font = hVar.FONTC,
				--size = textSize+2, --字体映射会小一点
				size = textSize+2,
				align = "MC",
				--width = 800,
				text = text_i,
				border = 1,
			})
			--计算文字宽度
			local length_i = button.childUI["labelParent"].childUI["LabelText" .. i]:getWH()
			textLengthList[i] = length_i
			--print(length_i)
			--button.childUI["labelParent"].childUI["LabelText" .. i].data.beginX = beginX --记录一开始的坐标
			--button.childUI["labelParent"].childUI["LabelText" .. i].data.beginY = beginY --记录一开始的坐标
			button.childUI["labelParent"].childUI["LabelText" .. i].handle.s:setColor(color_i)
			
			--偏移值
			--leftLength = leftLength + length_i * textSize + textDistance
			--leftLength = leftLength + length_i + textDistance
		end
		
		--计算文字的总长度
		local textLength = 0
		for i = 1, #textLengthList, 1 do
			textLength = textLength + textLengthList[i] + textDistance
		end
		--print("textLength=", textLength)
		
		--计算文字初始位置
		local leftLength = -textLength / 2 + textDistance + text1OffsetX
		--如果文字总长度超过了clip区域，那么初始的位置得往右挪
		if (textLength > bgWidth) then
			leftLength = leftLength + (textLength - bgWidth) / 2
		end
		for i = 1, #bubblelist, 1 do
			local length_i = textLengthList[i]
			local crtilI = button.childUI["labelParent"].childUI["LabelText" .. i]
			
			--绘制文字
			local toX = leftLength + length_i / 2
			local toY = -2
			local beginX = toX + bgWidth
			local beginY = toY
			
			crtilI:setXY(beginX, beginY)
			crtilI.data.beginX = beginX
			crtilI.data.beginY = beginY
			
			leftLength = leftLength + length_i + textDistance
		end
		
		--这里用timer做动画，因为action的速率不稳定
		local delay1_time = 0
		local delay1_time_max = 1200 --毫秒
		
		local moveLeft_time = 0
		local moveLeft_time_max = 8000 --毫秒
		--如果文字总长度超过了clip区域，那么左移时间要长点
		if (textLength > bgWidth) then
			moveLeft_time_max = math.floor(8000 * textLength / bgWidth)
		end
		local moveLeft_speed = bgWidth / moveLeft_time_max --速度
		--local button_begin_x = button.childUI["labelParent"].data.x
		--local button_begin_y = button.childUI["labelParent"].data.y
		local button_to_offset_x = -bgWidth
		local button_to_offset_y = 0
		local button_to_dx = 0
		local button_to_dy = 0
		
		local delay2_time = 0
		local delay2_time_max = (1000 + disappearTime * 1000) / timeRatio --毫秒
		--print(delay2_time_max)
		
		local button_finish_offset_x = button_to_offset_x - bgWidth
		--如果文字总长度超过了clip区域，那么结束的位置得往左挪
		if (textLength > bgWidth) then
			button_finish_offset_x = button_finish_offset_x - (textLength - bgWidth)
		end
		local button_finish_offset_y = 0
		
		local delay3_time = 0
		local delay3_time_max = 1200 --毫秒
		
		local action_state = 0 --动画的步骤
		hApi.addTimerForever("__TD__BROADCAST_TIMER__", hVar.TIMER_MODE.GAMETIME, 1, function(currentTime, deltaTime)
			--local deltaTime = 16 --稳定60帧
			
			if (action_state == 0) then --初始化
				action_state = "delay1"
			elseif (action_state == "delay1") then --在屏幕最右侧，等待
				delay1_time = delay1_time + deltaTime
				if (delay1_time >= delay1_time_max) then
					action_state = "moveLeft"
				end
			elseif (action_state == "moveLeft") then --移动到屏幕中央
				button_to_dx = button_to_dx - moveLeft_speed * deltaTime / hApi.GetTimeScale()
				if (button_to_dx <= button_to_offset_x) then
					button_to_dx = button_to_offset_x
					
					action_state = "delay2"
				end
				
				--逐一运动
				for i = 1, #bubblelist, 1 do
					local ctrli = button.childUI["labelParent"].childUI["LabelText" .. i]
					if ctrli then
						local beginX = ctrli.data.beginX
						local beginY = ctrli.data.beginY
						ctrli:setXY(beginX + button_to_dx, beginY + button_to_dy)
					end
				end
				--button.childUI["labelParent"]:setXY(button_x, button_y)
			elseif (action_state == "delay2") then --在屏幕中央，等待
				delay2_time = delay2_time + deltaTime
				if (delay2_time >= delay2_time_max) then
					action_state = "moveOut"
				end
			elseif (action_state == "moveOut") then --移动到屏幕最左侧
				button_to_dx = button_to_dx - moveLeft_speed * deltaTime / hApi.GetTimeScale()
				if (button_to_dx <= button_finish_offset_x) then
					button_to_dx = button_finish_offset_x
					
					action_state = "delay3"
					
					--优化: 如果后续还有要广播的内容，移出屏幕的时间少0.8秒
					if (#tBubbleAreaMsg > 1) then
						delay3_time = 800 --毫秒
					end
				end
				
				--button.childUI["labelParent"]:setXY(button_x, button_y)
				--逐一运动
				for i = 1, #bubblelist, 1 do
					local ctrli = button.childUI["labelParent"].childUI["LabelText" .. i]
					if ctrli then
						local beginX = ctrli.data.beginX
						local beginY = ctrli.data.beginY
						ctrli:setXY(beginX + button_to_dx, beginY + button_to_dy)
					end
				end
			elseif (action_state == "delay3") then --在屏幕最左侧，等待动画结束
				delay3_time = delay3_time + deltaTime
				if (delay3_time >= delay3_time_max) then
					action_state = "actCall"
				end
			elseif (action_state == "actCall") then --动画结束
				--删除本控件
				--button.handle._n:removeChild(ClipNode, true)
				--button.handle._n:removeChild(SpriteMask, true)
				--button.handle._n:removeChild(pSpriteMaskN, true)
				--优化: 如果后续还有要广播的内容，不删除控件
				if (#tBubbleAreaMsg <= 1) then
					button:del()
					hGlobal.UI.ArenaMsgButton = nil
					--print("删除控件")
				end
				
				--删除timer
				hApi.clearTimer("__TD__BROADCAST_TIMER__")
				
				--触发回调
				if onFinished then
					onFinished()
				end
			end
		end)
	else
		--没有要广播的文字
		--删除本控件
		--button.handle._n:removeChild(ClipNode, true)
		--button.handle._n:removeChild(SpriteMask, true)
		--button.handle._n:removeChild(pSpriteMaskN, true)
		--优化: 如果后续还有要广播的内容，不删除控件
		if (#tBubbleAreaMsg <= 1) then
			button:del()
			hGlobal.UI.ArenaMsgButton = nil
			--print("删除控件")
		end
		
		--触发回调
		if onFinished then
			onFinished()
		end
	end
end

--队列冒泡消息回调函数
local BubbleQueueArenaMsgCallback = nil
BubbleQueueArenaMsgCallback = function()
	--移除队首的项
	table.remove(tBubbleAreaMsg, 1)
	
	--队列还有待冒泡的，继续动画
	if (#tBubbleAreaMsg > 0) then
		local t = tBubbleAreaMsg[1]
		BubbleSingleArenaMsg(t[1], t[2], t[3], t[4], BubbleQueueArenaMsgCallback)
		--print("继续播放")
	else
		--print("停止播放")
	end
end

--队列冒泡消息
hApi.BubbleQueueArenaMsg = function(userName, noticeInfo, noticeType, nDiff)
	--不重复插入相同的数据
	for i = 1, #tBubbleAreaMsg, 1 do
		local t = tBubbleAreaMsg[i]
		if (t[1] == userName) and (t[2] == noticeInfo) and (t[3] == noticeType) and (t[4] == nDiff) then
			return
		end
	end
	
	--插入队列
	table.insert(tBubbleAreaMsg, {userName, noticeInfo, noticeType, nDiff})
	
	--是第一项，播放动画
	if (#tBubbleAreaMsg == 1) then
		BubbleSingleArenaMsg(userName, noticeInfo, noticeType, nDiff, BubbleQueueArenaMsgCallback)
		--print("开始播放")
	end
end

--显示快捷入口的tip
hApi.ShowShorcutTip = function()
	--删除上一次兵符界面
	if hGlobal.UI.PhonePvpoinFrm then
		hGlobal.UI.PhonePvpoinFrm:del()
		hGlobal.UI.PhonePvpoinFrm = nil
	end
	
	--移除事件监听：我的体力信息返回事件
	--hGlobal.event:listen("LocalEvent_TiLiInfo_Ret", "__TiLiInfo_PvpCoin_", nil)
	--移除事件监听：兑换体力返回事件
	--hGlobal.event:listen("LocalEvent_ExchangeTiLi_Ret", "__ExchangeTiLi_PvpCoin_", nil)
	--移除事件监听：横竖屏切换
	hGlobal.event:listen("LocalEvent_SpinScreen", "__SpinScreen_Shorcut_", nil)
	
	--local on_receive_TiLi_baseInfoRet_bf = hApi.DoNothing --我的体力信息返回事件
	--local on_receive_ExchangeTiLiRet_bf = hApi.DoNothing --兑换体力返回事件
	local on_spine_screen_event_shortcut = hApi.DoNothing --横竖屏切换
	
	--创建兵符面板
	hGlobal.UI.PhonePvpoinFrm = hUI.frame:new(
	{
		x = hVar.SCREEN.w / 2 - 720 / 2,
		y = hVar.SCREEN.h / 2 + 720 / 2 + 0,
		--z = 100002,
		w = 720,
		h = 720,
		dragable = 2,
		show = 1, --一开始不显示
		border = 0, --"UI:TileFrmBasic_thin",
		--border = "UI:TileFrmBack_PVP",
		--background = "panel/panel_part_pvp_00.png",
		background = 0, --"misc/skillup/msgbox6.png", --"UI:Tactic_Background",
		autoactive = 0,
		
		--点击事件
		codeOnTouch = function(self, x, y, sus)
			--在外部点击
			if (sus == 0) then
				self.childUI["closeBtn"].data.code()
			end
		end,
	})
	hGlobal.UI.PhonePvpoinFrm:active()
	
	--创建9宫格贴图(create)
	hApi.CCScale9SpriteCreate("data/image/misc/addition/info_center_panel.png", 360, -360, 602, 569, hGlobal.UI.PhonePvpoinFrm)
	
	--[[
	local onclickevent = nil
	local MsgSelections = nil
	MsgSelections = {
		style = "mini",
		select = 0,
		ok = function()
			onclickevent()
		end,
		--cancel = function()
		--	onclickevent()
		--end,
		--cancelFun = cancelCallback, --点否的回调函数
		--textOk = "领取",
		textOk = hVar.tab_string["__Get__"], --language
		--textCancel = "确定", --language
		--textCancel = hVar.tab_string["Exit_Ack"], --language
		userflag = 0, --用户的标记
	}
	local msgBox = hGlobal.UI.MsgBox("", MsgSelections)
	msgBox:active()
	msgBox:show(1,"fade",{time=0.08})
	]]
	local msgBox = hGlobal.UI.PhonePvpoinFrm
	
	--背景底图
	msgBox.childUI["BG"] = hUI.image:new({
		parent = msgBox.handle._n,
		model = "misc/mask_white.png",
		x = 0,
		y = 0,
		z = -100,
		w = hVar.SCREEN.w * 2,
		h = hVar.SCREEN.h * 2,
	})
	msgBox.childUI["BG"].handle.s:setOpacity(88)
	msgBox.childUI["BG"].handle.s:setColor(ccc3(0, 0, 0))
	
	--关闭按钮
	msgBox.childUI["closeBtn"] = hUI.button:new({
		parent = msgBox.handle._n,
		dragbox = msgBox.childUI["dragBox"],
		model = "ui/close.png",
		--x = hGlobal.UI.PhonePvpoinFrm.data.w - 78,
		--y = -140,
		--w = 48,
		--h = 48,
		x = 138,
		y = -590,
		w = 76,
		h = 76,
		scaleT = 0.95,
		code = function()
			--移除事件监听：我的体力信息返回事件
			hGlobal.event:listen("LocalEvent_TiLiInfo_Ret", "__TiLiInfo_PvpCoin_", nil)
			--移除事件监听：兑换体力返回事件
			hGlobal.event:listen("LocalEvent_ExchangeTiLi_Ret", "__ExchangeTiLi_PvpCoin_", nil)
			--移除事件监听：横竖屏切换
			hGlobal.event:listen("LocalEvent_SpinScreen", "__SpinScreen_Shorcut_", nil)
			
			msgBox:del()
			hGlobal.UI.PhonePvpoinFrm = nil
			
			--如果有world，允许操作
			local world = hGlobal.WORLD.LastWorldMap
			if world then
				world.data.keypadEnabled = true
			end
		end,
	})
	
	--仓库按钮
	msgBox.childUI["btnBag"] = hUI.button:new({
		parent = msgBox.handle._n,
		x = 240,
		y = -200,
		parent = msgBox.handle._n,
		dragbox = msgBox.childUI["dragBox"],
		model = "misc/mask.png",
		icon = "misc/tempbag/iconbag.png",
		iconWH = 64,
		iconX = 80,
		iconY = -20,
		label = {text = hVar.tab_string["__TEXT_PAGE_BAG"], x = -64, y = 36, font = hVar.FONTC, size = 26, border = 1, align = "MC",}, --"仓库"
		w = 260,
		h = 120,
		scaleT = 0.95,
		code = function()
			--关闭本界面
			if hGlobal.UI.PhonePvpoinFrm then
				hGlobal.UI.PhonePvpoinFrm.childUI["closeBtn"].data.code()
			end
			
			local callback = function()
				--触发事件，显示快捷入口界面
				hApi.ShowShorcutTip()
			end
			--弹出仓库按钮
			hGlobal.event:event("LocalEvent_HideBarrage")
			hGlobal.event:event("localEvent_ShowChariotItemFrm", 1, callback)
		end,
	})
	msgBox.childUI["btnBag"].handle.s:setOpacity(0) --只影响事件，不显示
	
	--最后战役按钮
	--找出最后已通关的战役
	local lastMapName = ""
	for c = #hVar.tab_chapter, 1, -1 do
		local tabChapter = hVar.tab_chapter[c]
		local firstmap = tabChapter.firstmap --第一关
		local lastmap = tabChapter.lastmap --最后一关
		local isFinishMapLast = LuaGetPlayerMapAchi(lastmap, hVar.ACHIEVEMENT_TYPE.LEVEL) or 0 --是否通本关最后一关
		
		--已通关本章最后一关
		if (isFinishMapLast == 1) then
			lastMapName = lastmap
			break
		end
		
		local isFinishMapFirst = LuaGetPlayerMapAchi(firstmap, hVar.ACHIEVEMENT_TYPE.LEVEL) or 0 --是否通本关第一关
		if (isFinishMapFirst == 1) then
			--从第一关开始，开始查找通到哪关了
			local lastmap_i = firstmap
			while true do
				--跳转下一关
				local nextmap = hVar.MAP_INFO[lastmap_i].nextmap[1]
				--print("nextmap=", nextmap)
				local isFinishMap = LuaGetPlayerMapAchi(nextmap, hVar.ACHIEVEMENT_TYPE.LEVEL) or 0 --是否通关nextmap
				--print("isFinishMap=", isFinishMap)
				if (isFinishMap == 0) then --未通关本章
					break
				else
					lastmap_i = nextmap
					
					if (nextmap == lastmap) then
						break
					end
				end
			end
			
			lastMapName = lastmap_i
		end
		
		if (lastMapName ~= "") then
			break
		end
	end
	--print("lastMapName=", lastMapName)
	--全部未通关，默认指向第一关
	if (lastMapName == "") then
		lastMapName = hVar.tab_chapter[1].firstmap
	else
		if (lastMapName ~= hVar.tab_chapter[#hVar.tab_chapter].lastmap) then --不是最后一关
			--指向下一关
			lastMapName = hVar.MAP_INFO[lastMapName].nextmap[1]
		end
	end
	--最后战役按钮
	msgBox.childUI["btnLastMap"] = hUI.button:new({
		parent = msgBox.handle._n,
		x = 494,
		y = -200,
		parent = msgBox.handle._n,
		icon = hVar.MAP_INFO[lastMapName].icon_title,
		iconX = 60,
		iconY = -20,
		label = {text = hVar.tab_string["__TEXT_PAGE_LASTMAP"], x = -86, y = 36, font = hVar.FONTC, size = 26, border = 1, align = "MC",}, --"最后战役"
		dragbox = msgBox.childUI["dragBox"],
		model = "misc/mask.png",
		w = 240,
		h = 120,
		scaleT = 0.95,
		code = function()
			--关闭本界面
			if hGlobal.UI.PhonePvpoinFrm then
				hGlobal.UI.PhonePvpoinFrm.childUI["closeBtn"].data.code()
			end
			
			--弹出DLC地图信息界面通知事件
			local dlcMapPackageName = hVar.MAP_INFO[lastMapName].dlcMapPackageName --所属的地图包名字
			local bOpenImmediate = true
			--print(lastMapName)
			local callback = function()
				--触发事件，显示快捷入口界面
				hApi.ShowShorcutTip()
			end
			hGlobal.event:event("LocalEvent_Phone_ShowDLCMapInfoFrm", dlcMapPackageName, callback, bOpenImmediate, lastMapName)
		end,
	})
	msgBox.childUI["btnLastMap"].handle.s:setOpacity(0) --只影响事件，不显示
	
	--售货机按钮
	msgBox.childUI["btnShop"] = hUI.button:new({
		parent = msgBox.handle._n,
		x = 240,
		y = -340,
		parent = msgBox.handle._n,
		dragbox = msgBox.childUI["dragBox"],
		model = "misc/mask.png",
		icon = "ui/shop.png",
		iconWH = 84,
		iconX = 70,
		iconY = -20,
		label = {text = hVar.tab_string["__TEXT_PAGE_SHOP2"], x = -68, y = 48, font = hVar.FONTC, size = 26, border = 1, align = "MC",}, --"售货机"
		w = 260,
		h = 140,
		scaleT = 0.95,
		code = function()
			--关闭本界面
			if hGlobal.UI.PhonePvpoinFrm then
				hGlobal.UI.PhonePvpoinFrm.childUI["closeBtn"].data.code()
			end
			
			local callback = function()
				--触发事件，显示快捷入口界面
				hApi.ShowShorcutTip()
			end
			--触发事件，显示商城界面
			local bOpenImmediate = true
			hGlobal.event:event("LocalEvent_Phone_ShowNetShopNewFrm", callback, bOpenImmediate)
		end,
	})
	msgBox.childUI["btnShop"].handle.s:setOpacity(0) --只影响事件，不显示
	
	--碎片合成按钮
	msgBox.childUI["btnDebris"] = hUI.button:new({
		parent = msgBox.handle._n,
		x = 494,
		y = -340,
		parent = msgBox.handle._n,
		icon = "icon/item/chest_3.png",
		iconWH = 78,
		iconX = 48,
		iconY = -24,
		label = {text = hVar.tab_string["__TEXT_PAGE_DEBRIS"], x = -58, y = 48, font = hVar.FONTC, size = 26, border = 1, align = "MC",}, --"碎片合成"
		dragbox = msgBox.childUI["dragBox"],
		model = "misc/mask.png",
		w = 240,
		h = 140,
		scaleT = 0.95,
		code = function()
			--关闭本界面
			if hGlobal.UI.PhonePvpoinFrm then
				hGlobal.UI.PhonePvpoinFrm.childUI["closeBtn"].data.code()
			end
			
			local callback = function()
				--触发事件，显示快捷入口界面
				hApi.ShowShorcutTip()
			end
			--触发事件，显示宝箱界面
			local bOpenImmediate = true
			hGlobal.event:event("LocalEvent_Phone_ShowPhoneChestFrame", callback, bOpenImmediate)
		end,
	})
	msgBox.childUI["btnDebris"].handle.s:setOpacity(0) --只影响事件，不显示
	
	--黑龙洞窟按钮
	msgBox.childUI["btnDragon"] = hUI.button:new({
		parent = msgBox.handle._n,
		x = 240,
		y = -490,
		parent = msgBox.handle._n,
		dragbox = msgBox.childUI["dragBox"],
		model = "misc/mask.png",
		icon = "ui/dragon.png",
		iconWH = 108,
		iconX = 82,
		iconY = -20,
		label = {text = hVar.tab_string["__TEXT_PAGE_DRAGON"], x = -84, y = 48, font = hVar.FONTC, size = 26, border = 1, align = "MC",}, --"黑龙洞窟"
		w = 260,
		h = 150,
		scaleT = 0.95,
		code = function()
			--检测是否通关"矿山巨兽"
			local isFinish = LuaGetPlayerMapAchi("world/yxys_spider_04", hVar.ACHIEVEMENT_TYPE.LEVEL) or 0
			if (isFinish == 0) then
				--冒字
				--local strText = "击败矿山巨兽可进入" --language
				local strText = hVar.tab_string["clearspider04"] --language
				hUI.floatNumber:new({
					x = hVar.SCREEN.w / 2,
					y = hVar.SCREEN.h / 2,
					align = "MC",
					text = "",
					lifetime = 2000,
					fadeout = -550,
					moveY = 32,
				}):addtext(strText, hVar.FONTC, 32, "MC", 0, 0, nil, 1)
				
				return
			end
			
			--关闭本界面
			if hGlobal.UI.PhonePvpoinFrm then
				hGlobal.UI.PhonePvpoinFrm.childUI["closeBtn"].data.code()
			end
			
			--查询VIP等级和领取状态
			SendCmdFunc["get_VIP_Lv_New"]()
			
			--hGlobal.LocalPlayer:setfocusworld(nil)
			hGlobal.event:event("LocalEvent_HideBarrage")
			hGlobal.WORLD.LastWorldMap:disableTimer()
			local chapterId = 99
			local callback = function()
				--触发事件，显示快捷入口界面
				hApi.ShowShorcutTip()
			end
			hGlobal.event:event("LocalEvent_Phone_ShowPhone_SelecteMap", chapterId, callback)
		end,
	})
	msgBox.childUI["btnDragon"].handle.s:setOpacity(0) --只影响事件，不显示
	
	--改造中心按钮
	msgBox.childUI["btnEquipment"] = hUI.button:new({
		parent = msgBox.handle._n,
		x = 494,
		y = -490,
		parent = msgBox.handle._n,
		icon = "misc/chariotconfig/go_equips.png",
		iconWH = 120,
		iconX = 32,
		iconY = -20,
		label = {text = hVar.tab_string["__TEXT_PAGE_EQUIPMENT"], x = -76, y = 48, font = hVar.FONTC, size = 26, border = 1, align = "MC",}, --"改造中心"
		dragbox = msgBox.childUI["dragBox"],
		model = "misc/mask.png",
		w = 240,
		h = 150,
		scaleT = 0.95,
		code = function()
			--关闭本界面
			if hGlobal.UI.PhonePvpoinFrm then
				hGlobal.UI.PhonePvpoinFrm.childUI["closeBtn"].data.code()
			end
			
			local callback = function()
				--触发事件，显示快捷入口界面
				hApi.ShowShorcutTip()
			end
			--触发事件，显示装备界面
			hGlobal.event:event("LocalEvent_ShowChariotEquipFrm", callback)
		end,
	})
	msgBox.childUI["btnEquipment"].handle.s:setOpacity(0) --只影响事件，不显示
	--改造中心叹号
	msgBox.childUI["btnEquipment"].childUI["lvup"] = hUI.image:new({
		parent = msgBox.childUI["btnEquipment"].handle._n,
		model = "UI:TaskTanHao",
		x = 22,
		y = 10,
		z = 1,
		scale = 1.0,
	})
	local act1 = CCMoveBy:create(0.2, ccp(0, 6))
		local act2 = CCMoveBy:create(0.2, ccp(0, -6))
		local act3 = CCMoveBy:create(0.2, ccp(0, 6))
		local act4 = CCMoveBy:create(0.2, ccp(0, -6))
		local act5 = CCDelayTime:create(0.6)
		local act6 = CCRotateBy:create(0.1, 10)
		local act7 = CCRotateBy:create(0.1 * 1, -10 * 2)
		local act8 = CCRotateBy:create(0.1 * 1, 10 * 2)
		local act9 = CCRotateBy:create(0.1, -10)
		local act10 = CCDelayTime:create(0.8)
		local a = CCArray:create()
		a:addObject(act1)
		a:addObject(act2)
		a:addObject(act3)
		a:addObject(act4)
		a:addObject(act5)
		a:addObject(act6)
		a:addObject(act7)
		a:addObject(act8)
		a:addObject(act9)
		a:addObject(act10)
		local sequence = CCSequence:create(a)
	msgBox.childUI["btnEquipment"].childUI["lvup"].handle._n:runAction(CCRepeatForever:create(sequence))
	--msgBox.childUI["btnEquipment"].childUI["lvup"].handle._n:setVisible(false) --默认隐藏
	--检测是否有背包的道具可装备到英雄身上
	local bHaveBagTakeOnEquip = hApi.CheckBagTakeOnEquip()
	local bShowNotice = (bHaveBagTakeOnEquip)
	msgBox.childUI["btnEquipment"].childUI["lvup"].handle._n:setVisible(bShowNotice)
	
	--函数：横竖屏切换
	on_spine_screen_event_shortcut = function()
		--关闭本界面
		if hGlobal.UI.PhonePvpoinFrm then
			hGlobal.UI.PhonePvpoinFrm.childUI["closeBtn"].data.code()
		end
		
		--重新绘制本界面
		hApi.ShowShorcutTip()
	end
	
	--添加事件监听：我的体力信息返回事件
	--hGlobal.event:listen("LocalEvent_TiLiInfo_Ret", "__TiLiInfo_PvpCoin_", on_receive_TiLi_baseInfoRet_bf)
	--添加事件监听：兑换体力返回事件
	--hGlobal.event:listen("LocalEvent_ExchangeTiLi_Ret", "__ExchangeTiLi_PvpCoin_", on_receive_ExchangeTiLiRet_bf)
	--移除事件监听：横竖屏切换
	hGlobal.event:listen("LocalEvent_SpinScreen", "__SpinScreen_Shorcut_", on_spine_screen_event_shortcut)
	
	--挡操作
	--hUI.NetDisable(30000)
	
	--请求查询玩家体力产量信息
	--SendCmdFunc["tank_reqiure_tili_info"]()
end
--[[
hApi.ShowShorcutTip()
]]

-- 分享接口
-- @param shareType(number|hVar.ShareType) 分享类型，定义在hVar.ShareType
-- @param localImgPath(string) 本地图片路径
-- @return number 0成功|-1失败:未联网|-2失败:旧版本|-3失败:平台不支持
hApi.ShareSNS = function(shareType, localImgPath)
	-- localImgPath = string.gsub(localImgPath, ".png", "")
	print("hApi.ShareSNS: shareType = " .. tostring(shareType) .. ", localImgPath = " .. tostring(localImgPath))
	local ret
	
    local targetPlatform = CCApplication:sharedApplication():getTargetPlatform()
    print("targetPlatform : " .. tostring(targetPlatform))
	if not targetPlatform or targetPlatform ~= g_tTargetPlatform.kTargetIphone then
		ret = -3

		hGlobal.UI.MsgBox(hVar.tab_string["__TEXT_Cant_Share_Platform"],{ --"当前平台暂不支持分享"
			font = hVar.FONTC,
			ok = function()
				--
			end,
		})
		return ret
	end

	--检测是否联网
	if g_cur_net_state == -1 then --未联网
		ret = -1

		hGlobal.UI.MsgBox(hVar.tab_string["__TEXT_Cant_Share_Net"],{ --"必须联网才能使用分享功能"
			font = hVar.FONTC,
			ok = function()
				--
			end,
		})
		return ret
	end

	if xlShareSNS2 then
		ret = 0

		-- -- 测试代码
		-- hGlobal.UI.MsgBox(string.format("【测试分享】：\n%s\n%s", tostring(localImgPath), tostring(shareType)),{
		-- 	font = hVar.FONTC,
		-- 	ok = function()
		-- 		--
		-- 	end,
		-- })
		
		local function callback(flag)
			-- 返回App
			if flag == 0 then
				hGlobal.event:listen("LocalEvent_AppEnterBackground", "__ShareSNS", nil)
			
				--请求领取分享奖励
				SendCmdFunc["require_share_takereward"]()
			end
		end
		hGlobal.event:listen("LocalEvent_AppEnterBackground", "__ShareSNS", callback)

		xlShareSNS2(shareType, localImgPath)
		return ret
	else
		ret = -2

		local version_control = tostring(g_version_control) --1.0.070502-v018-018-app
		local vbpos = string.find(version_control, "-")
		if vbpos then
			version_control = string.sub(version_control, 1, vbpos - 1)
		end
		local sInfo = string.format(hVar.tab_string["__TEXT_Cant_Share_Old_Version"], version_control, tostring(hVar.CURRENT_ITEM_VERSION))
		ShowMsgBoxOldVersion(sInfo)
		return ret
	end
end

--显示月卡的充值tip
hApi.ShowMonthCardPurchaseTip = function()
	--先清除上一次的游戏币说明面板
	if hGlobal.UI.PurchaseInfoFram then
		hGlobal.UI.PurchaseInfoFram:del()
		hGlobal.UI.PurchaseInfoFram = nil
	end
	
	--移除事件监听：充值信息列表回调
	hGlobal.event:listen("LocalEvent_OnIapList_Back", "__IapListBack_MonthCard_", nil)
	--移除事件监听：充值成功或失败的回调
	hGlobal.event:listen("LocalEvent_Purchase_Back", "__PurchaseBack_MonthCard_", nil)
	--移除事件监听：收到月卡信息返回
	hGlobal.event:listen("localEvent_MonthCardGiftList", "__MonthCardGift_MonthCard_", nil)
	
	local on_receive_IapList_event = hApi.DoNothing --收到充值信息列表回调
	local OnSelectChargeMoneyButton = hApi.DoNothing --选中某个充值按钮
	local on_receive_purchase_event = hApi.DoNothing --收到充值成功或失败的回调
	local on_receive_monthcard_gift_event = hApi.DoNothing --收到月卡信息返回
	
	--创建游戏币说明tip
	hGlobal.UI.PurchaseInfoFram = hUI.frame:new({
		x = 0,
		y = 0,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		z = hZorder.CommentFrm - 2,
		show = 1,
		--dragable = 2,
		dragable = 2,
		--buttononly = 1,
		autoactive = 0,
		--background = "UI:PANEL_INFO_MINI",
		failcall = 1, --出按钮区域抬起也会响应事件
		background = -1, --无底图
		border = 0, --无边框
		
		--点击事件（有可能在控件外部点击）
		codeOnDragEx = function(screenX, screenY, touchMode)
			--print("codeOnDragEx", screenX, screenY, touchMode)
			if (touchMode == 0) then --按下
				--
			elseif (touchMode == 1) then --滑动
				--
			elseif (touchMode == 2) then --抬起
				--[[
				--清除技能说明面板
				hGlobal.UI.PurchaseInfoFram:del()
				hGlobal.UI.PurchaseInfoFram = nil
				--print("点击事件（有可能在控件外部点击）")
				]]
			end
		end,
	})
	hGlobal.UI.PurchaseInfoFram:active()
	
	local _frm2 = hGlobal.UI.PurchaseInfoFram
	local _GameCoinTipParent = hGlobal.UI.PurchaseInfoFram.handle._n
	local _GameCoinTipChildUI = hGlobal.UI.PurchaseInfoFram.childUI
	
	local _offX = hVar.SCREEN.w / 2
	local _offY = hVar.SCREEN.h / 2 + 220
	
	local current_iType = xlGetIapType() --读取支付类型
	local current_IapList = {}
	
	--关闭按钮响应区域
	_GameCoinTipChildUI["closeBtn"] = hUI.button:new({
		parent = _GameCoinTipParent,
		model = -1,
		--model = "misc/mask.png",
		dragbox = _frm2.childUI["dragBox"],
		align = "MC",
		x = hVar.SCREEN.w/2,
		y = hVar.SCREEN.h/2,
		w = hVar.SCREEN.w,
		h = hVar.SCREEN.h,
		code = function()
			--清除本面板
			if hGlobal.UI.PurchaseInfoFram then
				hGlobal.UI.PurchaseInfoFram:del()
				hGlobal.UI.PurchaseInfoFram = nil
			end
			
			--移除事件监听：充值信息列表回调
			hGlobal.event:listen("LocalEvent_OnIapList_Back", "__IapListBack_MonthCard_", nil)
			--移除事件监听：充值成功或失败的回调
			hGlobal.event:listen("LocalEvent_Purchase_Back", "__PurchaseBack_MonthCard_", nil)
			--移除事件监听：收到月卡信息返回
			hGlobal.event:listen("localEvent_MonthCardGiftList", "__MonthCardGift_MonthCard_", nil)
		end,
	})
	
	local img9 = hApi.CCScale9SpriteCreate("data/image/misc/chest/itemtip.png", _offX, _offY - 235, 680, 480, hGlobal.UI.PurchaseInfoFram)
	
	_GameCoinTipChildUI["BtnMask"] = hUI.button:new({
		parent = _GameCoinTipParent,
		model = "misc/button_null.png",
		x = _offX,
		y = _offY - 235,
		w = 680,
		h = 480,
		dragbox = _frm2.childUI["dragBox"],
		scaleT = 0.95,
		code = function()
		end
	})
	
	--底板
	--创建游戏币图标
	_GameCoinTipChildUI["TacticIcon"] = hUI.image:new({
		parent = _GameCoinTipParent,
		model = "UI:MONTHCARD_ICON",
		x = _offX - 76 - 8,
		y = _offY - 65-10,
		z = 1,
		w = 72,
		h = 72,
	})
	
	--创建游戏币名称
	local title = hVar.tab_string["__TEXT_MONTHCARD"]
	local titleColor = ccc3(255, 255, 0)
	_GameCoinTipChildUI["TacticName"] = hUI.label:new({
		parent = _GameCoinTipParent,
		size = 30,
		x = _offX + 40,
		y = _offY - 60 - 8 - 10,
		width = 300,
		align = "MC",
		font = hVar.FONTC,
		text = title,
		border = 1,
	})
	_GameCoinTipChildUI["TacticName"].handle.s:setColor(titleColor)
	
	local img9Width = 500
	local img9 = hApi.CCScale9SpriteCreate("data/image/misc/treasure/medal_content2.png", _offX, _offY - 235, img9Width, 150, hGlobal.UI.PurchaseInfoFram)
	
	--显示文字说明1
	_GameCoinTipChildUI["rewardLabel_1"] = hUI.label:new({
		parent = _GameCoinTipParent,
		x = _offX - 220,
		y = _offY - 232 + 42,
		width = 500,
		align = "LC",
		font = hVar.FONTC,
		size = 26,
		text = hVar.tab_string["__TEXT_MONTHCARD_INTRODUCE1"],
	})
	
	--显示文字说明2
	_GameCoinTipChildUI["rewardLabel_2"] = hUI.label:new({
		parent = _GameCoinTipParent,
		x = _offX - 220,
		y = _offY - 232 - 0,
		width = 500,
		align = "LC",
		font = hVar.FONTC,
		size = 26,
		text = hVar.tab_string["__TEXT_MONTHCARD_INTRODUCE2"],
	})
	
	--显示文字说明3
	_GameCoinTipChildUI["rewardLabel_3"] = hUI.label:new({
		parent = _GameCoinTipParent,
		x = _offX - 220,
		y = _offY - 232 - 42,
		width = 500,
		align = "LC",
		font = hVar.FONTC,
		size = 26,
		text = hVar.tab_string["__TEXT_MONTHCARD_INTRODUCE3"],
	})
	
	--展示剩余月卡时间
	if (g_monthcard_leftdays > 0) then
		--显示文字说明2
		_GameCoinTipChildUI["monthcardLeftTimeLabel"] = hUI.label:new({
			parent = _GameCoinTipParent,
			x = _offX,
			y = _offY - 130,
			width = 500,
			align = "MC",
			font = hVar.FONTC,
			size = 24,
			text = string.format(hVar.tab_string["__TEXT_MONTHCARD_LEFTTIME"], g_monthcard_leftdays),
			RGB = {0, 255, 0,},
		})
	else
		--显示文字说明2
		_GameCoinTipChildUI["monthcardLeftTimeLabel"] = hUI.label:new({
			parent = _GameCoinTipParent,
			x = _offX,
			y = _offY - 130,
			width = 500,
			align = "MC",
			font = hVar.FONTC,
			size = 24,
			text = hVar.tab_string["__TEXT_MONTHCARD_NOTHAVE"],
			RGB = {212, 64, 42,},
		})
	end
	
	--月卡的评论区按钮
	_GameCoinTipChildUI["BtnComment"] = hUI.button:new({
		parent = _GameCoinTipParent,
		model = "misc/addition/commentbtn.png",
		x = _offX + 280,
		y = _offY - 80,
		dragbox = _frm2.childUI["dragBox"],
		scaleT = 0.95,
		scale = 0.8,
		scaleT = 0.8,
		--z = 10,
		code = function()
			--清除tip面版
			--if hGlobal.UI.PurchaseInfoFram then
				--hGlobal.UI.PurchaseInfoFram:del()
				--hGlobal.UI.PurchaseInfoFram = nil
			--end
			CommentManage.ReadyComment(hVar.CommentTargetTypeDefine.MONTH_CARD)
			hGlobal.event:event("LocalEvent_DoCommentProcess",{})
		end,
	})
	
	--充值按钮
	_GameCoinTipChildUI["BtnBuy"] = hUI.button:new({
		parent = _GameCoinTipParent,
		model = "misc/chest/itembtn.png",
		x = _offX,
		y = _offY - 400,
		w = 108,
		h = 63,
		label = {x = 0, y = 2, font = hVar.FONTC, align = "MC", border = 1, text = hVar.tab_string["__TEXT_Buy"], size = 28, width = 300, RGB = {255, 255, 0,},}, --"购买"
		dragbox = _frm2.childUI["dragBox"],
		scaleT = 0.95,
		code = function()
			--清除本面板
			if hGlobal.UI.PurchaseInfoFram then
				hGlobal.UI.PurchaseInfoFram:del()
				hGlobal.UI.PurchaseInfoFram = nil
			end
			
			--移除事件监听：充值信息列表回调
			hGlobal.event:listen("LocalEvent_OnIapList_Back", "__IapListBack_MonthCard_", nil)
			--移除事件监听：充值成功或失败的回调
			hGlobal.event:listen("LocalEvent_Purchase_Back", "__PurchaseBack_MonthCard_", nil)
			--移除事件监听：收到月卡信息返回
			hGlobal.event:listen("localEvent_MonthCardGiftList", "__MonthCardGift_MonthCard_", nil)
			
			--点击充值按钮的执行逻辑
			OnSelectChargeMoneyButton()
		end,
	})
	
	--函数：收到充值信息列表回调
	on_receive_IapList_event = function(list)
		--local _frm2 = hGlobal.UI.PurchaseInfoFram
		--local _GameCoinTipParent = hGlobal.UI.PurchaseInfoFram.handle._n
		--local _GameCoinTipChildUI = hGlobal.UI.PurchaseInfoFram.childUI
		
		if (#list > 0) then
			--初始化实际的充值索引
			for i = 1, #list, 1 do
				local listI = list[i]
				listI.custombuyindex = i
			end
		end
		
		--存储充值条目
		current_IapList = list
	end
	
	--函数：点击充值按钮的执行逻辑
	OnSelectChargeMoneyButton = function()
		--local _frm2 = hGlobal.UI.PurchaseInfoFram
		--local _GameCoinTipParent = hGlobal.UI.PurchaseInfoFram.handle._n
		--local _GameCoinTipChildUI = hGlobal.UI.PurchaseInfoFram.childUI
		
		local list = current_IapList
		
		--弹出购买游戏币的窗口
		if xlIapBuyItem then
			--支付类型(1:苹果 / 2:支付宝 / 3:用户选择)
			if (current_iType == 0) or (current_iType == 1) then --苹果
				--找到月卡所在的位置
				local idxEx = 0
				for i = 1, #list, 1 do
					local listI = list[i]
					if (listI.productId == "tier05.yellowstone.aliensmash") then --月卡(苹果)
						idxEx = i
						break
					end
				end
				
				--[[
				hGlobal.UI.MsgBox("idxEx="..tostring(idxEx),{
					font = hVar.FONTC,
					ok = function()
					end,
				})
				]]
				
				--服务器没取到product，不能充值
				if (idxEx == 0) then
					--[[
					--local strText = "内购条目准备中" --language
					local strText = hVar.tab_string["ios_pruchase_connect_ios"] --language
					hUI.floatNumber:new({
						x = hVar.SCREEN.w / 2,
						y = hVar.SCREEN.h / 2,
						align = "MC",
						text = "",
						lifetime = 2000,
						fadeout = -550,
						moveY = 32,
					}):addtext(strText, hVar.FONTC, 32, "MC", 0, 0, nil, 1)
					
					--模拟触发事件: 充值失败事件回调
					hGlobal.event:event("LocalEvent_Purchase_Back", 0)
					
					return
					]]
					
					--挡操作
					hUI.NetDisable(5000, "purchase")
					
					--直接按key买商品
					local sItemName = "tier05.yellowstone.aliensmash"
					xlIapBuyIosItem(sItemName)
				else
					local listI = current_IapList[idxEx] --第i项
					--local id = current_focus_achievementEx_idx - 1
					local id = listI.custombuyindex - 1
					--local productId = listI.productId
					
					--挡操作
					hUI.NetDisable(5000, "purchase")
					
					xlIapBuyItem(current_iType, id)
				end
			elseif (current_iType == 2) then --支付宝
				--找到月卡所在的位置
				local idxEx = 0
				for i = 1, #list, 1 do
					local listI = list[i]
					if (listI.productId == 10101) or (listI.productId == "10101") then --月卡(安卓)
						idxEx = i
						break
					end
				end
				
				local listI = current_IapList[idxEx] --第i项
				if (listI) then --存在充值信息第i项表
					local iChannelId = getChannelInfo()
					if (iChannelId == 100) or (iChannelId == 106) or (iChannelId == 1002) then --taptap
					--if (iChannelId == 10002) then --taptap
						--支付宝支付
						local onclickevent_zfb = function()
							print("支付宝")
							
							--挡操作
							hUI.NetDisable(5000, "purchase")
							
							local productId = listI.productId --产品id
							xlIapBuyItem(current_iType, productId)
						end
						
						--微信支付
						local onclickevent_wx = function()
							print("微信")
							
							--检测程序版本号是否支持微信支付
							if (xlGetChannelVersion() >= 2023010101) then
								--挡操作
								hUI.NetDisable(5000, "purchase")
								
								local productId = listI.productId --产品id
								xlIapBuyItem(4, productId)
							else
								--弹框，版本太旧
								local strText = hVar.tab_string["__TEXT_AppVersionTooOld_Download"] --"您的应用程序版本太旧，请从商店更新至最新版本！"
								hGlobal.UI.MsgBox(strText,{
									font = hVar.FONTC,
									ok = function()
									end,
								})
								
								--[[
								--取消标记当前正在交易的id
								current_deal_idx = 0
								--隐藏菊花
								_frmNode.childUI["AchievementNode" .. current_focus_achievementEx_idx].childUI["waiting"].handle.s:setVisible(false)
								]]
							end
						end
						
						local MsgSelections = nil
						MsgSelections = {
							style = "mini",
							select = 0,
							ok = onclickevent_zfb,
							cancel = onclickevent_wx,
							--cancelFun = cancelCallback, --点否的回调函数
							--textOk = "领取",
							textOk = hVar.tab_string["__TEXT_IAPPAY_ALI"], --language
							--textCancel = "确定", --language
							textCancel = hVar.tab_string["__TEXT_IAPPAY_WEIXIN"], --language
							userflag = 0, --用户的标记
						}
						local msgBox = hGlobal.UI.MsgBox(hVar.tab_string["__TEXT_IAPPAY_SELECT"], MsgSelections) --"请选择支付方式"
						msgBox:active()
						msgBox:show(1,"fade",{time=0.08})
					else
						--挡操作
						hUI.NetDisable(5000, "purchase")
						
						local productId = listI.productId --产品id
						xlIapBuyItem(current_iType, productId)
					end
				end
			end
		end
	end
	
	--函数：收到充值成功或失败的回调
	on_receive_purchase_event = function(nResult)
		--local _frm2 = hGlobal.UI.PurchaseInfoFram
		--local _GameCoinTipParent = hGlobal.UI.PurchaseInfoFram.handle._n
		--local _GameCoinTipChildUI = hGlobal.UI.PurchaseInfoFram.childUI
		
		--取消挡操作
		hUI.NetDisable(0)
		
		--充值成功
		if (nResult == 1) then
			--弹框
			--"充值成功！"
			hGlobal.UI.MsgBox(hVar.tab_string["recharge_success_short"],{
				font = hVar.FONTC,
				ok = function()
				end,
			})
			
			--再次发起查询月卡和月卡每日领奖
			SendCmdFunc["query_month_card"]()
			
			--再次发起查询首充状态
			SendCmdFunc["gift_state"]("9;100;18;3;1030;1031;1033;1034;1035;1036;1900;1901;1902;")
			
			--查询VIP等级和领取状态
			SendCmdFunc["get_VIP_Lv_New"]()
		end
	end
	
	--函数：收到月卡信息回调
	on_receive_monthcard_gift_event = function(iMonthCard, iDays, iFreeCount)
		local _frm2 = hGlobal.UI.PurchaseInfoFram
		local _GameCoinTipParent = hGlobal.UI.PurchaseInfoFram.handle._n
		local _GameCoinTipChildUI = hGlobal.UI.PurchaseInfoFram.childUI
		
		--取消挡操作
		hUI.NetDisable(0)
		
		--...
	end
	
	--添加事件监听：充值信息列表回调
	hGlobal.event:listen("LocalEvent_OnIapList_Back", "__IapListBack_MonthCard_", on_receive_IapList_event)
	--添加事件监听：充值成功或失败的回调
	hGlobal.event:listen("LocalEvent_Purchase_Back", "__PurchaseBack_MonthCard_", on_receive_purchase_event)
	--添加事件监听：收到月卡信息返回
	hGlobal.event:listen("localEvent_MonthCardGiftList", "__MonthCardGift_MonthCard_", on_receive_monthcard_gift_event)
	
	--发起查询，充值条目
	xlRequestIapList(current_iType)
end
